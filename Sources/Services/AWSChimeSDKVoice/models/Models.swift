// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have the permissions needed to run this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case country
        case postDirectional
        case postalCode
        case postalCodePlus4
        case preDirectional
        case state
        case streetName
        case streetNumber
        case streetSuffix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postDirectional = self.postDirectional {
            try encodeContainer.encode(postDirectional, forKey: .postDirectional)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let postalCodePlus4 = self.postalCodePlus4 {
            try encodeContainer.encode(postalCodePlus4, forKey: .postalCodePlus4)
        }
        if let preDirectional = self.preDirectional {
            try encodeContainer.encode(preDirectional, forKey: .preDirectional)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetName = self.streetName {
            try encodeContainer.encode(streetName, forKey: .streetName)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
        if let streetSuffix = self.streetSuffix {
            try encodeContainer.encode(streetSuffix, forKey: .streetSuffix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetName)
        streetName = streetNameDecoded
        let streetSuffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetSuffix)
        streetSuffix = streetSuffixDecoded
        let postDirectionalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postDirectional)
        postDirectional = postDirectionalDecoded
        let preDirectionalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preDirectional)
        preDirectional = preDirectionalDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let postalCodePlus4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCodePlus4)
        postalCodePlus4 = postalCodePlus4Decoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postDirectional: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", preDirectional: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetName: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\", streetSuffix: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A validated address.
    public struct Address {
        /// The city of an address.
        public var city: Swift.String?
        /// The country of an address.
        public var country: Swift.String?
        /// An address suffix location, such as the S. Unit A in Central Park S. Unit A.
        public var postDirectional: Swift.String?
        /// The postal code of an address.
        public var postalCode: Swift.String?
        /// The zip + 4 or postal code + 4 of an address.
        public var postalCodePlus4: Swift.String?
        /// An address prefix location, such as the N in N. Third St.
        public var preDirectional: Swift.String?
        /// The state of an address.
        public var state: Swift.String?
        /// The address street, such as 8th Avenue.
        public var streetName: Swift.String?
        /// The numeric portion of an address.
        public var streetNumber: Swift.String?
        /// The address suffix, such as the N in 8th Avenue N.
        public var streetSuffix: Swift.String?

        public init(
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postDirectional: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            preDirectional: Swift.String? = nil,
            state: Swift.String? = nil,
            streetName: Swift.String? = nil,
            streetNumber: Swift.String? = nil,
            streetSuffix: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postDirectional = postDirectional
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.preDirectional = preDirectional
            self.state = state
            self.streetName = streetName
            self.streetNumber = streetNumber
            self.streetSuffix = streetSuffix
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum AlexaSkillStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AlexaSkillStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlexaSkillStatus(rawValue: rawValue) ?? AlexaSkillStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let forceAssociate = self.forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput {

    static func queryItemProvider(_ value: AssociatePhoneNumbersWithVoiceConnectorGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "associate-phone-numbers"))
        return items
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: AssociatePhoneNumbersWithVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInput {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime SDK Voice Connector Group and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Amazon Chime SDK Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupInputBody {
    let e164PhoneNumbers: [Swift.String]?
    let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociatePhoneNumbersWithVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupOutputBody {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum AssociatePhoneNumbersWithVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let forceAssociate = self.forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput {

    static func queryItemProvider(_ value: AssociatePhoneNumbersWithVoiceConnectorInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "associate-phone-numbers"))
        return items
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput {

    static func urlPathProvider(_ value: AssociatePhoneNumbersWithVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorInput {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime SDK Voice Connector and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorId = voiceConnectorId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorInputBody {
    let e164PhoneNumbers: [Swift.String]?
    let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociatePhoneNumbersWithVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorOutputBody {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum AssociatePhoneNumbersWithVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct BadRequestExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchDeletePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumberIds = phoneNumberIds {
            var phoneNumberIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberIds)
            for string0 in phoneNumberIds {
                try phoneNumberIdsContainer.encode(string0)
            }
        }
    }
}

extension BatchDeletePhoneNumberInput {

    static func queryItemProvider(_ value: BatchDeletePhoneNumberInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "batch-delete"))
        return items
    }
}

extension BatchDeletePhoneNumberInput {

    static func urlPathProvider(_ value: BatchDeletePhoneNumberInput) -> Swift.String? {
        return "/phone-numbers"
    }
}

public struct BatchDeletePhoneNumberInput {
    /// List of phone number IDs.
    /// This member is required.
    public var phoneNumberIds: [Swift.String]?

    public init(
        phoneNumberIds: [Swift.String]? = nil
    )
    {
        self.phoneNumberIds = phoneNumberIds
    }
}

struct BatchDeletePhoneNumberInputBody {
    let phoneNumberIds: [Swift.String]?
}

extension BatchDeletePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberIds)
        var phoneNumberIdsDecoded0:[Swift.String]? = nil
        if let phoneNumberIdsContainer = phoneNumberIdsContainer {
            phoneNumberIdsDecoded0 = [Swift.String]()
            for string0 in phoneNumberIdsContainer {
                if let string0 = string0 {
                    phoneNumberIdsDecoded0?.append(string0)
                }
            }
        }
        phoneNumberIds = phoneNumberIdsDecoded0
    }
}

extension BatchDeletePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeletePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchDeletePhoneNumberOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchDeletePhoneNumberOutputBody {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension BatchDeletePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum BatchDeletePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatePhoneNumberRequestItems = updatePhoneNumberRequestItems {
            var updatePhoneNumberRequestItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updatePhoneNumberRequestItems)
            for updatephonenumberrequestitem0 in updatePhoneNumberRequestItems {
                try updatePhoneNumberRequestItemsContainer.encode(updatephonenumberrequestitem0)
            }
        }
    }
}

extension BatchUpdatePhoneNumberInput {

    static func queryItemProvider(_ value: BatchUpdatePhoneNumberInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "batch-update"))
        return items
    }
}

extension BatchUpdatePhoneNumberInput {

    static func urlPathProvider(_ value: BatchUpdatePhoneNumberInput) -> Swift.String? {
        return "/phone-numbers"
    }
}

public struct BatchUpdatePhoneNumberInput {
    /// Lists the phone numbers in the update request.
    /// This member is required.
    public var updatePhoneNumberRequestItems: [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]?

    public init(
        updatePhoneNumberRequestItems: [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]? = nil
    )
    {
        self.updatePhoneNumberRequestItems = updatePhoneNumberRequestItems
    }
}

struct BatchUpdatePhoneNumberInputBody {
    let updatePhoneNumberRequestItems: [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]?
}

extension BatchUpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatePhoneNumberRequestItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem?].self, forKey: .updatePhoneNumberRequestItems)
        var updatePhoneNumberRequestItemsDecoded0:[ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]? = nil
        if let updatePhoneNumberRequestItemsContainer = updatePhoneNumberRequestItemsContainer {
            updatePhoneNumberRequestItemsDecoded0 = [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]()
            for structure0 in updatePhoneNumberRequestItemsContainer {
                if let structure0 = structure0 {
                    updatePhoneNumberRequestItemsDecoded0?.append(structure0)
                }
            }
        }
        updatePhoneNumberRequestItems = updatePhoneNumberRequestItemsDecoded0
    }
}

extension BatchUpdatePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdatePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchUpdatePhoneNumberOutput {
    /// A list of failed phone numbers and their error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchUpdatePhoneNumberOutputBody {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension BatchUpdatePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum BatchUpdatePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKVoiceClientTypes.CallDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isCaller = "IsCaller"
        case transactionId = "TransactionId"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isCaller = self.isCaller {
            try encodeContainer.encode(isCaller, forKey: .isCaller)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let isCallerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isCaller)
        isCaller = isCallerDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of an Amazon Chime SDK Voice Connector call.
    public struct CallDetails {
        /// Identifies a person as the caller or the callee.
        public var isCaller: Swift.Bool?
        /// The transaction ID of a Voice Connector call.
        public var transactionId: Swift.String?
        /// The Voice Connector ID.
        public var voiceConnectorId: Swift.String?

        public init(
            isCaller: Swift.Bool? = nil,
            transactionId: Swift.String? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.isCaller = isCaller
            self.transactionId = transactionId
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum CallLegType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case callee
        case caller
        case sdkUnknown(Swift.String)

        public static var allCases: [CallLegType] {
            return [
                .callee,
                .caller,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .callee: return "Callee"
            case .caller: return "Caller"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CallLegType(rawValue: rawValue) ?? CallLegType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum CallingNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case unassigned
        case updatefailed
        case updateinprogress
        case updatesucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CallingNameStatus] {
            return [
                .unassigned,
                .updatefailed,
                .updateinprogress,
                .updatesucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .unassigned: return "Unassigned"
            case .updatefailed: return "UpdateFailed"
            case .updateinprogress: return "UpdateInProgress"
            case .updatesucceeded: return "UpdateSucceeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CallingNameStatus(rawValue: rawValue) ?? CallingNameStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.CandidateAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case country
        case postalCode
        case postalCodePlus4
        case state
        case streetInfo
        case streetNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let postalCodePlus4 = self.postalCodePlus4 {
            try encodeContainer.encode(postalCodePlus4, forKey: .postalCodePlus4)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetInfo = self.streetInfo {
            try encodeContainer.encode(streetInfo, forKey: .streetInfo)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetInfo)
        streetInfo = streetInfoDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let postalCodePlus4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCodePlus4)
        postalCodePlus4 = postalCodePlus4Decoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
    }
}

extension ChimeSDKVoiceClientTypes.CandidateAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CandidateAddress(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A suggested address.
    public struct CandidateAddress {
        /// The city of the candidate address.
        public var city: Swift.String?
        /// The country of the candidate address.
        public var country: Swift.String?
        /// The postal code of the candidate address.
        public var postalCode: Swift.String?
        /// The zip + 4 or postal code +4 of the candidate address.
        public var postalCodePlus4: Swift.String?
        /// The state of the candidate address.
        public var state: Swift.String?
        /// The street information of the candidate address.
        public var streetInfo: Swift.String?
        /// The numeric portion of the candidate address.
        public var streetNumber: Swift.String?

        public init(
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            state: Swift.String? = nil,
            streetInfo: Swift.String? = nil,
            streetNumber: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.state = state
            self.streetInfo = streetInfo
            self.streetNumber = streetNumber
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum Capability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [Capability] {
            return [
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .voice: return "Voice"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Capability(rawValue: rawValue) ?? Capability.sdkUnknown(rawValue)
        }
    }
}

public enum ChimeSDKVoiceClientTypes {}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Multiple instances of the same request were made simultaneously.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ConflictExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreatePhoneNumberOrderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePhoneNumberOrderInput(e164PhoneNumbers: \(Swift.String(describing: e164PhoneNumbers)), productType: \(Swift.String(describing: productType)), name: \"CONTENT_REDACTED\")"}
}

extension CreatePhoneNumberOrderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case name = "Name"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

extension CreatePhoneNumberOrderInput {

    static func urlPathProvider(_ value: CreatePhoneNumberOrderInput) -> Swift.String? {
        return "/phone-number-orders"
    }
}

public struct CreatePhoneNumberOrderInput {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// Specifies the name assigned to one or more phone numbers.
    public var name: Swift.String?
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        name: Swift.String? = nil,
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.name = name
        self.productType = productType
    }
}

struct CreatePhoneNumberOrderInputBody {
    let productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
    let e164PhoneNumbers: [Swift.String]?
    let name: Swift.String?
}

extension CreatePhoneNumberOrderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case name = "Name"
        case productType = "ProductType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreatePhoneNumberOrderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePhoneNumberOrderOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct CreatePhoneNumberOrderOutput {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?

    public init(
        phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct CreatePhoneNumberOrderOutputBody {
    let phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?
}

extension CreatePhoneNumberOrderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

enum CreatePhoneNumberOrderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProxySessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProxySessionInput(capabilities: \(Swift.String(describing: capabilities)), expiryMinutes: \(Swift.String(describing: expiryMinutes)), geoMatchLevel: \(Swift.String(describing: geoMatchLevel)), geoMatchParams: \(Swift.String(describing: geoMatchParams)), numberSelectionBehavior: \(Swift.String(describing: numberSelectionBehavior)), participantPhoneNumbers: \(Swift.String(describing: participantPhoneNumbers)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), name: \"CONTENT_REDACTED\")"}
}

extension CreateProxySessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = self.geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = self.geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = self.numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participantPhoneNumbers = participantPhoneNumbers {
            var participantPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participantPhoneNumbers)
            for e164phonenumber0 in participantPhoneNumbers {
                try participantPhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension CreateProxySessionInput {

    static func urlPathProvider(_ value: CreateProxySessionInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

public struct CreateProxySessionInput {
    /// The proxy session's capabilities.
    /// This member is required.
    public var capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
    public var geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel?
    /// The country and area code for the proxy phone number.
    public var geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams?
    /// The name of the proxy session.
    public var name: Swift.String?
    /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
    public var numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior?
    /// The participant phone numbers.
    /// This member is required.
    public var participantPhoneNumbers: [Swift.String]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        capabilities: [ChimeSDKVoiceClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel? = nil,
        geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams? = nil,
        name: Swift.String? = nil,
        numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior? = nil,
        participantPhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.geoMatchLevel = geoMatchLevel
        self.geoMatchParams = geoMatchParams
        self.name = name
        self.numberSelectionBehavior = numberSelectionBehavior
        self.participantPhoneNumbers = participantPhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct CreateProxySessionInputBody {
    let participantPhoneNumbers: [Swift.String]?
    let name: Swift.String?
    let expiryMinutes: Swift.Int?
    let capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    let numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior?
    let geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel?
    let geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams?
}

extension CreateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantPhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .participantPhoneNumbers)
        var participantPhoneNumbersDecoded0:[Swift.String]? = nil
        if let participantPhoneNumbersContainer = participantPhoneNumbersContainer {
            participantPhoneNumbersDecoded0 = [Swift.String]()
            for string0 in participantPhoneNumbersContainer {
                if let string0 = string0 {
                    participantPhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        participantPhoneNumbers = participantPhoneNumbersDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeSDKVoiceClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeSDKVoiceClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

extension CreateProxySessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProxySessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct CreateProxySessionOutput {
    /// The proxy session details.
    public var proxySession: ChimeSDKVoiceClientTypes.ProxySession?

    public init(
        proxySession: ChimeSDKVoiceClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct CreateProxySessionOutputBody {
    let proxySession: ChimeSDKVoiceClientTypes.ProxySession?
}

extension CreateProxySessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

enum CreateProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSipMediaApplicationCallInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipMediaApplicationCallInput(argumentsMap: \(Swift.String(describing: argumentsMap)), sipHeaders: \(Swift.String(describing: sipHeaders)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), fromPhoneNumber: \"CONTENT_REDACTED\", toPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension CreateSipMediaApplicationCallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case argumentsMap = "ArgumentsMap"
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let argumentsMap = argumentsMap {
            var argumentsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .argumentsMap)
            for (dictKey0, smaCreateCallArgumentsMap0) in argumentsMap {
                try argumentsMapContainer.encode(smaCreateCallArgumentsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let fromPhoneNumber = self.fromPhoneNumber {
            try encodeContainer.encode(fromPhoneNumber, forKey: .fromPhoneNumber)
        }
        if let sipHeaders = sipHeaders {
            var sipHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sipHeaders)
            for (dictKey0, sipHeadersMap0) in sipHeaders {
                try sipHeadersContainer.encode(sipHeadersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let toPhoneNumber = self.toPhoneNumber {
            try encodeContainer.encode(toPhoneNumber, forKey: .toPhoneNumber)
        }
    }
}

extension CreateSipMediaApplicationCallInput {

    static func urlPathProvider(_ value: CreateSipMediaApplicationCallInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls"
    }
}

public struct CreateSipMediaApplicationCallInput {
    /// Context passed to a CreateSipMediaApplication API call. For example, you could pass key-value pairs such as: "FirstName": "John", "LastName": "Doe"
    public var argumentsMap: [Swift.String:Swift.String]?
    /// The phone number that a user calls from. This is a phone number in your Amazon Chime SDK phone number inventory.
    /// This member is required.
    public var fromPhoneNumber: Swift.String?
    /// The SIP headers added to an outbound call leg.
    public var sipHeaders: [Swift.String:Swift.String]?
    /// The ID of the SIP media application.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The phone number that the service should call.
    /// This member is required.
    public var toPhoneNumber: Swift.String?

    public init(
        argumentsMap: [Swift.String:Swift.String]? = nil,
        fromPhoneNumber: Swift.String? = nil,
        sipHeaders: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        toPhoneNumber: Swift.String? = nil
    )
    {
        self.argumentsMap = argumentsMap
        self.fromPhoneNumber = fromPhoneNumber
        self.sipHeaders = sipHeaders
        self.sipMediaApplicationId = sipMediaApplicationId
        self.toPhoneNumber = toPhoneNumber
    }
}

struct CreateSipMediaApplicationCallInputBody {
    let fromPhoneNumber: Swift.String?
    let toPhoneNumber: Swift.String?
    let sipHeaders: [Swift.String:Swift.String]?
    let argumentsMap: [Swift.String:Swift.String]?
}

extension CreateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case argumentsMap = "ArgumentsMap"
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPhoneNumber)
        fromPhoneNumber = fromPhoneNumberDecoded
        let toPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPhoneNumber)
        toPhoneNumber = toPhoneNumberDecoded
        let sipHeadersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sipHeaders)
        var sipHeadersDecoded0: [Swift.String:Swift.String]? = nil
        if let sipHeadersContainer = sipHeadersContainer {
            sipHeadersDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in sipHeadersContainer {
                if let sensitivestring0 = sensitivestring0 {
                    sipHeadersDecoded0?[key0] = sensitivestring0
                }
            }
        }
        sipHeaders = sipHeadersDecoded0
        let argumentsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .argumentsMap)
        var argumentsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let argumentsMapContainer = argumentsMapContainer {
            argumentsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in argumentsMapContainer {
                if let sensitivestring0 = sensitivestring0 {
                    argumentsMapDecoded0?[key0] = sensitivestring0
                }
            }
        }
        argumentsMap = argumentsMapDecoded0
    }
}

extension CreateSipMediaApplicationCallOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSipMediaApplicationCallOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct CreateSipMediaApplicationCallOutput {
    /// The actual call.
    public var sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?

    public init(
        sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct CreateSipMediaApplicationCallOutputBody {
    let sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?
}

extension CreateSipMediaApplicationCallOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

enum CreateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSipMediaApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSipMediaApplicationInput {

    static func urlPathProvider(_ value: CreateSipMediaApplicationInput) -> Swift.String? {
        return "/sip-media-applications"
    }
}

public struct CreateSipMediaApplicationInput {
    /// The AWS Region assigned to the SIP media application.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// List of endpoints (Lambda ARNs) specified for the SIP media application.
    /// This member is required.
    public var endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
    /// The SIP media application's name.
    /// This member is required.
    public var name: Swift.String?
    /// The tags assigned to the SIP media application.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        awsRegion: Swift.String? = nil,
        endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil,
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.awsRegion = awsRegion
        self.endpoints = endpoints
        self.name = name
        self.tags = tags
    }
}

struct CreateSipMediaApplicationInputBody {
    let awsRegion: Swift.String?
    let name: Swift.String?
    let endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension CreateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSipMediaApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSipMediaApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct CreateSipMediaApplicationOutput {
    /// The SIP media application details.
    public var sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct CreateSipMediaApplicationOutputBody {
    let sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?
}

extension CreateSipMediaApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

enum CreateSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSipRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = self.triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
    }
}

extension CreateSipRuleInput {

    static func urlPathProvider(_ value: CreateSipRuleInput) -> Swift.String? {
        return "/sip-rules"
    }
}

public struct CreateSipRuleInput {
    /// Disables or enables a SIP rule. You must disable SIP rules before you can delete them.
    public var disabled: Swift.Bool?
    /// The name of the SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// List of SIP media applications, with priority and AWS Region. Only one SIP application per AWS Region can be used.
    public var targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
    /// The type of trigger assigned to the SIP rule in TriggerValue, currently RequestUriHostname or ToPhoneNumber.
    /// This member is required.
    public var triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType?
    /// If TriggerType is RequestUriHostname, the value can be the outbound host name of a Voice Connector. If TriggerType is ToPhoneNumber, the value can be a customer-owned phone number in the E164 format. The SipMediaApplication specified in the SipRule is triggered if the request URI in an incoming SIP request matches the RequestUriHostname, or if the To header in the incoming SIP request matches the ToPhoneNumber value.
    /// This member is required.
    public var triggerValue: Swift.String?

    public init(
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil,
        triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType? = nil,
        triggerValue: Swift.String? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.targetApplications = targetApplications
        self.triggerType = triggerType
        self.triggerValue = triggerValue
    }
}

struct CreateSipRuleInputBody {
    let name: Swift.String?
    let triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType?
    let triggerValue: Swift.String?
    let disabled: Swift.Bool?
    let targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
}

extension CreateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

extension CreateSipRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSipRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct CreateSipRuleOutput {
    /// The SIP rule information, including the rule ID, triggers, and target applications.
    public var sipRule: ChimeSDKVoiceClientTypes.SipRule?

    public init(
        sipRule: ChimeSDKVoiceClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct CreateSipRuleOutputBody {
    let sipRule: ChimeSDKVoiceClientTypes.SipRule?
}

extension CreateSipRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

enum CreateSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }
}

extension CreateVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: CreateVoiceConnectorGroupInput) -> Swift.String? {
        return "/voice-connector-groups"
    }
}

public struct CreateVoiceConnectorGroupInput {
    /// The name of the Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// Lists the Voice Connectors that inbound calls are routed to.
    public var voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?

    public init(
        name: Swift.String? = nil,
        voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct CreateVoiceConnectorGroupInputBody {
    let name: Swift.String?
    let voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?
}

extension CreateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

extension CreateVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct CreateVoiceConnectorGroupOutput {
    /// The details of the Voice Connector group.
    public var voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct CreateVoiceConnectorGroupOutputBody {
    let voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?
}

extension CreateVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

enum CreateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateVoiceConnectorInput {

    static func urlPathProvider(_ value: CreateVoiceConnectorInput) -> Swift.String? {
        return "/voice-connectors"
    }
}

public struct CreateVoiceConnectorInput {
    /// The AWS Region in which the Amazon Chime SDK Voice Connector is created. Default value: us-east-1 .
    public var awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?
    /// The name of the Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// Enables or disables encryption for the Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?
    /// The tags assigned to the Voice Connector.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion? = nil,
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil,
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.awsRegion = awsRegion
        self.name = name
        self.requireEncryption = requireEncryption
        self.tags = tags
    }
}

struct CreateVoiceConnectorInputBody {
    let name: Swift.String?
    let awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?
    let requireEncryption: Swift.Bool?
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension CreateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct CreateVoiceConnectorOutput {
    /// The details of the Voice Connector.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct CreateVoiceConnectorOutputBody {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?
}

extension CreateVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

enum CreateVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceProfileDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateVoiceProfileDomainInput {

    static func urlPathProvider(_ value: CreateVoiceProfileDomainInput) -> Swift.String? {
        return "/voice-profile-domains"
    }
}

public struct CreateVoiceProfileDomainInput {
    /// The unique identifier for the client request. Use a different token for different domain creation requests.
    public var clientRequestToken: Swift.String?
    /// A description of the voice profile domain.
    public var description: Swift.String?
    /// The name of the voice profile domain.
    /// This member is required.
    public var name: Swift.String?
    /// The server-side encryption configuration for the request.
    /// This member is required.
    public var serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration?
    /// The tags assigned to the domain.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
    }
}

struct CreateVoiceProfileDomainInputBody {
    let name: Swift.String?
    let description: Swift.String?
    let serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension CreateVoiceProfileDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVoiceProfileDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceProfileDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfileDomain = output.voiceProfileDomain
        } else {
            self.voiceProfileDomain = nil
        }
    }
}

public struct CreateVoiceProfileDomainOutput {
    /// The requested voice profile domain.
    public var voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?

    public init(
        voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain? = nil
    )
    {
        self.voiceProfileDomain = voiceProfileDomain
    }
}

struct CreateVoiceProfileDomainOutputBody {
    let voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?
}

extension CreateVoiceProfileDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfileDomain = "VoiceProfileDomain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfileDomain.self, forKey: .voiceProfileDomain)
        voiceProfileDomain = voiceProfileDomainDecoded
    }
}

enum CreateVoiceProfileDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTaskId = "SpeakerSearchTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let speakerSearchTaskId = self.speakerSearchTaskId {
            try encodeContainer.encode(speakerSearchTaskId, forKey: .speakerSearchTaskId)
        }
    }
}

extension CreateVoiceProfileInput {

    static func urlPathProvider(_ value: CreateVoiceProfileInput) -> Swift.String? {
        return "/voice-profiles"
    }
}

public struct CreateVoiceProfileInput {
    /// The ID of the speaker search task.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?

    public init(
        speakerSearchTaskId: Swift.String? = nil
    )
    {
        self.speakerSearchTaskId = speakerSearchTaskId
    }
}

struct CreateVoiceProfileInputBody {
    let speakerSearchTaskId: Swift.String?
}

extension CreateVoiceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTaskId = "SpeakerSearchTaskId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerSearchTaskId)
        speakerSearchTaskId = speakerSearchTaskIdDecoded
    }
}

extension CreateVoiceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfile = output.voiceProfile
        } else {
            self.voiceProfile = nil
        }
    }
}

public struct CreateVoiceProfileOutput {
    /// The requested voice profile.
    public var voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?

    public init(
        voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile? = nil
    )
    {
        self.voiceProfile = voiceProfile
    }
}

struct CreateVoiceProfileOutputBody {
    let voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?
}

extension CreateVoiceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfile = "VoiceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfile.self, forKey: .voiceProfile)
        voiceProfile = voiceProfileDecoded
    }
}

enum CreateVoiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GoneException": return try await GoneException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Credential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Credential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credential(password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The SIP credentials used to authenticate requests to an Amazon Chime SDK Voice Connector.
    public struct Credential {
        /// The RFC2617 compliant password associated with the SIP credentials, in US-ASCII format.
        public var password: Swift.String?
        /// The RFC2617 compliant user name associated with the SIP credentials, in US-ASCII format.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingCountry = "CallingCountry"
        case emergencyPhoneNumber = "EmergencyPhoneNumber"
        case testPhoneNumber = "TestPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingCountry = self.callingCountry {
            try encodeContainer.encode(callingCountry, forKey: .callingCountry)
        }
        if let emergencyPhoneNumber = self.emergencyPhoneNumber {
            try encodeContainer.encode(emergencyPhoneNumber, forKey: .emergencyPhoneNumber)
        }
        if let testPhoneNumber = self.testPhoneNumber {
            try encodeContainer.encode(testPhoneNumber, forKey: .testPhoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emergencyPhoneNumber)
        emergencyPhoneNumber = emergencyPhoneNumberDecoded
        let testPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testPhoneNumber)
        testPhoneNumber = testPhoneNumberDecoded
        let callingCountryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingCountry)
        callingCountry = callingCountryDecoded
    }
}

extension ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DNISEmergencyCallingConfiguration(callingCountry: \(Swift.String(describing: callingCountry)), emergencyPhoneNumber: \"CONTENT_REDACTED\", testPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The Dialed Number Identification Service (DNIS) emergency calling configuration details associated with an Amazon Chime SDK Voice Connector's emergency calling configuration.
    public struct DNISEmergencyCallingConfiguration {
        /// The country from which emergency calls are allowed, in ISO 3166-1 alpha-2 format.
        /// This member is required.
        public var callingCountry: Swift.String?
        /// The DNIS phone number that you route emergency calls to, in E.164 format.
        /// This member is required.
        public var emergencyPhoneNumber: Swift.String?
        /// The DNIS phone number for routing test emergency calls to, in E.164 format.
        public var testPhoneNumber: Swift.String?

        public init(
            callingCountry: Swift.String? = nil,
            emergencyPhoneNumber: Swift.String? = nil,
            testPhoneNumber: Swift.String? = nil
        )
        {
            self.callingCountry = callingCountry
            self.emergencyPhoneNumber = emergencyPhoneNumber
            self.testPhoneNumber = testPhoneNumber
        }
    }

}

extension DeletePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePhoneNumberInput(phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension DeletePhoneNumberInput {

    static func urlPathProvider(_ value: DeletePhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct DeletePhoneNumberInput {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct DeletePhoneNumberInputBody {
}

extension DeletePhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePhoneNumberOutput {

    public init() { }
}

enum DeletePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProxySessionInput {

    static func urlPathProvider(_ value: DeleteProxySessionInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = value.proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct DeleteProxySessionInput {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteProxySessionInputBody {
}

extension DeleteProxySessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProxySessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProxySessionOutput {

    public init() { }
}

enum DeleteProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSipMediaApplicationInput {

    static func urlPathProvider(_ value: DeleteSipMediaApplicationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct DeleteSipMediaApplicationInput {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct DeleteSipMediaApplicationInputBody {
}

extension DeleteSipMediaApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipMediaApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSipMediaApplicationOutput {

    public init() { }
}

enum DeleteSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSipRuleInput {

    static func urlPathProvider(_ value: DeleteSipRuleInput) -> Swift.String? {
        guard let sipRuleId = value.sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct DeleteSipRuleInput {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init(
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct DeleteSipRuleInputBody {
}

extension DeleteSipRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSipRuleOutput {

    public init() { }
}

enum DeleteSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorEmergencyCallingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorEmergencyCallingConfigurationInputBody {
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationOutput {

    public init() { }
}

enum DeleteVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceConnectorGroupInput {
    /// The Voice Connector Group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DeleteVoiceConnectorGroupInputBody {
}

extension DeleteVoiceConnectorGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorGroupOutput {

    public init() { }
}

enum DeleteVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceConnectorInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorInputBody {
}

extension DeleteVoiceConnectorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOriginationInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorOriginationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct DeleteVoiceConnectorOriginationInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorOriginationInputBody {
}

extension DeleteVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOriginationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorOriginationOutput {

    public init() { }
}

enum DeleteVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorOutput {

    public init() { }
}

enum DeleteVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorProxyInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorProxyInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct DeleteVoiceConnectorProxyInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorProxyInputBody {
}

extension DeleteVoiceConnectorProxyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorProxyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorProxyOutput {

    public init() { }
}

enum DeleteVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorStreamingConfigurationInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorStreamingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorStreamingConfigurationInputBody {
}

extension DeleteVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorStreamingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationOutput {

    public init() { }
}

enum DeleteVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usernames = usernames {
            var usernamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usernames)
            for sensitivestring0 in usernames {
                try usernamesContainer.encode(sensitivestring0)
            }
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput {

    static func queryItemProvider(_ value: DeleteVoiceConnectorTerminationCredentialsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "delete"))
        return items
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorTerminationCredentialsInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsInput {
    /// The RFC2617 compliant username associated with the SIP credentials, in US-ASCII format.
    /// This member is required.
    public var usernames: [Swift.String]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        usernames: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.usernames = usernames
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationCredentialsInputBody {
    let usernames: [Swift.String]?
}

extension DeleteVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

extension DeleteVoiceConnectorTerminationCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsOutput {

    public init() { }
}

enum DeleteVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorTerminationInput {

    static func urlPathProvider(_ value: DeleteVoiceConnectorTerminationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct DeleteVoiceConnectorTerminationInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationInputBody {
}

extension DeleteVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorTerminationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorTerminationOutput {

    public init() { }
}

enum DeleteVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceProfileDomainInput {

    static func urlPathProvider(_ value: DeleteVoiceProfileDomainInput) -> Swift.String? {
        guard let voiceProfileDomainId = value.voiceProfileDomainId else {
            return nil
        }
        return "/voice-profile-domains/\(voiceProfileDomainId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceProfileDomainInput {
    /// The voice profile domain ID.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct DeleteVoiceProfileDomainInputBody {
}

extension DeleteVoiceProfileDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceProfileDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceProfileDomainOutput {

    public init() { }
}

enum DeleteVoiceProfileDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceProfileInput {

    static func urlPathProvider(_ value: DeleteVoiceProfileInput) -> Swift.String? {
        guard let voiceProfileId = value.voiceProfileId else {
            return nil
        }
        return "/voice-profiles/\(voiceProfileId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceProfileInput {
    /// The voice profile ID.
    /// This member is required.
    public var voiceProfileId: Swift.String?

    public init(
        voiceProfileId: Swift.String? = nil
    )
    {
        self.voiceProfileId = voiceProfileId
    }
}

struct DeleteVoiceProfileInputBody {
}

extension DeleteVoiceProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceProfileOutput {

    public init() { }
}

enum DeleteVoiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput {

    static func queryItemProvider(_ value: DisassociatePhoneNumbersFromVoiceConnectorGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
        return items
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: DisassociatePhoneNumbersFromVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInput {
    /// The list of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody {
    let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociatePhoneNumbersFromVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutputBody {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput {

    static func queryItemProvider(_ value: DisassociatePhoneNumbersFromVoiceConnectorInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
        return items
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput {

    static func urlPathProvider(_ value: DisassociatePhoneNumbersFromVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInput {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorInputBody {
    let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociatePhoneNumbersFromVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorOutput {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorOutputBody {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

enum DisassociatePhoneNumbersFromVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnis = "DNIS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnis = dnis {
            var dnisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnis)
            for dnisemergencycallingconfiguration0 in dnis {
                try dnisContainer.encode(dnisemergencycallingconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnisContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration?].self, forKey: .dnis)
        var dnisDecoded0:[ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]? = nil
        if let dnisContainer = dnisContainer {
            dnisDecoded0 = [ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]()
            for structure0 in dnisContainer {
                if let structure0 = structure0 {
                    dnisDecoded0?.append(structure0)
                }
            }
        }
        dnis = dnisDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The emergency calling configuration details associated with an Amazon Chime SDK Voice Connector.
    public struct EmergencyCallingConfiguration {
        /// The Dialed Number Identification Service (DNIS) emergency calling configuration details.
        public var dnis: [ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]?

        public init(
            dnis: [ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]? = nil
        )
        {
            self.dnis = dnis
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case gone
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .gone,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .gone: return "Gone"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum GeoMatchLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case areacode
        case country
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoMatchLevel] {
            return [
                .areacode,
                .country,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .areacode: return "AreaCode"
            case .country: return "Country"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoMatchLevel(rawValue: rawValue) ?? GeoMatchLevel.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.GeoMatchParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaCode = "AreaCode"
        case country = "Country"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaCode = self.areaCode {
            try encodeContainer.encode(areaCode, forKey: .areaCode)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let areaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .areaCode)
        areaCode = areaCodeDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The country and area code for a proxy phone number in a proxy phone session.
    public struct GeoMatchParams {
        /// The area code.
        /// This member is required.
        public var areaCode: Swift.String?
        /// The country.
        /// This member is required.
        public var country: Swift.String?

        public init(
            areaCode: Swift.String? = nil,
            country: Swift.String? = nil
        )
        {
            self.areaCode = areaCode
            self.country = country
        }
    }

}

extension GetGlobalSettingsInput {

    static func urlPathProvider(_ value: GetGlobalSettingsInput) -> Swift.String? {
        return "/settings"
    }
}

public struct GetGlobalSettingsInput {

    public init() { }
}

struct GetGlobalSettingsInputBody {
}

extension GetGlobalSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGlobalSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGlobalSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct GetGlobalSettingsOutput {
    /// The Voice Connector settings.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct GetGlobalSettingsOutputBody {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?
}

extension GetGlobalSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

enum GetGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberInput(phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension GetPhoneNumberInput {

    static func urlPathProvider(_ value: GetPhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct GetPhoneNumberInput {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct GetPhoneNumberInputBody {
}

extension GetPhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberOrderInput {

    static func urlPathProvider(_ value: GetPhoneNumberOrderInput) -> Swift.String? {
        guard let phoneNumberOrderId = value.phoneNumberOrderId else {
            return nil
        }
        return "/phone-number-orders/\(phoneNumberOrderId.urlPercentEncoding())"
    }
}

public struct GetPhoneNumberOrderInput {
    /// The ID of the phone number order .
    /// This member is required.
    public var phoneNumberOrderId: Swift.String?

    public init(
        phoneNumberOrderId: Swift.String? = nil
    )
    {
        self.phoneNumberOrderId = phoneNumberOrderId
    }
}

struct GetPhoneNumberOrderInputBody {
}

extension GetPhoneNumberOrderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberOrderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPhoneNumberOrderOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct GetPhoneNumberOrderOutput {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?

    public init(
        phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct GetPhoneNumberOrderOutputBody {
    let phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?
}

extension GetPhoneNumberOrderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

enum GetPhoneNumberOrderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct GetPhoneNumberOutput {
    /// The phone number details.
    public var phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct GetPhoneNumberOutputBody {
    let phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?
}

extension GetPhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

enum GetPhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPhoneNumberSettingsInput {

    static func urlPathProvider(_ value: GetPhoneNumberSettingsInput) -> Swift.String? {
        return "/settings/phone-number"
    }
}

public struct GetPhoneNumberSettingsInput {

    public init() { }
}

struct GetPhoneNumberSettingsInputBody {
}

extension GetPhoneNumberSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberSettingsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberSettingsOutput(callingNameUpdatedTimestamp: \(Swift.String(describing: callingNameUpdatedTimestamp)), callingName: \"CONTENT_REDACTED\")"}
}

extension GetPhoneNumberSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPhoneNumberSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.callingName = output.callingName
            self.callingNameUpdatedTimestamp = output.callingNameUpdatedTimestamp
        } else {
            self.callingName = nil
            self.callingNameUpdatedTimestamp = nil
        }
    }
}

public struct GetPhoneNumberSettingsOutput {
    /// The default outbound calling name for the account.
    public var callingName: Swift.String?
    /// The updated outbound calling name timestamp, in ISO 8601 format.
    public var callingNameUpdatedTimestamp: ClientRuntime.Date?

    public init(
        callingName: Swift.String? = nil,
        callingNameUpdatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.callingName = callingName
        self.callingNameUpdatedTimestamp = callingNameUpdatedTimestamp
    }
}

struct GetPhoneNumberSettingsOutputBody {
    let callingName: Swift.String?
    let callingNameUpdatedTimestamp: ClientRuntime.Date?
}

extension GetPhoneNumberSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case callingNameUpdatedTimestamp = "CallingNameUpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .callingNameUpdatedTimestamp)
        callingNameUpdatedTimestamp = callingNameUpdatedTimestampDecoded
    }
}

enum GetPhoneNumberSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProxySessionInput {

    static func urlPathProvider(_ value: GetProxySessionInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = value.proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct GetProxySessionInput {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetProxySessionInputBody {
}

extension GetProxySessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProxySessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProxySessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct GetProxySessionOutput {
    /// The proxy session details.
    public var proxySession: ChimeSDKVoiceClientTypes.ProxySession?

    public init(
        proxySession: ChimeSDKVoiceClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct GetProxySessionOutputBody {
    let proxySession: ChimeSDKVoiceClientTypes.ProxySession?
}

extension GetProxySessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

enum GetProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipMediaApplicationAlexaSkillConfigurationInput {

    static func urlPathProvider(_ value: GetSipMediaApplicationAlexaSkillConfigurationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/alexa-skill-configuration"
    }
}

public struct GetSipMediaApplicationAlexaSkillConfigurationInput {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationAlexaSkillConfigurationInputBody {
}

extension GetSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationAlexaSkillConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipMediaApplicationAlexaSkillConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationAlexaSkillConfiguration = output.sipMediaApplicationAlexaSkillConfiguration
        } else {
            self.sipMediaApplicationAlexaSkillConfiguration = nil
        }
    }
}

public struct GetSipMediaApplicationAlexaSkillConfigurationOutput {
    /// Returns the Alexa Skill configuration.
    public var sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?

    public init(
        sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration? = nil
    )
    {
        self.sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfiguration
    }
}

struct GetSipMediaApplicationAlexaSkillConfigurationOutputBody {
    let sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
}

extension GetSipMediaApplicationAlexaSkillConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationAlexaSkillConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration.self, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfigurationDecoded
    }
}

enum GetSipMediaApplicationAlexaSkillConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipMediaApplicationInput {

    static func urlPathProvider(_ value: GetSipMediaApplicationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct GetSipMediaApplicationInput {
    /// The SIP media application ID .
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationInputBody {
}

extension GetSipMediaApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationLoggingConfigurationInput {

    static func urlPathProvider(_ value: GetSipMediaApplicationLoggingConfigurationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

public struct GetSipMediaApplicationLoggingConfigurationInput {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationLoggingConfigurationInputBody {
}

extension GetSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipMediaApplicationLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct GetSipMediaApplicationLoggingConfigurationOutput {
    /// The actual logging configuration.
    public var sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct GetSipMediaApplicationLoggingConfigurationOutputBody {
    let sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension GetSipMediaApplicationLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

enum GetSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipMediaApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipMediaApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct GetSipMediaApplicationOutput {
    /// The details of the SIP media application.
    public var sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct GetSipMediaApplicationOutputBody {
    let sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?
}

extension GetSipMediaApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

enum GetSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipRuleInput {

    static func urlPathProvider(_ value: GetSipRuleInput) -> Swift.String? {
        guard let sipRuleId = value.sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct GetSipRuleInput {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init(
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct GetSipRuleInputBody {
}

extension GetSipRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSipRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct GetSipRuleOutput {
    /// The SIP rule details.
    public var sipRule: ChimeSDKVoiceClientTypes.SipRule?

    public init(
        sipRule: ChimeSDKVoiceClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct GetSipRuleOutputBody {
    let sipRule: ChimeSDKVoiceClientTypes.SipRule?
}

extension GetSipRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

enum GetSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSpeakerSearchTaskInput {

    static func urlPathProvider(_ value: GetSpeakerSearchTaskInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let speakerSearchTaskId = value.speakerSearchTaskId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/speaker-search-tasks/\(speakerSearchTaskId.urlPercentEncoding())"
    }
}

public struct GetSpeakerSearchTaskInput {
    /// The ID of the speaker search task.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        speakerSearchTaskId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.speakerSearchTaskId = speakerSearchTaskId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetSpeakerSearchTaskInputBody {
}

extension GetSpeakerSearchTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSpeakerSearchTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSpeakerSearchTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.speakerSearchTask = output.speakerSearchTask
        } else {
            self.speakerSearchTask = nil
        }
    }
}

public struct GetSpeakerSearchTaskOutput {
    /// The details of the speaker search task.
    public var speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask?

    public init(
        speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask? = nil
    )
    {
        self.speakerSearchTask = speakerSearchTask
    }
}

struct GetSpeakerSearchTaskOutputBody {
    let speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask?
}

extension GetSpeakerSearchTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTask = "SpeakerSearchTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SpeakerSearchTask.self, forKey: .speakerSearchTask)
        speakerSearchTask = speakerSearchTaskDecoded
    }
}

enum GetSpeakerSearchTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorEmergencyCallingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationInputBody {
}

extension GetVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorEmergencyCallingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationOutput {
    /// The details of the emergency calling configuration.
    public var emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?

    public init(
        emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationOutputBody {
    let emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

enum GetVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: GetVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct GetVoiceConnectorGroupInput {
    /// The Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct GetVoiceConnectorGroupInputBody {
}

extension GetVoiceConnectorGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct GetVoiceConnectorGroupOutput {
    /// The details of the Voice Connector group.
    public var voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct GetVoiceConnectorGroupOutputBody {
    let voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?
}

extension GetVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

enum GetVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorInput {

    static func urlPathProvider(_ value: GetVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct GetVoiceConnectorInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorInputBody {
}

extension GetVoiceConnectorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorLoggingConfigurationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorLoggingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

public struct GetVoiceConnectorLoggingConfigurationInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorLoggingConfigurationInputBody {
}

extension GetVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorLoggingConfigurationOutput {
    /// The logging configuration details .
    public var loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?

    public init(
        loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct GetVoiceConnectorLoggingConfigurationOutputBody {
    let loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
}

extension GetVoiceConnectorLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

enum GetVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorOriginationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorOriginationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct GetVoiceConnectorOriginationInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorOriginationInputBody {
}

extension GetVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorOriginationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorOriginationOutputBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct GetVoiceConnectorOriginationOutput {
    /// The origination setting details.
    public var origination: ChimeSDKVoiceClientTypes.Origination?

    public init(
        origination: ChimeSDKVoiceClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct GetVoiceConnectorOriginationOutputBody {
    let origination: ChimeSDKVoiceClientTypes.Origination?
}

extension GetVoiceConnectorOriginationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

enum GetVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct GetVoiceConnectorOutput {
    /// The Voice Connector details.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct GetVoiceConnectorOutputBody {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?
}

extension GetVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

enum GetVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorProxyInput {

    static func urlPathProvider(_ value: GetVoiceConnectorProxyInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct GetVoiceConnectorProxyInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorProxyInputBody {
}

extension GetVoiceConnectorProxyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorProxyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorProxyOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct GetVoiceConnectorProxyOutput {
    /// The proxy configuration details.
    public var proxy: ChimeSDKVoiceClientTypes.Proxy?

    public init(
        proxy: ChimeSDKVoiceClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct GetVoiceConnectorProxyOutputBody {
    let proxy: ChimeSDKVoiceClientTypes.Proxy?
}

extension GetVoiceConnectorProxyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

enum GetVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorStreamingConfigurationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorStreamingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct GetVoiceConnectorStreamingConfigurationInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorStreamingConfigurationInputBody {
}

extension GetVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorStreamingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorStreamingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorStreamingConfigurationOutput {
    /// The details of the streaming configuration.
    public var streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?

    public init(
        streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct GetVoiceConnectorStreamingConfigurationOutputBody {
    let streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
}

extension GetVoiceConnectorStreamingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

enum GetVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorTerminationHealthInput {

    static func urlPathProvider(_ value: GetVoiceConnectorTerminationHealthInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/health"
    }
}

public struct GetVoiceConnectorTerminationHealthInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationHealthInputBody {
}

extension GetVoiceConnectorTerminationHealthInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorTerminationHealthOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorTerminationHealthOutputBody = try responseDecoder.decode(responseBody: data)
            self.terminationHealth = output.terminationHealth
        } else {
            self.terminationHealth = nil
        }
    }
}

public struct GetVoiceConnectorTerminationHealthOutput {
    /// The termination health details.
    public var terminationHealth: ChimeSDKVoiceClientTypes.TerminationHealth?

    public init(
        terminationHealth: ChimeSDKVoiceClientTypes.TerminationHealth? = nil
    )
    {
        self.terminationHealth = terminationHealth
    }
}

struct GetVoiceConnectorTerminationHealthOutputBody {
    let terminationHealth: ChimeSDKVoiceClientTypes.TerminationHealth?
}

extension GetVoiceConnectorTerminationHealthOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminationHealth = "TerminationHealth"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationHealthDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.TerminationHealth.self, forKey: .terminationHealth)
        terminationHealth = terminationHealthDecoded
    }
}

enum GetVoiceConnectorTerminationHealthOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorTerminationInput {

    static func urlPathProvider(_ value: GetVoiceConnectorTerminationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct GetVoiceConnectorTerminationInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationInputBody {
}

extension GetVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorTerminationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorTerminationOutputBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct GetVoiceConnectorTerminationOutput {
    /// The termination setting details.
    public var termination: ChimeSDKVoiceClientTypes.Termination?

    public init(
        termination: ChimeSDKVoiceClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct GetVoiceConnectorTerminationOutputBody {
    let termination: ChimeSDKVoiceClientTypes.Termination?
}

extension GetVoiceConnectorTerminationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

enum GetVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceProfileDomainInput {

    static func urlPathProvider(_ value: GetVoiceProfileDomainInput) -> Swift.String? {
        guard let voiceProfileDomainId = value.voiceProfileDomainId else {
            return nil
        }
        return "/voice-profile-domains/\(voiceProfileDomainId.urlPercentEncoding())"
    }
}

public struct GetVoiceProfileDomainInput {
    /// The voice profile domain ID.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct GetVoiceProfileDomainInputBody {
}

extension GetVoiceProfileDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceProfileDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceProfileDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfileDomain = output.voiceProfileDomain
        } else {
            self.voiceProfileDomain = nil
        }
    }
}

public struct GetVoiceProfileDomainOutput {
    /// The details of the voice profile domain.
    public var voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?

    public init(
        voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain? = nil
    )
    {
        self.voiceProfileDomain = voiceProfileDomain
    }
}

struct GetVoiceProfileDomainOutputBody {
    let voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?
}

extension GetVoiceProfileDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfileDomain = "VoiceProfileDomain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfileDomain.self, forKey: .voiceProfileDomain)
        voiceProfileDomain = voiceProfileDomainDecoded
    }
}

enum GetVoiceProfileDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceProfileInput {

    static func urlPathProvider(_ value: GetVoiceProfileInput) -> Swift.String? {
        guard let voiceProfileId = value.voiceProfileId else {
            return nil
        }
        return "/voice-profiles/\(voiceProfileId.urlPercentEncoding())"
    }
}

public struct GetVoiceProfileInput {
    /// The voice profile ID.
    /// This member is required.
    public var voiceProfileId: Swift.String?

    public init(
        voiceProfileId: Swift.String? = nil
    )
    {
        self.voiceProfileId = voiceProfileId
    }
}

struct GetVoiceProfileInputBody {
}

extension GetVoiceProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfile = output.voiceProfile
        } else {
            self.voiceProfile = nil
        }
    }
}

public struct GetVoiceProfileOutput {
    /// The voice profile details.
    public var voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?

    public init(
        voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile? = nil
    )
    {
        self.voiceProfile = voiceProfile
    }
}

struct GetVoiceProfileOutputBody {
    let voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?
}

extension GetVoiceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfile = "VoiceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfile.self, forKey: .voiceProfile)
        voiceProfile = voiceProfileDecoded
    }
}

enum GetVoiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceToneAnalysisTaskInput {

    static func queryItemProvider(_ value: GetVoiceToneAnalysisTaskInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let isCaller = value.isCaller else {
            let message = "Creating a URL Query Item failed. isCaller is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let isCallerQueryItem = ClientRuntime.SDKURLQueryItem(name: "isCaller".urlPercentEncoding(), value: Swift.String(isCaller).urlPercentEncoding())
        items.append(isCallerQueryItem)
        return items
    }
}

extension GetVoiceToneAnalysisTaskInput {

    static func urlPathProvider(_ value: GetVoiceToneAnalysisTaskInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let voiceToneAnalysisTaskId = value.voiceToneAnalysisTaskId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/voice-tone-analysis-tasks/\(voiceToneAnalysisTaskId.urlPercentEncoding())"
    }
}

public struct GetVoiceToneAnalysisTaskInput {
    /// Specifies whether the voice being analyzed is the caller (originator) or the callee (responder).
    /// This member is required.
    public var isCaller: Swift.Bool?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?
    /// The ID of the voice tone anlysis task.
    /// This member is required.
    public var voiceToneAnalysisTaskId: Swift.String?

    public init(
        isCaller: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil,
        voiceToneAnalysisTaskId: Swift.String? = nil
    )
    {
        self.isCaller = isCaller
        self.voiceConnectorId = voiceConnectorId
        self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
    }
}

struct GetVoiceToneAnalysisTaskInputBody {
}

extension GetVoiceToneAnalysisTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceToneAnalysisTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceToneAnalysisTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceToneAnalysisTask = output.voiceToneAnalysisTask
        } else {
            self.voiceToneAnalysisTask = nil
        }
    }
}

public struct GetVoiceToneAnalysisTaskOutput {
    /// The details of the voice tone analysis task.
    public var voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask?

    public init(
        voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask? = nil
    )
    {
        self.voiceToneAnalysisTask = voiceToneAnalysisTask
    }
}

struct GetVoiceToneAnalysisTaskOutputBody {
    let voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask?
}

extension GetVoiceToneAnalysisTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceToneAnalysisTask = "VoiceToneAnalysisTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceToneAnalysisTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask.self, forKey: .voiceToneAnalysisTask)
        voiceToneAnalysisTask = voiceToneAnalysisTaskDecoded
    }
}

enum GetVoiceToneAnalysisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GoneException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GoneExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access to the target resource is no longer available at the origin server. This condition is likely to be permanent.
public struct GoneException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GoneException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct GoneExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension GoneExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ListAvailableVoiceConnectorRegionsInput {

    static func urlPathProvider(_ value: ListAvailableVoiceConnectorRegionsInput) -> Swift.String? {
        return "/voice-connector-regions"
    }
}

public struct ListAvailableVoiceConnectorRegionsInput {

    public init() { }
}

struct ListAvailableVoiceConnectorRegionsInputBody {
}

extension ListAvailableVoiceConnectorRegionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAvailableVoiceConnectorRegionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAvailableVoiceConnectorRegionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorRegions = output.voiceConnectorRegions
        } else {
            self.voiceConnectorRegions = nil
        }
    }
}

public struct ListAvailableVoiceConnectorRegionsOutput {
    /// The list of AWS Regions.
    public var voiceConnectorRegions: [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]?

    public init(
        voiceConnectorRegions: [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]? = nil
    )
    {
        self.voiceConnectorRegions = voiceConnectorRegions
    }
}

struct ListAvailableVoiceConnectorRegionsOutputBody {
    let voiceConnectorRegions: [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]?
}

extension ListAvailableVoiceConnectorRegionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorRegions = "VoiceConnectorRegions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorRegionsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?].self, forKey: .voiceConnectorRegions)
        var voiceConnectorRegionsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]? = nil
        if let voiceConnectorRegionsContainer = voiceConnectorRegionsContainer {
            voiceConnectorRegionsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]()
            for enum0 in voiceConnectorRegionsContainer {
                if let enum0 = enum0 {
                    voiceConnectorRegionsDecoded0?.append(enum0)
                }
            }
        }
        voiceConnectorRegions = voiceConnectorRegionsDecoded0
    }
}

enum ListAvailableVoiceConnectorRegionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPhoneNumberOrdersInput {

    static func queryItemProvider(_ value: ListPhoneNumberOrdersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPhoneNumberOrdersInput {

    static func urlPathProvider(_ value: ListPhoneNumberOrdersInput) -> Swift.String? {
        return "/phone-number-orders"
    }
}

public struct ListPhoneNumberOrdersInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPhoneNumberOrdersInputBody {
}

extension ListPhoneNumberOrdersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumberOrdersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPhoneNumberOrdersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumberOrders = output.phoneNumberOrders
        } else {
            self.nextToken = nil
            self.phoneNumberOrders = nil
        }
    }
}

public struct ListPhoneNumberOrdersOutput {
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number order details.
    public var phoneNumberOrders: [ChimeSDKVoiceClientTypes.PhoneNumberOrder]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumberOrders: [ChimeSDKVoiceClientTypes.PhoneNumberOrder]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberOrders = phoneNumberOrders
    }
}

struct ListPhoneNumberOrdersOutputBody {
    let phoneNumberOrders: [ChimeSDKVoiceClientTypes.PhoneNumberOrder]?
    let nextToken: Swift.String?
}

extension ListPhoneNumberOrdersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumberOrders = "PhoneNumberOrders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrdersContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberOrder?].self, forKey: .phoneNumberOrders)
        var phoneNumberOrdersDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberOrder]? = nil
        if let phoneNumberOrdersContainer = phoneNumberOrdersContainer {
            phoneNumberOrdersDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberOrder]()
            for structure0 in phoneNumberOrdersContainer {
                if let structure0 = structure0 {
                    phoneNumberOrdersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberOrders = phoneNumberOrdersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPhoneNumberOrdersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPhoneNumbersInput {

    static func queryItemProvider(_ value: ListPhoneNumbersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let productType = value.productType {
            let productTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
            items.append(productTypeQueryItem)
        }
        if let filterName = value.filterName {
            let filterNameQueryItem = ClientRuntime.SDKURLQueryItem(name: "filter-name".urlPercentEncoding(), value: Swift.String(filterName.rawValue).urlPercentEncoding())
            items.append(filterNameQueryItem)
        }
        if let filterValue = value.filterValue {
            let filterValueQueryItem = ClientRuntime.SDKURLQueryItem(name: "filter-value".urlPercentEncoding(), value: Swift.String(filterValue).urlPercentEncoding())
            items.append(filterValueQueryItem)
        }
        return items
    }
}

extension ListPhoneNumbersInput {

    static func urlPathProvider(_ value: ListPhoneNumbersInput) -> Swift.String? {
        return "/phone-numbers"
    }
}

public struct ListPhoneNumbersInput {
    /// The filter to limit the number of results.
    public var filterName: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName?
    /// The filter value.
    public var filterValue: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The phone number product types.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
    /// The status of your organization's phone numbers.
    public var status: Swift.String?

    public init(
        filterName: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName? = nil,
        filterValue: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil,
        status: Swift.String? = nil
    )
    {
        self.filterName = filterName
        self.filterValue = filterValue
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productType = productType
        self.status = status
    }
}

struct ListPhoneNumbersInputBody {
}

extension ListPhoneNumbersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPhoneNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListPhoneNumbersOutput {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The phone number details.
    public var phoneNumbers: [ChimeSDKVoiceClientTypes.PhoneNumber]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [ChimeSDKVoiceClientTypes.PhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListPhoneNumbersOutputBody {
    let phoneNumbers: [ChimeSDKVoiceClientTypes.PhoneNumber]?
    let nextToken: Swift.String?
}

extension ListPhoneNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumbersContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProxySessionsInput {

    static func queryItemProvider(_ value: ListProxySessionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProxySessionsInput {

    static func urlPathProvider(_ value: ListProxySessionsInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

public struct ListProxySessionsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy session status.
    public var status: ChimeSDKVoiceClientTypes.ProxySessionStatus?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: ChimeSDKVoiceClientTypes.ProxySessionStatus? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListProxySessionsInputBody {
}

extension ListProxySessionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProxySessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProxySessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proxySessions = output.proxySessions
        } else {
            self.nextToken = nil
            self.proxySessions = nil
        }
    }
}

public struct ListProxySessionsOutput {
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy sessions' details.
    public var proxySessions: [ChimeSDKVoiceClientTypes.ProxySession]?

    public init(
        nextToken: Swift.String? = nil,
        proxySessions: [ChimeSDKVoiceClientTypes.ProxySession]? = nil
    )
    {
        self.nextToken = nextToken
        self.proxySessions = proxySessions
    }
}

struct ListProxySessionsOutputBody {
    let proxySessions: [ChimeSDKVoiceClientTypes.ProxySession]?
    let nextToken: Swift.String?
}

extension ListProxySessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proxySessions = "ProxySessions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.ProxySession?].self, forKey: .proxySessions)
        var proxySessionsDecoded0:[ChimeSDKVoiceClientTypes.ProxySession]? = nil
        if let proxySessionsContainer = proxySessionsContainer {
            proxySessionsDecoded0 = [ChimeSDKVoiceClientTypes.ProxySession]()
            for structure0 in proxySessionsContainer {
                if let structure0 = structure0 {
                    proxySessionsDecoded0?.append(structure0)
                }
            }
        }
        proxySessions = proxySessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProxySessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSipMediaApplicationsInput {

    static func queryItemProvider(_ value: ListSipMediaApplicationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSipMediaApplicationsInput {

    static func urlPathProvider(_ value: ListSipMediaApplicationsInput) -> Swift.String? {
        return "/sip-media-applications"
    }
}

public struct ListSipMediaApplicationsInput {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSipMediaApplicationsInputBody {
}

extension ListSipMediaApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSipMediaApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSipMediaApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipMediaApplications = output.sipMediaApplications
        } else {
            self.nextToken = nil
            self.sipMediaApplications = nil
        }
    }
}

public struct ListSipMediaApplicationsOutput {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The list of SIP media applications and application details.
    public var sipMediaApplications: [ChimeSDKVoiceClientTypes.SipMediaApplication]?

    public init(
        nextToken: Swift.String? = nil,
        sipMediaApplications: [ChimeSDKVoiceClientTypes.SipMediaApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipMediaApplications = sipMediaApplications
    }
}

struct ListSipMediaApplicationsOutputBody {
    let sipMediaApplications: [ChimeSDKVoiceClientTypes.SipMediaApplication]?
    let nextToken: Swift.String?
}

extension ListSipMediaApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipMediaApplications = "SipMediaApplications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplication?].self, forKey: .sipMediaApplications)
        var sipMediaApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplication]? = nil
        if let sipMediaApplicationsContainer = sipMediaApplicationsContainer {
            sipMediaApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplication]()
            for structure0 in sipMediaApplicationsContainer {
                if let structure0 = structure0 {
                    sipMediaApplicationsDecoded0?.append(structure0)
                }
            }
        }
        sipMediaApplications = sipMediaApplicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSipMediaApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSipRulesInput {

    static func queryItemProvider(_ value: ListSipRulesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let sipMediaApplicationId = value.sipMediaApplicationId {
            let sipMediaApplicationIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "sip-media-application".urlPercentEncoding(), value: Swift.String(sipMediaApplicationId).urlPercentEncoding())
            items.append(sipMediaApplicationIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSipRulesInput {

    static func urlPathProvider(_ value: ListSipRulesInput) -> Swift.String? {
        return "/sip-rules"
    }
}

public struct ListSipRulesInput {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The SIP media application ID.
    public var sipMediaApplicationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct ListSipRulesInputBody {
}

extension ListSipRulesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSipRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSipRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipRules = output.sipRules
        } else {
            self.nextToken = nil
            self.sipRules = nil
        }
    }
}

public struct ListSipRulesOutput {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The list of SIP rules and details.
    public var sipRules: [ChimeSDKVoiceClientTypes.SipRule]?

    public init(
        nextToken: Swift.String? = nil,
        sipRules: [ChimeSDKVoiceClientTypes.SipRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipRules = sipRules
    }
}

struct ListSipRulesOutputBody {
    let sipRules: [ChimeSDKVoiceClientTypes.SipRule]?
    let nextToken: Swift.String?
}

extension ListSipRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipRules = "SipRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRulesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRule?].self, forKey: .sipRules)
        var sipRulesDecoded0:[ChimeSDKVoiceClientTypes.SipRule]? = nil
        if let sipRulesContainer = sipRulesContainer {
            sipRulesDecoded0 = [ChimeSDKVoiceClientTypes.SipRule]()
            for structure0 in sipRulesContainer {
                if let structure0 = structure0 {
                    sipRulesDecoded0?.append(structure0)
                }
            }
        }
        sipRules = sipRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSipRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSupportedPhoneNumberCountriesInput {

    static func queryItemProvider(_ value: ListSupportedPhoneNumberCountriesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let productType = value.productType else {
            let message = "Creating a URL Query Item failed. productType is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let productTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
        items.append(productTypeQueryItem)
        return items
    }
}

extension ListSupportedPhoneNumberCountriesInput {

    static func urlPathProvider(_ value: ListSupportedPhoneNumberCountriesInput) -> Swift.String? {
        return "/phone-number-countries"
    }
}

public struct ListSupportedPhoneNumberCountriesInput {
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

    public init(
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.productType = productType
    }
}

struct ListSupportedPhoneNumberCountriesInputBody {
}

extension ListSupportedPhoneNumberCountriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSupportedPhoneNumberCountriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSupportedPhoneNumberCountriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberCountries = output.phoneNumberCountries
        } else {
            self.phoneNumberCountries = nil
        }
    }
}

public struct ListSupportedPhoneNumberCountriesOutput {
    /// The supported phone number countries.
    public var phoneNumberCountries: [ChimeSDKVoiceClientTypes.PhoneNumberCountry]?

    public init(
        phoneNumberCountries: [ChimeSDKVoiceClientTypes.PhoneNumberCountry]? = nil
    )
    {
        self.phoneNumberCountries = phoneNumberCountries
    }
}

struct ListSupportedPhoneNumberCountriesOutputBody {
    let phoneNumberCountries: [ChimeSDKVoiceClientTypes.PhoneNumberCountry]?
}

extension ListSupportedPhoneNumberCountriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberCountry?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberCountry]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberCountry]()
            for structure0 in phoneNumberCountriesContainer {
                if let structure0 = structure0 {
                    phoneNumberCountriesDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

enum ListSupportedPhoneNumberCountriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let resourceARN = value.resourceARN else {
            let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let resourceARNQueryItem = ClientRuntime.SDKURLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
        items.append(resourceARNQueryItem)
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput {
    /// The tags in the list.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody {
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceConnectorGroupsInput {

    static func queryItemProvider(_ value: ListVoiceConnectorGroupsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVoiceConnectorGroupsInput {

    static func urlPathProvider(_ value: ListVoiceConnectorGroupsInput) -> Swift.String? {
        return "/voice-connector-groups"
    }
}

public struct ListVoiceConnectorGroupsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorGroupsInputBody {
}

extension ListVoiceConnectorGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceConnectorGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectorGroups = output.voiceConnectorGroups
        } else {
            self.nextToken = nil
            self.voiceConnectorGroups = nil
        }
    }
}

public struct ListVoiceConnectorGroupsOutput {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Voice Connector groups.
    public var voiceConnectorGroups: [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]?

    public init(
        nextToken: Swift.String? = nil,
        voiceConnectorGroups: [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectorGroups = voiceConnectorGroups
    }
}

struct ListVoiceConnectorGroupsOutputBody {
    let voiceConnectorGroups: [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]?
    let nextToken: Swift.String?
}

extension ListVoiceConnectorGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectorGroups = "VoiceConnectorGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorGroup?].self, forKey: .voiceConnectorGroups)
        var voiceConnectorGroupsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorGroup]? = nil
        if let voiceConnectorGroupsContainer = voiceConnectorGroupsContainer {
            voiceConnectorGroupsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]()
            for structure0 in voiceConnectorGroupsContainer {
                if let structure0 = structure0 {
                    voiceConnectorGroupsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorGroups = voiceConnectorGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVoiceConnectorGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceConnectorTerminationCredentialsInput {

    static func urlPathProvider(_ value: ListVoiceConnectorTerminationCredentialsInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct ListVoiceConnectorTerminationCredentialsInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListVoiceConnectorTerminationCredentialsInputBody {
}

extension ListVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorTerminationCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceConnectorTerminationCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.usernames = output.usernames
        } else {
            self.usernames = nil
        }
    }
}

public struct ListVoiceConnectorTerminationCredentialsOutput {
    /// A list of user names.
    public var usernames: [Swift.String]?

    public init(
        usernames: [Swift.String]? = nil
    )
    {
        self.usernames = usernames
    }
}

struct ListVoiceConnectorTerminationCredentialsOutputBody {
    let usernames: [Swift.String]?
}

extension ListVoiceConnectorTerminationCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

enum ListVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceConnectorsInput {

    static func queryItemProvider(_ value: ListVoiceConnectorsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVoiceConnectorsInput {

    static func urlPathProvider(_ value: ListVoiceConnectorsInput) -> Swift.String? {
        return "/voice-connectors"
    }
}

public struct ListVoiceConnectorsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorsInputBody {
}

extension ListVoiceConnectorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceConnectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectors = output.voiceConnectors
        } else {
            self.nextToken = nil
            self.voiceConnectors = nil
        }
    }
}

public struct ListVoiceConnectorsOutput {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Voice Connectors.
    public var voiceConnectors: [ChimeSDKVoiceClientTypes.VoiceConnector]?

    public init(
        nextToken: Swift.String? = nil,
        voiceConnectors: [ChimeSDKVoiceClientTypes.VoiceConnector]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectors = voiceConnectors
    }
}

struct ListVoiceConnectorsOutputBody {
    let voiceConnectors: [ChimeSDKVoiceClientTypes.VoiceConnector]?
    let nextToken: Swift.String?
}

extension ListVoiceConnectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectors = "VoiceConnectors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnector?].self, forKey: .voiceConnectors)
        var voiceConnectorsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnector]? = nil
        if let voiceConnectorsContainer = voiceConnectorsContainer {
            voiceConnectorsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnector]()
            for structure0 in voiceConnectorsContainer {
                if let structure0 = structure0 {
                    voiceConnectorsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectors = voiceConnectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVoiceConnectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceProfileDomainsInput {

    static func queryItemProvider(_ value: ListVoiceProfileDomainsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVoiceProfileDomainsInput {

    static func urlPathProvider(_ value: ListVoiceProfileDomainsInput) -> Swift.String? {
        return "/voice-profile-domains"
    }
}

public struct ListVoiceProfileDomainsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceProfileDomainsInputBody {
}

extension ListVoiceProfileDomainsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceProfileDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceProfileDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceProfileDomains = output.voiceProfileDomains
        } else {
            self.nextToken = nil
            self.voiceProfileDomains = nil
        }
    }
}

public struct ListVoiceProfileDomainsOutput {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The list of voice profile domains.
    public var voiceProfileDomains: [ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]?

    public init(
        nextToken: Swift.String? = nil,
        voiceProfileDomains: [ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceProfileDomains = voiceProfileDomains
    }
}

struct ListVoiceProfileDomainsOutputBody {
    let voiceProfileDomains: [ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]?
    let nextToken: Swift.String?
}

extension ListVoiceProfileDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceProfileDomains = "VoiceProfileDomains"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary?].self, forKey: .voiceProfileDomains)
        var voiceProfileDomainsDecoded0:[ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]? = nil
        if let voiceProfileDomainsContainer = voiceProfileDomainsContainer {
            voiceProfileDomainsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]()
            for structure0 in voiceProfileDomainsContainer {
                if let structure0 = structure0 {
                    voiceProfileDomainsDecoded0?.append(structure0)
                }
            }
        }
        voiceProfileDomains = voiceProfileDomainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVoiceProfileDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceProfilesInput {

    static func queryItemProvider(_ value: ListVoiceProfilesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let voiceProfileDomainId = value.voiceProfileDomainId else {
            let message = "Creating a URL Query Item failed. voiceProfileDomainId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let voiceProfileDomainIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "voice-profile-domain-id".urlPercentEncoding(), value: Swift.String(voiceProfileDomainId).urlPercentEncoding())
        items.append(voiceProfileDomainIdQueryItem)
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListVoiceProfilesInput {

    static func urlPathProvider(_ value: ListVoiceProfilesInput) -> Swift.String? {
        return "/voice-profiles"
    }
}

public struct ListVoiceProfilesInput {
    /// The maximum number of results in the request.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the voice profile domain.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct ListVoiceProfilesInputBody {
}

extension ListVoiceProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceProfiles = output.voiceProfiles
        } else {
            self.nextToken = nil
            self.voiceProfiles = nil
        }
    }
}

public struct ListVoiceProfilesOutput {
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The list of voice profiles.
    public var voiceProfiles: [ChimeSDKVoiceClientTypes.VoiceProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        voiceProfiles: [ChimeSDKVoiceClientTypes.VoiceProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceProfiles = voiceProfiles
    }
}

struct ListVoiceProfilesOutputBody {
    let voiceProfiles: [ChimeSDKVoiceClientTypes.VoiceProfileSummary]?
    let nextToken: Swift.String?
}

extension ListVoiceProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceProfiles = "VoiceProfiles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfilesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceProfileSummary?].self, forKey: .voiceProfiles)
        var voiceProfilesDecoded0:[ChimeSDKVoiceClientTypes.VoiceProfileSummary]? = nil
        if let voiceProfilesContainer = voiceProfilesContainer {
            voiceProfilesDecoded0 = [ChimeSDKVoiceClientTypes.VoiceProfileSummary]()
            for structure0 in voiceProfilesContainer {
                if let structure0 = structure0 {
                    voiceProfilesDecoded0?.append(structure0)
                }
            }
        }
        voiceProfiles = voiceProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVoiceProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKVoiceClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableMediaMetricLogs = "EnableMediaMetricLogs"
        case enableSIPLogs = "EnableSIPLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableMediaMetricLogs = self.enableMediaMetricLogs {
            try encodeContainer.encode(enableMediaMetricLogs, forKey: .enableMediaMetricLogs)
        }
        if let enableSIPLogs = self.enableSIPLogs {
            try encodeContainer.encode(enableSIPLogs, forKey: .enableSIPLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSIPLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSIPLogs)
        enableSIPLogs = enableSIPLogsDecoded
        let enableMediaMetricLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMediaMetricLogs)
        enableMediaMetricLogs = enableMediaMetricLogsDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The logging configuration associated with an Amazon Chime SDK Voice Connector. Specifies whether SIP message logs can be sent to Amazon CloudWatch Logs.
    public struct LoggingConfiguration {
        /// Enables or disables media metrics logging.
        public var enableMediaMetricLogs: Swift.Bool?
        /// Boolean that enables sending SIP message logs to Amazon CloudWatch.
        public var enableSIPLogs: Swift.Bool?

        public init(
            enableMediaMetricLogs: Swift.Bool? = nil,
            enableSIPLogs: Swift.Bool? = nil
        )
        {
            self.enableMediaMetricLogs = enableMediaMetricLogs
            self.enableSIPLogs = enableSIPLogs
        }
    }

}

extension ChimeSDKVoiceClientTypes.MediaInsightsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationArn = "ConfigurationArn"
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationArn = self.configurationArn {
            try encodeContainer.encode(configurationArn, forKey: .configurationArn)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let configurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationArn)
        configurationArn = configurationArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes.MediaInsightsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaInsightsConfiguration(disabled: \(Swift.String(describing: disabled)), configurationArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The configuration for a call analytics task.
    public struct MediaInsightsConfiguration {
        /// The configuration's ARN.
        public var configurationArn: Swift.String?
        /// Denotes the configration as enabled or disabled.
        public var disabled: Swift.Bool?

        public init(
            configurationArn: Swift.String? = nil,
            disabled: Swift.Bool? = nil
        )
        {
            self.configurationArn = configurationArn
            self.disabled = disabled
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource couldn't be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct NotFoundExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum NotificationTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventbridge
        case sns
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationTarget] {
            return [
                .eventbridge,
                .sns,
                .sqs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventbridge: return "EventBridge"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationTarget(rawValue: rawValue) ?? NotificationTarget.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum NumberSelectionBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avoidsticky
        case prefersticky
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberSelectionBehavior] {
            return [
                .avoidsticky,
                .prefersticky,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avoidsticky: return "AvoidSticky"
            case .prefersticky: return "PreferSticky"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberSelectionBehavior(rawValue: rawValue) ?? NumberSelectionBehavior.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.OrderedPhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumber = "E164PhoneNumber"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumber = self.e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.OrderedPhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ChimeSDKVoiceClientTypes.OrderedPhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderedPhoneNumber(status: \(Swift.String(describing: status)), e164PhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A phone number for which an order has been placed.
    public struct OrderedPhoneNumber {
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The phone number status.
        public var status: ChimeSDKVoiceClientTypes.OrderedPhoneNumberStatus?

        public init(
            e164PhoneNumber: Swift.String? = nil,
            status: ChimeSDKVoiceClientTypes.OrderedPhoneNumberStatus? = nil
        )
        {
            self.e164PhoneNumber = e164PhoneNumber
            self.status = status
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum OrderedPhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquired
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderedPhoneNumberStatus] {
            return [
                .acquired,
                .failed,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquired: return "Acquired"
            case .failed: return "Failed"
            case .processing: return "Processing"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderedPhoneNumberStatus(rawValue: rawValue) ?? OrderedPhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Origination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case routes = "Routes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let routes = routes {
            var routesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routes)
            for originationroute0 in routes {
                try routesContainer.encode(originationroute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.OriginationRoute?].self, forKey: .routes)
        var routesDecoded0:[ChimeSDKVoiceClientTypes.OriginationRoute]? = nil
        if let routesContainer = routesContainer {
            routesDecoded0 = [ChimeSDKVoiceClientTypes.OriginationRoute]()
            for structure0 in routesContainer {
                if let structure0 = structure0 {
                    routesDecoded0?.append(structure0)
                }
            }
        }
        routes = routesDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// Origination settings enable your SIP hosts to receive inbound calls using your Amazon Chime SDK Voice Connector. The parameters listed below are not required, but you must use at least one.
    public struct Origination {
        /// When origination settings are disabled, inbound calls are not enabled for your Amazon Chime SDK Voice Connector. This parameter is not required, but you must specify this parameter or Routes.
        public var disabled: Swift.Bool?
        /// The call distribution properties defined for your SIP hosts. Valid range: Minimum value of 1. Maximum value of 20. This parameter is not required, but you must specify this parameter or Disabled.
        public var routes: [ChimeSDKVoiceClientTypes.OriginationRoute]?

        public init(
            disabled: Swift.Bool? = nil,
            routes: [ChimeSDKVoiceClientTypes.OriginationRoute]? = nil
        )
        {
            self.disabled = disabled
            self.routes = routes
        }
    }

}

extension ChimeSDKVoiceClientTypes.OriginationRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
        case priority = "Priority"
        case `protocol` = "Protocol"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.OriginationRouteProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// Origination routes define call distribution properties for your SIP hosts to receive inbound calls using an Amazon Chime SDK Voice Connector. Limit: Ten origination routes for each Voice Connector. The parameters listed below are not required, but you must use at least one.
    public struct OriginationRoute {
        /// The FQDN or IP address to contact for origination traffic.
        public var host: Swift.String?
        /// The designated origination route port. Defaults to 5060.
        public var port: Swift.Int?
        /// The priority associated with the host, with 1 being the highest priority. Higher priority hosts are attempted first.
        public var priority: Swift.Int?
        /// The protocol to use for the origination route. Encryption-enabled Amazon Chime SDK Voice Connectors use TCP protocol by default.
        public var `protocol`: ChimeSDKVoiceClientTypes.OriginationRouteProtocol?
        /// The weight assigned to an origination route. When hosts have equal priority, calls are distributed between them based on their relative weights.
        public var weight: Swift.Int?

        public init(
            host: Swift.String? = nil,
            port: Swift.Int? = nil,
            priority: Swift.Int? = nil,
            `protocol`: ChimeSDKVoiceClientTypes.OriginationRouteProtocol? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.host = host
            self.port = port
            self.priority = priority
            self.`protocol` = `protocol`
            self.weight = weight
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum OriginationRouteProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginationRouteProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginationRouteProtocol(rawValue: rawValue) ?? OriginationRouteProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Participant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
        case proxyPhoneNumber = "ProxyPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let proxyPhoneNumber = self.proxyPhoneNumber {
            try encodeContainer.encode(proxyPhoneNumber, forKey: .proxyPhoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let proxyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyPhoneNumber)
        proxyPhoneNumber = proxyPhoneNumberDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Participant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Participant(phoneNumber: \"CONTENT_REDACTED\", proxyPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number and proxy phone number for a participant in an Amazon Chime SDK Voice Connector proxy session.
    public struct Participant {
        /// The participant's phone number.
        public var phoneNumber: Swift.String?
        /// The participant's proxy phone number.
        public var proxyPhoneNumber: Swift.String?

        public init(
            phoneNumber: Swift.String? = nil,
            proxyPhoneNumber: Swift.String? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.proxyPhoneNumber = proxyPhoneNumber
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case callingName = "CallingName"
        case callingNameStatus = "CallingNameStatus"
        case capabilities = "Capabilities"
        case country = "Country"
        case createdTimestamp = "CreatedTimestamp"
        case deletionTimestamp = "DeletionTimestamp"
        case e164PhoneNumber = "E164PhoneNumber"
        case name = "Name"
        case orderId = "OrderId"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
        case status = "Status"
        case type = "Type"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for phonenumberassociation0 in associations {
                try associationsContainer.encode(phonenumberassociation0)
            }
        }
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let callingNameStatus = self.callingNameStatus {
            try encodeContainer.encode(callingNameStatus.rawValue, forKey: .callingNameStatus)
        }
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let deletionTimestamp = self.deletionTimestamp {
            try encodeContainer.encodeTimestamp(deletionTimestamp, format: .dateTime, forKey: .deletionTimestamp)
        }
        if let e164PhoneNumber = self.e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let orderId = self.orderId {
            try encodeContainer.encode(orderId, forKey: .orderId)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberType.self, forKey: .type)
        type = typeDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
        let associationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberAssociation?].self, forKey: .associations)
        var associationsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.CallingNameStatus.self, forKey: .callingNameStatus)
        callingNameStatus = callingNameStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let deletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .deletionTimestamp)
        deletionTimestamp = deletionTimestampDecoded
        let orderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderId)
        orderId = orderIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeSDKVoiceClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(associations: \(Swift.String(describing: associations)), callingNameStatus: \(Swift.String(describing: callingNameStatus)), capabilities: \(Swift.String(describing: capabilities)), country: \(Swift.String(describing: country)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), deletionTimestamp: \(Swift.String(describing: deletionTimestamp)), orderId: \(Swift.String(describing: orderId)), productType: \(Swift.String(describing: productType)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), callingName: \"CONTENT_REDACTED\", e164PhoneNumber: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A phone number used to call an Amazon Chime SDK Voice Connector.
    public struct PhoneNumber {
        /// The phone number's associations.
        public var associations: [ChimeSDKVoiceClientTypes.PhoneNumberAssociation]?
        /// The outbound calling name associated with the phone number.
        public var callingName: Swift.String?
        /// The outbound calling name status.
        public var callingNameStatus: ChimeSDKVoiceClientTypes.CallingNameStatus?
        /// The phone number's capabilities.
        public var capabilities: ChimeSDKVoiceClientTypes.PhoneNumberCapabilities?
        /// The phone number's country. Format: ISO 3166-1 alpha-2.
        public var country: Swift.String?
        /// The phone number creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The deleted phone number timestamp, in ISO 8601 format.
        public var deletionTimestamp: ClientRuntime.Date?
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The name of the phone number.
        public var name: Swift.String?
        /// The phone number's order ID.
        public var orderId: Swift.String?
        /// The phone number's ID.
        public var phoneNumberId: Swift.String?
        /// The phone number's product type.
        public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
        /// The phone number's status.
        public var status: ChimeSDKVoiceClientTypes.PhoneNumberStatus?
        /// The phone number's type.
        public var type: ChimeSDKVoiceClientTypes.PhoneNumberType?
        /// The updated phone number timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            associations: [ChimeSDKVoiceClientTypes.PhoneNumberAssociation]? = nil,
            callingName: Swift.String? = nil,
            callingNameStatus: ChimeSDKVoiceClientTypes.CallingNameStatus? = nil,
            capabilities: ChimeSDKVoiceClientTypes.PhoneNumberCapabilities? = nil,
            country: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            deletionTimestamp: ClientRuntime.Date? = nil,
            e164PhoneNumber: Swift.String? = nil,
            name: Swift.String? = nil,
            orderId: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil,
            status: ChimeSDKVoiceClientTypes.PhoneNumberStatus? = nil,
            type: ChimeSDKVoiceClientTypes.PhoneNumberType? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.associations = associations
            self.callingName = callingName
            self.callingNameStatus = callingNameStatus
            self.capabilities = capabilities
            self.country = country
            self.createdTimestamp = createdTimestamp
            self.deletionTimestamp = deletionTimestamp
            self.e164PhoneNumber = e164PhoneNumber
            self.name = name
            self.orderId = orderId
            self.phoneNumberId = phoneNumberId
            self.productType = productType
            self.status = status
            self.type = type
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedTimestamp = "AssociatedTimestamp"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedTimestamp = self.associatedTimestamp {
            try encodeContainer.encodeTimestamp(associatedTimestamp, format: .dateTime, forKey: .associatedTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberAssociationName.self, forKey: .name)
        name = nameDecoded
        let associatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .associatedTimestamp)
        associatedTimestamp = associatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number associations, such as an Amazon Chime SDK account ID, user ID, Voice Connector ID, or Voice Connector group ID.
    public struct PhoneNumberAssociation {
        /// The timestamp of the phone number association, in ISO 8601 format.
        public var associatedTimestamp: ClientRuntime.Date?
        /// Defines the association with an Amazon Chime SDK account ID, user ID, Voice Connector ID, or Voice Connector group ID.
        public var name: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName?
        /// Contains the ID for the entity specified in Name.
        public var value: Swift.String?

        public init(
            associatedTimestamp: ClientRuntime.Date? = nil,
            name: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName? = nil,
            value: Swift.String? = nil
        )
        {
            self.associatedTimestamp = associatedTimestamp
            self.name = name
            self.value = value
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberAssociationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sipruleid
        case voiceconnectorgroupid
        case voiceconnectorid
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberAssociationName] {
            return [
                .sipruleid,
                .voiceconnectorgroupid,
                .voiceconnectorid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sipruleid: return "SipRuleId"
            case .voiceconnectorgroupid: return "VoiceConnectorGroupId"
            case .voiceconnectorid: return "VoiceConnectorId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberAssociationName(rawValue: rawValue) ?? PhoneNumberAssociationName.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.PhoneNumberCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundCall = "InboundCall"
        case inboundMMS = "InboundMMS"
        case inboundSMS = "InboundSMS"
        case outboundCall = "OutboundCall"
        case outboundMMS = "OutboundMMS"
        case outboundSMS = "OutboundSMS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundCall = self.inboundCall {
            try encodeContainer.encode(inboundCall, forKey: .inboundCall)
        }
        if let inboundMMS = self.inboundMMS {
            try encodeContainer.encode(inboundMMS, forKey: .inboundMMS)
        }
        if let inboundSMS = self.inboundSMS {
            try encodeContainer.encode(inboundSMS, forKey: .inboundSMS)
        }
        if let outboundCall = self.outboundCall {
            try encodeContainer.encode(outboundCall, forKey: .outboundCall)
        }
        if let outboundMMS = self.outboundMMS {
            try encodeContainer.encode(outboundMMS, forKey: .outboundMMS)
        }
        if let outboundSMS = self.outboundSMS {
            try encodeContainer.encode(outboundSMS, forKey: .outboundSMS)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCall)
        inboundCall = inboundCallDecoded
        let outboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCall)
        outboundCall = outboundCallDecoded
        let inboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundSMS)
        inboundSMS = inboundSMSDecoded
        let outboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundSMS)
        outboundSMS = outboundSMSDecoded
        let inboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundMMS)
        inboundMMS = inboundMMSDecoded
        let outboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundMMS)
        outboundMMS = outboundMMSDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number capabilities for Amazon Chime SDK phone numbers, such as enabled inbound and outbound calling, and text messaging.
    public struct PhoneNumberCapabilities {
        /// Allows or denies inbound calling for the specified phone number.
        public var inboundCall: Swift.Bool?
        /// Allows or denies inbound MMS messaging for the specified phone number.
        public var inboundMMS: Swift.Bool?
        /// Allows or denies inbound SMS messaging for the specified phone number.
        public var inboundSMS: Swift.Bool?
        /// Allows or denies outbound calling for the specified phone number.
        public var outboundCall: Swift.Bool?
        /// Allows or denies inbound MMS messaging for the specified phone number.
        public var outboundMMS: Swift.Bool?
        /// Allows or denies outbound SMS messaging for the specified phone number.
        public var outboundSMS: Swift.Bool?

        public init(
            inboundCall: Swift.Bool? = nil,
            inboundMMS: Swift.Bool? = nil,
            inboundSMS: Swift.Bool? = nil,
            outboundCall: Swift.Bool? = nil,
            outboundMMS: Swift.Bool? = nil,
            outboundSMS: Swift.Bool? = nil
        )
        {
            self.inboundCall = inboundCall
            self.inboundMMS = inboundMMS
            self.inboundSMS = inboundSMS
            self.outboundCall = outboundCall
            self.outboundMMS = outboundMMS
            self.outboundSMS = outboundSMS
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberCountry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "CountryCode"
        case supportedPhoneNumberTypes = "SupportedPhoneNumberTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let supportedPhoneNumberTypes = supportedPhoneNumberTypes {
            var supportedPhoneNumberTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedPhoneNumberTypes)
            for phonenumbertype0 in supportedPhoneNumberTypes {
                try supportedPhoneNumberTypesContainer.encode(phonenumbertype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let supportedPhoneNumberTypesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberType?].self, forKey: .supportedPhoneNumberTypes)
        var supportedPhoneNumberTypesDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberType]? = nil
        if let supportedPhoneNumberTypesContainer = supportedPhoneNumberTypesContainer {
            supportedPhoneNumberTypesDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberType]()
            for enum0 in supportedPhoneNumberTypesContainer {
                if let enum0 = enum0 {
                    supportedPhoneNumberTypesDecoded0?.append(enum0)
                }
            }
        }
        supportedPhoneNumberTypes = supportedPhoneNumberTypesDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number's country.
    public struct PhoneNumberCountry {
        /// The phone number country code. Format: ISO 3166-1 alpha-2.
        public var countryCode: Swift.String?
        /// The supported phone number types.
        public var supportedPhoneNumberTypes: [ChimeSDKVoiceClientTypes.PhoneNumberType]?

        public init(
            countryCode: Swift.String? = nil,
            supportedPhoneNumberTypes: [ChimeSDKVoiceClientTypes.PhoneNumberType]? = nil
        )
        {
            self.countryCode = countryCode
            self.supportedPhoneNumberTypes = supportedPhoneNumberTypes
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case phoneNumberId = "PhoneNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeSDKVoiceClientTypes.PhoneNumberError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// If a phone number action fails for one or more of the phone numbers in a request, a list of the failed phone numbers is returned, along with error codes and error messages.
    public struct PhoneNumberError {
        /// The error code.
        public var errorCode: ChimeSDKVoiceClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The phone number ID for which the action failed.
        public var phoneNumberId: Swift.String?

        public init(
            errorCode: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.phoneNumberId = phoneNumberId
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberOrder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case orderType = "OrderType"
        case orderedPhoneNumbers = "OrderedPhoneNumbers"
        case phoneNumberOrderId = "PhoneNumberOrderId"
        case productType = "ProductType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let orderType = self.orderType {
            try encodeContainer.encode(orderType.rawValue, forKey: .orderType)
        }
        if let orderedPhoneNumbers = orderedPhoneNumbers {
            var orderedPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedPhoneNumbers)
            for orderedphonenumber0 in orderedPhoneNumbers {
                try orderedPhoneNumbersContainer.encode(orderedphonenumber0)
            }
        }
        if let phoneNumberOrderId = self.phoneNumberOrderId {
            try encodeContainer.encode(phoneNumberOrderId, forKey: .phoneNumberOrderId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberOrderId)
        phoneNumberOrderId = phoneNumberOrderIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrderStatus.self, forKey: .status)
        status = statusDecoded
        let orderTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrderType.self, forKey: .orderType)
        orderType = orderTypeDecoded
        let orderedPhoneNumbersContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.OrderedPhoneNumber?].self, forKey: .orderedPhoneNumbers)
        var orderedPhoneNumbersDecoded0:[ChimeSDKVoiceClientTypes.OrderedPhoneNumber]? = nil
        if let orderedPhoneNumbersContainer = orderedPhoneNumbersContainer {
            orderedPhoneNumbersDecoded0 = [ChimeSDKVoiceClientTypes.OrderedPhoneNumber]()
            for structure0 in orderedPhoneNumbersContainer {
                if let structure0 = structure0 {
                    orderedPhoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        orderedPhoneNumbers = orderedPhoneNumbersDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of an Amazon Chime SDK phone number order.
    public struct PhoneNumberOrder {
        /// The phone number order creation time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The type of phone number being ordered, local or toll-free.
        public var orderType: ChimeSDKVoiceClientTypes.PhoneNumberOrderType?
        /// The ordered phone number details, such as the phone number in E.164 format and the phone number status.
        public var orderedPhoneNumbers: [ChimeSDKVoiceClientTypes.OrderedPhoneNumber]?
        /// The ID of the phone order.
        public var phoneNumberOrderId: Swift.String?
        /// The phone number order product type.
        public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
        /// The status of the phone number order.
        public var status: ChimeSDKVoiceClientTypes.PhoneNumberOrderStatus?
        /// The updated phone number order time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            orderType: ChimeSDKVoiceClientTypes.PhoneNumberOrderType? = nil,
            orderedPhoneNumbers: [ChimeSDKVoiceClientTypes.OrderedPhoneNumber]? = nil,
            phoneNumberOrderId: Swift.String? = nil,
            productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil,
            status: ChimeSDKVoiceClientTypes.PhoneNumberOrderStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.orderType = orderType
            self.orderedPhoneNumbers = orderedPhoneNumbers
            self.phoneNumberOrderId = phoneNumberOrderId
            self.productType = productType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberOrderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelrequested
        case cancelled
        case changerequested
        case exception
        case foc
        case failed
        case partial
        case pendingdocuments
        case processing
        case submitted
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberOrderStatus] {
            return [
                .cancelrequested,
                .cancelled,
                .changerequested,
                .exception,
                .foc,
                .failed,
                .partial,
                .pendingdocuments,
                .processing,
                .submitted,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelrequested: return "CancelRequested"
            case .cancelled: return "Cancelled"
            case .changerequested: return "ChangeRequested"
            case .exception: return "Exception"
            case .foc: return "FOC"
            case .failed: return "Failed"
            case .partial: return "Partial"
            case .pendingdocuments: return "PendingDocuments"
            case .processing: return "Processing"
            case .submitted: return "Submitted"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberOrderStatus(rawValue: rawValue) ?? PhoneNumberOrderStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberOrderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case new
        case porting
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberOrderType] {
            return [
                .new,
                .porting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .new: return "New"
            case .porting: return "Porting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberOrderType(rawValue: rawValue) ?? PhoneNumberOrderType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberProductType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sipmediaapplicationdialin
        case voiceconnector
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberProductType] {
            return [
                .sipmediaapplicationdialin,
                .voiceconnector,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sipmediaapplicationdialin: return "SipMediaApplicationDialIn"
            case .voiceconnector: return "VoiceConnector"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberProductType(rawValue: rawValue) ?? PhoneNumberProductType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquirefailed
        case acquireinprogress
        case assigned
        case cancelled
        case deletefailed
        case deleteinprogress
        case portincancelrequested
        case portininprogress
        case releasefailed
        case releaseinprogress
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberStatus] {
            return [
                .acquirefailed,
                .acquireinprogress,
                .assigned,
                .cancelled,
                .deletefailed,
                .deleteinprogress,
                .portincancelrequested,
                .portininprogress,
                .releasefailed,
                .releaseinprogress,
                .unassigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquirefailed: return "AcquireFailed"
            case .acquireinprogress: return "AcquireInProgress"
            case .assigned: return "Assigned"
            case .cancelled: return "Cancelled"
            case .deletefailed: return "DeleteFailed"
            case .deleteinprogress: return "DeleteInProgress"
            case .portincancelrequested: return "PortinCancelRequested"
            case .portininprogress: return "PortinInProgress"
            case .releasefailed: return "ReleaseFailed"
            case .releaseinprogress: return "ReleaseInProgress"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberStatus(rawValue: rawValue) ?? PhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case tollfree
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .local,
                .tollfree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "Local"
            case .tollfree: return "TollFree"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Proxy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = self.defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = self.fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberCountries = phoneNumberCountries {
            var phoneNumberCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberCountries)
            for string0 in phoneNumberCountries {
                try phoneNumberCountriesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberCountriesContainer {
                if let string0 = string0 {
                    phoneNumberCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

extension ChimeSDKVoiceClientTypes.Proxy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Proxy(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberCountries: \(Swift.String(describing: phoneNumberCountries)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The proxy configuration for an Amazon Chime SDK Voice Connector.
    public struct Proxy {
        /// The default number of minutes allowed for proxy sessions.
        public var defaultSessionExpiryMinutes: Swift.Int?
        /// When true, stops proxy sessions from being created on the specified Amazon Chime SDK Voice Connector.
        public var disabled: Swift.Bool?
        /// The phone number to route calls to after a proxy session expires.
        public var fallBackPhoneNumber: Swift.String?
        /// The countries for proxy phone numbers to be selected from.
        public var phoneNumberCountries: [Swift.String]?

        public init(
            defaultSessionExpiryMinutes: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            fallBackPhoneNumber: Swift.String? = nil,
            phoneNumberCountries: [Swift.String]? = nil
        )
        {
            self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
            self.disabled = disabled
            self.fallBackPhoneNumber = fallBackPhoneNumber
            self.phoneNumberCountries = phoneNumberCountries
        }
    }

}

extension ChimeSDKVoiceClientTypes.ProxySession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case createdTimestamp = "CreatedTimestamp"
        case endedTimestamp = "EndedTimestamp"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participants = "Participants"
        case proxySessionId = "ProxySessionId"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let endedTimestamp = self.endedTimestamp {
            try encodeContainer.encodeTimestamp(endedTimestamp, format: .dateTime, forKey: .endedTimestamp)
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = self.geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = self.geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = self.numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participants = participants {
            var participantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participants)
            for participant0 in participants {
                try participantsContainer.encode(participant0)
            }
        }
        if let proxySessionId = self.proxySessionId {
            try encodeContainer.encode(proxySessionId, forKey: .proxySessionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let proxySessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxySessionId)
        proxySessionId = proxySessionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySessionStatus.self, forKey: .status)
        status = statusDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeSDKVoiceClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeSDKVoiceClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let endedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedTimestamp)
        endedTimestamp = endedTimestampDecoded
        let participantsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Participant?].self, forKey: .participants)
        var participantsDecoded0:[ChimeSDKVoiceClientTypes.Participant]? = nil
        if let participantsContainer = participantsContainer {
            participantsDecoded0 = [ChimeSDKVoiceClientTypes.Participant]()
            for structure0 in participantsContainer {
                if let structure0 = structure0 {
                    participantsDecoded0?.append(structure0)
                }
            }
        }
        participants = participantsDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The proxy session for an Amazon Chime SDK Voice Connector.
    public struct ProxySession {
        /// The proxy session capabilities.
        public var capabilities: [ChimeSDKVoiceClientTypes.Capability]?
        /// The created time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ended time stamp, in ISO 8601 format.
        public var endedTimestamp: ClientRuntime.Date?
        /// The number of minutes allowed for the proxy session.
        public var expiryMinutes: Swift.Int?
        /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
        public var geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel?
        /// The country and area code for the proxy phone number.
        public var geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams?
        /// The proxy session name.
        public var name: Swift.String?
        /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
        public var numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior?
        /// The proxy session participants.
        public var participants: [ChimeSDKVoiceClientTypes.Participant]?
        /// The proxy session ID.
        public var proxySessionId: Swift.String?
        /// The proxy session status.
        public var status: ChimeSDKVoiceClientTypes.ProxySessionStatus?
        /// The updated time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The Voice Connector ID.
        public var voiceConnectorId: Swift.String?

        public init(
            capabilities: [ChimeSDKVoiceClientTypes.Capability]? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endedTimestamp: ClientRuntime.Date? = nil,
            expiryMinutes: Swift.Int? = nil,
            geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel? = nil,
            geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams? = nil,
            name: Swift.String? = nil,
            numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior? = nil,
            participants: [ChimeSDKVoiceClientTypes.Participant]? = nil,
            proxySessionId: Swift.String? = nil,
            status: ChimeSDKVoiceClientTypes.ProxySessionStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.createdTimestamp = createdTimestamp
            self.endedTimestamp = endedTimestamp
            self.expiryMinutes = expiryMinutes
            self.geoMatchLevel = geoMatchLevel
            self.geoMatchParams = geoMatchParams
            self.name = name
            self.numberSelectionBehavior = numberSelectionBehavior
            self.participants = participants
            self.proxySessionId = proxySessionId
            self.status = status
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum ProxySessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case inprogress
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [ProxySessionStatus] {
            return [
                .closed,
                .inprogress,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "Closed"
            case .inprogress: return "InProgress"
            case .open: return "Open"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProxySessionStatus(rawValue: rawValue) ?? ProxySessionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sipMediaApplicationAlexaSkillConfiguration = self.sipMediaApplicationAlexaSkillConfiguration {
            try encodeContainer.encode(sipMediaApplicationAlexaSkillConfiguration, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        }
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationInput {

    static func urlPathProvider(_ value: PutSipMediaApplicationAlexaSkillConfigurationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/alexa-skill-configuration"
    }
}

public struct PutSipMediaApplicationAlexaSkillConfigurationInput {
    /// The Alexa Skill configuration.
    public var sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfiguration
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct PutSipMediaApplicationAlexaSkillConfigurationInputBody {
    let sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
}

extension PutSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationAlexaSkillConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration.self, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfigurationDecoded
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSipMediaApplicationAlexaSkillConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationAlexaSkillConfiguration = output.sipMediaApplicationAlexaSkillConfiguration
        } else {
            self.sipMediaApplicationAlexaSkillConfiguration = nil
        }
    }
}

public struct PutSipMediaApplicationAlexaSkillConfigurationOutput {
    /// Returns the Alexa Skill configuration.
    public var sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?

    public init(
        sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration? = nil
    )
    {
        self.sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfiguration
    }
}

struct PutSipMediaApplicationAlexaSkillConfigurationOutputBody {
    let sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
}

extension PutSipMediaApplicationAlexaSkillConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationAlexaSkillConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration.self, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfigurationDecoded
    }
}

enum PutSipMediaApplicationAlexaSkillConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sipMediaApplicationLoggingConfiguration = self.sipMediaApplicationLoggingConfiguration {
            try encodeContainer.encode(sipMediaApplicationLoggingConfiguration, forKey: .sipMediaApplicationLoggingConfiguration)
        }
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput {

    static func urlPathProvider(_ value: PutSipMediaApplicationLoggingConfigurationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

public struct PutSipMediaApplicationLoggingConfigurationInput {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The logging configuration for the specified SIP media application.
    public var sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationId: Swift.String? = nil,
        sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationInputBody {
    let sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

extension PutSipMediaApplicationLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSipMediaApplicationLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct PutSipMediaApplicationLoggingConfigurationOutput {
    /// The updated logging configuration for the specified SIP media application.
    public var sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationOutputBody {
    let sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

enum PutSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyCallingConfiguration = self.emergencyCallingConfiguration {
            try encodeContainer.encode(emergencyCallingConfiguration, forKey: .emergencyCallingConfiguration)
        }
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorEmergencyCallingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInput {
    /// The configuration being updated.
    /// This member is required.
    public var emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationInputBody {
    let emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorEmergencyCallingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationOutput {
    /// The updated configuration.
    public var emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?

    public init(
        emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationOutputBody {
    let emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

enum PutVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfiguration = self.loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
    }
}

extension PutVoiceConnectorLoggingConfigurationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorLoggingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

public struct PutVoiceConnectorLoggingConfigurationInput {
    /// The logging configuration being updated.
    /// This member is required.
    public var loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorLoggingConfigurationInputBody {
    let loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension PutVoiceConnectorLoggingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorLoggingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorLoggingConfigurationOutput {
    /// The updated logging configuration.
    public var loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?

    public init(
        loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct PutVoiceConnectorLoggingConfigurationOutputBody {
    let loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

enum PutVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorOriginationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let origination = self.origination {
            try encodeContainer.encode(origination, forKey: .origination)
        }
    }
}

extension PutVoiceConnectorOriginationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorOriginationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct PutVoiceConnectorOriginationInput {
    /// The origination settings being updated.
    /// This member is required.
    public var origination: ChimeSDKVoiceClientTypes.Origination?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        origination: ChimeSDKVoiceClientTypes.Origination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.origination = origination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorOriginationInputBody {
    let origination: ChimeSDKVoiceClientTypes.Origination?
}

extension PutVoiceConnectorOriginationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

extension PutVoiceConnectorOriginationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorOriginationOutputBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct PutVoiceConnectorOriginationOutput {
    /// The updated origination settings.
    public var origination: ChimeSDKVoiceClientTypes.Origination?

    public init(
        origination: ChimeSDKVoiceClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct PutVoiceConnectorOriginationOutputBody {
    let origination: ChimeSDKVoiceClientTypes.Origination?
}

extension PutVoiceConnectorOriginationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

enum PutVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorProxyInput(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberPoolCountries: \(Swift.String(describing: phoneNumberPoolCountries)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension PutVoiceConnectorProxyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = self.defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = self.fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberPoolCountries = phoneNumberPoolCountries {
            var phoneNumberPoolCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberPoolCountries)
            for country0 in phoneNumberPoolCountries {
                try phoneNumberPoolCountriesContainer.encode(country0)
            }
        }
    }
}

extension PutVoiceConnectorProxyInput {

    static func urlPathProvider(_ value: PutVoiceConnectorProxyInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct PutVoiceConnectorProxyInput {
    /// The default number of minutes allowed for proxy session.
    /// This member is required.
    public var defaultSessionExpiryMinutes: Swift.Int?
    /// When true, stops proxy sessions from being created on the specified Amazon Chime SDK Voice Connector.
    public var disabled: Swift.Bool?
    /// The phone number to route calls to after a proxy session expires.
    public var fallBackPhoneNumber: Swift.String?
    /// The countries for proxy phone numbers to be selected from.
    /// This member is required.
    public var phoneNumberPoolCountries: [Swift.String]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        defaultSessionExpiryMinutes: Swift.Int? = nil,
        disabled: Swift.Bool? = nil,
        fallBackPhoneNumber: Swift.String? = nil,
        phoneNumberPoolCountries: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
        self.disabled = disabled
        self.fallBackPhoneNumber = fallBackPhoneNumber
        self.phoneNumberPoolCountries = phoneNumberPoolCountries
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorProxyInputBody {
    let defaultSessionExpiryMinutes: Swift.Int?
    let phoneNumberPoolCountries: [Swift.String]?
    let fallBackPhoneNumber: Swift.String?
    let disabled: Swift.Bool?
}

extension PutVoiceConnectorProxyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let phoneNumberPoolCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberPoolCountries)
        var phoneNumberPoolCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberPoolCountriesContainer = phoneNumberPoolCountriesContainer {
            phoneNumberPoolCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberPoolCountriesContainer {
                if let string0 = string0 {
                    phoneNumberPoolCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberPoolCountries = phoneNumberPoolCountriesDecoded0
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension PutVoiceConnectorProxyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorProxyOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct PutVoiceConnectorProxyOutput {
    /// The proxy configuration details.
    public var proxy: ChimeSDKVoiceClientTypes.Proxy?

    public init(
        proxy: ChimeSDKVoiceClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct PutVoiceConnectorProxyOutputBody {
    let proxy: ChimeSDKVoiceClientTypes.Proxy?
}

extension PutVoiceConnectorProxyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

enum PutVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorStreamingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamingConfiguration = self.streamingConfiguration {
            try encodeContainer.encode(streamingConfiguration, forKey: .streamingConfiguration)
        }
    }
}

extension PutVoiceConnectorStreamingConfigurationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorStreamingConfigurationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct PutVoiceConnectorStreamingConfigurationInput {
    /// The streaming settings being updated.
    /// This member is required.
    public var streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorStreamingConfigurationInputBody {
    let streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension PutVoiceConnectorStreamingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorStreamingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorStreamingConfigurationOutput {
    /// The updated streaming settings.
    public var streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?

    public init(
        streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct PutVoiceConnectorStreamingConfigurationOutputBody {
    let streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

enum PutVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for credential0 in credentials {
                try credentialsContainer.encode(credential0)
            }
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsInput {

    static func queryItemProvider(_ value: PutVoiceConnectorTerminationCredentialsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "put"))
        return items
    }
}

extension PutVoiceConnectorTerminationCredentialsInput {

    static func urlPathProvider(_ value: PutVoiceConnectorTerminationCredentialsInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct PutVoiceConnectorTerminationCredentialsInput {
    /// The termination credentials being updated.
    public var credentials: [ChimeSDKVoiceClientTypes.Credential]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        credentials: [ChimeSDKVoiceClientTypes.Credential]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationCredentialsInputBody {
    let credentials: [ChimeSDKVoiceClientTypes.Credential]?
}

extension PutVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Credential?].self, forKey: .credentials)
        var credentialsDecoded0:[ChimeSDKVoiceClientTypes.Credential]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [ChimeSDKVoiceClientTypes.Credential]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
    }
}

extension PutVoiceConnectorTerminationCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutVoiceConnectorTerminationCredentialsOutput {

    public init() { }
}

enum PutVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorTerminationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let termination = self.termination {
            try encodeContainer.encode(termination, forKey: .termination)
        }
    }
}

extension PutVoiceConnectorTerminationInput {

    static func urlPathProvider(_ value: PutVoiceConnectorTerminationInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct PutVoiceConnectorTerminationInput {
    /// The termination settings to be updated.
    /// This member is required.
    public var termination: ChimeSDKVoiceClientTypes.Termination?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        termination: ChimeSDKVoiceClientTypes.Termination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.termination = termination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationInputBody {
    let termination: ChimeSDKVoiceClientTypes.Termination?
}

extension PutVoiceConnectorTerminationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension PutVoiceConnectorTerminationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorTerminationOutputBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct PutVoiceConnectorTerminationOutput {
    /// The updated termination settings.
    public var termination: ChimeSDKVoiceClientTypes.Termination?

    public init(
        termination: ChimeSDKVoiceClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct PutVoiceConnectorTerminationOutputBody {
    let termination: ChimeSDKVoiceClientTypes.Termination?
}

extension PutVoiceConnectorTerminationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

enum PutVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ResourceLimitExceededExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestorePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestorePhoneNumberInput(phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension RestorePhoneNumberInput {

    static func queryItemProvider(_ value: RestorePhoneNumberInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "restore"))
        return items
    }
}

extension RestorePhoneNumberInput {

    static func urlPathProvider(_ value: RestorePhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct RestorePhoneNumberInput {
    /// The ID of the phone number being restored.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct RestorePhoneNumberInputBody {
}

extension RestorePhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RestorePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestorePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct RestorePhoneNumberOutput {
    /// The restored phone number.
    public var phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct RestorePhoneNumberOutputBody {
    let phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?
}

extension RestorePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

enum RestorePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchAvailablePhoneNumbersInput {

    static func queryItemProvider(_ value: SearchAvailablePhoneNumbersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "type", value: "phone-numbers"))
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let state = value.state {
            let stateQueryItem = ClientRuntime.SDKURLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state).urlPercentEncoding())
            items.append(stateQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let areaCode = value.areaCode {
            let areaCodeQueryItem = ClientRuntime.SDKURLQueryItem(name: "area-code".urlPercentEncoding(), value: Swift.String(areaCode).urlPercentEncoding())
            items.append(areaCodeQueryItem)
        }
        if let country = value.country {
            let countryQueryItem = ClientRuntime.SDKURLQueryItem(name: "country".urlPercentEncoding(), value: Swift.String(country).urlPercentEncoding())
            items.append(countryQueryItem)
        }
        if let city = value.city {
            let cityQueryItem = ClientRuntime.SDKURLQueryItem(name: "city".urlPercentEncoding(), value: Swift.String(city).urlPercentEncoding())
            items.append(cityQueryItem)
        }
        if let phoneNumberType = value.phoneNumberType {
            let phoneNumberTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "phone-number-type".urlPercentEncoding(), value: Swift.String(phoneNumberType.rawValue).urlPercentEncoding())
            items.append(phoneNumberTypeQueryItem)
        }
        if let tollFreePrefix = value.tollFreePrefix {
            let tollFreePrefixQueryItem = ClientRuntime.SDKURLQueryItem(name: "toll-free-prefix".urlPercentEncoding(), value: Swift.String(tollFreePrefix).urlPercentEncoding())
            items.append(tollFreePrefixQueryItem)
        }
        return items
    }
}

extension SearchAvailablePhoneNumbersInput {

    static func urlPathProvider(_ value: SearchAvailablePhoneNumbersInput) -> Swift.String? {
        return "/search"
    }
}

public struct SearchAvailablePhoneNumbersInput {
    /// Confines a search to just the phone numbers associated with the specified area code.
    public var areaCode: Swift.String?
    /// Confines a search to just the phone numbers associated with the specified city.
    public var city: Swift.String?
    /// Confines a search to just the phone numbers associated with the specified country.
    public var country: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// Confines a search to just the phone numbers associated with the specified phone number type, either local or toll-free.
    public var phoneNumberType: ChimeSDKVoiceClientTypes.PhoneNumberType?
    /// Confines a search to just the phone numbers associated with the specified state.
    public var state: Swift.String?
    /// Confines a search to just the phone numbers associated with the specified toll-free prefix.
    public var tollFreePrefix: Swift.String?

    public init(
        areaCode: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberType: ChimeSDKVoiceClientTypes.PhoneNumberType? = nil,
        state: Swift.String? = nil,
        tollFreePrefix: Swift.String? = nil
    )
    {
        self.areaCode = areaCode
        self.city = city
        self.country = country
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberType = phoneNumberType
        self.state = state
        self.tollFreePrefix = tollFreePrefix
    }
}

struct SearchAvailablePhoneNumbersInputBody {
}

extension SearchAvailablePhoneNumbersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SearchAvailablePhoneNumbersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchAvailablePhoneNumbersOutputBody = try responseDecoder.decode(responseBody: data)
            self.e164PhoneNumbers = output.e164PhoneNumbers
            self.nextToken = output.nextToken
        } else {
            self.e164PhoneNumbers = nil
            self.nextToken = nil
        }
    }
}

public struct SearchAvailablePhoneNumbersOutput {
    /// Confines a search to just the phone numbers in the E.164 format.
    public var e164PhoneNumbers: [Swift.String]?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.nextToken = nextToken
    }
}

struct SearchAvailablePhoneNumbersOutputBody {
    let e164PhoneNumbers: [Swift.String]?
    let nextToken: Swift.String?
}

extension SearchAvailablePhoneNumbersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum SearchAvailablePhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerSideEncryptionConfiguration(kmsKeyArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A structure that contains the configuration settings for server-side encryption. We only support symmetric keys. Do not use asymmetric or HMAC keys, or KMS aliases.
    public struct ServerSideEncryptionConfiguration {
        /// The ARN of the KMS key used to encrypt the enrollment data in a voice profile domain. Asymmetric customer managed keys are not supported.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension ServiceFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceFailureExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes.SipMediaApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case endpoints = "Endpoints"
        case name = "Name"
        case sipMediaApplicationArn = "SipMediaApplicationArn"
        case sipMediaApplicationId = "SipMediaApplicationId"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipMediaApplicationArn = self.sipMediaApplicationArn {
            try encodeContainer.encode(sipMediaApplicationArn, forKey: .sipMediaApplicationArn)
        }
        if let sipMediaApplicationId = self.sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let sipMediaApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationArn)
        sipMediaApplicationArn = sipMediaApplicationArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of the SIP media application, including name and endpoints. An AWS account can have multiple SIP media applications.
    public struct SipMediaApplication {
        /// The AWS Region in which the SIP media application is created.
        public var awsRegion: Swift.String?
        /// The SIP media application creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// List of endpoints for a SIP media application. Currently, only one endpoint per SIP media application is permitted.
        public var endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
        /// The SIP media application's name.
        public var name: Swift.String?
        /// The ARN of the SIP media application.
        public var sipMediaApplicationArn: Swift.String?
        /// A SIP media application's ID.
        public var sipMediaApplicationId: Swift.String?
        /// The time at which the SIP media application was updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            awsRegion: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil,
            name: Swift.String? = nil,
            sipMediaApplicationArn: Swift.String? = nil,
            sipMediaApplicationId: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.endpoints = endpoints
            self.name = name
            self.sipMediaApplicationArn = sipMediaApplicationArn
            self.sipMediaApplicationId = sipMediaApplicationId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaSkillIds = "AlexaSkillIds"
        case alexaSkillStatus = "AlexaSkillStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alexaSkillIds = alexaSkillIds {
            var alexaSkillIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alexaSkillIds)
            for alexaskillid0 in alexaSkillIds {
                try alexaSkillIdsContainer.encode(alexaskillid0)
            }
        }
        if let alexaSkillStatus = self.alexaSkillStatus {
            try encodeContainer.encode(alexaSkillStatus.rawValue, forKey: .alexaSkillStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alexaSkillStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.AlexaSkillStatus.self, forKey: .alexaSkillStatus)
        alexaSkillStatus = alexaSkillStatusDecoded
        let alexaSkillIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .alexaSkillIds)
        var alexaSkillIdsDecoded0:[Swift.String]? = nil
        if let alexaSkillIdsContainer = alexaSkillIdsContainer {
            alexaSkillIdsDecoded0 = [Swift.String]()
            for string0 in alexaSkillIdsContainer {
                if let string0 = string0 {
                    alexaSkillIdsDecoded0?.append(string0)
                }
            }
        }
        alexaSkillIds = alexaSkillIdsDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The Alexa Skill configuration of a SIP media application.
    public struct SipMediaApplicationAlexaSkillConfiguration {
        /// The ID of the Alexa Skill configuration.
        /// This member is required.
        public var alexaSkillIds: [Swift.String]?
        /// The status of the Alexa Skill configuration.
        /// This member is required.
        public var alexaSkillStatus: ChimeSDKVoiceClientTypes.AlexaSkillStatus?

        public init(
            alexaSkillIds: [Swift.String]? = nil,
            alexaSkillStatus: ChimeSDKVoiceClientTypes.AlexaSkillStatus? = nil
        )
        {
            self.alexaSkillIds = alexaSkillIds
            self.alexaSkillStatus = alexaSkillStatus
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationCall: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// A Call instance for a SIP media application.
    public struct SipMediaApplicationCall {
        /// The call's transaction ID.
        public var transactionId: Swift.String?

        public init(
            transactionId: Swift.String? = nil
        )
        {
            self.transactionId = transactionId
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipMediaApplicationEndpoint(lambdaArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The endpoint assigned to a SIP media application.
    public struct SipMediaApplicationEndpoint {
        /// Valid Amazon Resource Name (ARN) of the Lambda function, version, or alias. The function must be created in the same AWS Region as the SIP media application.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableSipMediaApplicationMessageLogs = "EnableSipMediaApplicationMessageLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableSipMediaApplicationMessageLogs = self.enableSipMediaApplicationMessageLogs {
            try encodeContainer.encode(enableSipMediaApplicationMessageLogs, forKey: .enableSipMediaApplicationMessageLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSipMediaApplicationMessageLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSipMediaApplicationMessageLogs)
        enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogsDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The logging configuration of a SIP media application.
    public struct SipMediaApplicationLoggingConfiguration {
        /// Enables message logging for the specified SIP media application.
        public var enableSipMediaApplicationMessageLogs: Swift.Bool?

        public init(
            enableSipMediaApplicationMessageLogs: Swift.Bool? = nil
        )
        {
            self.enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogs
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case disabled = "Disabled"
        case name = "Name"
        case sipRuleId = "SipRuleId"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipRuleId = self.sipRuleId {
            try encodeContainer.encode(sipRuleId, forKey: .sipRuleId)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = self.triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipRuleId)
        sipRuleId = sipRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of a SIP rule, including name, triggers, and target applications. An AWS account can have multiple SIP rules.
    public struct SipRule {
        /// The time at which the SIP rule was created, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// Indicates whether the SIP rule is enabled or disabled. You must disable a rule before you can delete it.
        public var disabled: Swift.Bool?
        /// A SIP rule's name.
        public var name: Swift.String?
        /// A SIP rule's ID.
        public var sipRuleId: Swift.String?
        /// The target SIP media application and other details, such as priority and AWS Region, to be specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
        public var targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
        /// The type of trigger set for a SIP rule, either a phone number or a URI request host name.
        public var triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType?
        /// The value set for a SIP rule's trigger type. Either a phone number or a URI hostname.
        public var triggerValue: Swift.String?
        /// The time at which the SIP rule was updated, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            disabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            sipRuleId: Swift.String? = nil,
            targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil,
            triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType? = nil,
            triggerValue: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.disabled = disabled
            self.name = name
            self.sipRuleId = sipRuleId
            self.targetApplications = targetApplications
            self.triggerType = triggerType
            self.triggerValue = triggerValue
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipRuleTargetApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case priority = "Priority"
        case sipMediaApplicationId = "SipMediaApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let sipMediaApplicationId = self.sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// A target SIP media application and other details, such as priority and AWS Region, to be specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
    public struct SipRuleTargetApplication {
        /// The AWS Region of a rule's target SIP media application.
        public var awsRegion: Swift.String?
        /// The priority setting of a rule's target SIP media application.
        public var priority: Swift.Int?
        /// The ID of a rule's target SIP media application.
        public var sipMediaApplicationId: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sipMediaApplicationId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.priority = priority
            self.sipMediaApplicationId = sipMediaApplicationId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum SipRuleTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requesturihostname
        case tophonenumber
        case sdkUnknown(Swift.String)

        public static var allCases: [SipRuleTriggerType] {
            return [
                .requesturihostname,
                .tophonenumber,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requesturihostname: return "RequestUriHostname"
            case .tophonenumber: return "ToPhoneNumber"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SipRuleTriggerType(rawValue: rawValue) ?? SipRuleTriggerType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.SpeakerSearchDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case voiceprintGenerationStatus = "VoiceprintGenerationStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let results = results {
            var resultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .results)
            for speakersearchresult0 in results {
                try resultsContainer.encode(speakersearchresult0)
            }
        }
        if let voiceprintGenerationStatus = self.voiceprintGenerationStatus {
            try encodeContainer.encode(voiceprintGenerationStatus, forKey: .voiceprintGenerationStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SpeakerSearchResult?].self, forKey: .results)
        var resultsDecoded0:[ChimeSDKVoiceClientTypes.SpeakerSearchResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [ChimeSDKVoiceClientTypes.SpeakerSearchResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let voiceprintGenerationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceprintGenerationStatus)
        voiceprintGenerationStatus = voiceprintGenerationStatusDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of a speaker search task.
    public struct SpeakerSearchDetails {
        /// The result value in the speaker search details.
        public var results: [ChimeSDKVoiceClientTypes.SpeakerSearchResult]?
        /// The status of a voice print generation operation, VoiceprintGenerationSuccess or VoiceprintGenerationFailure..
        public var voiceprintGenerationStatus: Swift.String?

        public init(
            results: [ChimeSDKVoiceClientTypes.SpeakerSearchResult]? = nil,
            voiceprintGenerationStatus: Swift.String? = nil
        )
        {
            self.results = results
            self.voiceprintGenerationStatus = voiceprintGenerationStatus
        }
    }

}

extension ChimeSDKVoiceClientTypes.SpeakerSearchResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidenceScore = "ConfidenceScore"
        case voiceProfileId = "VoiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if confidenceScore != 0.0 {
            try encodeContainer.encode(confidenceScore, forKey: .confidenceScore)
        }
        if let voiceProfileId = self.voiceProfileId {
            try encodeContainer.encode(voiceProfileId, forKey: .voiceProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confidenceScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .confidenceScore) ?? 0.0
        confidenceScore = confidenceScoreDecoded
        let voiceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileId)
        voiceProfileId = voiceProfileIdDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The result of a speaker search analysis.
    public struct SpeakerSearchResult {
        /// The confidence score in the speaker search analysis.
        public var confidenceScore: Swift.Float
        /// The voice profile ID.
        public var voiceProfileId: Swift.String?

        public init(
            confidenceScore: Swift.Float = 0.0,
            voiceProfileId: Swift.String? = nil
        )
        {
            self.confidenceScore = confidenceScore
            self.voiceProfileId = voiceProfileId
        }
    }

}

extension ChimeSDKVoiceClientTypes.SpeakerSearchTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callDetails = "CallDetails"
        case createdTimestamp = "CreatedTimestamp"
        case speakerSearchDetails = "SpeakerSearchDetails"
        case speakerSearchTaskId = "SpeakerSearchTaskId"
        case speakerSearchTaskStatus = "SpeakerSearchTaskStatus"
        case startedTimestamp = "StartedTimestamp"
        case statusMessage = "StatusMessage"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callDetails = self.callDetails {
            try encodeContainer.encode(callDetails, forKey: .callDetails)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let speakerSearchDetails = self.speakerSearchDetails {
            try encodeContainer.encode(speakerSearchDetails, forKey: .speakerSearchDetails)
        }
        if let speakerSearchTaskId = self.speakerSearchTaskId {
            try encodeContainer.encode(speakerSearchTaskId, forKey: .speakerSearchTaskId)
        }
        if let speakerSearchTaskStatus = self.speakerSearchTaskStatus {
            try encodeContainer.encode(speakerSearchTaskStatus, forKey: .speakerSearchTaskStatus)
        }
        if let startedTimestamp = self.startedTimestamp {
            try encodeContainer.encodeTimestamp(startedTimestamp, format: .dateTime, forKey: .startedTimestamp)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerSearchTaskId)
        speakerSearchTaskId = speakerSearchTaskIdDecoded
        let speakerSearchTaskStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerSearchTaskStatus)
        speakerSearchTaskStatus = speakerSearchTaskStatusDecoded
        let callDetailsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.CallDetails.self, forKey: .callDetails)
        callDetails = callDetailsDecoded
        let speakerSearchDetailsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SpeakerSearchDetails.self, forKey: .speakerSearchDetails)
        speakerSearchDetails = speakerSearchDetailsDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let startedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedTimestamp)
        startedTimestamp = startedTimestampDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// A representation of an asynchronous request to perform speaker search analysis on a Voice Connector call.
    public struct SpeakerSearchTask {
        /// The call details of a speaker search task.
        public var callDetails: ChimeSDKVoiceClientTypes.CallDetails?
        /// The time at which a speaker search task was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The details of a speaker search task.
        public var speakerSearchDetails: ChimeSDKVoiceClientTypes.SpeakerSearchDetails?
        /// The speaker search task ID.
        public var speakerSearchTaskId: Swift.String?
        /// The status of the speaker search task, IN_QUEUE, IN_PROGRESS, PARTIAL_SUCCESS, SUCCEEDED, FAILED, or STOPPED.
        public var speakerSearchTaskStatus: Swift.String?
        /// The time at which the speaker search task began.
        public var startedTimestamp: ClientRuntime.Date?
        /// A detailed message about the status of a speaker search.
        public var statusMessage: Swift.String?
        /// The time at which a speaker search task was updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            callDetails: ChimeSDKVoiceClientTypes.CallDetails? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            speakerSearchDetails: ChimeSDKVoiceClientTypes.SpeakerSearchDetails? = nil,
            speakerSearchTaskId: Swift.String? = nil,
            speakerSearchTaskStatus: Swift.String? = nil,
            startedTimestamp: ClientRuntime.Date? = nil,
            statusMessage: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.callDetails = callDetails
            self.createdTimestamp = createdTimestamp
            self.speakerSearchDetails = speakerSearchDetails
            self.speakerSearchTaskId = speakerSearchTaskId
            self.speakerSearchTaskStatus = speakerSearchTaskStatus
            self.startedTimestamp = startedTimestamp
            self.statusMessage = statusMessage
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension StartSpeakerSearchTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callLeg = "CallLeg"
        case clientRequestToken = "ClientRequestToken"
        case transactionId = "TransactionId"
        case voiceProfileDomainId = "VoiceProfileDomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callLeg = self.callLeg {
            try encodeContainer.encode(callLeg.rawValue, forKey: .callLeg)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
    }
}

extension StartSpeakerSearchTaskInput {

    static func urlPathProvider(_ value: StartSpeakerSearchTaskInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/speaker-search-tasks"
    }
}

public struct StartSpeakerSearchTaskInput {
    /// Specifies which call leg to stream for speaker search.
    public var callLeg: ChimeSDKVoiceClientTypes.CallLegType?
    /// The unique identifier for the client request. Use a different token for different speaker search tasks.
    public var clientRequestToken: Swift.String?
    /// The transaction ID of the call being analyzed.
    /// This member is required.
    public var transactionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?
    /// The ID of the voice profile domain that will store the voice profile.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        callLeg: ChimeSDKVoiceClientTypes.CallLegType? = nil,
        clientRequestToken: Swift.String? = nil,
        transactionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil,
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.callLeg = callLeg
        self.clientRequestToken = clientRequestToken
        self.transactionId = transactionId
        self.voiceConnectorId = voiceConnectorId
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct StartSpeakerSearchTaskInputBody {
    let transactionId: Swift.String?
    let voiceProfileDomainId: Swift.String?
    let clientRequestToken: Swift.String?
    let callLeg: ChimeSDKVoiceClientTypes.CallLegType?
}

extension StartSpeakerSearchTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callLeg = "CallLeg"
        case clientRequestToken = "ClientRequestToken"
        case transactionId = "TransactionId"
        case voiceProfileDomainId = "VoiceProfileDomainId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let callLegDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.CallLegType.self, forKey: .callLeg)
        callLeg = callLegDecoded
    }
}

extension StartSpeakerSearchTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSpeakerSearchTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.speakerSearchTask = output.speakerSearchTask
        } else {
            self.speakerSearchTask = nil
        }
    }
}

public struct StartSpeakerSearchTaskOutput {
    /// The details of the speaker search task.
    public var speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask?

    public init(
        speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask? = nil
    )
    {
        self.speakerSearchTask = speakerSearchTask
    }
}

struct StartSpeakerSearchTaskOutputBody {
    let speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask?
}

extension StartSpeakerSearchTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTask = "SpeakerSearchTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SpeakerSearchTask.self, forKey: .speakerSearchTask)
        speakerSearchTask = speakerSearchTaskDecoded
    }
}

enum StartSpeakerSearchTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GoneException": return try await GoneException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartVoiceToneAnalysisTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case languageCode = "LanguageCode"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension StartVoiceToneAnalysisTaskInput {

    static func urlPathProvider(_ value: StartVoiceToneAnalysisTaskInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/voice-tone-analysis-tasks"
    }
}

public struct StartVoiceToneAnalysisTaskInput {
    /// The unique identifier for the client request. Use a different token for different voice tone analysis tasks.
    public var clientRequestToken: Swift.String?
    /// The language code.
    /// This member is required.
    public var languageCode: ChimeSDKVoiceClientTypes.LanguageCode?
    /// The transaction ID.
    /// This member is required.
    public var transactionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        languageCode: ChimeSDKVoiceClientTypes.LanguageCode? = nil,
        transactionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.languageCode = languageCode
        self.transactionId = transactionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct StartVoiceToneAnalysisTaskInputBody {
    let transactionId: Swift.String?
    let languageCode: ChimeSDKVoiceClientTypes.LanguageCode?
    let clientRequestToken: Swift.String?
}

extension StartVoiceToneAnalysisTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case languageCode = "LanguageCode"
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartVoiceToneAnalysisTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartVoiceToneAnalysisTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceToneAnalysisTask = output.voiceToneAnalysisTask
        } else {
            self.voiceToneAnalysisTask = nil
        }
    }
}

public struct StartVoiceToneAnalysisTaskOutput {
    /// The details of the voice tone analysis task.
    public var voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask?

    public init(
        voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask? = nil
    )
    {
        self.voiceToneAnalysisTask = voiceToneAnalysisTask
    }
}

struct StartVoiceToneAnalysisTaskOutputBody {
    let voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask?
}

extension StartVoiceToneAnalysisTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceToneAnalysisTask = "VoiceToneAnalysisTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceToneAnalysisTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask.self, forKey: .voiceToneAnalysisTask)
        voiceToneAnalysisTask = voiceToneAnalysisTaskDecoded
    }
}

enum StartVoiceToneAnalysisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GoneException": return try await GoneException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopSpeakerSearchTaskInput {

    static func queryItemProvider(_ value: StopSpeakerSearchTaskInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "stop"))
        return items
    }
}

extension StopSpeakerSearchTaskInput {

    static func urlPathProvider(_ value: StopSpeakerSearchTaskInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let speakerSearchTaskId = value.speakerSearchTaskId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/speaker-search-tasks/\(speakerSearchTaskId.urlPercentEncoding())"
    }
}

public struct StopSpeakerSearchTaskInput {
    /// The speaker search task ID.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        speakerSearchTaskId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.speakerSearchTaskId = speakerSearchTaskId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct StopSpeakerSearchTaskInputBody {
}

extension StopSpeakerSearchTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopSpeakerSearchTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopSpeakerSearchTaskOutput {

    public init() { }
}

enum StopSpeakerSearchTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopVoiceToneAnalysisTaskInput {

    static func queryItemProvider(_ value: StopVoiceToneAnalysisTaskInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "stop"))
        return items
    }
}

extension StopVoiceToneAnalysisTaskInput {

    static func urlPathProvider(_ value: StopVoiceToneAnalysisTaskInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let voiceToneAnalysisTaskId = value.voiceToneAnalysisTaskId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/voice-tone-analysis-tasks/\(voiceToneAnalysisTaskId.urlPercentEncoding())"
    }
}

public struct StopVoiceToneAnalysisTaskInput {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?
    /// The ID of the voice tone analysis task.
    /// This member is required.
    public var voiceToneAnalysisTaskId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil,
        voiceToneAnalysisTaskId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
        self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
    }
}

struct StopVoiceToneAnalysisTaskInputBody {
}

extension StopVoiceToneAnalysisTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopVoiceToneAnalysisTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopVoiceToneAnalysisTaskOutput {

    public init() { }
}

enum StopVoiceToneAnalysisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKVoiceClientTypes.StreamingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case disabled = "Disabled"
        case mediaInsightsConfiguration = "MediaInsightsConfiguration"
        case streamingNotificationTargets = "StreamingNotificationTargets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let mediaInsightsConfiguration = self.mediaInsightsConfiguration {
            try encodeContainer.encode(mediaInsightsConfiguration, forKey: .mediaInsightsConfiguration)
        }
        if let streamingNotificationTargets = streamingNotificationTargets {
            var streamingNotificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingNotificationTargets)
            for streamingnotificationtarget0 in streamingNotificationTargets {
                try streamingNotificationTargetsContainer.encode(streamingnotificationtarget0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let streamingNotificationTargetsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.StreamingNotificationTarget?].self, forKey: .streamingNotificationTargets)
        var streamingNotificationTargetsDecoded0:[ChimeSDKVoiceClientTypes.StreamingNotificationTarget]? = nil
        if let streamingNotificationTargetsContainer = streamingNotificationTargetsContainer {
            streamingNotificationTargetsDecoded0 = [ChimeSDKVoiceClientTypes.StreamingNotificationTarget]()
            for structure0 in streamingNotificationTargetsContainer {
                if let structure0 = structure0 {
                    streamingNotificationTargetsDecoded0?.append(structure0)
                }
            }
        }
        streamingNotificationTargets = streamingNotificationTargetsDecoded0
        let mediaInsightsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.MediaInsightsConfiguration.self, forKey: .mediaInsightsConfiguration)
        mediaInsightsConfiguration = mediaInsightsConfigurationDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The streaming configuration associated with an Amazon Chime SDK Voice Connector. Specifies whether media streaming is enabled for sending to Amazon Kinesis, and shows the retention period for the Amazon Kinesis data, in hours.
    public struct StreamingConfiguration {
        /// The amount of time, in hours, to the Kinesis data.
        /// This member is required.
        public var dataRetentionInHours: Swift.Int?
        /// When true, streaming to Kinesis is off.
        /// This member is required.
        public var disabled: Swift.Bool?
        /// The call analytics configuration.
        public var mediaInsightsConfiguration: ChimeSDKVoiceClientTypes.MediaInsightsConfiguration?
        /// The streaming notification targets.
        public var streamingNotificationTargets: [ChimeSDKVoiceClientTypes.StreamingNotificationTarget]?

        public init(
            dataRetentionInHours: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            mediaInsightsConfiguration: ChimeSDKVoiceClientTypes.MediaInsightsConfiguration? = nil,
            streamingNotificationTargets: [ChimeSDKVoiceClientTypes.StreamingNotificationTarget]? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
            self.disabled = disabled
            self.mediaInsightsConfiguration = mediaInsightsConfiguration
            self.streamingNotificationTargets = streamingNotificationTargets
        }
    }

}

extension ChimeSDKVoiceClientTypes.StreamingNotificationTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationTarget = "NotificationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationTarget = self.notificationTarget {
            try encodeContainer.encode(notificationTarget.rawValue, forKey: .notificationTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationTargetDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.NotificationTarget.self, forKey: .notificationTarget)
        notificationTarget = notificationTargetDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The target recipient for a streaming configuration notification.
    public struct StreamingNotificationTarget {
        /// The streaming notification target.
        public var notificationTarget: ChimeSDKVoiceClientTypes.NotificationTarget?

        public init(
            notificationTarget: ChimeSDKVoiceClientTypes.NotificationTarget? = nil
        )
        {
            self.notificationTarget = notificationTarget
        }
    }

}

extension ChimeSDKVoiceClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(tags: \(Swift.String(describing: tags)), resourceARN: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "tag-resource"))
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput {
    /// The ARN of the resource being tagged.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of the tags being added to the resource.
    /// This member is required.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody {
    let resourceARN: Swift.String?
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Termination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingRegions = "CallingRegions"
        case cidrAllowedList = "CidrAllowedList"
        case cpsLimit = "CpsLimit"
        case defaultPhoneNumber = "DefaultPhoneNumber"
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingRegions = callingRegions {
            var callingRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callingRegions)
            for callingregion0 in callingRegions {
                try callingRegionsContainer.encode(callingregion0)
            }
        }
        if let cidrAllowedList = cidrAllowedList {
            var cidrAllowedListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowedList)
            for string0 in cidrAllowedList {
                try cidrAllowedListContainer.encode(string0)
            }
        }
        if let cpsLimit = self.cpsLimit {
            try encodeContainer.encode(cpsLimit, forKey: .cpsLimit)
        }
        if let defaultPhoneNumber = self.defaultPhoneNumber {
            try encodeContainer.encode(defaultPhoneNumber, forKey: .defaultPhoneNumber)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpsLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpsLimit)
        cpsLimit = cpsLimitDecoded
        let defaultPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultPhoneNumber)
        defaultPhoneNumber = defaultPhoneNumberDecoded
        let callingRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .callingRegions)
        var callingRegionsDecoded0:[Swift.String]? = nil
        if let callingRegionsContainer = callingRegionsContainer {
            callingRegionsDecoded0 = [Swift.String]()
            for string0 in callingRegionsContainer {
                if let string0 = string0 {
                    callingRegionsDecoded0?.append(string0)
                }
            }
        }
        callingRegions = callingRegionsDecoded0
        let cidrAllowedListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowedList)
        var cidrAllowedListDecoded0:[Swift.String]? = nil
        if let cidrAllowedListContainer = cidrAllowedListContainer {
            cidrAllowedListDecoded0 = [Swift.String]()
            for string0 in cidrAllowedListContainer {
                if let string0 = string0 {
                    cidrAllowedListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowedList = cidrAllowedListDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Termination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Termination(callingRegions: \(Swift.String(describing: callingRegions)), cidrAllowedList: \(Swift.String(describing: cidrAllowedList)), cpsLimit: \(Swift.String(describing: cpsLimit)), disabled: \(Swift.String(describing: disabled)), defaultPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// Termination settings enable SIP hosts to make outbound calls using an Amazon Chime SDK Voice Connector.
    public struct Termination {
        /// The countries to which calls are allowed, in ISO 3166-1 alpha-2 format. Required.
        public var callingRegions: [Swift.String]?
        /// The IP addresses allowed to make calls, in CIDR format.
        public var cidrAllowedList: [Swift.String]?
        /// The limit on calls per second. Max value based on account service quota. Default value of 1.
        public var cpsLimit: Swift.Int?
        /// The default outbound calling number.
        public var defaultPhoneNumber: Swift.String?
        /// When termination is disabled, outbound calls cannot be made.
        public var disabled: Swift.Bool?

        public init(
            callingRegions: [Swift.String]? = nil,
            cidrAllowedList: [Swift.String]? = nil,
            cpsLimit: Swift.Int? = nil,
            defaultPhoneNumber: Swift.String? = nil,
            disabled: Swift.Bool? = nil
        )
        {
            self.callingRegions = callingRegions
            self.cidrAllowedList = cidrAllowedList
            self.cpsLimit = cpsLimit
            self.defaultPhoneNumber = defaultPhoneNumber
            self.disabled = disabled
        }
    }

}

extension ChimeSDKVoiceClientTypes.TerminationHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .dateTime, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .timestamp)
        timestamp = timestampDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The termination health details, including the source IP address and timestamp of the last successful SIP OPTIONS message from your SIP infrastructure.
    public struct TerminationHealth {
        /// The source IP address.
        public var source: Swift.String?
        /// The timestamp, in ISO 8601 format.
        public var timestamp: ClientRuntime.Date?

        public init(
            source: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.source = source
            self.timestamp = timestamp
        }
    }

}

extension ThrottledClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of customer requests exceeds the request rate limit.
public struct ThrottledClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ThrottledClientExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client isn't authorized to request a resource.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UnauthorizedClientExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableEntityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A well-formed request couldn't be followed due to semantic errors.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UnprocessableEntityExceptionBody {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(tagKeys: \(Swift.String(describing: tagKeys)), resourceARN: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        items.append(ClientRuntime.SDKURLQueryItem(name: "operation", value: "untag-resource"))
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput {
    /// The ARN of the resource having its tags removed.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags being removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGlobalSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceConnector = self.voiceConnector {
            try encodeContainer.encode(voiceConnector, forKey: .voiceConnector)
        }
    }
}

extension UpdateGlobalSettingsInput {

    static func urlPathProvider(_ value: UpdateGlobalSettingsInput) -> Swift.String? {
        return "/settings"
    }
}

public struct UpdateGlobalSettingsInput {
    /// The Voice Connector settings.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct UpdateGlobalSettingsInputBody {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?
}

extension UpdateGlobalSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension UpdateGlobalSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGlobalSettingsOutput {

    public init() { }
}

enum UpdateGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberInput(productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension UpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case name = "Name"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

extension UpdatePhoneNumberInput {

    static func urlPathProvider(_ value: UpdatePhoneNumberInput) -> Swift.String? {
        guard let phoneNumberId = value.phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct UpdatePhoneNumberInput {
    /// The outbound calling name associated with the phone number.
    public var callingName: Swift.String?
    /// Specifies the name assigned to one or more phone numbers.
    public var name: Swift.String?
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// The product type.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

    public init(
        callingName: Swift.String? = nil,
        name: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.callingName = callingName
        self.name = name
        self.phoneNumberId = phoneNumberId
        self.productType = productType
    }
}

struct UpdatePhoneNumberInputBody {
    let productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
    let callingName: Swift.String?
    let name: Swift.String?
}

extension UpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case name = "Name"
        case productType = "ProductType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdatePhoneNumberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePhoneNumberOutputBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct UpdatePhoneNumberOutput {
    /// The updated phone number details.
    public var phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct UpdatePhoneNumberOutputBody {
    let phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?
}

extension UpdatePhoneNumberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

enum UpdatePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case name = "Name"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberRequestItem(productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number ID, product type, or calling name fields to update, used with the [BatchUpdatePhoneNumber] and [UpdatePhoneNumber] actions.
    public struct UpdatePhoneNumberRequestItem {
        /// The outbound calling name to update.
        public var callingName: Swift.String?
        /// The name of the phone number.
        public var name: Swift.String?
        /// The phone number ID to update.
        /// This member is required.
        public var phoneNumberId: Swift.String?
        /// The product type to update.
        public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

        public init(
            callingName: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
        )
        {
            self.callingName = callingName
            self.name = name
            self.phoneNumberId = phoneNumberId
            self.productType = productType
        }
    }

}

extension UpdatePhoneNumberSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberSettingsInput(callingName: \"CONTENT_REDACTED\")"}
}

extension UpdatePhoneNumberSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
    }
}

extension UpdatePhoneNumberSettingsInput {

    static func urlPathProvider(_ value: UpdatePhoneNumberSettingsInput) -> Swift.String? {
        return "/settings/phone-number"
    }
}

public struct UpdatePhoneNumberSettingsInput {
    /// The default outbound calling name for the account.
    /// This member is required.
    public var callingName: Swift.String?

    public init(
        callingName: Swift.String? = nil
    )
    {
        self.callingName = callingName
    }
}

struct UpdatePhoneNumberSettingsInputBody {
    let callingName: Swift.String?
}

extension UpdatePhoneNumberSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension UpdatePhoneNumberSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePhoneNumberSettingsOutput {

    public init() { }
}

enum UpdatePhoneNumberSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProxySessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
    }
}

extension UpdateProxySessionInput {

    static func urlPathProvider(_ value: UpdateProxySessionInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = value.proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct UpdateProxySessionInput {
    /// The proxy session capabilities.
    /// This member is required.
    public var capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        capabilities: [ChimeSDKVoiceClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateProxySessionInputBody {
    let capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    let expiryMinutes: Swift.Int?
}

extension UpdateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeSDKVoiceClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeSDKVoiceClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
    }
}

extension UpdateProxySessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProxySessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct UpdateProxySessionOutput {
    /// The updated proxy session details.
    public var proxySession: ChimeSDKVoiceClientTypes.ProxySession?

    public init(
        proxySession: ChimeSDKVoiceClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct UpdateProxySessionOutputBody {
    let proxySession: ChimeSDKVoiceClientTypes.ProxySession?
}

extension UpdateProxySessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

enum UpdateProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSipMediaApplicationCallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .arguments)
            for (dictKey0, smaUpdateCallArgumentsMap0) in arguments {
                try argumentsContainer.encode(smaUpdateCallArgumentsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateSipMediaApplicationCallInput {

    static func urlPathProvider(_ value: UpdateSipMediaApplicationCallInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        guard let transactionId = value.transactionId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls/\(transactionId.urlPercentEncoding())"
    }
}

public struct UpdateSipMediaApplicationCallInput {
    /// Arguments made available to the Lambda function as part of the CALL_UPDATE_REQUESTED event. Can contain 0-20 key-value pairs.
    /// This member is required.
    public var arguments: [Swift.String:Swift.String]?
    /// The ID of the SIP media application handling the call.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The ID of the call transaction.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        arguments: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.arguments = arguments
        self.sipMediaApplicationId = sipMediaApplicationId
        self.transactionId = transactionId
    }
}

struct UpdateSipMediaApplicationCallInputBody {
    let arguments: [Swift.String:Swift.String]?
}

extension UpdateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let argumentsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .arguments)
        var argumentsDecoded0: [Swift.String:Swift.String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in argumentsContainer {
                if let sensitivestring0 = sensitivestring0 {
                    argumentsDecoded0?[key0] = sensitivestring0
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

extension UpdateSipMediaApplicationCallOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSipMediaApplicationCallOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct UpdateSipMediaApplicationCallOutput {
    /// A Call instance for a SIP media application.
    public var sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?

    public init(
        sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct UpdateSipMediaApplicationCallOutputBody {
    let sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?
}

extension UpdateSipMediaApplicationCallOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

enum UpdateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSipMediaApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateSipMediaApplicationInput {

    static func urlPathProvider(_ value: UpdateSipMediaApplicationInput) -> Swift.String? {
        guard let sipMediaApplicationId = value.sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct UpdateSipMediaApplicationInput {
    /// The new set of endpoints for the specified SIP media application.
    public var endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
    /// The new name for the specified SIP media application.
    public var name: Swift.String?
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.name = name
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct UpdateSipMediaApplicationInputBody {
    let name: Swift.String?
    let endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
}

extension UpdateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension UpdateSipMediaApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSipMediaApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct UpdateSipMediaApplicationOutput {
    /// The updated SIP media applications details.
    public var sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct UpdateSipMediaApplicationOutputBody {
    let sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?
}

extension UpdateSipMediaApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

enum UpdateSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSipRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
    }
}

extension UpdateSipRuleInput {

    static func urlPathProvider(_ value: UpdateSipRuleInput) -> Swift.String? {
        guard let sipRuleId = value.sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct UpdateSipRuleInput {
    /// The new value that indicates whether the rule is disabled.
    public var disabled: Swift.Bool?
    /// The new name for the specified SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?
    /// The new list of target applications.
    public var targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?

    public init(
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        sipRuleId: Swift.String? = nil,
        targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.sipRuleId = sipRuleId
        self.targetApplications = targetApplications
    }
}

struct UpdateSipRuleInputBody {
    let name: Swift.String?
    let disabled: Swift.Bool?
    let targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
}

extension UpdateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

extension UpdateSipRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSipRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct UpdateSipRuleOutput {
    /// The updated SIP rule details.
    public var sipRule: ChimeSDKVoiceClientTypes.SipRule?

    public init(
        sipRule: ChimeSDKVoiceClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct UpdateSipRuleOutputBody {
    let sipRule: ChimeSDKVoiceClientTypes.SipRule?
}

extension UpdateSipRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

enum UpdateSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }
}

extension UpdateVoiceConnectorGroupInput {

    static func urlPathProvider(_ value: UpdateVoiceConnectorGroupInput) -> Swift.String? {
        guard let voiceConnectorGroupId = value.voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceConnectorGroupInput {
    /// The name of the Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?
    /// The VoiceConnectorItems to associate with the Voice Connector group.
    /// This member is required.
    public var voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?

    public init(
        name: Swift.String? = nil,
        voiceConnectorGroupId: Swift.String? = nil,
        voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorGroupId = voiceConnectorGroupId
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct UpdateVoiceConnectorGroupInputBody {
    let name: Swift.String?
    let voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?
}

extension UpdateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

extension UpdateVoiceConnectorGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceConnectorGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct UpdateVoiceConnectorGroupOutput {
    /// The updated Voice Connector group.
    public var voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct UpdateVoiceConnectorGroupOutputBody {
    let voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?
}

extension UpdateVoiceConnectorGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

enum UpdateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
    }
}

extension UpdateVoiceConnectorInput {

    static func urlPathProvider(_ value: UpdateVoiceConnectorInput) -> Swift.String? {
        guard let voiceConnectorId = value.voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceConnectorInput {
    /// The name of the Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// When enabled, requires encryption for the Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.name = name
        self.requireEncryption = requireEncryption
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateVoiceConnectorInputBody {
    let name: Swift.String?
    let requireEncryption: Swift.Bool?
}

extension UpdateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
    }
}

extension UpdateVoiceConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct UpdateVoiceConnectorOutput {
    /// The updated Voice Connector details.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct UpdateVoiceConnectorOutputBody {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?
}

extension UpdateVoiceConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

enum UpdateVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceProfileDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateVoiceProfileDomainInput {

    static func urlPathProvider(_ value: UpdateVoiceProfileDomainInput) -> Swift.String? {
        guard let voiceProfileDomainId = value.voiceProfileDomainId else {
            return nil
        }
        return "/voice-profile-domains/\(voiceProfileDomainId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceProfileDomainInput {
    /// The description of the voice profile domain.
    public var description: Swift.String?
    /// The name of the voice profile domain.
    public var name: Swift.String?
    /// The domain ID.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct UpdateVoiceProfileDomainInputBody {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateVoiceProfileDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateVoiceProfileDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceProfileDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfileDomain = output.voiceProfileDomain
        } else {
            self.voiceProfileDomain = nil
        }
    }
}

public struct UpdateVoiceProfileDomainOutput {
    /// The updated details of the voice profile domain.
    public var voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?

    public init(
        voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain? = nil
    )
    {
        self.voiceProfileDomain = voiceProfileDomain
    }
}

struct UpdateVoiceProfileDomainOutputBody {
    let voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?
}

extension UpdateVoiceProfileDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfileDomain = "VoiceProfileDomain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfileDomain.self, forKey: .voiceProfileDomain)
        voiceProfileDomain = voiceProfileDomainDecoded
    }
}

enum UpdateVoiceProfileDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTaskId = "SpeakerSearchTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let speakerSearchTaskId = self.speakerSearchTaskId {
            try encodeContainer.encode(speakerSearchTaskId, forKey: .speakerSearchTaskId)
        }
    }
}

extension UpdateVoiceProfileInput {

    static func urlPathProvider(_ value: UpdateVoiceProfileInput) -> Swift.String? {
        guard let voiceProfileId = value.voiceProfileId else {
            return nil
        }
        return "/voice-profiles/\(voiceProfileId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceProfileInput {
    /// The ID of the speaker search task.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?
    /// The profile ID.
    /// This member is required.
    public var voiceProfileId: Swift.String?

    public init(
        speakerSearchTaskId: Swift.String? = nil,
        voiceProfileId: Swift.String? = nil
    )
    {
        self.speakerSearchTaskId = speakerSearchTaskId
        self.voiceProfileId = voiceProfileId
    }
}

struct UpdateVoiceProfileInputBody {
    let speakerSearchTaskId: Swift.String?
}

extension UpdateVoiceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTaskId = "SpeakerSearchTaskId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerSearchTaskId)
        speakerSearchTaskId = speakerSearchTaskIdDecoded
    }
}

extension UpdateVoiceProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfile = output.voiceProfile
        } else {
            self.voiceProfile = nil
        }
    }
}

public struct UpdateVoiceProfileOutput {
    /// The updated voice profile settings.
    public var voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?

    public init(
        voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile? = nil
    )
    {
        self.voiceProfile = voiceProfile
    }
}

struct UpdateVoiceProfileOutputBody {
    let voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?
}

extension UpdateVoiceProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfile = "VoiceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfile.self, forKey: .voiceProfile)
        voiceProfile = voiceProfileDecoded
    }
}

enum UpdateVoiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GoneException": return try await GoneException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidateE911AddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateE911AddressInput(awsAccountId: \(Swift.String(describing: awsAccountId)), city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

extension ValidateE911AddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case city = "City"
        case country = "Country"
        case postalCode = "PostalCode"
        case state = "State"
        case streetInfo = "StreetInfo"
        case streetNumber = "StreetNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetInfo = self.streetInfo {
            try encodeContainer.encode(streetInfo, forKey: .streetInfo)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
    }
}

extension ValidateE911AddressInput {

    static func urlPathProvider(_ value: ValidateE911AddressInput) -> Swift.String? {
        return "/emergency-calling/address"
    }
}

public struct ValidateE911AddressInput {
    /// The AWS account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The address city, such as Portland.
    /// This member is required.
    public var city: Swift.String?
    /// The country in the address being validated.
    /// This member is required.
    public var country: Swift.String?
    /// The dress postal code, such 04352.
    /// This member is required.
    public var postalCode: Swift.String?
    /// The address state, such as ME.
    /// This member is required.
    public var state: Swift.String?
    /// The address street information, such as 8th Avenue.
    /// This member is required.
    public var streetInfo: Swift.String?
    /// The address street number, such as 200 or 2121.
    /// This member is required.
    public var streetNumber: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        postalCode: Swift.String? = nil,
        state: Swift.String? = nil,
        streetInfo: Swift.String? = nil,
        streetNumber: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.city = city
        self.country = country
        self.postalCode = postalCode
        self.state = state
        self.streetInfo = streetInfo
        self.streetNumber = streetNumber
    }
}

struct ValidateE911AddressInputBody {
    let awsAccountId: Swift.String?
    let streetNumber: Swift.String?
    let streetInfo: Swift.String?
    let city: Swift.String?
    let state: Swift.String?
    let country: Swift.String?
    let postalCode: Swift.String?
}

extension ValidateE911AddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case city = "City"
        case country = "Country"
        case postalCode = "PostalCode"
        case state = "State"
        case streetInfo = "StreetInfo"
        case streetNumber = "StreetNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let streetInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetInfo)
        streetInfo = streetInfoDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
    }
}

extension ValidateE911AddressOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidateE911AddressOutputBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
            self.addressExternalId = output.addressExternalId
            self.candidateAddressList = output.candidateAddressList
            self.validationResult = output.validationResult
        } else {
            self.address = nil
            self.addressExternalId = nil
            self.candidateAddressList = nil
            self.validationResult = 0
        }
    }
}

public struct ValidateE911AddressOutput {
    /// The validated address.
    public var address: ChimeSDKVoiceClientTypes.Address?
    /// The ID that represents the address.
    public var addressExternalId: Swift.String?
    /// The list of address suggestions..
    public var candidateAddressList: [ChimeSDKVoiceClientTypes.CandidateAddress]?
    /// Number indicating the result of address validation. 0 means the address was perfect as-is and successfully validated. 1 means the address was corrected. 2 means the address sent was not close enough and was not validated.
    public var validationResult: Swift.Int

    public init(
        address: ChimeSDKVoiceClientTypes.Address? = nil,
        addressExternalId: Swift.String? = nil,
        candidateAddressList: [ChimeSDKVoiceClientTypes.CandidateAddress]? = nil,
        validationResult: Swift.Int = 0
    )
    {
        self.address = address
        self.addressExternalId = addressExternalId
        self.candidateAddressList = candidateAddressList
        self.validationResult = validationResult
    }
}

struct ValidateE911AddressOutputBody {
    let validationResult: Swift.Int
    let addressExternalId: Swift.String?
    let address: ChimeSDKVoiceClientTypes.Address?
    let candidateAddressList: [ChimeSDKVoiceClientTypes.CandidateAddress]?
}

extension ValidateE911AddressOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressExternalId = "AddressExternalId"
        case candidateAddressList = "CandidateAddressList"
        case validationResult = "ValidationResult"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationResult) ?? 0
        validationResult = validationResultDecoded
        let addressExternalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressExternalId)
        addressExternalId = addressExternalIdDecoded
        let addressDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Address.self, forKey: .address)
        address = addressDecoded
        let candidateAddressListContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.CandidateAddress?].self, forKey: .candidateAddressList)
        var candidateAddressListDecoded0:[ChimeSDKVoiceClientTypes.CandidateAddress]? = nil
        if let candidateAddressListContainer = candidateAddressListContainer {
            candidateAddressListDecoded0 = [ChimeSDKVoiceClientTypes.CandidateAddress]()
            for structure0 in candidateAddressListContainer {
                if let structure0 = structure0 {
                    candidateAddressListDecoded0?.append(structure0)
                }
            }
        }
        candidateAddressList = candidateAddressListDecoded0
    }
}

enum ValidateE911AddressOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKVoiceClientTypes.VoiceConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case outboundHostName = "OutboundHostName"
        case requireEncryption = "RequireEncryption"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorArn = "VoiceConnectorArn"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundHostName = self.outboundHostName {
            try encodeContainer.encode(outboundHostName, forKey: .outboundHostName)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorArn = self.voiceConnectorArn {
            try encodeContainer.encode(voiceConnectorArn, forKey: .voiceConnectorArn)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outboundHostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundHostName)
        outboundHostName = outboundHostNameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let voiceConnectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorArn)
        voiceConnectorArn = voiceConnectorArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The Amazon Chime SDK Voice Connector configuration, including outbound host name and encryption settings.
    public struct VoiceConnector {
        /// The AWS Region in which the Voice Connector is created. Default: us-east-1.
        public var awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?
        /// The Voice Connector's creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The Voice Connector's name.
        public var name: Swift.String?
        /// The outbound host name for the Voice Connector.
        public var outboundHostName: Swift.String?
        /// Enables or disables encryption for the Voice Connector.
        public var requireEncryption: Swift.Bool?
        /// The Voice Connector's updated timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the Voice Connector.
        public var voiceConnectorArn: Swift.String?
        /// The Voice Connector's ID.
        public var voiceConnectorId: Swift.String?

        public init(
            awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            outboundHostName: Swift.String? = nil,
            requireEncryption: Swift.Bool? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorArn: Swift.String? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.outboundHostName = outboundHostName
            self.requireEncryption = requireEncryption
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorArn = voiceConnectorArn
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum VoiceConnectorAwsRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apNortheast1
        case apNortheast2
        case apSoutheast1
        case apSoutheast2
        case caCentral1
        case euCentral1
        case euWest1
        case euWest2
        case usEast1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceConnectorAwsRegion] {
            return [
                .apNortheast1,
                .apNortheast2,
                .apSoutheast1,
                .apSoutheast2,
                .caCentral1,
                .euCentral1,
                .euWest1,
                .euWest2,
                .usEast1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .caCentral1: return "ca-central-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .usEast1: return "us-east-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceConnectorAwsRegion(rawValue: rawValue) ?? VoiceConnectorAwsRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.VoiceConnectorGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorGroupArn = "VoiceConnectorGroupArn"
        case voiceConnectorGroupId = "VoiceConnectorGroupId"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorGroupArn = self.voiceConnectorGroupArn {
            try encodeContainer.encode(voiceConnectorGroupArn, forKey: .voiceConnectorGroupArn)
        }
        if let voiceConnectorGroupId = self.voiceConnectorGroupId {
            try encodeContainer.encode(voiceConnectorGroupId, forKey: .voiceConnectorGroupId)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorGroupId)
        voiceConnectorGroupId = voiceConnectorGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let voiceConnectorGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorGroupArn)
        voiceConnectorGroupArn = voiceConnectorGroupArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The Amazon Chime SDK Voice Connector group configuration, including associated Voice Connectors. You can include Voice Connectors from different AWS Regions in a group. This creates a fault tolerant mechanism for fallback in case of availability events.
    public struct VoiceConnectorGroup {
        /// The Voice Connector group's creation time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The name of a Voice Connector group.
        public var name: Swift.String?
        /// The Voice Connector group's creation time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the Voice Connector group.
        public var voiceConnectorGroupArn: Swift.String?
        /// The ID of a Voice Connector group.
        public var voiceConnectorGroupId: Swift.String?
        /// The Voice Connectors to which you route inbound calls.
        public var voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorGroupArn: Swift.String? = nil,
            voiceConnectorGroupId: Swift.String? = nil,
            voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorGroupArn = voiceConnectorGroupArn
            self.voiceConnectorGroupId = voiceConnectorGroupId
            self.voiceConnectorItems = voiceConnectorItems
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceConnectorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// For Amazon Chime SDK Voice Connector groups, the Amazon Chime SDK Voice Connectors to which you route inbound calls. Includes priority configuration settings. Limit: 3 VoiceConnectorItems per Voice Connector group.
    public struct VoiceConnectorItem {
        /// The priority setting of a Voice Connector item. Calls are routed to hosts in priority order, with 1 as the highest priority. When hosts have equal priority, the system distributes calls among them based on their relative weight.
        /// This member is required.
        public var priority: Swift.Int?
        /// The Voice Connector ID.
        /// This member is required.
        public var voiceConnectorId: Swift.String?

        public init(
            priority: Swift.Int? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.priority = priority
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceConnectorSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdrBucket = "CdrBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdrBucket = self.cdrBucket {
            try encodeContainer.encode(cdrBucket, forKey: .cdrBucket)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdrBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdrBucket)
        cdrBucket = cdrBucketDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The Amazon Chime SDK Voice Connector settings. Includes any Amazon S3 buckets designated for storing call detail records.
    public struct VoiceConnectorSettings {
        /// The S3 bucket that stores the Voice Connector's call detail records.
        public var cdrBucket: Swift.String?

        public init(
            cdrBucket: Swift.String? = nil
        )
        {
            self.cdrBucket = cdrBucket
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case expirationTimestamp = "ExpirationTimestamp"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceProfileArn = "VoiceProfileArn"
        case voiceProfileDomainId = "VoiceProfileDomainId"
        case voiceProfileId = "VoiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let expirationTimestamp = self.expirationTimestamp {
            try encodeContainer.encodeTimestamp(expirationTimestamp, format: .dateTime, forKey: .expirationTimestamp)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceProfileArn = self.voiceProfileArn {
            try encodeContainer.encode(voiceProfileArn, forKey: .voiceProfileArn)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
        if let voiceProfileId = self.voiceProfileId {
            try encodeContainer.encode(voiceProfileId, forKey: .voiceProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileId)
        voiceProfileId = voiceProfileIdDecoded
        let voiceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileArn)
        voiceProfileArn = voiceProfileArnDecoded
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let expirationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expirationTimestamp)
        expirationTimestamp = expirationTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes.VoiceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceProfile(createdTimestamp: \(Swift.String(describing: createdTimestamp)), expirationTimestamp: \(Swift.String(describing: expirationTimestamp)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceProfileDomainId: \(Swift.String(describing: voiceProfileDomainId)), voiceProfileId: \(Swift.String(describing: voiceProfileId)), voiceProfileArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The combination of a voice print and caller ID.
    public struct VoiceProfile {
        /// The time at which the voice profile was created and enrolled.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a voice profile expires unless you re-enroll the caller via the UpdateVoiceProfile API.
        public var expirationTimestamp: ClientRuntime.Date?
        /// The time at which the voice profile was last updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the voice profile.
        public var voiceProfileArn: Swift.String?
        /// The ID of the domain that contains the voice profile.
        public var voiceProfileDomainId: Swift.String?
        /// The ID of the voice profile.
        public var voiceProfileId: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            expirationTimestamp: ClientRuntime.Date? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceProfileArn: Swift.String? = nil,
            voiceProfileDomainId: Swift.String? = nil,
            voiceProfileId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.expirationTimestamp = expirationTimestamp
            self.updatedTimestamp = updatedTimestamp
            self.voiceProfileArn = voiceProfileArn
            self.voiceProfileDomainId = voiceProfileDomainId
            self.voiceProfileId = voiceProfileId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceProfileDomain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceProfileDomainArn = "VoiceProfileDomainArn"
        case voiceProfileDomainId = "VoiceProfileDomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceProfileDomainArn = self.voiceProfileDomainArn {
            try encodeContainer.encode(voiceProfileDomainArn, forKey: .voiceProfileDomainArn)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let voiceProfileDomainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainArn)
        voiceProfileDomainArn = voiceProfileDomainArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes.VoiceProfileDomain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceProfileDomain(createdTimestamp: \(Swift.String(describing: createdTimestamp)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceProfileDomainId: \(Swift.String(describing: voiceProfileDomainId)), voiceProfileDomainArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A collection of voice profiles.
    public struct VoiceProfileDomain {
        /// The time at which the voice profile domain was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The description of the voice profile domain.
        public var description: Swift.String?
        /// The name of the voice profile domain.
        public var name: Swift.String?
        /// A structure that contains the configuration settings for server-side encryption.
        public var serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration?
        /// The time at which the voice profile was last updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The voice profile domain's Amazon Resource Number (ARN).
        public var voiceProfileDomainArn: Swift.String?
        /// The ID of the voice profile domain.
        public var voiceProfileDomainId: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceProfileDomainArn: Swift.String? = nil,
            voiceProfileDomainId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.updatedTimestamp = updatedTimestamp
            self.voiceProfileDomainArn = voiceProfileDomainArn
            self.voiceProfileDomainId = voiceProfileDomainId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case description = "Description"
        case name = "Name"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceProfileDomainArn = "VoiceProfileDomainArn"
        case voiceProfileDomainId = "VoiceProfileDomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceProfileDomainArn = self.voiceProfileDomainArn {
            try encodeContainer.encode(voiceProfileDomainArn, forKey: .voiceProfileDomainArn)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let voiceProfileDomainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainArn)
        voiceProfileDomainArn = voiceProfileDomainArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceProfileDomainSummary(createdTimestamp: \(Swift.String(describing: createdTimestamp)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceProfileDomainId: \(Swift.String(describing: voiceProfileDomainId)), voiceProfileDomainArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A high-level overview of a voice profile domain.
    public struct VoiceProfileDomainSummary {
        /// The time at which the voice profile domain summary was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// Describes the voice profile domain summary.
        public var description: Swift.String?
        /// The name of the voice profile domain summary.
        public var name: Swift.String?
        /// The time at which the voice profile domain summary was last updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of a voice profile in a voice profile domain summary.
        public var voiceProfileDomainArn: Swift.String?
        /// The ID of the voice profile domain summary.
        public var voiceProfileDomainId: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceProfileDomainArn: Swift.String? = nil,
            voiceProfileDomainId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.name = name
            self.updatedTimestamp = updatedTimestamp
            self.voiceProfileDomainArn = voiceProfileDomainArn
            self.voiceProfileDomainId = voiceProfileDomainId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case expirationTimestamp = "ExpirationTimestamp"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceProfileArn = "VoiceProfileArn"
        case voiceProfileDomainId = "VoiceProfileDomainId"
        case voiceProfileId = "VoiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let expirationTimestamp = self.expirationTimestamp {
            try encodeContainer.encodeTimestamp(expirationTimestamp, format: .dateTime, forKey: .expirationTimestamp)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceProfileArn = self.voiceProfileArn {
            try encodeContainer.encode(voiceProfileArn, forKey: .voiceProfileArn)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
        if let voiceProfileId = self.voiceProfileId {
            try encodeContainer.encode(voiceProfileId, forKey: .voiceProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileId)
        voiceProfileId = voiceProfileIdDecoded
        let voiceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileArn)
        voiceProfileArn = voiceProfileArnDecoded
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let expirationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expirationTimestamp)
        expirationTimestamp = expirationTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes.VoiceProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceProfileSummary(createdTimestamp: \(Swift.String(describing: createdTimestamp)), expirationTimestamp: \(Swift.String(describing: expirationTimestamp)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceProfileDomainId: \(Swift.String(describing: voiceProfileDomainId)), voiceProfileId: \(Swift.String(describing: voiceProfileId)), voiceProfileArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A high-level summary of a voice profile.
    public struct VoiceProfileSummary {
        /// The time at which a voice profile summary was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// Extends the life of the voice profile. You can use UpdateVoiceProfile to refresh an existing voice profile's voice print and extend the life of the summary.
        public var expirationTimestamp: ClientRuntime.Date?
        /// The time at which a voice profile summary was last updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the voice profile in a voice profile summary.
        public var voiceProfileArn: Swift.String?
        /// The ID of the voice profile domain in a voice profile summary.
        public var voiceProfileDomainId: Swift.String?
        /// The ID of the voice profile in a voice profile summary.
        public var voiceProfileId: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            expirationTimestamp: ClientRuntime.Date? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceProfileArn: Swift.String? = nil,
            voiceProfileDomainId: Swift.String? = nil,
            voiceProfileId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.expirationTimestamp = expirationTimestamp
            self.updatedTimestamp = updatedTimestamp
            self.voiceProfileArn = voiceProfileArn
            self.voiceProfileDomainId = voiceProfileDomainId
            self.voiceProfileId = voiceProfileId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callDetails = "CallDetails"
        case createdTimestamp = "CreatedTimestamp"
        case startedTimestamp = "StartedTimestamp"
        case statusMessage = "StatusMessage"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceToneAnalysisTaskId = "VoiceToneAnalysisTaskId"
        case voiceToneAnalysisTaskStatus = "VoiceToneAnalysisTaskStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callDetails = self.callDetails {
            try encodeContainer.encode(callDetails, forKey: .callDetails)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let startedTimestamp = self.startedTimestamp {
            try encodeContainer.encodeTimestamp(startedTimestamp, format: .dateTime, forKey: .startedTimestamp)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceToneAnalysisTaskId = self.voiceToneAnalysisTaskId {
            try encodeContainer.encode(voiceToneAnalysisTaskId, forKey: .voiceToneAnalysisTaskId)
        }
        if let voiceToneAnalysisTaskStatus = self.voiceToneAnalysisTaskStatus {
            try encodeContainer.encode(voiceToneAnalysisTaskStatus, forKey: .voiceToneAnalysisTaskStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceToneAnalysisTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceToneAnalysisTaskId)
        voiceToneAnalysisTaskId = voiceToneAnalysisTaskIdDecoded
        let voiceToneAnalysisTaskStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceToneAnalysisTaskStatus)
        voiceToneAnalysisTaskStatus = voiceToneAnalysisTaskStatusDecoded
        let callDetailsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.CallDetails.self, forKey: .callDetails)
        callDetails = callDetailsDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let startedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedTimestamp)
        startedTimestamp = startedTimestampDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// A representation of an asynchronous request to perform voice tone analysis on a Voice Connector call.
    public struct VoiceToneAnalysisTask {
        /// The call details of a voice tone analysis task.
        public var callDetails: ChimeSDKVoiceClientTypes.CallDetails?
        /// The time at which a voice tone analysis task was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a voice tone analysis task started.
        public var startedTimestamp: ClientRuntime.Date?
        /// The status of a voice tone analysis task.
        public var statusMessage: Swift.String?
        /// The time at which a voice tone analysis task was updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ID of the voice tone analysis task.
        public var voiceToneAnalysisTaskId: Swift.String?
        /// The status of a voice tone analysis task, IN_QUEUE, IN_PROGRESS, PARTIAL_SUCCESS, SUCCEEDED, FAILED, or STOPPED.
        public var voiceToneAnalysisTaskStatus: Swift.String?

        public init(
            callDetails: ChimeSDKVoiceClientTypes.CallDetails? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            startedTimestamp: ClientRuntime.Date? = nil,
            statusMessage: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceToneAnalysisTaskId: Swift.String? = nil,
            voiceToneAnalysisTaskStatus: Swift.String? = nil
        )
        {
            self.callDetails = callDetails
            self.createdTimestamp = createdTimestamp
            self.startedTimestamp = startedTimestamp
            self.statusMessage = statusMessage
            self.updatedTimestamp = updatedTimestamp
            self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
            self.voiceToneAnalysisTaskStatus = voiceToneAnalysisTaskStatus
        }
    }

}
