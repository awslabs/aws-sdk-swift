// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have the permissions needed to run this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case country
        case postDirectional
        case postalCode
        case postalCodePlus4
        case preDirectional
        case state
        case streetName
        case streetNumber
        case streetSuffix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postDirectional = self.postDirectional {
            try encodeContainer.encode(postDirectional, forKey: .postDirectional)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let postalCodePlus4 = self.postalCodePlus4 {
            try encodeContainer.encode(postalCodePlus4, forKey: .postalCodePlus4)
        }
        if let preDirectional = self.preDirectional {
            try encodeContainer.encode(preDirectional, forKey: .preDirectional)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetName = self.streetName {
            try encodeContainer.encode(streetName, forKey: .streetName)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
        if let streetSuffix = self.streetSuffix {
            try encodeContainer.encode(streetSuffix, forKey: .streetSuffix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetName)
        streetName = streetNameDecoded
        let streetSuffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetSuffix)
        streetSuffix = streetSuffixDecoded
        let postDirectionalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postDirectional)
        postDirectional = postDirectionalDecoded
        let preDirectionalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preDirectional)
        preDirectional = preDirectionalDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let postalCodePlus4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCodePlus4)
        postalCodePlus4 = postalCodePlus4Decoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postDirectional: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", preDirectional: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetName: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\", streetSuffix: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A validated address.
    public struct Address: Swift.Equatable {
        /// The city of an address.
        public var city: Swift.String?
        /// The country of an address.
        public var country: Swift.String?
        /// An address suffix location, such as the S. Unit A in Central Park S. Unit A.
        public var postDirectional: Swift.String?
        /// The postal code of an address.
        public var postalCode: Swift.String?
        /// The zip + 4 or postal code + 4 of an address.
        public var postalCodePlus4: Swift.String?
        /// An address prefix location, such as the N in N. Third St.
        public var preDirectional: Swift.String?
        /// The state of an address.
        public var state: Swift.String?
        /// The address street, such as 8th Avenue.
        public var streetName: Swift.String?
        /// The numeric portion of an address.
        public var streetNumber: Swift.String?
        /// The address suffix, such as the N in 8th Avenue N.
        public var streetSuffix: Swift.String?

        public init(
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postDirectional: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            preDirectional: Swift.String? = nil,
            state: Swift.String? = nil,
            streetName: Swift.String? = nil,
            streetNumber: Swift.String? = nil,
            streetSuffix: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postDirectional = postDirectional
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.preDirectional = preDirectional
            self.state = state
            self.streetName = streetName
            self.streetNumber = streetNumber
            self.streetSuffix = streetSuffix
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum AlexaSkillStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AlexaSkillStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlexaSkillStatus(rawValue: rawValue) ?? AlexaSkillStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let forceAssociate = self.forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-numbers"))
            return items
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime SDK Voice Connector Group and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Amazon Chime SDK Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
    let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

public enum AssociatePhoneNumbersWithVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let forceAssociate = self.forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-numbers"))
            return items
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// If true, associates the provided phone numbers with the provided Amazon Chime SDK Voice Connector and removes any previously existing associations. If false, does not associate any phone numbers that have previously existing associations.
    public var forceAssociate: Swift.Bool?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorId = voiceConnectorId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
    let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

public enum AssociatePhoneNumbersWithVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociatePhoneNumbersWithVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchDeletePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumberIds = phoneNumberIds {
            var phoneNumberIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberIds)
            for string0 in phoneNumberIds {
                try phoneNumberIdsContainer.encode(string0)
            }
        }
    }
}

extension BatchDeletePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-delete"))
            return items
        }
    }
}

extension BatchDeletePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-numbers"
    }
}

public struct BatchDeletePhoneNumberInput: Swift.Equatable {
    /// List of phone number IDs.
    /// This member is required.
    public var phoneNumberIds: [Swift.String]?

    public init(
        phoneNumberIds: [Swift.String]? = nil
    )
    {
        self.phoneNumberIds = phoneNumberIds
    }
}

struct BatchDeletePhoneNumberInputBody: Swift.Equatable {
    let phoneNumberIds: [Swift.String]?
}

extension BatchDeletePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberIds)
        var phoneNumberIdsDecoded0:[Swift.String]? = nil
        if let phoneNumberIdsContainer = phoneNumberIdsContainer {
            phoneNumberIdsDecoded0 = [Swift.String]()
            for string0 in phoneNumberIdsContainer {
                if let string0 = string0 {
                    phoneNumberIdsDecoded0?.append(string0)
                }
            }
        }
        phoneNumberIds = phoneNumberIdsDecoded0
    }
}

public enum BatchDeletePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDeletePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeletePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchDeletePhoneNumberOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchDeletePhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension BatchDeletePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension BatchUpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatePhoneNumberRequestItems = updatePhoneNumberRequestItems {
            var updatePhoneNumberRequestItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updatePhoneNumberRequestItems)
            for updatephonenumberrequestitem0 in updatePhoneNumberRequestItems {
                try updatePhoneNumberRequestItemsContainer.encode(updatephonenumberrequestitem0)
            }
        }
    }
}

extension BatchUpdatePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-update"))
            return items
        }
    }
}

extension BatchUpdatePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-numbers"
    }
}

public struct BatchUpdatePhoneNumberInput: Swift.Equatable {
    /// Lists the phone numbers in the update request.
    /// This member is required.
    public var updatePhoneNumberRequestItems: [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]?

    public init(
        updatePhoneNumberRequestItems: [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]? = nil
    )
    {
        self.updatePhoneNumberRequestItems = updatePhoneNumberRequestItems
    }
}

struct BatchUpdatePhoneNumberInputBody: Swift.Equatable {
    let updatePhoneNumberRequestItems: [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]?
}

extension BatchUpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatePhoneNumberRequestItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem?].self, forKey: .updatePhoneNumberRequestItems)
        var updatePhoneNumberRequestItemsDecoded0:[ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]? = nil
        if let updatePhoneNumberRequestItemsContainer = updatePhoneNumberRequestItemsContainer {
            updatePhoneNumberRequestItemsDecoded0 = [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]()
            for structure0 in updatePhoneNumberRequestItemsContainer {
                if let structure0 = structure0 {
                    updatePhoneNumberRequestItemsDecoded0?.append(structure0)
                }
            }
        }
        updatePhoneNumberRequestItems = updatePhoneNumberRequestItemsDecoded0
    }
}

public enum BatchUpdatePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpdatePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdatePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchUpdatePhoneNumberOutputResponse: Swift.Equatable {
    /// A list of failed phone numbers and their error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchUpdatePhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension BatchUpdatePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension ChimeSDKVoiceClientTypes.CallDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isCaller = "IsCaller"
        case transactionId = "TransactionId"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isCaller = self.isCaller {
            try encodeContainer.encode(isCaller, forKey: .isCaller)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let isCallerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isCaller)
        isCaller = isCallerDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of an Amazon Chime SDK Voice Connector call.
    public struct CallDetails: Swift.Equatable {
        /// Identifies a person as the caller or the callee.
        public var isCaller: Swift.Bool?
        /// The transaction ID of a Voice Connector call.
        public var transactionId: Swift.String?
        /// The Voice Connector ID.
        public var voiceConnectorId: Swift.String?

        public init(
            isCaller: Swift.Bool? = nil,
            transactionId: Swift.String? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.isCaller = isCaller
            self.transactionId = transactionId
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum CallingNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case unassigned
        case updatefailed
        case updateinprogress
        case updatesucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CallingNameStatus] {
            return [
                .unassigned,
                .updatefailed,
                .updateinprogress,
                .updatesucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .unassigned: return "Unassigned"
            case .updatefailed: return "UpdateFailed"
            case .updateinprogress: return "UpdateInProgress"
            case .updatesucceeded: return "UpdateSucceeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CallingNameStatus(rawValue: rawValue) ?? CallingNameStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.CandidateAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case country
        case postalCode
        case postalCodePlus4
        case state
        case streetInfo
        case streetNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let postalCodePlus4 = self.postalCodePlus4 {
            try encodeContainer.encode(postalCodePlus4, forKey: .postalCodePlus4)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetInfo = self.streetInfo {
            try encodeContainer.encode(streetInfo, forKey: .streetInfo)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetInfo)
        streetInfo = streetInfoDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let postalCodePlus4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCodePlus4)
        postalCodePlus4 = postalCodePlus4Decoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
    }
}

extension ChimeSDKVoiceClientTypes.CandidateAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CandidateAddress(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A suggested address.
    public struct CandidateAddress: Swift.Equatable {
        /// The city of the candidate address.
        public var city: Swift.String?
        /// The country of the candidate address.
        public var country: Swift.String?
        /// The postal code of the candidate address.
        public var postalCode: Swift.String?
        /// The zip + 4 or postal code +4 of the candidate address.
        public var postalCodePlus4: Swift.String?
        /// The state of the candidate address.
        public var state: Swift.String?
        /// The street information of the candidate address.
        public var streetInfo: Swift.String?
        /// The numeric portion of the candidate address.
        public var streetNumber: Swift.String?

        public init(
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            state: Swift.String? = nil,
            streetInfo: Swift.String? = nil,
            streetNumber: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.state = state
            self.streetInfo = streetInfo
            self.streetNumber = streetNumber
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum Capability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [Capability] {
            return [
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .voice: return "Voice"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Capability(rawValue: rawValue) ?? Capability.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Multiple instances of the same request were made simultaneously.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreatePhoneNumberOrderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

extension CreatePhoneNumberOrderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number-orders"
    }
}

public struct CreatePhoneNumberOrderInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.productType = productType
    }
}

struct CreatePhoneNumberOrderInputBody: Swift.Equatable {
    let productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
    let e164PhoneNumbers: [Swift.String]?
}

extension CreatePhoneNumberOrderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case productType = "ProductType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

public enum CreatePhoneNumberOrderOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePhoneNumberOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePhoneNumberOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct CreatePhoneNumberOrderOutputResponse: Swift.Equatable {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?

    public init(
        phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct CreatePhoneNumberOrderOutputResponseBody: Swift.Equatable {
    let phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?
}

extension CreatePhoneNumberOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

extension CreateProxySessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProxySessionInput(capabilities: \(Swift.String(describing: capabilities)), expiryMinutes: \(Swift.String(describing: expiryMinutes)), geoMatchLevel: \(Swift.String(describing: geoMatchLevel)), geoMatchParams: \(Swift.String(describing: geoMatchParams)), numberSelectionBehavior: \(Swift.String(describing: numberSelectionBehavior)), participantPhoneNumbers: \(Swift.String(describing: participantPhoneNumbers)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), name: \"CONTENT_REDACTED\")"}
}

extension CreateProxySessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = self.geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = self.geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = self.numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participantPhoneNumbers = participantPhoneNumbers {
            var participantPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participantPhoneNumbers)
            for e164phonenumber0 in participantPhoneNumbers {
                try participantPhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension CreateProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

public struct CreateProxySessionInput: Swift.Equatable {
    /// The proxy session's capabilities.
    /// This member is required.
    public var capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
    public var geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel?
    /// The country and area code for the proxy phone number.
    public var geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams?
    /// The name of the proxy session.
    public var name: Swift.String?
    /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
    public var numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior?
    /// The participant phone numbers.
    /// This member is required.
    public var participantPhoneNumbers: [Swift.String]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        capabilities: [ChimeSDKVoiceClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel? = nil,
        geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams? = nil,
        name: Swift.String? = nil,
        numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior? = nil,
        participantPhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.geoMatchLevel = geoMatchLevel
        self.geoMatchParams = geoMatchParams
        self.name = name
        self.numberSelectionBehavior = numberSelectionBehavior
        self.participantPhoneNumbers = participantPhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct CreateProxySessionInputBody: Swift.Equatable {
    let participantPhoneNumbers: [Swift.String]?
    let name: Swift.String?
    let expiryMinutes: Swift.Int?
    let capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    let numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior?
    let geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel?
    let geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams?
}

extension CreateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantPhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .participantPhoneNumbers)
        var participantPhoneNumbersDecoded0:[Swift.String]? = nil
        if let participantPhoneNumbersContainer = participantPhoneNumbersContainer {
            participantPhoneNumbersDecoded0 = [Swift.String]()
            for string0 in participantPhoneNumbersContainer {
                if let string0 = string0 {
                    participantPhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        participantPhoneNumbers = participantPhoneNumbersDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeSDKVoiceClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeSDKVoiceClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

public enum CreateProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProxySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct CreateProxySessionOutputResponse: Swift.Equatable {
    /// The proxy session details.
    public var proxySession: ChimeSDKVoiceClientTypes.ProxySession?

    public init(
        proxySession: ChimeSDKVoiceClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct CreateProxySessionOutputResponseBody: Swift.Equatable {
    let proxySession: ChimeSDKVoiceClientTypes.ProxySession?
}

extension CreateProxySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

extension CreateSipMediaApplicationCallInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipMediaApplicationCallInput(argumentsMap: \(Swift.String(describing: argumentsMap)), sipHeaders: \(Swift.String(describing: sipHeaders)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), fromPhoneNumber: \"CONTENT_REDACTED\", toPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension CreateSipMediaApplicationCallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case argumentsMap = "ArgumentsMap"
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let argumentsMap = argumentsMap {
            var argumentsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .argumentsMap)
            for (dictKey0, smaCreateCallArgumentsMap0) in argumentsMap {
                try argumentsMapContainer.encode(smaCreateCallArgumentsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let fromPhoneNumber = self.fromPhoneNumber {
            try encodeContainer.encode(fromPhoneNumber, forKey: .fromPhoneNumber)
        }
        if let sipHeaders = sipHeaders {
            var sipHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sipHeaders)
            for (dictKey0, sipHeadersMap0) in sipHeaders {
                try sipHeadersContainer.encode(sipHeadersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let toPhoneNumber = self.toPhoneNumber {
            try encodeContainer.encode(toPhoneNumber, forKey: .toPhoneNumber)
        }
    }
}

extension CreateSipMediaApplicationCallInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls"
    }
}

public struct CreateSipMediaApplicationCallInput: Swift.Equatable {
    /// Context passed to a CreateSipMediaApplication API call. For example, you could pass key-value pairs such as: "FirstName": "John", "LastName": "Doe"
    public var argumentsMap: [Swift.String:Swift.String]?
    /// The phone number that a user calls from. This is a phone number in your Amazon Chime SDK phone number inventory.
    /// This member is required.
    public var fromPhoneNumber: Swift.String?
    /// The SIP headers added to an outbound call leg.
    public var sipHeaders: [Swift.String:Swift.String]?
    /// The ID of the SIP media application.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The phone number that the service should call.
    /// This member is required.
    public var toPhoneNumber: Swift.String?

    public init(
        argumentsMap: [Swift.String:Swift.String]? = nil,
        fromPhoneNumber: Swift.String? = nil,
        sipHeaders: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        toPhoneNumber: Swift.String? = nil
    )
    {
        self.argumentsMap = argumentsMap
        self.fromPhoneNumber = fromPhoneNumber
        self.sipHeaders = sipHeaders
        self.sipMediaApplicationId = sipMediaApplicationId
        self.toPhoneNumber = toPhoneNumber
    }
}

struct CreateSipMediaApplicationCallInputBody: Swift.Equatable {
    let fromPhoneNumber: Swift.String?
    let toPhoneNumber: Swift.String?
    let sipHeaders: [Swift.String:Swift.String]?
    let argumentsMap: [Swift.String:Swift.String]?
}

extension CreateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case argumentsMap = "ArgumentsMap"
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPhoneNumber)
        fromPhoneNumber = fromPhoneNumberDecoded
        let toPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPhoneNumber)
        toPhoneNumber = toPhoneNumberDecoded
        let sipHeadersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sipHeaders)
        var sipHeadersDecoded0: [Swift.String:Swift.String]? = nil
        if let sipHeadersContainer = sipHeadersContainer {
            sipHeadersDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in sipHeadersContainer {
                if let sensitivestring0 = sensitivestring0 {
                    sipHeadersDecoded0?[key0] = sensitivestring0
                }
            }
        }
        sipHeaders = sipHeadersDecoded0
        let argumentsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .argumentsMap)
        var argumentsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let argumentsMapContainer = argumentsMapContainer {
            argumentsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in argumentsMapContainer {
                if let sensitivestring0 = sensitivestring0 {
                    argumentsMapDecoded0?[key0] = sensitivestring0
                }
            }
        }
        argumentsMap = argumentsMapDecoded0
    }
}

public enum CreateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSipMediaApplicationCallOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSipMediaApplicationCallOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct CreateSipMediaApplicationCallOutputResponse: Swift.Equatable {
    /// The actual call.
    public var sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?

    public init(
        sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct CreateSipMediaApplicationCallOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?
}

extension CreateSipMediaApplicationCallOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

extension CreateSipMediaApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-media-applications"
    }
}

public struct CreateSipMediaApplicationInput: Swift.Equatable {
    /// The AWS Region assigned to the SIP media application.
    /// This member is required.
    public var awsRegion: Swift.String?
    /// List of endpoints (Lambda ARNs) specified for the SIP media application.
    /// This member is required.
    public var endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
    /// The SIP media application's name.
    /// This member is required.
    public var name: Swift.String?
    /// The tags assigned to the SIP media application.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        awsRegion: Swift.String? = nil,
        endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil,
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.awsRegion = awsRegion
        self.endpoints = endpoints
        self.name = name
        self.tags = tags
    }
}

struct CreateSipMediaApplicationInputBody: Swift.Equatable {
    let awsRegion: Swift.String?
    let name: Swift.String?
    let endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension CreateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum CreateSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSipMediaApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct CreateSipMediaApplicationOutputResponse: Swift.Equatable {
    /// The SIP media application details.
    public var sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct CreateSipMediaApplicationOutputResponseBody: Swift.Equatable {
    let sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?
}

extension CreateSipMediaApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

extension CreateSipRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = self.triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
    }
}

extension CreateSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-rules"
    }
}

public struct CreateSipRuleInput: Swift.Equatable {
    /// Disables or enables a SIP rule. You must disable SIP rules before you can delete them.
    public var disabled: Swift.Bool?
    /// The name of the SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// List of SIP media applications, with priority and AWS Region. Only one SIP application per AWS Region can be used.
    public var targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
    /// The type of trigger assigned to the SIP rule in TriggerValue, currently RequestUriHostname or ToPhoneNumber.
    /// This member is required.
    public var triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType?
    /// If TriggerType is RequestUriHostname, the value can be the outbound host name of a Voice Connector. If TriggerType is ToPhoneNumber, the value can be a customer-owned phone number in the E164 format. The SipMediaApplication specified in the SipRule is triggered if the request URI in an incoming SIP request matches the RequestUriHostname, or if the To header in the incoming SIP request matches the ToPhoneNumber value.
    /// This member is required.
    public var triggerValue: Swift.String?

    public init(
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil,
        triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType? = nil,
        triggerValue: Swift.String? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.targetApplications = targetApplications
        self.triggerType = triggerType
        self.triggerValue = triggerValue
    }
}

struct CreateSipRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType?
    let triggerValue: Swift.String?
    let disabled: Swift.Bool?
    let targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
}

extension CreateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

public enum CreateSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSipRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct CreateSipRuleOutputResponse: Swift.Equatable {
    /// The SIP rule information, including the rule ID, triggers, and target applications.
    public var sipRule: ChimeSDKVoiceClientTypes.SipRule?

    public init(
        sipRule: ChimeSDKVoiceClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct CreateSipRuleOutputResponseBody: Swift.Equatable {
    let sipRule: ChimeSDKVoiceClientTypes.SipRule?
}

extension CreateSipRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

extension CreateVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }
}

extension CreateVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connector-groups"
    }
}

public struct CreateVoiceConnectorGroupInput: Swift.Equatable {
    /// The name of the Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// Lists the Voice Connectors that inbound calls are routed to.
    public var voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?

    public init(
        name: Swift.String? = nil,
        voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct CreateVoiceConnectorGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?
}

extension CreateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

public enum CreateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct CreateVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// The details of the Voice Connector group.
    public var voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct CreateVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?
}

extension CreateVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

extension CreateVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connectors"
    }
}

public struct CreateVoiceConnectorInput: Swift.Equatable {
    /// The AWS Region in which the Amazon Chime SDK Voice Connector is created. Default value: us-east-1 .
    public var awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?
    /// The name of the Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// Enables or disables encryption for the Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?
    /// The tags assigned to the Voice Connector.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion? = nil,
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil,
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.awsRegion = awsRegion
        self.name = name
        self.requireEncryption = requireEncryption
        self.tags = tags
    }
}

struct CreateVoiceConnectorInputBody: Swift.Equatable {
    let name: Swift.String?
    let awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?
    let requireEncryption: Swift.Bool?
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension CreateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum CreateVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct CreateVoiceConnectorOutputResponse: Swift.Equatable {
    /// The details of the Voice Connector.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct CreateVoiceConnectorOutputResponseBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?
}

extension CreateVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension CreateVoiceProfileDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateVoiceProfileDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-profile-domains"
    }
}

public struct CreateVoiceProfileDomainInput: Swift.Equatable {
    /// The unique identifier for the client request. Use a different token for different domain creation requests.
    public var clientRequestToken: Swift.String?
    /// A description of the voice profile domain.
    public var description: Swift.String?
    /// The name of the voice profile domain.
    /// This member is required.
    public var name: Swift.String?
    /// The server-side encryption configuration for the request.
    /// This member is required.
    public var serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration?
    /// The tags assigned to the domain.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
    }
}

struct CreateVoiceProfileDomainInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension CreateVoiceProfileDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum CreateVoiceProfileDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceProfileDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceProfileDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfileDomain = output.voiceProfileDomain
        } else {
            self.voiceProfileDomain = nil
        }
    }
}

public struct CreateVoiceProfileDomainOutputResponse: Swift.Equatable {
    /// The requested voice profile domain.
    public var voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?

    public init(
        voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain? = nil
    )
    {
        self.voiceProfileDomain = voiceProfileDomain
    }
}

struct CreateVoiceProfileDomainOutputResponseBody: Swift.Equatable {
    let voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?
}

extension CreateVoiceProfileDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfileDomain = "VoiceProfileDomain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfileDomain.self, forKey: .voiceProfileDomain)
        voiceProfileDomain = voiceProfileDomainDecoded
    }
}

extension CreateVoiceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTaskId = "SpeakerSearchTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let speakerSearchTaskId = self.speakerSearchTaskId {
            try encodeContainer.encode(speakerSearchTaskId, forKey: .speakerSearchTaskId)
        }
    }
}

extension CreateVoiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-profiles"
    }
}

public struct CreateVoiceProfileInput: Swift.Equatable {
    /// The ID of the speaker search task.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?

    public init(
        speakerSearchTaskId: Swift.String? = nil
    )
    {
        self.speakerSearchTaskId = speakerSearchTaskId
    }
}

struct CreateVoiceProfileInputBody: Swift.Equatable {
    let speakerSearchTaskId: Swift.String?
}

extension CreateVoiceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTaskId = "SpeakerSearchTaskId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerSearchTaskId)
        speakerSearchTaskId = speakerSearchTaskIdDecoded
    }
}

public enum CreateVoiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GoneException": return try await GoneException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVoiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVoiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfile = output.voiceProfile
        } else {
            self.voiceProfile = nil
        }
    }
}

public struct CreateVoiceProfileOutputResponse: Swift.Equatable {
    /// The requested voice profile.
    public var voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?

    public init(
        voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile? = nil
    )
    {
        self.voiceProfile = voiceProfile
    }
}

struct CreateVoiceProfileOutputResponseBody: Swift.Equatable {
    let voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?
}

extension CreateVoiceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfile = "VoiceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfile.self, forKey: .voiceProfile)
        voiceProfile = voiceProfileDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Credential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Credential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credential(password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The SIP credentials used to authenticate requests to an Amazon Chime SDK Voice Connector.
    public struct Credential: Swift.Equatable {
        /// The RFC2617 compliant password associated with the SIP credentials, in US-ASCII format.
        public var password: Swift.String?
        /// The RFC2617 compliant user name associated with the SIP credentials, in US-ASCII format.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingCountry = "CallingCountry"
        case emergencyPhoneNumber = "EmergencyPhoneNumber"
        case testPhoneNumber = "TestPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingCountry = self.callingCountry {
            try encodeContainer.encode(callingCountry, forKey: .callingCountry)
        }
        if let emergencyPhoneNumber = self.emergencyPhoneNumber {
            try encodeContainer.encode(emergencyPhoneNumber, forKey: .emergencyPhoneNumber)
        }
        if let testPhoneNumber = self.testPhoneNumber {
            try encodeContainer.encode(testPhoneNumber, forKey: .testPhoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emergencyPhoneNumber)
        emergencyPhoneNumber = emergencyPhoneNumberDecoded
        let testPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testPhoneNumber)
        testPhoneNumber = testPhoneNumberDecoded
        let callingCountryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingCountry)
        callingCountry = callingCountryDecoded
    }
}

extension ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DNISEmergencyCallingConfiguration(callingCountry: \(Swift.String(describing: callingCountry)), emergencyPhoneNumber: \"CONTENT_REDACTED\", testPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The Dialed Number Identification Service (DNIS) emergency calling configuration details associated with an Amazon Chime SDK Voice Connector's emergency calling configuration.
    public struct DNISEmergencyCallingConfiguration: Swift.Equatable {
        /// The country from which emergency calls are allowed, in ISO 3166-1 alpha-2 format.
        /// This member is required.
        public var callingCountry: Swift.String?
        /// The DNIS phone number that you route emergency calls to, in E.164 format.
        /// This member is required.
        public var emergencyPhoneNumber: Swift.String?
        /// The DNIS phone number for routing test emergency calls to, in E.164 format.
        public var testPhoneNumber: Swift.String?

        public init(
            callingCountry: Swift.String? = nil,
            emergencyPhoneNumber: Swift.String? = nil,
            testPhoneNumber: Swift.String? = nil
        )
        {
            self.callingCountry = callingCountry
            self.emergencyPhoneNumber = emergencyPhoneNumber
            self.testPhoneNumber = testPhoneNumber
        }
    }

}

extension DeletePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePhoneNumberInput(phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension DeletePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct DeletePhoneNumberInput: Swift.Equatable {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct DeletePhoneNumberInputBody: Swift.Equatable {
}

extension DeletePhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeletePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePhoneNumberOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct DeleteProxySessionInput: Swift.Equatable {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteProxySessionInputBody: Swift.Equatable {
}

extension DeleteProxySessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProxySessionOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct DeleteSipMediaApplicationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct DeleteSipMediaApplicationInputBody: Swift.Equatable {
}

extension DeleteSipMediaApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSipMediaApplicationOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipRuleId = sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct DeleteSipRuleInput: Swift.Equatable {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init(
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct DeleteSipRuleInputBody: Swift.Equatable {
}

extension DeleteSipRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSipRuleOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceConnectorGroupInput: Swift.Equatable {
    /// The Voice Connector Group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DeleteVoiceConnectorGroupInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorGroupOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceConnectorInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOriginationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct DeleteVoiceConnectorOriginationInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorOriginationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorOriginationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorOriginationOutputResponse: Swift.Equatable {

    public init() { }
}

public enum DeleteVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteVoiceConnectorProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct DeleteVoiceConnectorProxyInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorProxyInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorProxyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorProxyOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteVoiceConnectorStreamingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorStreamingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usernames = usernames {
            var usernamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usernames)
            for sensitivestring0 in usernames {
                try usernamesContainer.encode(sensitivestring0)
            }
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "delete"))
            return items
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// The RFC2617 compliant username associated with the SIP credentials, in US-ASCII format.
    /// This member is required.
    public var usernames: [Swift.String]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        usernames: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.usernames = usernames
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
    let usernames: [Swift.String]?
}

extension DeleteVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

public enum DeleteVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteVoiceConnectorTerminationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct DeleteVoiceConnectorTerminationInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceConnectorTerminationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceConnectorTerminationOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteVoiceProfileDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceProfileDomainId = voiceProfileDomainId else {
            return nil
        }
        return "/voice-profile-domains/\(voiceProfileDomainId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceProfileDomainInput: Swift.Equatable {
    /// The voice profile domain ID.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct DeleteVoiceProfileDomainInputBody: Swift.Equatable {
}

extension DeleteVoiceProfileDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteVoiceProfileDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceProfileDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceProfileDomainOutputResponse: Swift.Equatable {

    public init() { }
}

extension DeleteVoiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceProfileId = voiceProfileId else {
            return nil
        }
        return "/voice-profiles/\(voiceProfileId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceProfileInput: Swift.Equatable {
    /// The voice profile ID.
    /// This member is required.
    public var voiceProfileId: Swift.String?

    public init(
        voiceProfileId: Swift.String? = nil
    )
    {
        self.voiceProfileId = voiceProfileId
    }
}

struct DeleteVoiceProfileInputBody: Swift.Equatable {
}

extension DeleteVoiceProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteVoiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVoiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVoiceProfileOutputResponse: Swift.Equatable {

    public init() { }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
            return items
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.Equatable {
    /// The list of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

public enum DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
            return items
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.Equatable {
    /// List of phone numbers, in E.164 format.
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

public enum DisassociatePhoneNumbersFromVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociatePhoneNumbersFromVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorOutputResponse: Swift.Equatable {
    /// If the action fails for one or more of the phone numbers in the request, a list of the phone numbers is returned, along with error codes and error messages.
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init(
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnis = "DNIS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnis = dnis {
            var dnisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnis)
            for dnisemergencycallingconfiguration0 in dnis {
                try dnisContainer.encode(dnisemergencycallingconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnisContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration?].self, forKey: .dnis)
        var dnisDecoded0:[ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]? = nil
        if let dnisContainer = dnisContainer {
            dnisDecoded0 = [ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]()
            for structure0 in dnisContainer {
                if let structure0 = structure0 {
                    dnisDecoded0?.append(structure0)
                }
            }
        }
        dnis = dnisDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The emergency calling configuration details associated with an Amazon Chime SDK Voice Connector.
    public struct EmergencyCallingConfiguration: Swift.Equatable {
        /// The Dialed Number Identification Service (DNIS) emergency calling configuration details.
        public var dnis: [ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]?

        public init(
            dnis: [ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]? = nil
        )
        {
            self.dnis = dnis
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case gone
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .gone,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .gone: return "Gone"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum GeoMatchLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case areacode
        case country
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoMatchLevel] {
            return [
                .areacode,
                .country,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .areacode: return "AreaCode"
            case .country: return "Country"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoMatchLevel(rawValue: rawValue) ?? GeoMatchLevel.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.GeoMatchParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaCode = "AreaCode"
        case country = "Country"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaCode = self.areaCode {
            try encodeContainer.encode(areaCode, forKey: .areaCode)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let areaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .areaCode)
        areaCode = areaCodeDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The country and area code for a proxy phone number in a proxy phone session.
    public struct GeoMatchParams: Swift.Equatable {
        /// The area code.
        /// This member is required.
        public var areaCode: Swift.String?
        /// The country.
        /// This member is required.
        public var country: Swift.String?

        public init(
            areaCode: Swift.String? = nil,
            country: Swift.String? = nil
        )
        {
            self.areaCode = areaCode
            self.country = country
        }
    }

}

extension GetGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings"
    }
}

public struct GetGlobalSettingsInput: Swift.Equatable {

    public init() { }
}

struct GetGlobalSettingsInputBody: Swift.Equatable {
}

extension GetGlobalSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGlobalSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct GetGlobalSettingsOutputResponse: Swift.Equatable {
    /// The Voice Connector settings.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct GetGlobalSettingsOutputResponseBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?
}

extension GetGlobalSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension GetPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberInput(phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension GetPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct GetPhoneNumberInput: Swift.Equatable {
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct GetPhoneNumberInputBody: Swift.Equatable {
}

extension GetPhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberOrderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberOrderId = phoneNumberOrderId else {
            return nil
        }
        return "/phone-number-orders/\(phoneNumberOrderId.urlPercentEncoding())"
    }
}

public struct GetPhoneNumberOrderInput: Swift.Equatable {
    /// The ID of the phone number order .
    /// This member is required.
    public var phoneNumberOrderId: Swift.String?

    public init(
        phoneNumberOrderId: Swift.String? = nil
    )
    {
        self.phoneNumberOrderId = phoneNumberOrderId
    }
}

struct GetPhoneNumberOrderInputBody: Swift.Equatable {
}

extension GetPhoneNumberOrderInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetPhoneNumberOrderOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPhoneNumberOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPhoneNumberOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct GetPhoneNumberOrderOutputResponse: Swift.Equatable {
    /// The phone number order details.
    public var phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?

    public init(
        phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct GetPhoneNumberOrderOutputResponseBody: Swift.Equatable {
    let phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?
}

extension GetPhoneNumberOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

public enum GetPhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct GetPhoneNumberOutputResponse: Swift.Equatable {
    /// The phone number details.
    public var phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct GetPhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?
}

extension GetPhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension GetPhoneNumberSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings/phone-number"
    }
}

public struct GetPhoneNumberSettingsInput: Swift.Equatable {

    public init() { }
}

struct GetPhoneNumberSettingsInputBody: Swift.Equatable {
}

extension GetPhoneNumberSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetPhoneNumberSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPhoneNumberSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberSettingsOutputResponse(callingNameUpdatedTimestamp: \(Swift.String(describing: callingNameUpdatedTimestamp)), callingName: \"CONTENT_REDACTED\")"}
}

extension GetPhoneNumberSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPhoneNumberSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.callingName = output.callingName
            self.callingNameUpdatedTimestamp = output.callingNameUpdatedTimestamp
        } else {
            self.callingName = nil
            self.callingNameUpdatedTimestamp = nil
        }
    }
}

public struct GetPhoneNumberSettingsOutputResponse: Swift.Equatable {
    /// The default outbound calling name for the account.
    public var callingName: Swift.String?
    /// The updated outbound calling name timestamp, in ISO 8601 format.
    public var callingNameUpdatedTimestamp: ClientRuntime.Date?

    public init(
        callingName: Swift.String? = nil,
        callingNameUpdatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.callingName = callingName
        self.callingNameUpdatedTimestamp = callingNameUpdatedTimestamp
    }
}

struct GetPhoneNumberSettingsOutputResponseBody: Swift.Equatable {
    let callingName: Swift.String?
    let callingNameUpdatedTimestamp: ClientRuntime.Date?
}

extension GetPhoneNumberSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case callingNameUpdatedTimestamp = "CallingNameUpdatedTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .callingNameUpdatedTimestamp)
        callingNameUpdatedTimestamp = callingNameUpdatedTimestampDecoded
    }
}

extension GetProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct GetProxySessionInput: Swift.Equatable {
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetProxySessionInputBody: Swift.Equatable {
}

extension GetProxySessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProxySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct GetProxySessionOutputResponse: Swift.Equatable {
    /// The proxy session details.
    public var proxySession: ChimeSDKVoiceClientTypes.ProxySession?

    public init(
        proxySession: ChimeSDKVoiceClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct GetProxySessionOutputResponseBody: Swift.Equatable {
    let proxySession: ChimeSDKVoiceClientTypes.ProxySession?
}

extension GetProxySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

extension GetSipMediaApplicationAlexaSkillConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/alexa-skill-configuration"
    }
}

public struct GetSipMediaApplicationAlexaSkillConfigurationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetSipMediaApplicationAlexaSkillConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipMediaApplicationAlexaSkillConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipMediaApplicationAlexaSkillConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationAlexaSkillConfiguration = output.sipMediaApplicationAlexaSkillConfiguration
        } else {
            self.sipMediaApplicationAlexaSkillConfiguration = nil
        }
    }
}

public struct GetSipMediaApplicationAlexaSkillConfigurationOutputResponse: Swift.Equatable {
    /// Returns the Alexa Skill configuration.
    public var sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?

    public init(
        sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration? = nil
    )
    {
        self.sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfiguration
    }
}

struct GetSipMediaApplicationAlexaSkillConfigurationOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
}

extension GetSipMediaApplicationAlexaSkillConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationAlexaSkillConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration.self, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfigurationDecoded
    }
}

extension GetSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct GetSipMediaApplicationInput: Swift.Equatable {
    /// The SIP media application ID .
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

public struct GetSipMediaApplicationLoggingConfigurationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationLoggingConfigurationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipMediaApplicationLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipMediaApplicationLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct GetSipMediaApplicationLoggingConfigurationOutputResponse: Swift.Equatable {
    /// The actual logging configuration.
    public var sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct GetSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension GetSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

public enum GetSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipMediaApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct GetSipMediaApplicationOutputResponse: Swift.Equatable {
    /// The details of the SIP media application.
    public var sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct GetSipMediaApplicationOutputResponseBody: Swift.Equatable {
    let sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?
}

extension GetSipMediaApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

extension GetSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipRuleId = sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct GetSipRuleInput: Swift.Equatable {
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init(
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct GetSipRuleInputBody: Swift.Equatable {
}

extension GetSipRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSipRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct GetSipRuleOutputResponse: Swift.Equatable {
    /// The SIP rule details.
    public var sipRule: ChimeSDKVoiceClientTypes.SipRule?

    public init(
        sipRule: ChimeSDKVoiceClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct GetSipRuleOutputResponseBody: Swift.Equatable {
    let sipRule: ChimeSDKVoiceClientTypes.SipRule?
}

extension GetSipRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

extension GetSpeakerSearchTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let speakerSearchTaskId = speakerSearchTaskId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/speaker-search-tasks/\(speakerSearchTaskId.urlPercentEncoding())"
    }
}

public struct GetSpeakerSearchTaskInput: Swift.Equatable {
    /// The ID of the speaker search task.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        speakerSearchTaskId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.speakerSearchTaskId = speakerSearchTaskId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetSpeakerSearchTaskInputBody: Swift.Equatable {
}

extension GetSpeakerSearchTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetSpeakerSearchTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSpeakerSearchTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSpeakerSearchTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.speakerSearchTask = output.speakerSearchTask
        } else {
            self.speakerSearchTask = nil
        }
    }
}

public struct GetSpeakerSearchTaskOutputResponse: Swift.Equatable {
    /// The details of the speaker search task.
    public var speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask?

    public init(
        speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask? = nil
    )
    {
        self.speakerSearchTask = speakerSearchTask
    }
}

struct GetSpeakerSearchTaskOutputResponseBody: Swift.Equatable {
    let speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask?
}

extension GetSpeakerSearchTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTask = "SpeakerSearchTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SpeakerSearchTask.self, forKey: .speakerSearchTask)
        speakerSearchTask = speakerSearchTaskDecoded
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorEmergencyCallingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.Equatable {
    /// The details of the emergency calling configuration.
    public var emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?

    public init(
        emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Equatable {
    let emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

extension GetVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct GetVoiceConnectorGroupInput: Swift.Equatable {
    /// The Voice Connector group ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init(
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct GetVoiceConnectorGroupInputBody: Swift.Equatable {
}

extension GetVoiceConnectorGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct GetVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// The details of the Voice Connector group.
    public var voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct GetVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?
}

extension GetVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

extension GetVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct GetVoiceConnectorInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorInputBody: Swift.Equatable {
}

extension GetVoiceConnectorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

public struct GetVoiceConnectorLoggingConfigurationInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorLoggingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorLoggingConfigurationOutputResponse: Swift.Equatable {
    /// The logging configuration details .
    public var loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?

    public init(
        loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct GetVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
}

extension GetVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension GetVoiceConnectorOriginationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct GetVoiceConnectorOriginationInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorOriginationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorOriginationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorOriginationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct GetVoiceConnectorOriginationOutputResponse: Swift.Equatable {
    /// The origination setting details.
    public var origination: ChimeSDKVoiceClientTypes.Origination?

    public init(
        origination: ChimeSDKVoiceClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct GetVoiceConnectorOriginationOutputResponseBody: Swift.Equatable {
    let origination: ChimeSDKVoiceClientTypes.Origination?
}

extension GetVoiceConnectorOriginationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

public enum GetVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct GetVoiceConnectorOutputResponse: Swift.Equatable {
    /// The Voice Connector details.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct GetVoiceConnectorOutputResponseBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?
}

extension GetVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension GetVoiceConnectorProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct GetVoiceConnectorProxyInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorProxyInputBody: Swift.Equatable {
}

extension GetVoiceConnectorProxyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct GetVoiceConnectorProxyOutputResponse: Swift.Equatable {
    /// The proxy configuration details.
    public var proxy: ChimeSDKVoiceClientTypes.Proxy?

    public init(
        proxy: ChimeSDKVoiceClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct GetVoiceConnectorProxyOutputResponseBody: Swift.Equatable {
    let proxy: ChimeSDKVoiceClientTypes.Proxy?
}

extension GetVoiceConnectorProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

extension GetVoiceConnectorStreamingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct GetVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorStreamingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorStreamingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorStreamingConfigurationOutputResponse: Swift.Equatable {
    /// The details of the streaming configuration.
    public var streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?

    public init(
        streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct GetVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Equatable {
    let streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
}

extension GetVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension GetVoiceConnectorTerminationHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/health"
    }
}

public struct GetVoiceConnectorTerminationHealthInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationHealthInputBody: Swift.Equatable {
}

extension GetVoiceConnectorTerminationHealthInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceConnectorTerminationHealthOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorTerminationHealthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorTerminationHealthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.terminationHealth = output.terminationHealth
        } else {
            self.terminationHealth = nil
        }
    }
}

public struct GetVoiceConnectorTerminationHealthOutputResponse: Swift.Equatable {
    /// The termination health details.
    public var terminationHealth: ChimeSDKVoiceClientTypes.TerminationHealth?

    public init(
        terminationHealth: ChimeSDKVoiceClientTypes.TerminationHealth? = nil
    )
    {
        self.terminationHealth = terminationHealth
    }
}

struct GetVoiceConnectorTerminationHealthOutputResponseBody: Swift.Equatable {
    let terminationHealth: ChimeSDKVoiceClientTypes.TerminationHealth?
}

extension GetVoiceConnectorTerminationHealthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminationHealth = "TerminationHealth"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationHealthDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.TerminationHealth.self, forKey: .terminationHealth)
        terminationHealth = terminationHealthDecoded
    }
}

extension GetVoiceConnectorTerminationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct GetVoiceConnectorTerminationInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceConnectorTerminationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceConnectorTerminationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct GetVoiceConnectorTerminationOutputResponse: Swift.Equatable {
    /// The termination setting details.
    public var termination: ChimeSDKVoiceClientTypes.Termination?

    public init(
        termination: ChimeSDKVoiceClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct GetVoiceConnectorTerminationOutputResponseBody: Swift.Equatable {
    let termination: ChimeSDKVoiceClientTypes.Termination?
}

extension GetVoiceConnectorTerminationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension GetVoiceProfileDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceProfileDomainId = voiceProfileDomainId else {
            return nil
        }
        return "/voice-profile-domains/\(voiceProfileDomainId.urlPercentEncoding())"
    }
}

public struct GetVoiceProfileDomainInput: Swift.Equatable {
    /// The voice profile domain ID.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct GetVoiceProfileDomainInputBody: Swift.Equatable {
}

extension GetVoiceProfileDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceProfileDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceProfileDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceProfileDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfileDomain = output.voiceProfileDomain
        } else {
            self.voiceProfileDomain = nil
        }
    }
}

public struct GetVoiceProfileDomainOutputResponse: Swift.Equatable {
    /// The details of the voice profile domain.
    public var voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?

    public init(
        voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain? = nil
    )
    {
        self.voiceProfileDomain = voiceProfileDomain
    }
}

struct GetVoiceProfileDomainOutputResponseBody: Swift.Equatable {
    let voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?
}

extension GetVoiceProfileDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfileDomain = "VoiceProfileDomain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfileDomain.self, forKey: .voiceProfileDomain)
        voiceProfileDomain = voiceProfileDomainDecoded
    }
}

extension GetVoiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceProfileId = voiceProfileId else {
            return nil
        }
        return "/voice-profiles/\(voiceProfileId.urlPercentEncoding())"
    }
}

public struct GetVoiceProfileInput: Swift.Equatable {
    /// The voice profile ID.
    /// This member is required.
    public var voiceProfileId: Swift.String?

    public init(
        voiceProfileId: Swift.String? = nil
    )
    {
        self.voiceProfileId = voiceProfileId
    }
}

struct GetVoiceProfileInputBody: Swift.Equatable {
}

extension GetVoiceProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfile = output.voiceProfile
        } else {
            self.voiceProfile = nil
        }
    }
}

public struct GetVoiceProfileOutputResponse: Swift.Equatable {
    /// The voice profile details.
    public var voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?

    public init(
        voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile? = nil
    )
    {
        self.voiceProfile = voiceProfile
    }
}

struct GetVoiceProfileOutputResponseBody: Swift.Equatable {
    let voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?
}

extension GetVoiceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfile = "VoiceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfile.self, forKey: .voiceProfile)
        voiceProfile = voiceProfileDecoded
    }
}

extension GetVoiceToneAnalysisTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let isCaller = isCaller else {
                let message = "Creating a URL Query Item failed. isCaller is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let isCallerQueryItem = ClientRuntime.URLQueryItem(name: "isCaller".urlPercentEncoding(), value: Swift.String(isCaller).urlPercentEncoding())
            items.append(isCallerQueryItem)
            return items
        }
    }
}

extension GetVoiceToneAnalysisTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let voiceToneAnalysisTaskId = voiceToneAnalysisTaskId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/voice-tone-analysis-tasks/\(voiceToneAnalysisTaskId.urlPercentEncoding())"
    }
}

public struct GetVoiceToneAnalysisTaskInput: Swift.Equatable {
    /// Specifies whether the voice being analyzed is the caller (originator) or the callee (responder).
    /// This member is required.
    public var isCaller: Swift.Bool?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?
    /// The ID of the voice tone anlysis task.
    /// This member is required.
    public var voiceToneAnalysisTaskId: Swift.String?

    public init(
        isCaller: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil,
        voiceToneAnalysisTaskId: Swift.String? = nil
    )
    {
        self.isCaller = isCaller
        self.voiceConnectorId = voiceConnectorId
        self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
    }
}

struct GetVoiceToneAnalysisTaskInputBody: Swift.Equatable {
}

extension GetVoiceToneAnalysisTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum GetVoiceToneAnalysisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVoiceToneAnalysisTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVoiceToneAnalysisTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceToneAnalysisTask = output.voiceToneAnalysisTask
        } else {
            self.voiceToneAnalysisTask = nil
        }
    }
}

public struct GetVoiceToneAnalysisTaskOutputResponse: Swift.Equatable {
    /// The details of the voice tone analysis task.
    public var voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask?

    public init(
        voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask? = nil
    )
    {
        self.voiceToneAnalysisTask = voiceToneAnalysisTask
    }
}

struct GetVoiceToneAnalysisTaskOutputResponseBody: Swift.Equatable {
    let voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask?
}

extension GetVoiceToneAnalysisTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceToneAnalysisTask = "VoiceToneAnalysisTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceToneAnalysisTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask.self, forKey: .voiceToneAnalysisTask)
        voiceToneAnalysisTask = voiceToneAnalysisTaskDecoded
    }
}

extension GoneException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GoneExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access to the target resource is no longer available at the origin server. This condition is likely to be permanent.
public struct GoneException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GoneException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct GoneExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension GoneExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ListAvailableVoiceConnectorRegionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connector-regions"
    }
}

public struct ListAvailableVoiceConnectorRegionsInput: Swift.Equatable {

    public init() { }
}

struct ListAvailableVoiceConnectorRegionsInputBody: Swift.Equatable {
}

extension ListAvailableVoiceConnectorRegionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListAvailableVoiceConnectorRegionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAvailableVoiceConnectorRegionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAvailableVoiceConnectorRegionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorRegions = output.voiceConnectorRegions
        } else {
            self.voiceConnectorRegions = nil
        }
    }
}

public struct ListAvailableVoiceConnectorRegionsOutputResponse: Swift.Equatable {
    /// The list of AWS Regions.
    public var voiceConnectorRegions: [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]?

    public init(
        voiceConnectorRegions: [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]? = nil
    )
    {
        self.voiceConnectorRegions = voiceConnectorRegions
    }
}

struct ListAvailableVoiceConnectorRegionsOutputResponseBody: Swift.Equatable {
    let voiceConnectorRegions: [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]?
}

extension ListAvailableVoiceConnectorRegionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorRegions = "VoiceConnectorRegions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorRegionsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?].self, forKey: .voiceConnectorRegions)
        var voiceConnectorRegionsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]? = nil
        if let voiceConnectorRegionsContainer = voiceConnectorRegionsContainer {
            voiceConnectorRegionsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]()
            for enum0 in voiceConnectorRegionsContainer {
                if let enum0 = enum0 {
                    voiceConnectorRegionsDecoded0?.append(enum0)
                }
            }
        }
        voiceConnectorRegions = voiceConnectorRegionsDecoded0
    }
}

extension ListPhoneNumberOrdersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPhoneNumberOrdersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number-orders"
    }
}

public struct ListPhoneNumberOrdersInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPhoneNumberOrdersInputBody: Swift.Equatable {
}

extension ListPhoneNumberOrdersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListPhoneNumberOrdersOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPhoneNumberOrdersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPhoneNumberOrdersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumberOrders = output.phoneNumberOrders
        } else {
            self.nextToken = nil
            self.phoneNumberOrders = nil
        }
    }
}

public struct ListPhoneNumberOrdersOutputResponse: Swift.Equatable {
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The phone number order details.
    public var phoneNumberOrders: [ChimeSDKVoiceClientTypes.PhoneNumberOrder]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumberOrders: [ChimeSDKVoiceClientTypes.PhoneNumberOrder]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberOrders = phoneNumberOrders
    }
}

struct ListPhoneNumberOrdersOutputResponseBody: Swift.Equatable {
    let phoneNumberOrders: [ChimeSDKVoiceClientTypes.PhoneNumberOrder]?
    let nextToken: Swift.String?
}

extension ListPhoneNumberOrdersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumberOrders = "PhoneNumberOrders"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrdersContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberOrder?].self, forKey: .phoneNumberOrders)
        var phoneNumberOrdersDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberOrder]? = nil
        if let phoneNumberOrdersContainer = phoneNumberOrdersContainer {
            phoneNumberOrdersDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberOrder]()
            for structure0 in phoneNumberOrdersContainer {
                if let structure0 = structure0 {
                    phoneNumberOrdersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberOrders = phoneNumberOrdersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPhoneNumbersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let productType = productType {
                let productTypeQueryItem = ClientRuntime.URLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
                items.append(productTypeQueryItem)
            }
            if let filterName = filterName {
                let filterNameQueryItem = ClientRuntime.URLQueryItem(name: "filter-name".urlPercentEncoding(), value: Swift.String(filterName.rawValue).urlPercentEncoding())
                items.append(filterNameQueryItem)
            }
            if let filterValue = filterValue {
                let filterValueQueryItem = ClientRuntime.URLQueryItem(name: "filter-value".urlPercentEncoding(), value: Swift.String(filterValue).urlPercentEncoding())
                items.append(filterValueQueryItem)
            }
            return items
        }
    }
}

extension ListPhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-numbers"
    }
}

public struct ListPhoneNumbersInput: Swift.Equatable {
    /// The filter to limit the number of results.
    public var filterName: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName?
    /// The filter value.
    public var filterValue: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The phone number product types.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
    /// The status of your organization's phone numbers.
    public var status: Swift.String?

    public init(
        filterName: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName? = nil,
        filterValue: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil,
        status: Swift.String? = nil
    )
    {
        self.filterName = filterName
        self.filterValue = filterValue
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productType = productType
        self.status = status
    }
}

struct ListPhoneNumbersInputBody: Swift.Equatable {
}

extension ListPhoneNumbersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListPhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPhoneNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListPhoneNumbersOutputResponse: Swift.Equatable {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The phone number details.
    public var phoneNumbers: [ChimeSDKVoiceClientTypes.PhoneNumber]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [ChimeSDKVoiceClientTypes.PhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListPhoneNumbersOutputResponseBody: Swift.Equatable {
    let phoneNumbers: [ChimeSDKVoiceClientTypes.PhoneNumber]?
    let nextToken: Swift.String?
}

extension ListPhoneNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumbersContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProxySessionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProxySessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

public struct ListProxySessionsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy session status.
    public var status: ChimeSDKVoiceClientTypes.ProxySessionStatus?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: ChimeSDKVoiceClientTypes.ProxySessionStatus? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListProxySessionsInputBody: Swift.Equatable {
}

extension ListProxySessionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListProxySessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProxySessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProxySessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proxySessions = output.proxySessions
        } else {
            self.nextToken = nil
            self.proxySessions = nil
        }
    }
}

public struct ListProxySessionsOutputResponse: Swift.Equatable {
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The proxy sessions' details.
    public var proxySessions: [ChimeSDKVoiceClientTypes.ProxySession]?

    public init(
        nextToken: Swift.String? = nil,
        proxySessions: [ChimeSDKVoiceClientTypes.ProxySession]? = nil
    )
    {
        self.nextToken = nextToken
        self.proxySessions = proxySessions
    }
}

struct ListProxySessionsOutputResponseBody: Swift.Equatable {
    let proxySessions: [ChimeSDKVoiceClientTypes.ProxySession]?
    let nextToken: Swift.String?
}

extension ListProxySessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proxySessions = "ProxySessions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.ProxySession?].self, forKey: .proxySessions)
        var proxySessionsDecoded0:[ChimeSDKVoiceClientTypes.ProxySession]? = nil
        if let proxySessionsContainer = proxySessionsContainer {
            proxySessionsDecoded0 = [ChimeSDKVoiceClientTypes.ProxySession]()
            for structure0 in proxySessionsContainer {
                if let structure0 = structure0 {
                    proxySessionsDecoded0?.append(structure0)
                }
            }
        }
        proxySessions = proxySessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSipMediaApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSipMediaApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-media-applications"
    }
}

public struct ListSipMediaApplicationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSipMediaApplicationsInputBody: Swift.Equatable {
}

extension ListSipMediaApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListSipMediaApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSipMediaApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSipMediaApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipMediaApplications = output.sipMediaApplications
        } else {
            self.nextToken = nil
            self.sipMediaApplications = nil
        }
    }
}

public struct ListSipMediaApplicationsOutputResponse: Swift.Equatable {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The list of SIP media applications and application details.
    public var sipMediaApplications: [ChimeSDKVoiceClientTypes.SipMediaApplication]?

    public init(
        nextToken: Swift.String? = nil,
        sipMediaApplications: [ChimeSDKVoiceClientTypes.SipMediaApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipMediaApplications = sipMediaApplications
    }
}

struct ListSipMediaApplicationsOutputResponseBody: Swift.Equatable {
    let sipMediaApplications: [ChimeSDKVoiceClientTypes.SipMediaApplication]?
    let nextToken: Swift.String?
}

extension ListSipMediaApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipMediaApplications = "SipMediaApplications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplication?].self, forKey: .sipMediaApplications)
        var sipMediaApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplication]? = nil
        if let sipMediaApplicationsContainer = sipMediaApplicationsContainer {
            sipMediaApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplication]()
            for structure0 in sipMediaApplicationsContainer {
                if let structure0 = structure0 {
                    sipMediaApplicationsDecoded0?.append(structure0)
                }
            }
        }
        sipMediaApplications = sipMediaApplicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSipRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sipMediaApplicationId = sipMediaApplicationId {
                let sipMediaApplicationIdQueryItem = ClientRuntime.URLQueryItem(name: "sip-media-application".urlPercentEncoding(), value: Swift.String(sipMediaApplicationId).urlPercentEncoding())
                items.append(sipMediaApplicationIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSipRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-rules"
    }
}

public struct ListSipRulesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Defaults to 100.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The SIP media application ID.
    public var sipMediaApplicationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct ListSipRulesInputBody: Swift.Equatable {
}

extension ListSipRulesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListSipRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSipRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSipRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipRules = output.sipRules
        } else {
            self.nextToken = nil
            self.sipRules = nil
        }
    }
}

public struct ListSipRulesOutputResponse: Swift.Equatable {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The list of SIP rules and details.
    public var sipRules: [ChimeSDKVoiceClientTypes.SipRule]?

    public init(
        nextToken: Swift.String? = nil,
        sipRules: [ChimeSDKVoiceClientTypes.SipRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipRules = sipRules
    }
}

struct ListSipRulesOutputResponseBody: Swift.Equatable {
    let sipRules: [ChimeSDKVoiceClientTypes.SipRule]?
    let nextToken: Swift.String?
}

extension ListSipRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipRules = "SipRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRulesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRule?].self, forKey: .sipRules)
        var sipRulesDecoded0:[ChimeSDKVoiceClientTypes.SipRule]? = nil
        if let sipRulesContainer = sipRulesContainer {
            sipRulesDecoded0 = [ChimeSDKVoiceClientTypes.SipRule]()
            for structure0 in sipRulesContainer {
                if let structure0 = structure0 {
                    sipRulesDecoded0?.append(structure0)
                }
            }
        }
        sipRules = sipRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSupportedPhoneNumberCountriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let productType = productType else {
                let message = "Creating a URL Query Item failed. productType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let productTypeQueryItem = ClientRuntime.URLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
            items.append(productTypeQueryItem)
            return items
        }
    }
}

extension ListSupportedPhoneNumberCountriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number-countries"
    }
}

public struct ListSupportedPhoneNumberCountriesInput: Swift.Equatable {
    /// The phone number product type.
    /// This member is required.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

    public init(
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.productType = productType
    }
}

struct ListSupportedPhoneNumberCountriesInputBody: Swift.Equatable {
}

extension ListSupportedPhoneNumberCountriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListSupportedPhoneNumberCountriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSupportedPhoneNumberCountriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSupportedPhoneNumberCountriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberCountries = output.phoneNumberCountries
        } else {
            self.phoneNumberCountries = nil
        }
    }
}

public struct ListSupportedPhoneNumberCountriesOutputResponse: Swift.Equatable {
    /// The supported phone number countries.
    public var phoneNumberCountries: [ChimeSDKVoiceClientTypes.PhoneNumberCountry]?

    public init(
        phoneNumberCountries: [ChimeSDKVoiceClientTypes.PhoneNumberCountry]? = nil
    )
    {
        self.phoneNumberCountries = phoneNumberCountries
    }
}

struct ListSupportedPhoneNumberCountriesOutputResponseBody: Swift.Equatable {
    let phoneNumberCountries: [ChimeSDKVoiceClientTypes.PhoneNumberCountry]?
}

extension ListSupportedPhoneNumberCountriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberCountry?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberCountry]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberCountry]()
            for structure0 in phoneNumberCountriesContainer {
                if let structure0 = structure0 {
                    phoneNumberCountriesDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceARN = resourceARN else {
                let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags in the list.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVoiceConnectorGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVoiceConnectorGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connector-groups"
    }
}

public struct ListVoiceConnectorGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorGroupsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListVoiceConnectorGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceConnectorGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceConnectorGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectorGroups = output.voiceConnectorGroups
        } else {
            self.nextToken = nil
            self.voiceConnectorGroups = nil
        }
    }
}

public struct ListVoiceConnectorGroupsOutputResponse: Swift.Equatable {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Voice Connector groups.
    public var voiceConnectorGroups: [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]?

    public init(
        nextToken: Swift.String? = nil,
        voiceConnectorGroups: [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectorGroups = voiceConnectorGroups
    }
}

struct ListVoiceConnectorGroupsOutputResponseBody: Swift.Equatable {
    let voiceConnectorGroups: [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]?
    let nextToken: Swift.String?
}

extension ListVoiceConnectorGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectorGroups = "VoiceConnectorGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorGroup?].self, forKey: .voiceConnectorGroups)
        var voiceConnectorGroupsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorGroup]? = nil
        if let voiceConnectorGroupsContainer = voiceConnectorGroupsContainer {
            voiceConnectorGroupsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]()
            for structure0 in voiceConnectorGroupsContainer {
                if let structure0 = structure0 {
                    voiceConnectorGroupsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorGroups = voiceConnectorGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVoiceConnectorTerminationCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct ListVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceConnectorTerminationCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceConnectorTerminationCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.usernames = output.usernames
        } else {
            self.usernames = nil
        }
    }
}

public struct ListVoiceConnectorTerminationCredentialsOutputResponse: Swift.Equatable {
    /// A list of user names.
    public var usernames: [Swift.String]?

    public init(
        usernames: [Swift.String]? = nil
    )
    {
        self.usernames = usernames
    }
}

struct ListVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Equatable {
    let usernames: [Swift.String]?
}

extension ListVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

extension ListVoiceConnectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVoiceConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connectors"
    }
}

public struct ListVoiceConnectorsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListVoiceConnectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceConnectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectors = output.voiceConnectors
        } else {
            self.nextToken = nil
            self.voiceConnectors = nil
        }
    }
}

public struct ListVoiceConnectorsOutputResponse: Swift.Equatable {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Voice Connectors.
    public var voiceConnectors: [ChimeSDKVoiceClientTypes.VoiceConnector]?

    public init(
        nextToken: Swift.String? = nil,
        voiceConnectors: [ChimeSDKVoiceClientTypes.VoiceConnector]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectors = voiceConnectors
    }
}

struct ListVoiceConnectorsOutputResponseBody: Swift.Equatable {
    let voiceConnectors: [ChimeSDKVoiceClientTypes.VoiceConnector]?
    let nextToken: Swift.String?
}

extension ListVoiceConnectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectors = "VoiceConnectors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnector?].self, forKey: .voiceConnectors)
        var voiceConnectorsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnector]? = nil
        if let voiceConnectorsContainer = voiceConnectorsContainer {
            voiceConnectorsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnector]()
            for structure0 in voiceConnectorsContainer {
                if let structure0 = structure0 {
                    voiceConnectorsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectors = voiceConnectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVoiceProfileDomainsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVoiceProfileDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-profile-domains"
    }
}

public struct ListVoiceProfileDomainsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceProfileDomainsInputBody: Swift.Equatable {
}

extension ListVoiceProfileDomainsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListVoiceProfileDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceProfileDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceProfileDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceProfileDomains = output.voiceProfileDomains
        } else {
            self.nextToken = nil
            self.voiceProfileDomains = nil
        }
    }
}

public struct ListVoiceProfileDomainsOutputResponse: Swift.Equatable {
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// The list of voice profile domains.
    public var voiceProfileDomains: [ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]?

    public init(
        nextToken: Swift.String? = nil,
        voiceProfileDomains: [ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceProfileDomains = voiceProfileDomains
    }
}

struct ListVoiceProfileDomainsOutputResponseBody: Swift.Equatable {
    let voiceProfileDomains: [ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]?
    let nextToken: Swift.String?
}

extension ListVoiceProfileDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceProfileDomains = "VoiceProfileDomains"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary?].self, forKey: .voiceProfileDomains)
        var voiceProfileDomainsDecoded0:[ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]? = nil
        if let voiceProfileDomainsContainer = voiceProfileDomainsContainer {
            voiceProfileDomainsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary]()
            for structure0 in voiceProfileDomainsContainer {
                if let structure0 = structure0 {
                    voiceProfileDomainsDecoded0?.append(structure0)
                }
            }
        }
        voiceProfileDomains = voiceProfileDomainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVoiceProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let voiceProfileDomainId = voiceProfileDomainId else {
                let message = "Creating a URL Query Item failed. voiceProfileDomainId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let voiceProfileDomainIdQueryItem = ClientRuntime.URLQueryItem(name: "voice-profile-domain-id".urlPercentEncoding(), value: Swift.String(voiceProfileDomainId).urlPercentEncoding())
            items.append(voiceProfileDomainIdQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVoiceProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-profiles"
    }
}

public struct ListVoiceProfilesInput: Swift.Equatable {
    /// The maximum number of results in the request.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the voice profile domain.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct ListVoiceProfilesInputBody: Swift.Equatable {
}

extension ListVoiceProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum ListVoiceProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVoiceProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVoiceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceProfiles = output.voiceProfiles
        } else {
            self.nextToken = nil
            self.voiceProfiles = nil
        }
    }
}

public struct ListVoiceProfilesOutputResponse: Swift.Equatable {
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The list of voice profiles.
    public var voiceProfiles: [ChimeSDKVoiceClientTypes.VoiceProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        voiceProfiles: [ChimeSDKVoiceClientTypes.VoiceProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceProfiles = voiceProfiles
    }
}

struct ListVoiceProfilesOutputResponseBody: Swift.Equatable {
    let voiceProfiles: [ChimeSDKVoiceClientTypes.VoiceProfileSummary]?
    let nextToken: Swift.String?
}

extension ListVoiceProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceProfiles = "VoiceProfiles"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfilesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceProfileSummary?].self, forKey: .voiceProfiles)
        var voiceProfilesDecoded0:[ChimeSDKVoiceClientTypes.VoiceProfileSummary]? = nil
        if let voiceProfilesContainer = voiceProfilesContainer {
            voiceProfilesDecoded0 = [ChimeSDKVoiceClientTypes.VoiceProfileSummary]()
            for structure0 in voiceProfilesContainer {
                if let structure0 = structure0 {
                    voiceProfilesDecoded0?.append(structure0)
                }
            }
        }
        voiceProfiles = voiceProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ChimeSDKVoiceClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableMediaMetricLogs = "EnableMediaMetricLogs"
        case enableSIPLogs = "EnableSIPLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableMediaMetricLogs = self.enableMediaMetricLogs {
            try encodeContainer.encode(enableMediaMetricLogs, forKey: .enableMediaMetricLogs)
        }
        if let enableSIPLogs = self.enableSIPLogs {
            try encodeContainer.encode(enableSIPLogs, forKey: .enableSIPLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSIPLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSIPLogs)
        enableSIPLogs = enableSIPLogsDecoded
        let enableMediaMetricLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMediaMetricLogs)
        enableMediaMetricLogs = enableMediaMetricLogsDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The logging configuration associated with an Amazon Chime SDK Voice Connector. Specifies whether SIP message logs can be sent to Amazon CloudWatch Logs.
    public struct LoggingConfiguration: Swift.Equatable {
        /// Enables or disables media metrics logging.
        public var enableMediaMetricLogs: Swift.Bool?
        /// Boolean that enables sending SIP message logs to Amazon CloudWatch.
        public var enableSIPLogs: Swift.Bool?

        public init(
            enableMediaMetricLogs: Swift.Bool? = nil,
            enableSIPLogs: Swift.Bool? = nil
        )
        {
            self.enableMediaMetricLogs = enableMediaMetricLogs
            self.enableSIPLogs = enableSIPLogs
        }
    }

}

extension ChimeSDKVoiceClientTypes.MediaInsightsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationArn = "ConfigurationArn"
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationArn = self.configurationArn {
            try encodeContainer.encode(configurationArn, forKey: .configurationArn)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let configurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationArn)
        configurationArn = configurationArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes.MediaInsightsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaInsightsConfiguration(disabled: \(Swift.String(describing: disabled)), configurationArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The configuration for a call analytics task.
    public struct MediaInsightsConfiguration: Swift.Equatable {
        /// The configuration's ARN.
        public var configurationArn: Swift.String?
        /// Denotes the configration as enabled or disabled.
        public var disabled: Swift.Bool?

        public init(
            configurationArn: Swift.String? = nil,
            disabled: Swift.Bool? = nil
        )
        {
            self.configurationArn = configurationArn
            self.disabled = disabled
        }
    }

}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource couldn't be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum NotificationTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventbridge
        case sns
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationTarget] {
            return [
                .eventbridge,
                .sns,
                .sqs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventbridge: return "EventBridge"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationTarget(rawValue: rawValue) ?? NotificationTarget.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum NumberSelectionBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avoidsticky
        case prefersticky
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberSelectionBehavior] {
            return [
                .avoidsticky,
                .prefersticky,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avoidsticky: return "AvoidSticky"
            case .prefersticky: return "PreferSticky"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberSelectionBehavior(rawValue: rawValue) ?? NumberSelectionBehavior.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.OrderedPhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumber = "E164PhoneNumber"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumber = self.e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.OrderedPhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ChimeSDKVoiceClientTypes.OrderedPhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderedPhoneNumber(status: \(Swift.String(describing: status)), e164PhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A phone number for which an order has been placed.
    public struct OrderedPhoneNumber: Swift.Equatable {
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The phone number status.
        public var status: ChimeSDKVoiceClientTypes.OrderedPhoneNumberStatus?

        public init(
            e164PhoneNumber: Swift.String? = nil,
            status: ChimeSDKVoiceClientTypes.OrderedPhoneNumberStatus? = nil
        )
        {
            self.e164PhoneNumber = e164PhoneNumber
            self.status = status
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum OrderedPhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquired
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderedPhoneNumberStatus] {
            return [
                .acquired,
                .failed,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquired: return "Acquired"
            case .failed: return "Failed"
            case .processing: return "Processing"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderedPhoneNumberStatus(rawValue: rawValue) ?? OrderedPhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Origination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case routes = "Routes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let routes = routes {
            var routesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routes)
            for originationroute0 in routes {
                try routesContainer.encode(originationroute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.OriginationRoute?].self, forKey: .routes)
        var routesDecoded0:[ChimeSDKVoiceClientTypes.OriginationRoute]? = nil
        if let routesContainer = routesContainer {
            routesDecoded0 = [ChimeSDKVoiceClientTypes.OriginationRoute]()
            for structure0 in routesContainer {
                if let structure0 = structure0 {
                    routesDecoded0?.append(structure0)
                }
            }
        }
        routes = routesDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// Origination settings enable your SIP hosts to receive inbound calls using your Amazon Chime SDK Voice Connector. The parameters listed below are not required, but you must use at least one.
    public struct Origination: Swift.Equatable {
        /// When origination settings are disabled, inbound calls are not enabled for your Amazon Chime SDK Voice Connector. This parameter is not required, but you must specify this parameter or Routes.
        public var disabled: Swift.Bool?
        /// The call distribution properties defined for your SIP hosts. Valid range: Minimum value of 1. Maximum value of 20. This parameter is not required, but you must specify this parameter or Disabled.
        public var routes: [ChimeSDKVoiceClientTypes.OriginationRoute]?

        public init(
            disabled: Swift.Bool? = nil,
            routes: [ChimeSDKVoiceClientTypes.OriginationRoute]? = nil
        )
        {
            self.disabled = disabled
            self.routes = routes
        }
    }

}

extension ChimeSDKVoiceClientTypes.OriginationRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
        case priority = "Priority"
        case `protocol` = "Protocol"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.OriginationRouteProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// Origination routes define call distribution properties for your SIP hosts to receive inbound calls using an Amazon Chime SDK Voice Connector. Limit: Ten origination routes for each Voice Connector. The parameters listed below are not required, but you must use at least one.
    public struct OriginationRoute: Swift.Equatable {
        /// The FQDN or IP address to contact for origination traffic.
        public var host: Swift.String?
        /// The designated origination route port. Defaults to 5060.
        public var port: Swift.Int?
        /// The priority associated with the host, with 1 being the highest priority. Higher priority hosts are attempted first.
        public var priority: Swift.Int?
        /// The protocol to use for the origination route. Encryption-enabled Amazon Chime SDK Voice Connectors use TCP protocol by default.
        public var `protocol`: ChimeSDKVoiceClientTypes.OriginationRouteProtocol?
        /// The weight assigned to an origination route. When hosts have equal priority, calls are distributed between them based on their relative weights.
        public var weight: Swift.Int?

        public init(
            host: Swift.String? = nil,
            port: Swift.Int? = nil,
            priority: Swift.Int? = nil,
            `protocol`: ChimeSDKVoiceClientTypes.OriginationRouteProtocol? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.host = host
            self.port = port
            self.priority = priority
            self.`protocol` = `protocol`
            self.weight = weight
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum OriginationRouteProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginationRouteProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginationRouteProtocol(rawValue: rawValue) ?? OriginationRouteProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Participant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
        case proxyPhoneNumber = "ProxyPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let proxyPhoneNumber = self.proxyPhoneNumber {
            try encodeContainer.encode(proxyPhoneNumber, forKey: .proxyPhoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let proxyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyPhoneNumber)
        proxyPhoneNumber = proxyPhoneNumberDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Participant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Participant(phoneNumber: \"CONTENT_REDACTED\", proxyPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number and proxy phone number for a participant in an Amazon Chime SDK Voice Connector proxy session.
    public struct Participant: Swift.Equatable {
        /// The participant's phone number.
        public var phoneNumber: Swift.String?
        /// The participant's proxy phone number.
        public var proxyPhoneNumber: Swift.String?

        public init(
            phoneNumber: Swift.String? = nil,
            proxyPhoneNumber: Swift.String? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.proxyPhoneNumber = proxyPhoneNumber
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case callingName = "CallingName"
        case callingNameStatus = "CallingNameStatus"
        case capabilities = "Capabilities"
        case country = "Country"
        case createdTimestamp = "CreatedTimestamp"
        case deletionTimestamp = "DeletionTimestamp"
        case e164PhoneNumber = "E164PhoneNumber"
        case orderId = "OrderId"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
        case status = "Status"
        case type = "Type"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for phonenumberassociation0 in associations {
                try associationsContainer.encode(phonenumberassociation0)
            }
        }
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let callingNameStatus = self.callingNameStatus {
            try encodeContainer.encode(callingNameStatus.rawValue, forKey: .callingNameStatus)
        }
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let deletionTimestamp = self.deletionTimestamp {
            try encodeContainer.encodeTimestamp(deletionTimestamp, format: .dateTime, forKey: .deletionTimestamp)
        }
        if let e164PhoneNumber = self.e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let orderId = self.orderId {
            try encodeContainer.encode(orderId, forKey: .orderId)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberType.self, forKey: .type)
        type = typeDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
        let associationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberAssociation?].self, forKey: .associations)
        var associationsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.CallingNameStatus.self, forKey: .callingNameStatus)
        callingNameStatus = callingNameStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let deletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .deletionTimestamp)
        deletionTimestamp = deletionTimestampDecoded
        let orderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderId)
        orderId = orderIdDecoded
    }
}

extension ChimeSDKVoiceClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(associations: \(Swift.String(describing: associations)), callingNameStatus: \(Swift.String(describing: callingNameStatus)), capabilities: \(Swift.String(describing: capabilities)), country: \(Swift.String(describing: country)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), deletionTimestamp: \(Swift.String(describing: deletionTimestamp)), orderId: \(Swift.String(describing: orderId)), productType: \(Swift.String(describing: productType)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), callingName: \"CONTENT_REDACTED\", e164PhoneNumber: \"CONTENT_REDACTED\", phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A phone number used to call an Amazon Chime SDK Voice Connector.
    public struct PhoneNumber: Swift.Equatable {
        /// The phone number's associations.
        public var associations: [ChimeSDKVoiceClientTypes.PhoneNumberAssociation]?
        /// The outbound calling name associated with the phone number.
        public var callingName: Swift.String?
        /// The outbound calling name status.
        public var callingNameStatus: ChimeSDKVoiceClientTypes.CallingNameStatus?
        /// The phone number's capabilities.
        public var capabilities: ChimeSDKVoiceClientTypes.PhoneNumberCapabilities?
        /// The phone number's country. Format: ISO 3166-1 alpha-2.
        public var country: Swift.String?
        /// The phone number creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The deleted phone number timestamp, in ISO 8601 format.
        public var deletionTimestamp: ClientRuntime.Date?
        /// The phone number, in E.164 format.
        public var e164PhoneNumber: Swift.String?
        /// The phone number's order ID.
        public var orderId: Swift.String?
        /// The phone number's ID.
        public var phoneNumberId: Swift.String?
        /// The phone number's product type.
        public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
        /// The phone number's status.
        public var status: ChimeSDKVoiceClientTypes.PhoneNumberStatus?
        /// The phone number's type.
        public var type: ChimeSDKVoiceClientTypes.PhoneNumberType?
        /// The updated phone number timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            associations: [ChimeSDKVoiceClientTypes.PhoneNumberAssociation]? = nil,
            callingName: Swift.String? = nil,
            callingNameStatus: ChimeSDKVoiceClientTypes.CallingNameStatus? = nil,
            capabilities: ChimeSDKVoiceClientTypes.PhoneNumberCapabilities? = nil,
            country: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            deletionTimestamp: ClientRuntime.Date? = nil,
            e164PhoneNumber: Swift.String? = nil,
            orderId: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil,
            status: ChimeSDKVoiceClientTypes.PhoneNumberStatus? = nil,
            type: ChimeSDKVoiceClientTypes.PhoneNumberType? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.associations = associations
            self.callingName = callingName
            self.callingNameStatus = callingNameStatus
            self.capabilities = capabilities
            self.country = country
            self.createdTimestamp = createdTimestamp
            self.deletionTimestamp = deletionTimestamp
            self.e164PhoneNumber = e164PhoneNumber
            self.orderId = orderId
            self.phoneNumberId = phoneNumberId
            self.productType = productType
            self.status = status
            self.type = type
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedTimestamp = "AssociatedTimestamp"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedTimestamp = self.associatedTimestamp {
            try encodeContainer.encodeTimestamp(associatedTimestamp, format: .dateTime, forKey: .associatedTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberAssociationName.self, forKey: .name)
        name = nameDecoded
        let associatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .associatedTimestamp)
        associatedTimestamp = associatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number associations, such as an Amazon Chime SDK account ID, user ID, Voice Connector ID, or Voice Connector group ID.
    public struct PhoneNumberAssociation: Swift.Equatable {
        /// The timestamp of the phone number association, in ISO 8601 format.
        public var associatedTimestamp: ClientRuntime.Date?
        /// Defines the association with an Amazon Chime SDK account ID, user ID, Voice Connector ID, or Voice Connector group ID.
        public var name: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName?
        /// Contains the ID for the entity specified in Name.
        public var value: Swift.String?

        public init(
            associatedTimestamp: ClientRuntime.Date? = nil,
            name: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName? = nil,
            value: Swift.String? = nil
        )
        {
            self.associatedTimestamp = associatedTimestamp
            self.name = name
            self.value = value
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberAssociationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sipruleid
        case voiceconnectorgroupid
        case voiceconnectorid
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberAssociationName] {
            return [
                .sipruleid,
                .voiceconnectorgroupid,
                .voiceconnectorid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sipruleid: return "SipRuleId"
            case .voiceconnectorgroupid: return "VoiceConnectorGroupId"
            case .voiceconnectorid: return "VoiceConnectorId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberAssociationName(rawValue: rawValue) ?? PhoneNumberAssociationName.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.PhoneNumberCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundCall = "InboundCall"
        case inboundMMS = "InboundMMS"
        case inboundSMS = "InboundSMS"
        case outboundCall = "OutboundCall"
        case outboundMMS = "OutboundMMS"
        case outboundSMS = "OutboundSMS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundCall = self.inboundCall {
            try encodeContainer.encode(inboundCall, forKey: .inboundCall)
        }
        if let inboundMMS = self.inboundMMS {
            try encodeContainer.encode(inboundMMS, forKey: .inboundMMS)
        }
        if let inboundSMS = self.inboundSMS {
            try encodeContainer.encode(inboundSMS, forKey: .inboundSMS)
        }
        if let outboundCall = self.outboundCall {
            try encodeContainer.encode(outboundCall, forKey: .outboundCall)
        }
        if let outboundMMS = self.outboundMMS {
            try encodeContainer.encode(outboundMMS, forKey: .outboundMMS)
        }
        if let outboundSMS = self.outboundSMS {
            try encodeContainer.encode(outboundSMS, forKey: .outboundSMS)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCall)
        inboundCall = inboundCallDecoded
        let outboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCall)
        outboundCall = outboundCallDecoded
        let inboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundSMS)
        inboundSMS = inboundSMSDecoded
        let outboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundSMS)
        outboundSMS = outboundSMSDecoded
        let inboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundMMS)
        inboundMMS = inboundMMSDecoded
        let outboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundMMS)
        outboundMMS = outboundMMSDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number capabilities for Amazon Chime SDK phone numbers, such as enabled inbound and outbound calling, and text messaging.
    public struct PhoneNumberCapabilities: Swift.Equatable {
        /// Allows or denies inbound calling for the specified phone number.
        public var inboundCall: Swift.Bool?
        /// Allows or denies inbound MMS messaging for the specified phone number.
        public var inboundMMS: Swift.Bool?
        /// Allows or denies inbound SMS messaging for the specified phone number.
        public var inboundSMS: Swift.Bool?
        /// Allows or denies outbound calling for the specified phone number.
        public var outboundCall: Swift.Bool?
        /// Allows or denies inbound MMS messaging for the specified phone number.
        public var outboundMMS: Swift.Bool?
        /// Allows or denies outbound SMS messaging for the specified phone number.
        public var outboundSMS: Swift.Bool?

        public init(
            inboundCall: Swift.Bool? = nil,
            inboundMMS: Swift.Bool? = nil,
            inboundSMS: Swift.Bool? = nil,
            outboundCall: Swift.Bool? = nil,
            outboundMMS: Swift.Bool? = nil,
            outboundSMS: Swift.Bool? = nil
        )
        {
            self.inboundCall = inboundCall
            self.inboundMMS = inboundMMS
            self.inboundSMS = inboundSMS
            self.outboundCall = outboundCall
            self.outboundMMS = outboundMMS
            self.outboundSMS = outboundSMS
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberCountry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "CountryCode"
        case supportedPhoneNumberTypes = "SupportedPhoneNumberTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let supportedPhoneNumberTypes = supportedPhoneNumberTypes {
            var supportedPhoneNumberTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedPhoneNumberTypes)
            for phonenumbertype0 in supportedPhoneNumberTypes {
                try supportedPhoneNumberTypesContainer.encode(phonenumbertype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let supportedPhoneNumberTypesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberType?].self, forKey: .supportedPhoneNumberTypes)
        var supportedPhoneNumberTypesDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberType]? = nil
        if let supportedPhoneNumberTypesContainer = supportedPhoneNumberTypesContainer {
            supportedPhoneNumberTypesDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberType]()
            for enum0 in supportedPhoneNumberTypesContainer {
                if let enum0 = enum0 {
                    supportedPhoneNumberTypesDecoded0?.append(enum0)
                }
            }
        }
        supportedPhoneNumberTypes = supportedPhoneNumberTypesDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number's country.
    public struct PhoneNumberCountry: Swift.Equatable {
        /// The phone number country code. Format: ISO 3166-1 alpha-2.
        public var countryCode: Swift.String?
        /// The supported phone number types.
        public var supportedPhoneNumberTypes: [ChimeSDKVoiceClientTypes.PhoneNumberType]?

        public init(
            countryCode: Swift.String? = nil,
            supportedPhoneNumberTypes: [ChimeSDKVoiceClientTypes.PhoneNumberType]? = nil
        )
        {
            self.countryCode = countryCode
            self.supportedPhoneNumberTypes = supportedPhoneNumberTypes
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case phoneNumberId = "PhoneNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeSDKVoiceClientTypes.PhoneNumberError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// If a phone number action fails for one or more of the phone numbers in a request, a list of the failed phone numbers is returned, along with error codes and error messages.
    public struct PhoneNumberError: Swift.Equatable {
        /// The error code.
        public var errorCode: ChimeSDKVoiceClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The phone number ID for which the action failed.
        public var phoneNumberId: Swift.String?

        public init(
            errorCode: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.phoneNumberId = phoneNumberId
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberOrder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case orderType = "OrderType"
        case orderedPhoneNumbers = "OrderedPhoneNumbers"
        case phoneNumberOrderId = "PhoneNumberOrderId"
        case productType = "ProductType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let orderType = self.orderType {
            try encodeContainer.encode(orderType.rawValue, forKey: .orderType)
        }
        if let orderedPhoneNumbers = orderedPhoneNumbers {
            var orderedPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedPhoneNumbers)
            for orderedphonenumber0 in orderedPhoneNumbers {
                try orderedPhoneNumbersContainer.encode(orderedphonenumber0)
            }
        }
        if let phoneNumberOrderId = self.phoneNumberOrderId {
            try encodeContainer.encode(phoneNumberOrderId, forKey: .phoneNumberOrderId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberOrderId)
        phoneNumberOrderId = phoneNumberOrderIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrderStatus.self, forKey: .status)
        status = statusDecoded
        let orderTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrderType.self, forKey: .orderType)
        orderType = orderTypeDecoded
        let orderedPhoneNumbersContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.OrderedPhoneNumber?].self, forKey: .orderedPhoneNumbers)
        var orderedPhoneNumbersDecoded0:[ChimeSDKVoiceClientTypes.OrderedPhoneNumber]? = nil
        if let orderedPhoneNumbersContainer = orderedPhoneNumbersContainer {
            orderedPhoneNumbersDecoded0 = [ChimeSDKVoiceClientTypes.OrderedPhoneNumber]()
            for structure0 in orderedPhoneNumbersContainer {
                if let structure0 = structure0 {
                    orderedPhoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        orderedPhoneNumbers = orderedPhoneNumbersDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of an Amazon Chime SDK phone number order.
    public struct PhoneNumberOrder: Swift.Equatable {
        /// The phone number order creation time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The type of phone number being ordered, local or toll-free.
        public var orderType: ChimeSDKVoiceClientTypes.PhoneNumberOrderType?
        /// The ordered phone number details, such as the phone number in E.164 format and the phone number status.
        public var orderedPhoneNumbers: [ChimeSDKVoiceClientTypes.OrderedPhoneNumber]?
        /// The ID of the phone order.
        public var phoneNumberOrderId: Swift.String?
        /// The phone number order product type.
        public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
        /// The status of the phone number order.
        public var status: ChimeSDKVoiceClientTypes.PhoneNumberOrderStatus?
        /// The updated phone number order time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            orderType: ChimeSDKVoiceClientTypes.PhoneNumberOrderType? = nil,
            orderedPhoneNumbers: [ChimeSDKVoiceClientTypes.OrderedPhoneNumber]? = nil,
            phoneNumberOrderId: Swift.String? = nil,
            productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil,
            status: ChimeSDKVoiceClientTypes.PhoneNumberOrderStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.orderType = orderType
            self.orderedPhoneNumbers = orderedPhoneNumbers
            self.phoneNumberOrderId = phoneNumberOrderId
            self.productType = productType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberOrderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelrequested
        case cancelled
        case changerequested
        case exception
        case foc
        case failed
        case partial
        case pendingdocuments
        case processing
        case submitted
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberOrderStatus] {
            return [
                .cancelrequested,
                .cancelled,
                .changerequested,
                .exception,
                .foc,
                .failed,
                .partial,
                .pendingdocuments,
                .processing,
                .submitted,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelrequested: return "CancelRequested"
            case .cancelled: return "Cancelled"
            case .changerequested: return "ChangeRequested"
            case .exception: return "Exception"
            case .foc: return "FOC"
            case .failed: return "Failed"
            case .partial: return "Partial"
            case .pendingdocuments: return "PendingDocuments"
            case .processing: return "Processing"
            case .submitted: return "Submitted"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberOrderStatus(rawValue: rawValue) ?? PhoneNumberOrderStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberOrderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case new
        case porting
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberOrderType] {
            return [
                .new,
                .porting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .new: return "New"
            case .porting: return "Porting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberOrderType(rawValue: rawValue) ?? PhoneNumberOrderType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberProductType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sipmediaapplicationdialin
        case voiceconnector
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberProductType] {
            return [
                .sipmediaapplicationdialin,
                .voiceconnector,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sipmediaapplicationdialin: return "SipMediaApplicationDialIn"
            case .voiceconnector: return "VoiceConnector"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberProductType(rawValue: rawValue) ?? PhoneNumberProductType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquirefailed
        case acquireinprogress
        case assigned
        case cancelled
        case deletefailed
        case deleteinprogress
        case portincancelrequested
        case portininprogress
        case releasefailed
        case releaseinprogress
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberStatus] {
            return [
                .acquirefailed,
                .acquireinprogress,
                .assigned,
                .cancelled,
                .deletefailed,
                .deleteinprogress,
                .portincancelrequested,
                .portininprogress,
                .releasefailed,
                .releaseinprogress,
                .unassigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquirefailed: return "AcquireFailed"
            case .acquireinprogress: return "AcquireInProgress"
            case .assigned: return "Assigned"
            case .cancelled: return "Cancelled"
            case .deletefailed: return "DeleteFailed"
            case .deleteinprogress: return "DeleteInProgress"
            case .portincancelrequested: return "PortinCancelRequested"
            case .portininprogress: return "PortinInProgress"
            case .releasefailed: return "ReleaseFailed"
            case .releaseinprogress: return "ReleaseInProgress"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberStatus(rawValue: rawValue) ?? PhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case tollfree
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .local,
                .tollfree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "Local"
            case .tollfree: return "TollFree"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Proxy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = self.defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = self.fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberCountries = phoneNumberCountries {
            var phoneNumberCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberCountries)
            for string0 in phoneNumberCountries {
                try phoneNumberCountriesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberCountriesContainer {
                if let string0 = string0 {
                    phoneNumberCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

extension ChimeSDKVoiceClientTypes.Proxy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Proxy(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberCountries: \(Swift.String(describing: phoneNumberCountries)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The proxy configuration for an Amazon Chime SDK Voice Connector.
    public struct Proxy: Swift.Equatable {
        /// The default number of minutes allowed for proxy sessions.
        public var defaultSessionExpiryMinutes: Swift.Int?
        /// When true, stops proxy sessions from being created on the specified Amazon Chime SDK Voice Connector.
        public var disabled: Swift.Bool?
        /// The phone number to route calls to after a proxy session expires.
        public var fallBackPhoneNumber: Swift.String?
        /// The countries for proxy phone numbers to be selected from.
        public var phoneNumberCountries: [Swift.String]?

        public init(
            defaultSessionExpiryMinutes: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            fallBackPhoneNumber: Swift.String? = nil,
            phoneNumberCountries: [Swift.String]? = nil
        )
        {
            self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
            self.disabled = disabled
            self.fallBackPhoneNumber = fallBackPhoneNumber
            self.phoneNumberCountries = phoneNumberCountries
        }
    }

}

extension ChimeSDKVoiceClientTypes.ProxySession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case createdTimestamp = "CreatedTimestamp"
        case endedTimestamp = "EndedTimestamp"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participants = "Participants"
        case proxySessionId = "ProxySessionId"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let endedTimestamp = self.endedTimestamp {
            try encodeContainer.encodeTimestamp(endedTimestamp, format: .dateTime, forKey: .endedTimestamp)
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = self.geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = self.geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = self.numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participants = participants {
            var participantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participants)
            for participant0 in participants {
                try participantsContainer.encode(participant0)
            }
        }
        if let proxySessionId = self.proxySessionId {
            try encodeContainer.encode(proxySessionId, forKey: .proxySessionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let proxySessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxySessionId)
        proxySessionId = proxySessionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySessionStatus.self, forKey: .status)
        status = statusDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeSDKVoiceClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeSDKVoiceClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let endedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedTimestamp)
        endedTimestamp = endedTimestampDecoded
        let participantsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Participant?].self, forKey: .participants)
        var participantsDecoded0:[ChimeSDKVoiceClientTypes.Participant]? = nil
        if let participantsContainer = participantsContainer {
            participantsDecoded0 = [ChimeSDKVoiceClientTypes.Participant]()
            for structure0 in participantsContainer {
                if let structure0 = structure0 {
                    participantsDecoded0?.append(structure0)
                }
            }
        }
        participants = participantsDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The proxy session for an Amazon Chime SDK Voice Connector.
    public struct ProxySession: Swift.Equatable {
        /// The proxy session capabilities.
        public var capabilities: [ChimeSDKVoiceClientTypes.Capability]?
        /// The created time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ended time stamp, in ISO 8601 format.
        public var endedTimestamp: ClientRuntime.Date?
        /// The number of minutes allowed for the proxy session.
        public var expiryMinutes: Swift.Int?
        /// The preference for matching the country or area code of the proxy phone number with that of the first participant.
        public var geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel?
        /// The country and area code for the proxy phone number.
        public var geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams?
        /// The proxy session name.
        public var name: Swift.String?
        /// The preference for proxy phone number reuse, or stickiness, between the same participants across sessions.
        public var numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior?
        /// The proxy session participants.
        public var participants: [ChimeSDKVoiceClientTypes.Participant]?
        /// The proxy session ID.
        public var proxySessionId: Swift.String?
        /// The proxy session status.
        public var status: ChimeSDKVoiceClientTypes.ProxySessionStatus?
        /// The updated time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The Voice Connector ID.
        public var voiceConnectorId: Swift.String?

        public init(
            capabilities: [ChimeSDKVoiceClientTypes.Capability]? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endedTimestamp: ClientRuntime.Date? = nil,
            expiryMinutes: Swift.Int? = nil,
            geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel? = nil,
            geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams? = nil,
            name: Swift.String? = nil,
            numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior? = nil,
            participants: [ChimeSDKVoiceClientTypes.Participant]? = nil,
            proxySessionId: Swift.String? = nil,
            status: ChimeSDKVoiceClientTypes.ProxySessionStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.createdTimestamp = createdTimestamp
            self.endedTimestamp = endedTimestamp
            self.expiryMinutes = expiryMinutes
            self.geoMatchLevel = geoMatchLevel
            self.geoMatchParams = geoMatchParams
            self.name = name
            self.numberSelectionBehavior = numberSelectionBehavior
            self.participants = participants
            self.proxySessionId = proxySessionId
            self.status = status
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum ProxySessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case inprogress
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [ProxySessionStatus] {
            return [
                .closed,
                .inprogress,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "Closed"
            case .inprogress: return "InProgress"
            case .open: return "Open"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProxySessionStatus(rawValue: rawValue) ?? ProxySessionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sipMediaApplicationAlexaSkillConfiguration = self.sipMediaApplicationAlexaSkillConfiguration {
            try encodeContainer.encode(sipMediaApplicationAlexaSkillConfiguration, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        }
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/alexa-skill-configuration"
    }
}

public struct PutSipMediaApplicationAlexaSkillConfigurationInput: Swift.Equatable {
    /// The Alexa Skill configuration.
    public var sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfiguration
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct PutSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Equatable {
    let sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
}

extension PutSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationAlexaSkillConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration.self, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfigurationDecoded
    }
}

public enum PutSipMediaApplicationAlexaSkillConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSipMediaApplicationAlexaSkillConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationAlexaSkillConfiguration = output.sipMediaApplicationAlexaSkillConfiguration
        } else {
            self.sipMediaApplicationAlexaSkillConfiguration = nil
        }
    }
}

public struct PutSipMediaApplicationAlexaSkillConfigurationOutputResponse: Swift.Equatable {
    /// Returns the Alexa Skill configuration.
    public var sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?

    public init(
        sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration? = nil
    )
    {
        self.sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfiguration
    }
}

struct PutSipMediaApplicationAlexaSkillConfigurationOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
}

extension PutSipMediaApplicationAlexaSkillConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationAlexaSkillConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration.self, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfigurationDecoded
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sipMediaApplicationLoggingConfiguration = self.sipMediaApplicationLoggingConfiguration {
            try encodeContainer.encode(sipMediaApplicationLoggingConfiguration, forKey: .sipMediaApplicationLoggingConfiguration)
        }
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

public struct PutSipMediaApplicationLoggingConfigurationInput: Swift.Equatable {
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The logging configuration for the specified SIP media application.
    public var sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationId: Swift.String? = nil,
        sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationInputBody: Swift.Equatable {
    let sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

public enum PutSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutSipMediaApplicationLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutSipMediaApplicationLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct PutSipMediaApplicationLoggingConfigurationOutputResponse: Swift.Equatable {
    /// The updated logging configuration for the specified SIP media application.
    public var sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?

    public init(
        sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyCallingConfiguration = self.emergencyCallingConfiguration {
            try encodeContainer.encode(emergencyCallingConfiguration, forKey: .emergencyCallingConfiguration)
        }
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// The configuration being updated.
    /// This member is required.
    public var emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
    let emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

public enum PutVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorEmergencyCallingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.Equatable {
    /// The updated configuration.
    public var emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?

    public init(
        emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Equatable {
    let emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

extension PutVoiceConnectorLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfiguration = self.loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
    }
}

extension PutVoiceConnectorLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

public struct PutVoiceConnectorLoggingConfigurationInput: Swift.Equatable {
    /// The logging configuration being updated.
    /// This member is required.
    public var loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorLoggingConfigurationInputBody: Swift.Equatable {
    let loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

public enum PutVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorLoggingConfigurationOutputResponse: Swift.Equatable {
    /// The updated logging configuration.
    public var loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?

    public init(
        loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct PutVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension PutVoiceConnectorOriginationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let origination = self.origination {
            try encodeContainer.encode(origination, forKey: .origination)
        }
    }
}

extension PutVoiceConnectorOriginationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct PutVoiceConnectorOriginationInput: Swift.Equatable {
    /// The origination settings being updated.
    /// This member is required.
    public var origination: ChimeSDKVoiceClientTypes.Origination?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        origination: ChimeSDKVoiceClientTypes.Origination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.origination = origination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorOriginationInputBody: Swift.Equatable {
    let origination: ChimeSDKVoiceClientTypes.Origination?
}

extension PutVoiceConnectorOriginationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

public enum PutVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorOriginationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorOriginationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct PutVoiceConnectorOriginationOutputResponse: Swift.Equatable {
    /// The updated origination settings.
    public var origination: ChimeSDKVoiceClientTypes.Origination?

    public init(
        origination: ChimeSDKVoiceClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct PutVoiceConnectorOriginationOutputResponseBody: Swift.Equatable {
    let origination: ChimeSDKVoiceClientTypes.Origination?
}

extension PutVoiceConnectorOriginationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

extension PutVoiceConnectorProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorProxyInput(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberPoolCountries: \(Swift.String(describing: phoneNumberPoolCountries)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension PutVoiceConnectorProxyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = self.defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = self.fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberPoolCountries = phoneNumberPoolCountries {
            var phoneNumberPoolCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberPoolCountries)
            for country0 in phoneNumberPoolCountries {
                try phoneNumberPoolCountriesContainer.encode(country0)
            }
        }
    }
}

extension PutVoiceConnectorProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct PutVoiceConnectorProxyInput: Swift.Equatable {
    /// The default number of minutes allowed for proxy session.
    /// This member is required.
    public var defaultSessionExpiryMinutes: Swift.Int?
    /// When true, stops proxy sessions from being created on the specified Amazon Chime SDK Voice Connector.
    public var disabled: Swift.Bool?
    /// The phone number to route calls to after a proxy session expires.
    public var fallBackPhoneNumber: Swift.String?
    /// The countries for proxy phone numbers to be selected from.
    /// This member is required.
    public var phoneNumberPoolCountries: [Swift.String]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        defaultSessionExpiryMinutes: Swift.Int? = nil,
        disabled: Swift.Bool? = nil,
        fallBackPhoneNumber: Swift.String? = nil,
        phoneNumberPoolCountries: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
        self.disabled = disabled
        self.fallBackPhoneNumber = fallBackPhoneNumber
        self.phoneNumberPoolCountries = phoneNumberPoolCountries
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorProxyInputBody: Swift.Equatable {
    let defaultSessionExpiryMinutes: Swift.Int?
    let phoneNumberPoolCountries: [Swift.String]?
    let fallBackPhoneNumber: Swift.String?
    let disabled: Swift.Bool?
}

extension PutVoiceConnectorProxyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let phoneNumberPoolCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberPoolCountries)
        var phoneNumberPoolCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberPoolCountriesContainer = phoneNumberPoolCountriesContainer {
            phoneNumberPoolCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberPoolCountriesContainer {
                if let string0 = string0 {
                    phoneNumberPoolCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberPoolCountries = phoneNumberPoolCountriesDecoded0
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

public enum PutVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct PutVoiceConnectorProxyOutputResponse: Swift.Equatable {
    /// The proxy configuration details.
    public var proxy: ChimeSDKVoiceClientTypes.Proxy?

    public init(
        proxy: ChimeSDKVoiceClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct PutVoiceConnectorProxyOutputResponseBody: Swift.Equatable {
    let proxy: ChimeSDKVoiceClientTypes.Proxy?
}

extension PutVoiceConnectorProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

extension PutVoiceConnectorStreamingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamingConfiguration = self.streamingConfiguration {
            try encodeContainer.encode(streamingConfiguration, forKey: .streamingConfiguration)
        }
    }
}

extension PutVoiceConnectorStreamingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct PutVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// The streaming settings being updated.
    /// This member is required.
    public var streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
    let streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

public enum PutVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorStreamingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorStreamingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorStreamingConfigurationOutputResponse: Swift.Equatable {
    /// The updated streaming settings.
    public var streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?

    public init(
        streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct PutVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Equatable {
    let streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for credential0 in credentials {
                try credentialsContainer.encode(credential0)
            }
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "put"))
            return items
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct PutVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// The termination credentials being updated.
    public var credentials: [ChimeSDKVoiceClientTypes.Credential]?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        credentials: [ChimeSDKVoiceClientTypes.Credential]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
    let credentials: [ChimeSDKVoiceClientTypes.Credential]?
}

extension PutVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Credential?].self, forKey: .credentials)
        var credentialsDecoded0:[ChimeSDKVoiceClientTypes.Credential]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [ChimeSDKVoiceClientTypes.Credential]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
    }
}

public enum PutVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutVoiceConnectorTerminationCredentialsOutputResponse: Swift.Equatable {

    public init() { }
}

extension PutVoiceConnectorTerminationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let termination = self.termination {
            try encodeContainer.encode(termination, forKey: .termination)
        }
    }
}

extension PutVoiceConnectorTerminationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct PutVoiceConnectorTerminationInput: Swift.Equatable {
    /// The termination settings to be updated.
    /// This member is required.
    public var termination: ChimeSDKVoiceClientTypes.Termination?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        termination: ChimeSDKVoiceClientTypes.Termination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.termination = termination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationInputBody: Swift.Equatable {
    let termination: ChimeSDKVoiceClientTypes.Termination?
}

extension PutVoiceConnectorTerminationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

public enum PutVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutVoiceConnectorTerminationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutVoiceConnectorTerminationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct PutVoiceConnectorTerminationOutputResponse: Swift.Equatable {
    /// The updated termination settings.
    public var termination: ChimeSDKVoiceClientTypes.Termination?

    public init(
        termination: ChimeSDKVoiceClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct PutVoiceConnectorTerminationOutputResponseBody: Swift.Equatable {
    let termination: ChimeSDKVoiceClientTypes.Termination?
}

extension PutVoiceConnectorTerminationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension ResourceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestorePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestorePhoneNumberInput(phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension RestorePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "restore"))
            return items
        }
    }
}

extension RestorePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct RestorePhoneNumberInput: Swift.Equatable {
    /// The ID of the phone number being restored.
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct RestorePhoneNumberInputBody: Swift.Equatable {
}

extension RestorePhoneNumberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum RestorePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RestorePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RestorePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct RestorePhoneNumberOutputResponse: Swift.Equatable {
    /// The restored phone number.
    public var phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct RestorePhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?
}

extension RestorePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension SearchAvailablePhoneNumbersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "type", value: "phone-numbers"))
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let areaCode = areaCode {
                let areaCodeQueryItem = ClientRuntime.URLQueryItem(name: "area-code".urlPercentEncoding(), value: Swift.String(areaCode).urlPercentEncoding())
                items.append(areaCodeQueryItem)
            }
            if let country = country {
                let countryQueryItem = ClientRuntime.URLQueryItem(name: "country".urlPercentEncoding(), value: Swift.String(country).urlPercentEncoding())
                items.append(countryQueryItem)
            }
            if let city = city {
                let cityQueryItem = ClientRuntime.URLQueryItem(name: "city".urlPercentEncoding(), value: Swift.String(city).urlPercentEncoding())
                items.append(cityQueryItem)
            }
            if let phoneNumberType = phoneNumberType {
                let phoneNumberTypeQueryItem = ClientRuntime.URLQueryItem(name: "phone-number-type".urlPercentEncoding(), value: Swift.String(phoneNumberType.rawValue).urlPercentEncoding())
                items.append(phoneNumberTypeQueryItem)
            }
            if let tollFreePrefix = tollFreePrefix {
                let tollFreePrefixQueryItem = ClientRuntime.URLQueryItem(name: "toll-free-prefix".urlPercentEncoding(), value: Swift.String(tollFreePrefix).urlPercentEncoding())
                items.append(tollFreePrefixQueryItem)
            }
            return items
        }
    }
}

extension SearchAvailablePhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search"
    }
}

public struct SearchAvailablePhoneNumbersInput: Swift.Equatable {
    /// Confines a search to just the phone numbers associated with the specified area code.
    public var areaCode: Swift.String?
    /// Confines a search to just the phone numbers associated with the specified city.
    public var city: Swift.String?
    /// Confines a search to just the phone numbers associated with the specified country.
    public var country: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?
    /// Confines a search to just the phone numbers associated with the specified phone number type, either local or toll-free.
    public var phoneNumberType: ChimeSDKVoiceClientTypes.PhoneNumberType?
    /// Confines a search to just the phone numbers associated with the specified state.
    public var state: Swift.String?
    /// Confines a search to just the phone numbers associated with the specified toll-free prefix.
    public var tollFreePrefix: Swift.String?

    public init(
        areaCode: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberType: ChimeSDKVoiceClientTypes.PhoneNumberType? = nil,
        state: Swift.String? = nil,
        tollFreePrefix: Swift.String? = nil
    )
    {
        self.areaCode = areaCode
        self.city = city
        self.country = country
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberType = phoneNumberType
        self.state = state
        self.tollFreePrefix = tollFreePrefix
    }
}

struct SearchAvailablePhoneNumbersInputBody: Swift.Equatable {
}

extension SearchAvailablePhoneNumbersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum SearchAvailablePhoneNumbersOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SearchAvailablePhoneNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SearchAvailablePhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.e164PhoneNumbers = output.e164PhoneNumbers
            self.nextToken = output.nextToken
        } else {
            self.e164PhoneNumbers = nil
            self.nextToken = nil
        }
    }
}

public struct SearchAvailablePhoneNumbersOutputResponse: Swift.Equatable {
    /// Confines a search to just the phone numbers in the E.164 format.
    public var e164PhoneNumbers: [Swift.String]?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        e164PhoneNumbers: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.nextToken = nextToken
    }
}

struct SearchAvailablePhoneNumbersOutputResponseBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
    let nextToken: Swift.String?
}

extension SearchAvailablePhoneNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerSideEncryptionConfiguration(kmsKeyArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A structure that contains the configuration settings for server-side encryption. We only support symmetric keys. Do not use asymmetric or HMAC keys, or KMS aliases.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// The ARN of the KMS key used to encrypt the enrollment data in a voice profile domain. Asymmetric customer managed keys are not supported.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension ServiceFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes.SipMediaApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case endpoints = "Endpoints"
        case name = "Name"
        case sipMediaApplicationArn = "SipMediaApplicationArn"
        case sipMediaApplicationId = "SipMediaApplicationId"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipMediaApplicationArn = self.sipMediaApplicationArn {
            try encodeContainer.encode(sipMediaApplicationArn, forKey: .sipMediaApplicationArn)
        }
        if let sipMediaApplicationId = self.sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let sipMediaApplicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationArn)
        sipMediaApplicationArn = sipMediaApplicationArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of the SIP media application, including name and endpoints. An AWS account can have multiple SIP media applications.
    public struct SipMediaApplication: Swift.Equatable {
        /// The AWS Region in which the SIP media application is created.
        public var awsRegion: Swift.String?
        /// The SIP media application creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// List of endpoints for a SIP media application. Currently, only one endpoint per SIP media application is permitted.
        public var endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
        /// The SIP media application's name.
        public var name: Swift.String?
        /// The ARN of the SIP media application.
        public var sipMediaApplicationArn: Swift.String?
        /// A SIP media application's ID.
        public var sipMediaApplicationId: Swift.String?
        /// The time at which the SIP media application was updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            awsRegion: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil,
            name: Swift.String? = nil,
            sipMediaApplicationArn: Swift.String? = nil,
            sipMediaApplicationId: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.endpoints = endpoints
            self.name = name
            self.sipMediaApplicationArn = sipMediaApplicationArn
            self.sipMediaApplicationId = sipMediaApplicationId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaSkillIds = "AlexaSkillIds"
        case alexaSkillStatus = "AlexaSkillStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alexaSkillIds = alexaSkillIds {
            var alexaSkillIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alexaSkillIds)
            for alexaskillid0 in alexaSkillIds {
                try alexaSkillIdsContainer.encode(alexaskillid0)
            }
        }
        if let alexaSkillStatus = self.alexaSkillStatus {
            try encodeContainer.encode(alexaSkillStatus.rawValue, forKey: .alexaSkillStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alexaSkillStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.AlexaSkillStatus.self, forKey: .alexaSkillStatus)
        alexaSkillStatus = alexaSkillStatusDecoded
        let alexaSkillIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .alexaSkillIds)
        var alexaSkillIdsDecoded0:[Swift.String]? = nil
        if let alexaSkillIdsContainer = alexaSkillIdsContainer {
            alexaSkillIdsDecoded0 = [Swift.String]()
            for string0 in alexaSkillIdsContainer {
                if let string0 = string0 {
                    alexaSkillIdsDecoded0?.append(string0)
                }
            }
        }
        alexaSkillIds = alexaSkillIdsDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The Alexa Skill configuration of a SIP media application.
    public struct SipMediaApplicationAlexaSkillConfiguration: Swift.Equatable {
        /// The ID of the Alexa Skill configuration.
        /// This member is required.
        public var alexaSkillIds: [Swift.String]?
        /// The status of the Alexa Skill configuration.
        /// This member is required.
        public var alexaSkillStatus: ChimeSDKVoiceClientTypes.AlexaSkillStatus?

        public init(
            alexaSkillIds: [Swift.String]? = nil,
            alexaSkillStatus: ChimeSDKVoiceClientTypes.AlexaSkillStatus? = nil
        )
        {
            self.alexaSkillIds = alexaSkillIds
            self.alexaSkillStatus = alexaSkillStatus
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationCall: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// A Call instance for a SIP media application.
    public struct SipMediaApplicationCall: Swift.Equatable {
        /// The call's transaction ID.
        public var transactionId: Swift.String?

        public init(
            transactionId: Swift.String? = nil
        )
        {
            self.transactionId = transactionId
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipMediaApplicationEndpoint(lambdaArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The endpoint assigned to a SIP media application.
    public struct SipMediaApplicationEndpoint: Swift.Equatable {
        /// Valid Amazon Resource Name (ARN) of the Lambda function, version, or alias. The function must be created in the same AWS Region as the SIP media application.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableSipMediaApplicationMessageLogs = "EnableSipMediaApplicationMessageLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableSipMediaApplicationMessageLogs = self.enableSipMediaApplicationMessageLogs {
            try encodeContainer.encode(enableSipMediaApplicationMessageLogs, forKey: .enableSipMediaApplicationMessageLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSipMediaApplicationMessageLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSipMediaApplicationMessageLogs)
        enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogsDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The logging configuration of a SIP media application.
    public struct SipMediaApplicationLoggingConfiguration: Swift.Equatable {
        /// Enables message logging for the specified SIP media application.
        public var enableSipMediaApplicationMessageLogs: Swift.Bool?

        public init(
            enableSipMediaApplicationMessageLogs: Swift.Bool? = nil
        )
        {
            self.enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogs
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case disabled = "Disabled"
        case name = "Name"
        case sipRuleId = "SipRuleId"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipRuleId = self.sipRuleId {
            try encodeContainer.encode(sipRuleId, forKey: .sipRuleId)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = self.triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipRuleId)
        sipRuleId = sipRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of a SIP rule, including name, triggers, and target applications. An AWS account can have multiple SIP rules.
    public struct SipRule: Swift.Equatable {
        /// The time at which the SIP rule was created, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// Indicates whether the SIP rule is enabled or disabled. You must disable a rule before you can delete it.
        public var disabled: Swift.Bool?
        /// A SIP rule's name.
        public var name: Swift.String?
        /// A SIP rule's ID.
        public var sipRuleId: Swift.String?
        /// The target SIP media application and other details, such as priority and AWS Region, to be specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
        public var targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
        /// The type of trigger set for a SIP rule, either a phone number or a URI request host name.
        public var triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType?
        /// The value set for a SIP rule's trigger type. Either a phone number or a URI hostname.
        public var triggerValue: Swift.String?
        /// The time at which the SIP rule was updated, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            disabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            sipRuleId: Swift.String? = nil,
            targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil,
            triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType? = nil,
            triggerValue: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.disabled = disabled
            self.name = name
            self.sipRuleId = sipRuleId
            self.targetApplications = targetApplications
            self.triggerType = triggerType
            self.triggerValue = triggerValue
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipRuleTargetApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case priority = "Priority"
        case sipMediaApplicationId = "SipMediaApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let sipMediaApplicationId = self.sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// A target SIP media application and other details, such as priority and AWS Region, to be specified in the SIP rule. Only one SIP rule per AWS Region can be provided.
    public struct SipRuleTargetApplication: Swift.Equatable {
        /// The AWS Region of a rule's target SIP media application.
        public var awsRegion: Swift.String?
        /// The priority setting of a rule's target SIP media application.
        public var priority: Swift.Int?
        /// The ID of a rule's target SIP media application.
        public var sipMediaApplicationId: Swift.String?

        public init(
            awsRegion: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sipMediaApplicationId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.priority = priority
            self.sipMediaApplicationId = sipMediaApplicationId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum SipRuleTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requesturihostname
        case tophonenumber
        case sdkUnknown(Swift.String)

        public static var allCases: [SipRuleTriggerType] {
            return [
                .requesturihostname,
                .tophonenumber,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requesturihostname: return "RequestUriHostname"
            case .tophonenumber: return "ToPhoneNumber"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SipRuleTriggerType(rawValue: rawValue) ?? SipRuleTriggerType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.SpeakerSearchDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case results = "Results"
        case voiceprintGenerationStatus = "VoiceprintGenerationStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let results = results {
            var resultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .results)
            for speakersearchresult0 in results {
                try resultsContainer.encode(speakersearchresult0)
            }
        }
        if let voiceprintGenerationStatus = self.voiceprintGenerationStatus {
            try encodeContainer.encode(voiceprintGenerationStatus, forKey: .voiceprintGenerationStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SpeakerSearchResult?].self, forKey: .results)
        var resultsDecoded0:[ChimeSDKVoiceClientTypes.SpeakerSearchResult]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [ChimeSDKVoiceClientTypes.SpeakerSearchResult]()
            for structure0 in resultsContainer {
                if let structure0 = structure0 {
                    resultsDecoded0?.append(structure0)
                }
            }
        }
        results = resultsDecoded0
        let voiceprintGenerationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceprintGenerationStatus)
        voiceprintGenerationStatus = voiceprintGenerationStatusDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The details of a speaker search task.
    public struct SpeakerSearchDetails: Swift.Equatable {
        /// The result value in the speaker search details.
        public var results: [ChimeSDKVoiceClientTypes.SpeakerSearchResult]?
        /// The status of a voice print generation operation, VoiceprintGenerationSuccess or VoiceprintGenerationFailure..
        public var voiceprintGenerationStatus: Swift.String?

        public init(
            results: [ChimeSDKVoiceClientTypes.SpeakerSearchResult]? = nil,
            voiceprintGenerationStatus: Swift.String? = nil
        )
        {
            self.results = results
            self.voiceprintGenerationStatus = voiceprintGenerationStatus
        }
    }

}

extension ChimeSDKVoiceClientTypes.SpeakerSearchResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidenceScore = "ConfidenceScore"
        case voiceProfileId = "VoiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if confidenceScore != 0.0 {
            try encodeContainer.encode(confidenceScore, forKey: .confidenceScore)
        }
        if let voiceProfileId = self.voiceProfileId {
            try encodeContainer.encode(voiceProfileId, forKey: .voiceProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confidenceScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .confidenceScore) ?? 0.0
        confidenceScore = confidenceScoreDecoded
        let voiceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileId)
        voiceProfileId = voiceProfileIdDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The result of a speaker search analysis.
    public struct SpeakerSearchResult: Swift.Equatable {
        /// The confidence score in the speaker search analysis.
        public var confidenceScore: Swift.Float
        /// The voice profile ID.
        public var voiceProfileId: Swift.String?

        public init(
            confidenceScore: Swift.Float = 0.0,
            voiceProfileId: Swift.String? = nil
        )
        {
            self.confidenceScore = confidenceScore
            self.voiceProfileId = voiceProfileId
        }
    }

}

extension ChimeSDKVoiceClientTypes.SpeakerSearchTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callDetails = "CallDetails"
        case createdTimestamp = "CreatedTimestamp"
        case speakerSearchDetails = "SpeakerSearchDetails"
        case speakerSearchTaskId = "SpeakerSearchTaskId"
        case speakerSearchTaskStatus = "SpeakerSearchTaskStatus"
        case startedTimestamp = "StartedTimestamp"
        case statusMessage = "StatusMessage"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callDetails = self.callDetails {
            try encodeContainer.encode(callDetails, forKey: .callDetails)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let speakerSearchDetails = self.speakerSearchDetails {
            try encodeContainer.encode(speakerSearchDetails, forKey: .speakerSearchDetails)
        }
        if let speakerSearchTaskId = self.speakerSearchTaskId {
            try encodeContainer.encode(speakerSearchTaskId, forKey: .speakerSearchTaskId)
        }
        if let speakerSearchTaskStatus = self.speakerSearchTaskStatus {
            try encodeContainer.encode(speakerSearchTaskStatus, forKey: .speakerSearchTaskStatus)
        }
        if let startedTimestamp = self.startedTimestamp {
            try encodeContainer.encodeTimestamp(startedTimestamp, format: .dateTime, forKey: .startedTimestamp)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerSearchTaskId)
        speakerSearchTaskId = speakerSearchTaskIdDecoded
        let speakerSearchTaskStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerSearchTaskStatus)
        speakerSearchTaskStatus = speakerSearchTaskStatusDecoded
        let callDetailsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.CallDetails.self, forKey: .callDetails)
        callDetails = callDetailsDecoded
        let speakerSearchDetailsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SpeakerSearchDetails.self, forKey: .speakerSearchDetails)
        speakerSearchDetails = speakerSearchDetailsDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let startedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedTimestamp)
        startedTimestamp = startedTimestampDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// A representation of an asynchronous request to perform speaker search analysis on a Voice Connector call.
    public struct SpeakerSearchTask: Swift.Equatable {
        /// The call details of a speaker search task.
        public var callDetails: ChimeSDKVoiceClientTypes.CallDetails?
        /// The time at which a speaker search task was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The details of a speaker search task.
        public var speakerSearchDetails: ChimeSDKVoiceClientTypes.SpeakerSearchDetails?
        /// The speaker search task ID.
        public var speakerSearchTaskId: Swift.String?
        /// The status of the speaker search task, IN_QUEUE, IN_PROGRESS, PARTIAL_SUCCESS, SUCCEEDED, FAILED, or STOPPED.
        public var speakerSearchTaskStatus: Swift.String?
        /// The time at which the speaker search task began.
        public var startedTimestamp: ClientRuntime.Date?
        /// A detailed message about the status of a speaker search.
        public var statusMessage: Swift.String?
        /// The time at which a speaker search task was updated.
        public var updatedTimestamp: ClientRuntime.Date?

        public init(
            callDetails: ChimeSDKVoiceClientTypes.CallDetails? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            speakerSearchDetails: ChimeSDKVoiceClientTypes.SpeakerSearchDetails? = nil,
            speakerSearchTaskId: Swift.String? = nil,
            speakerSearchTaskStatus: Swift.String? = nil,
            startedTimestamp: ClientRuntime.Date? = nil,
            statusMessage: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.callDetails = callDetails
            self.createdTimestamp = createdTimestamp
            self.speakerSearchDetails = speakerSearchDetails
            self.speakerSearchTaskId = speakerSearchTaskId
            self.speakerSearchTaskStatus = speakerSearchTaskStatus
            self.startedTimestamp = startedTimestamp
            self.statusMessage = statusMessage
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension StartSpeakerSearchTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case transactionId = "TransactionId"
        case voiceProfileDomainId = "VoiceProfileDomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
    }
}

extension StartSpeakerSearchTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/speaker-search-tasks"
    }
}

public struct StartSpeakerSearchTaskInput: Swift.Equatable {
    /// The unique identifier for the client request. Use a different token for different speaker search tasks.
    public var clientRequestToken: Swift.String?
    /// The transaction ID of the call being analyzed.
    /// This member is required.
    public var transactionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?
    /// The ID of the voice profile domain that will store the voice profile.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        transactionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil,
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.transactionId = transactionId
        self.voiceConnectorId = voiceConnectorId
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct StartSpeakerSearchTaskInputBody: Swift.Equatable {
    let transactionId: Swift.String?
    let voiceProfileDomainId: Swift.String?
    let clientRequestToken: Swift.String?
}

extension StartSpeakerSearchTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case transactionId = "TransactionId"
        case voiceProfileDomainId = "VoiceProfileDomainId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

public enum StartSpeakerSearchTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GoneException": return try await GoneException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartSpeakerSearchTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSpeakerSearchTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.speakerSearchTask = output.speakerSearchTask
        } else {
            self.speakerSearchTask = nil
        }
    }
}

public struct StartSpeakerSearchTaskOutputResponse: Swift.Equatable {
    /// The details of the speaker search task.
    public var speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask?

    public init(
        speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask? = nil
    )
    {
        self.speakerSearchTask = speakerSearchTask
    }
}

struct StartSpeakerSearchTaskOutputResponseBody: Swift.Equatable {
    let speakerSearchTask: ChimeSDKVoiceClientTypes.SpeakerSearchTask?
}

extension StartSpeakerSearchTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTask = "SpeakerSearchTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SpeakerSearchTask.self, forKey: .speakerSearchTask)
        speakerSearchTask = speakerSearchTaskDecoded
    }
}

extension StartVoiceToneAnalysisTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case languageCode = "LanguageCode"
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension StartVoiceToneAnalysisTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/voice-tone-analysis-tasks"
    }
}

public struct StartVoiceToneAnalysisTaskInput: Swift.Equatable {
    /// The unique identifier for the client request. Use a different token for different voice tone analysis tasks.
    public var clientRequestToken: Swift.String?
    /// The language code.
    /// This member is required.
    public var languageCode: ChimeSDKVoiceClientTypes.LanguageCode?
    /// The transaction ID.
    /// This member is required.
    public var transactionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        languageCode: ChimeSDKVoiceClientTypes.LanguageCode? = nil,
        transactionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.languageCode = languageCode
        self.transactionId = transactionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct StartVoiceToneAnalysisTaskInputBody: Swift.Equatable {
    let transactionId: Swift.String?
    let languageCode: ChimeSDKVoiceClientTypes.LanguageCode?
    let clientRequestToken: Swift.String?
}

extension StartVoiceToneAnalysisTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case languageCode = "LanguageCode"
        case transactionId = "TransactionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

public enum StartVoiceToneAnalysisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GoneException": return try await GoneException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartVoiceToneAnalysisTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartVoiceToneAnalysisTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceToneAnalysisTask = output.voiceToneAnalysisTask
        } else {
            self.voiceToneAnalysisTask = nil
        }
    }
}

public struct StartVoiceToneAnalysisTaskOutputResponse: Swift.Equatable {
    /// The details of the voice tone analysis task.
    public var voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask?

    public init(
        voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask? = nil
    )
    {
        self.voiceToneAnalysisTask = voiceToneAnalysisTask
    }
}

struct StartVoiceToneAnalysisTaskOutputResponseBody: Swift.Equatable {
    let voiceToneAnalysisTask: ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask?
}

extension StartVoiceToneAnalysisTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceToneAnalysisTask = "VoiceToneAnalysisTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceToneAnalysisTaskDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask.self, forKey: .voiceToneAnalysisTask)
        voiceToneAnalysisTask = voiceToneAnalysisTaskDecoded
    }
}

extension StopSpeakerSearchTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "stop"))
            return items
        }
    }
}

extension StopSpeakerSearchTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let speakerSearchTaskId = speakerSearchTaskId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/speaker-search-tasks/\(speakerSearchTaskId.urlPercentEncoding())"
    }
}

public struct StopSpeakerSearchTaskInput: Swift.Equatable {
    /// The speaker search task ID.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        speakerSearchTaskId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.speakerSearchTaskId = speakerSearchTaskId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct StopSpeakerSearchTaskInputBody: Swift.Equatable {
}

extension StopSpeakerSearchTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum StopSpeakerSearchTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopSpeakerSearchTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopSpeakerSearchTaskOutputResponse: Swift.Equatable {

    public init() { }
}

extension StopVoiceToneAnalysisTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "stop"))
            return items
        }
    }
}

extension StopVoiceToneAnalysisTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let voiceToneAnalysisTaskId = voiceToneAnalysisTaskId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/voice-tone-analysis-tasks/\(voiceToneAnalysisTaskId.urlPercentEncoding())"
    }
}

public struct StopVoiceToneAnalysisTaskInput: Swift.Equatable {
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?
    /// The ID of the voice tone analysis task.
    /// This member is required.
    public var voiceToneAnalysisTaskId: Swift.String?

    public init(
        voiceConnectorId: Swift.String? = nil,
        voiceToneAnalysisTaskId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
        self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
    }
}

struct StopVoiceToneAnalysisTaskInputBody: Swift.Equatable {
}

extension StopVoiceToneAnalysisTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum StopVoiceToneAnalysisTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnprocessableEntityException": return try await UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopVoiceToneAnalysisTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopVoiceToneAnalysisTaskOutputResponse: Swift.Equatable {

    public init() { }
}

extension ChimeSDKVoiceClientTypes.StreamingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case disabled = "Disabled"
        case mediaInsightsConfiguration = "MediaInsightsConfiguration"
        case streamingNotificationTargets = "StreamingNotificationTargets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let mediaInsightsConfiguration = self.mediaInsightsConfiguration {
            try encodeContainer.encode(mediaInsightsConfiguration, forKey: .mediaInsightsConfiguration)
        }
        if let streamingNotificationTargets = streamingNotificationTargets {
            var streamingNotificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingNotificationTargets)
            for streamingnotificationtarget0 in streamingNotificationTargets {
                try streamingNotificationTargetsContainer.encode(streamingnotificationtarget0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let streamingNotificationTargetsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.StreamingNotificationTarget?].self, forKey: .streamingNotificationTargets)
        var streamingNotificationTargetsDecoded0:[ChimeSDKVoiceClientTypes.StreamingNotificationTarget]? = nil
        if let streamingNotificationTargetsContainer = streamingNotificationTargetsContainer {
            streamingNotificationTargetsDecoded0 = [ChimeSDKVoiceClientTypes.StreamingNotificationTarget]()
            for structure0 in streamingNotificationTargetsContainer {
                if let structure0 = structure0 {
                    streamingNotificationTargetsDecoded0?.append(structure0)
                }
            }
        }
        streamingNotificationTargets = streamingNotificationTargetsDecoded0
        let mediaInsightsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.MediaInsightsConfiguration.self, forKey: .mediaInsightsConfiguration)
        mediaInsightsConfiguration = mediaInsightsConfigurationDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The streaming configuration associated with an Amazon Chime SDK Voice Connector. Specifies whether media streaming is enabled for sending to Amazon Kinesis, and shows the retention period for the Amazon Kinesis data, in hours.
    public struct StreamingConfiguration: Swift.Equatable {
        /// The amount of time, in hours, to the Kinesis data.
        /// This member is required.
        public var dataRetentionInHours: Swift.Int?
        /// When true, streaming to Kinesis is off.
        /// This member is required.
        public var disabled: Swift.Bool?
        /// The call analytics configuration.
        public var mediaInsightsConfiguration: ChimeSDKVoiceClientTypes.MediaInsightsConfiguration?
        /// The streaming notification targets.
        public var streamingNotificationTargets: [ChimeSDKVoiceClientTypes.StreamingNotificationTarget]?

        public init(
            dataRetentionInHours: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            mediaInsightsConfiguration: ChimeSDKVoiceClientTypes.MediaInsightsConfiguration? = nil,
            streamingNotificationTargets: [ChimeSDKVoiceClientTypes.StreamingNotificationTarget]? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
            self.disabled = disabled
            self.mediaInsightsConfiguration = mediaInsightsConfiguration
            self.streamingNotificationTargets = streamingNotificationTargets
        }
    }

}

extension ChimeSDKVoiceClientTypes.StreamingNotificationTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationTarget = "NotificationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationTarget = self.notificationTarget {
            try encodeContainer.encode(notificationTarget.rawValue, forKey: .notificationTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationTargetDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.NotificationTarget.self, forKey: .notificationTarget)
        notificationTarget = notificationTargetDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The target recipient for a streaming configuration notification.
    public struct StreamingNotificationTarget: Swift.Equatable {
        /// The streaming notification target.
        public var notificationTarget: ChimeSDKVoiceClientTypes.NotificationTarget?

        public init(
            notificationTarget: ChimeSDKVoiceClientTypes.NotificationTarget? = nil
        )
        {
            self.notificationTarget = notificationTarget
        }
    }

}

extension ChimeSDKVoiceClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag: Swift.Equatable {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(tags: \(Swift.String(describing: tags)), resourceARN: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource being tagged.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of the tags being added to the resource.
    /// This member is required.
    public var tags: [ChimeSDKVoiceClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKVoiceClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeSDKVoiceClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKVoiceClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKVoiceClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension ChimeSDKVoiceClientTypes.Termination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingRegions = "CallingRegions"
        case cidrAllowedList = "CidrAllowedList"
        case cpsLimit = "CpsLimit"
        case defaultPhoneNumber = "DefaultPhoneNumber"
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingRegions = callingRegions {
            var callingRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callingRegions)
            for callingregion0 in callingRegions {
                try callingRegionsContainer.encode(callingregion0)
            }
        }
        if let cidrAllowedList = cidrAllowedList {
            var cidrAllowedListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowedList)
            for string0 in cidrAllowedList {
                try cidrAllowedListContainer.encode(string0)
            }
        }
        if let cpsLimit = self.cpsLimit {
            try encodeContainer.encode(cpsLimit, forKey: .cpsLimit)
        }
        if let defaultPhoneNumber = self.defaultPhoneNumber {
            try encodeContainer.encode(defaultPhoneNumber, forKey: .defaultPhoneNumber)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpsLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpsLimit)
        cpsLimit = cpsLimitDecoded
        let defaultPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultPhoneNumber)
        defaultPhoneNumber = defaultPhoneNumberDecoded
        let callingRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .callingRegions)
        var callingRegionsDecoded0:[Swift.String]? = nil
        if let callingRegionsContainer = callingRegionsContainer {
            callingRegionsDecoded0 = [Swift.String]()
            for string0 in callingRegionsContainer {
                if let string0 = string0 {
                    callingRegionsDecoded0?.append(string0)
                }
            }
        }
        callingRegions = callingRegionsDecoded0
        let cidrAllowedListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowedList)
        var cidrAllowedListDecoded0:[Swift.String]? = nil
        if let cidrAllowedListContainer = cidrAllowedListContainer {
            cidrAllowedListDecoded0 = [Swift.String]()
            for string0 in cidrAllowedListContainer {
                if let string0 = string0 {
                    cidrAllowedListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowedList = cidrAllowedListDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Termination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Termination(callingRegions: \(Swift.String(describing: callingRegions)), cidrAllowedList: \(Swift.String(describing: cidrAllowedList)), cpsLimit: \(Swift.String(describing: cpsLimit)), disabled: \(Swift.String(describing: disabled)), defaultPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// Termination settings enable SIP hosts to make outbound calls using an Amazon Chime SDK Voice Connector.
    public struct Termination: Swift.Equatable {
        /// The countries to which calls are allowed, in ISO 3166-1 alpha-2 format. Required.
        public var callingRegions: [Swift.String]?
        /// The IP addresses allowed to make calls, in CIDR format.
        public var cidrAllowedList: [Swift.String]?
        /// The limit on calls per second. Max value based on account service quota. Default value of 1.
        public var cpsLimit: Swift.Int?
        /// The default outbound calling number.
        public var defaultPhoneNumber: Swift.String?
        /// When termination is disabled, outbound calls cannot be made.
        public var disabled: Swift.Bool?

        public init(
            callingRegions: [Swift.String]? = nil,
            cidrAllowedList: [Swift.String]? = nil,
            cpsLimit: Swift.Int? = nil,
            defaultPhoneNumber: Swift.String? = nil,
            disabled: Swift.Bool? = nil
        )
        {
            self.callingRegions = callingRegions
            self.cidrAllowedList = cidrAllowedList
            self.cpsLimit = cpsLimit
            self.defaultPhoneNumber = defaultPhoneNumber
            self.disabled = disabled
        }
    }

}

extension ChimeSDKVoiceClientTypes.TerminationHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .dateTime, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .timestamp)
        timestamp = timestampDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The termination health details, including the source IP address and timestamp of the last successful SIP OPTIONS message from your SIP infrastructure.
    public struct TerminationHealth: Swift.Equatable {
        /// The source IP address.
        public var source: Swift.String?
        /// The timestamp, in ISO 8601 format.
        public var timestamp: ClientRuntime.Date?

        public init(
            source: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.source = source
            self.timestamp = timestamp
        }
    }

}

extension ThrottledClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of customer requests exceeds the request rate limit.
public struct ThrottledClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client isn't authorized to request a resource.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableEntityException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A well-formed request couldn't be followed due to semantic errors.
public struct UnprocessableEntityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKVoiceClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnprocessableEntityException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UnprocessableEntityExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnprocessableEntityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(tagKeys: \(Swift.String(describing: tagKeys)), resourceARN: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource having its tags removed.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags being removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

public enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension UpdateGlobalSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceConnector = self.voiceConnector {
            try encodeContainer.encode(voiceConnector, forKey: .voiceConnector)
        }
    }
}

extension UpdateGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings"
    }
}

public struct UpdateGlobalSettingsInput: Swift.Equatable {
    /// The Voice Connector settings.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct UpdateGlobalSettingsInputBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?
}

extension UpdateGlobalSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

public enum UpdateGlobalSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGlobalSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension UpdatePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberInput(productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\", phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension UpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

extension UpdatePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct UpdatePhoneNumberInput: Swift.Equatable {
    /// The outbound calling name associated with the phone number.
    public var callingName: Swift.String?
    /// The phone number ID.
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// The product type.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

    public init(
        callingName: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.callingName = callingName
        self.phoneNumberId = phoneNumberId
        self.productType = productType
    }
}

struct UpdatePhoneNumberInputBody: Swift.Equatable {
    let productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
    let callingName: Swift.String?
}

extension UpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case productType = "ProductType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

public enum UpdatePhoneNumberOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct UpdatePhoneNumberOutputResponse: Swift.Equatable {
    /// The updated phone number details.
    public var phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?

    public init(
        phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct UpdatePhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?
}

extension UpdatePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberRequestItem(productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\", phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The phone number ID, product type, or calling name fields to update, used with the [BatchUpdatePhoneNumber] and [UpdatePhoneNumber] actions.
    public struct UpdatePhoneNumberRequestItem: Swift.Equatable {
        /// The outbound calling name to update.
        public var callingName: Swift.String?
        /// The phone number ID to update.
        /// This member is required.
        public var phoneNumberId: Swift.String?
        /// The product type to update.
        public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

        public init(
            callingName: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
        )
        {
            self.callingName = callingName
            self.phoneNumberId = phoneNumberId
            self.productType = productType
        }
    }

}

extension UpdatePhoneNumberSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberSettingsInput(callingName: \"CONTENT_REDACTED\")"}
}

extension UpdatePhoneNumberSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
    }
}

extension UpdatePhoneNumberSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings/phone-number"
    }
}

public struct UpdatePhoneNumberSettingsInput: Swift.Equatable {
    /// The default outbound calling name for the account.
    /// This member is required.
    public var callingName: Swift.String?

    public init(
        callingName: Swift.String? = nil
    )
    {
        self.callingName = callingName
    }
}

struct UpdatePhoneNumberSettingsInputBody: Swift.Equatable {
    let callingName: Swift.String?
}

extension UpdatePhoneNumberSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

public enum UpdatePhoneNumberSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePhoneNumberSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePhoneNumberSettingsOutputResponse: Swift.Equatable {

    public init() { }
}

extension UpdateProxySessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
    }
}

extension UpdateProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct UpdateProxySessionInput: Swift.Equatable {
    /// The proxy session capabilities.
    /// This member is required.
    public var capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    /// The number of minutes allowed for the proxy session.
    public var expiryMinutes: Swift.Int?
    /// The proxy session ID.
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        capabilities: [ChimeSDKVoiceClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateProxySessionInputBody: Swift.Equatable {
    let capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    let expiryMinutes: Swift.Int?
}

extension UpdateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeSDKVoiceClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeSDKVoiceClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
    }
}

public enum UpdateProxySessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProxySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct UpdateProxySessionOutputResponse: Swift.Equatable {
    /// The updated proxy session details.
    public var proxySession: ChimeSDKVoiceClientTypes.ProxySession?

    public init(
        proxySession: ChimeSDKVoiceClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct UpdateProxySessionOutputResponseBody: Swift.Equatable {
    let proxySession: ChimeSDKVoiceClientTypes.ProxySession?
}

extension UpdateProxySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

extension UpdateSipMediaApplicationCallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .arguments)
            for (dictKey0, smaUpdateCallArgumentsMap0) in arguments {
                try argumentsContainer.encode(smaUpdateCallArgumentsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateSipMediaApplicationCallInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        guard let transactionId = transactionId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls/\(transactionId.urlPercentEncoding())"
    }
}

public struct UpdateSipMediaApplicationCallInput: Swift.Equatable {
    /// Arguments made available to the Lambda function as part of the CALL_UPDATE_REQUESTED event. Can contain 0-20 key-value pairs.
    /// This member is required.
    public var arguments: [Swift.String:Swift.String]?
    /// The ID of the SIP media application handling the call.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// The ID of the call transaction.
    /// This member is required.
    public var transactionId: Swift.String?

    public init(
        arguments: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.arguments = arguments
        self.sipMediaApplicationId = sipMediaApplicationId
        self.transactionId = transactionId
    }
}

struct UpdateSipMediaApplicationCallInputBody: Swift.Equatable {
    let arguments: [Swift.String:Swift.String]?
}

extension UpdateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let argumentsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .arguments)
        var argumentsDecoded0: [Swift.String:Swift.String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in argumentsContainer {
                if let sensitivestring0 = sensitivestring0 {
                    argumentsDecoded0?[key0] = sensitivestring0
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

public enum UpdateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSipMediaApplicationCallOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSipMediaApplicationCallOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct UpdateSipMediaApplicationCallOutputResponse: Swift.Equatable {
    /// A Call instance for a SIP media application.
    public var sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?

    public init(
        sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct UpdateSipMediaApplicationCallOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?
}

extension UpdateSipMediaApplicationCallOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

extension UpdateSipMediaApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct UpdateSipMediaApplicationInput: Swift.Equatable {
    /// The new set of endpoints for the specified SIP media application.
    public var endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
    /// The new name for the specified SIP media application.
    public var name: Swift.String?
    /// The SIP media application ID.
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init(
        endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.name = name
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct UpdateSipMediaApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
}

extension UpdateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

public enum UpdateSipMediaApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSipMediaApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct UpdateSipMediaApplicationOutputResponse: Swift.Equatable {
    /// The updated SIP media application’s details.
    public var sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?

    public init(
        sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct UpdateSipMediaApplicationOutputResponseBody: Swift.Equatable {
    let sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?
}

extension UpdateSipMediaApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

extension UpdateSipRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
    }
}

extension UpdateSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipRuleId = sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct UpdateSipRuleInput: Swift.Equatable {
    /// The new value that indicates whether the rule is disabled.
    public var disabled: Swift.Bool?
    /// The new name for the specified SIP rule.
    /// This member is required.
    public var name: Swift.String?
    /// The SIP rule ID.
    /// This member is required.
    public var sipRuleId: Swift.String?
    /// The new list of target applications.
    public var targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?

    public init(
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        sipRuleId: Swift.String? = nil,
        targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.sipRuleId = sipRuleId
        self.targetApplications = targetApplications
    }
}

struct UpdateSipRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let disabled: Swift.Bool?
    let targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
}

extension UpdateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

public enum UpdateSipRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSipRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct UpdateSipRuleOutputResponse: Swift.Equatable {
    /// The updated SIP rule details.
    public var sipRule: ChimeSDKVoiceClientTypes.SipRule?

    public init(
        sipRule: ChimeSDKVoiceClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct UpdateSipRuleOutputResponseBody: Swift.Equatable {
    let sipRule: ChimeSDKVoiceClientTypes.SipRule?
}

extension UpdateSipRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

extension UpdateVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }
}

extension UpdateVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceConnectorGroupInput: Swift.Equatable {
    /// The name of the Voice Connector group.
    /// This member is required.
    public var name: Swift.String?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?
    /// The VoiceConnectorItems to associate with the Voice Connector group.
    /// This member is required.
    public var voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?

    public init(
        name: Swift.String? = nil,
        voiceConnectorGroupId: Swift.String? = nil,
        voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorGroupId = voiceConnectorGroupId
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct UpdateVoiceConnectorGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?
}

extension UpdateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

public enum UpdateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct UpdateVoiceConnectorGroupOutputResponse: Swift.Equatable {
    /// The updated Voice Connector group.
    public var voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?

    public init(
        voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct UpdateVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?
}

extension UpdateVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

extension UpdateVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
    }
}

extension UpdateVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceConnectorInput: Swift.Equatable {
    /// The name of the Voice Connector.
    /// This member is required.
    public var name: Swift.String?
    /// When enabled, requires encryption for the Voice Connector.
    /// This member is required.
    public var requireEncryption: Swift.Bool?
    /// The Voice Connector ID.
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init(
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.name = name
        self.requireEncryption = requireEncryption
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateVoiceConnectorInputBody: Swift.Equatable {
    let name: Swift.String?
    let requireEncryption: Swift.Bool?
}

extension UpdateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
    }
}

public enum UpdateVoiceConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct UpdateVoiceConnectorOutputResponse: Swift.Equatable {
    /// The updated Voice Connector details.
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?

    public init(
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct UpdateVoiceConnectorOutputResponseBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?
}

extension UpdateVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension UpdateVoiceProfileDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateVoiceProfileDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceProfileDomainId = voiceProfileDomainId else {
            return nil
        }
        return "/voice-profile-domains/\(voiceProfileDomainId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceProfileDomainInput: Swift.Equatable {
    /// The description of the voice profile domain.
    public var description: Swift.String?
    /// The name of the voice profile domain.
    public var name: Swift.String?
    /// The domain ID.
    /// This member is required.
    public var voiceProfileDomainId: Swift.String?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        voiceProfileDomainId: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.voiceProfileDomainId = voiceProfileDomainId
    }
}

struct UpdateVoiceProfileDomainInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateVoiceProfileDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

public enum UpdateVoiceProfileDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceProfileDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceProfileDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfileDomain = output.voiceProfileDomain
        } else {
            self.voiceProfileDomain = nil
        }
    }
}

public struct UpdateVoiceProfileDomainOutputResponse: Swift.Equatable {
    /// The updated details of the voice profile domain.
    public var voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?

    public init(
        voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain? = nil
    )
    {
        self.voiceProfileDomain = voiceProfileDomain
    }
}

struct UpdateVoiceProfileDomainOutputResponseBody: Swift.Equatable {
    let voiceProfileDomain: ChimeSDKVoiceClientTypes.VoiceProfileDomain?
}

extension UpdateVoiceProfileDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfileDomain = "VoiceProfileDomain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfileDomain.self, forKey: .voiceProfileDomain)
        voiceProfileDomain = voiceProfileDomainDecoded
    }
}

extension UpdateVoiceProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTaskId = "SpeakerSearchTaskId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let speakerSearchTaskId = self.speakerSearchTaskId {
            try encodeContainer.encode(speakerSearchTaskId, forKey: .speakerSearchTaskId)
        }
    }
}

extension UpdateVoiceProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceProfileId = voiceProfileId else {
            return nil
        }
        return "/voice-profiles/\(voiceProfileId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceProfileInput: Swift.Equatable {
    /// The ID of the speaker search task.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?
    /// The profile ID.
    /// This member is required.
    public var voiceProfileId: Swift.String?

    public init(
        speakerSearchTaskId: Swift.String? = nil,
        voiceProfileId: Swift.String? = nil
    )
    {
        self.speakerSearchTaskId = speakerSearchTaskId
        self.voiceProfileId = voiceProfileId
    }
}

struct UpdateVoiceProfileInputBody: Swift.Equatable {
    let speakerSearchTaskId: Swift.String?
}

extension UpdateVoiceProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speakerSearchTaskId = "SpeakerSearchTaskId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSearchTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerSearchTaskId)
        speakerSearchTaskId = speakerSearchTaskIdDecoded
    }
}

public enum UpdateVoiceProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GoneException": return try await GoneException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVoiceProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVoiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceProfile = output.voiceProfile
        } else {
            self.voiceProfile = nil
        }
    }
}

public struct UpdateVoiceProfileOutputResponse: Swift.Equatable {
    /// The updated voice profile settings.
    public var voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?

    public init(
        voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile? = nil
    )
    {
        self.voiceProfile = voiceProfile
    }
}

struct UpdateVoiceProfileOutputResponseBody: Swift.Equatable {
    let voiceProfile: ChimeSDKVoiceClientTypes.VoiceProfile?
}

extension UpdateVoiceProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceProfile = "VoiceProfile"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceProfile.self, forKey: .voiceProfile)
        voiceProfile = voiceProfileDecoded
    }
}

extension ValidateE911AddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateE911AddressInput(awsAccountId: \(Swift.String(describing: awsAccountId)), city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

extension ValidateE911AddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case city = "City"
        case country = "Country"
        case postalCode = "PostalCode"
        case state = "State"
        case streetInfo = "StreetInfo"
        case streetNumber = "StreetNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetInfo = self.streetInfo {
            try encodeContainer.encode(streetInfo, forKey: .streetInfo)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
    }
}

extension ValidateE911AddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/emergency-calling/address"
    }
}

public struct ValidateE911AddressInput: Swift.Equatable {
    /// The AWS account ID.
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// The address city, such as Portland.
    /// This member is required.
    public var city: Swift.String?
    /// The country in the address being validated.
    /// This member is required.
    public var country: Swift.String?
    /// The dress postal code, such 04352.
    /// This member is required.
    public var postalCode: Swift.String?
    /// The address state, such as ME.
    /// This member is required.
    public var state: Swift.String?
    /// The address street information, such as 8th Avenue.
    /// This member is required.
    public var streetInfo: Swift.String?
    /// The address street number, such as 200 or 2121.
    /// This member is required.
    public var streetNumber: Swift.String?

    public init(
        awsAccountId: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        postalCode: Swift.String? = nil,
        state: Swift.String? = nil,
        streetInfo: Swift.String? = nil,
        streetNumber: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.city = city
        self.country = country
        self.postalCode = postalCode
        self.state = state
        self.streetInfo = streetInfo
        self.streetNumber = streetNumber
    }
}

struct ValidateE911AddressInputBody: Swift.Equatable {
    let awsAccountId: Swift.String?
    let streetNumber: Swift.String?
    let streetInfo: Swift.String?
    let city: Swift.String?
    let state: Swift.String?
    let country: Swift.String?
    let postalCode: Swift.String?
}

extension ValidateE911AddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case city = "City"
        case country = "Country"
        case postalCode = "PostalCode"
        case state = "State"
        case streetInfo = "StreetInfo"
        case streetNumber = "StreetNumber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let streetInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetInfo)
        streetInfo = streetInfoDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
    }
}

public enum ValidateE911AddressOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidateE911AddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidateE911AddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
            self.addressExternalId = output.addressExternalId
            self.candidateAddressList = output.candidateAddressList
            self.validationResult = output.validationResult
        } else {
            self.address = nil
            self.addressExternalId = nil
            self.candidateAddressList = nil
            self.validationResult = 0
        }
    }
}

public struct ValidateE911AddressOutputResponse: Swift.Equatable {
    /// The validated address.
    public var address: ChimeSDKVoiceClientTypes.Address?
    /// The ID that represents the address.
    public var addressExternalId: Swift.String?
    /// The list of address suggestions..
    public var candidateAddressList: [ChimeSDKVoiceClientTypes.CandidateAddress]?
    /// Number indicating the result of address validation. 0 means the address was perfect as-is and successfully validated. 1 means the address was corrected. 2 means the address sent was not close enough and was not validated.
    public var validationResult: Swift.Int

    public init(
        address: ChimeSDKVoiceClientTypes.Address? = nil,
        addressExternalId: Swift.String? = nil,
        candidateAddressList: [ChimeSDKVoiceClientTypes.CandidateAddress]? = nil,
        validationResult: Swift.Int = 0
    )
    {
        self.address = address
        self.addressExternalId = addressExternalId
        self.candidateAddressList = candidateAddressList
        self.validationResult = validationResult
    }
}

struct ValidateE911AddressOutputResponseBody: Swift.Equatable {
    let validationResult: Swift.Int
    let addressExternalId: Swift.String?
    let address: ChimeSDKVoiceClientTypes.Address?
    let candidateAddressList: [ChimeSDKVoiceClientTypes.CandidateAddress]?
}

extension ValidateE911AddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressExternalId = "AddressExternalId"
        case candidateAddressList = "CandidateAddressList"
        case validationResult = "ValidationResult"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationResult) ?? 0
        validationResult = validationResultDecoded
        let addressExternalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressExternalId)
        addressExternalId = addressExternalIdDecoded
        let addressDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Address.self, forKey: .address)
        address = addressDecoded
        let candidateAddressListContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.CandidateAddress?].self, forKey: .candidateAddressList)
        var candidateAddressListDecoded0:[ChimeSDKVoiceClientTypes.CandidateAddress]? = nil
        if let candidateAddressListContainer = candidateAddressListContainer {
            candidateAddressListDecoded0 = [ChimeSDKVoiceClientTypes.CandidateAddress]()
            for structure0 in candidateAddressListContainer {
                if let structure0 = structure0 {
                    candidateAddressListDecoded0?.append(structure0)
                }
            }
        }
        candidateAddressList = candidateAddressListDecoded0
    }
}

extension ChimeSDKVoiceClientTypes.VoiceConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case outboundHostName = "OutboundHostName"
        case requireEncryption = "RequireEncryption"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorArn = "VoiceConnectorArn"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundHostName = self.outboundHostName {
            try encodeContainer.encode(outboundHostName, forKey: .outboundHostName)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorArn = self.voiceConnectorArn {
            try encodeContainer.encode(voiceConnectorArn, forKey: .voiceConnectorArn)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outboundHostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundHostName)
        outboundHostName = outboundHostNameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let voiceConnectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorArn)
        voiceConnectorArn = voiceConnectorArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The Amazon Chime SDK Voice Connector configuration, including outbound host name and encryption settings.
    public struct VoiceConnector: Swift.Equatable {
        /// The AWS Region in which the Voice Connector is created. Default: us-east-1.
        public var awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?
        /// The Voice Connector's creation timestamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The Voice Connector's name.
        public var name: Swift.String?
        /// The outbound host name for the Voice Connector.
        public var outboundHostName: Swift.String?
        /// Enables or disables encryption for the Voice Connector.
        public var requireEncryption: Swift.Bool?
        /// The Voice Connector's updated timestamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the Voice Connector.
        public var voiceConnectorArn: Swift.String?
        /// The Voice Connector's ID.
        public var voiceConnectorId: Swift.String?

        public init(
            awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            outboundHostName: Swift.String? = nil,
            requireEncryption: Swift.Bool? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorArn: Swift.String? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.outboundHostName = outboundHostName
            self.requireEncryption = requireEncryption
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorArn = voiceConnectorArn
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum VoiceConnectorAwsRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apNortheast1
        case apNortheast2
        case apSoutheast1
        case apSoutheast2
        case caCentral1
        case euCentral1
        case euWest1
        case euWest2
        case usEast1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceConnectorAwsRegion] {
            return [
                .apNortheast1,
                .apNortheast2,
                .apSoutheast1,
                .apSoutheast2,
                .caCentral1,
                .euCentral1,
                .euWest1,
                .euWest2,
                .usEast1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .caCentral1: return "ca-central-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .usEast1: return "us-east-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceConnectorAwsRegion(rawValue: rawValue) ?? VoiceConnectorAwsRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.VoiceConnectorGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorGroupArn = "VoiceConnectorGroupArn"
        case voiceConnectorGroupId = "VoiceConnectorGroupId"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorGroupArn = self.voiceConnectorGroupArn {
            try encodeContainer.encode(voiceConnectorGroupArn, forKey: .voiceConnectorGroupArn)
        }
        if let voiceConnectorGroupId = self.voiceConnectorGroupId {
            try encodeContainer.encode(voiceConnectorGroupId, forKey: .voiceConnectorGroupId)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorGroupId)
        voiceConnectorGroupId = voiceConnectorGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let voiceConnectorGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorGroupArn)
        voiceConnectorGroupArn = voiceConnectorGroupArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The Amazon Chime SDK Voice Connector group configuration, including associated Voice Connectors. You can include Voice Connectors from different AWS Regions in a group. This creates a fault tolerant mechanism for fallback in case of availability events.
    public struct VoiceConnectorGroup: Swift.Equatable {
        /// The Voice Connector group's creation time stamp, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The name of a Voice Connector group.
        public var name: Swift.String?
        /// The Voice Connector group's creation time stamp, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the Voice Connector group.
        public var voiceConnectorGroupArn: Swift.String?
        /// The ID of a Voice Connector group.
        public var voiceConnectorGroupId: Swift.String?
        /// The Voice Connectors to which you route inbound calls.
        public var voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorGroupArn: Swift.String? = nil,
            voiceConnectorGroupId: Swift.String? = nil,
            voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorGroupArn = voiceConnectorGroupArn
            self.voiceConnectorGroupId = voiceConnectorGroupId
            self.voiceConnectorItems = voiceConnectorItems
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceConnectorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// For Amazon Chime SDK Voice Connector groups, the Amazon Chime SDK Voice Connectors to which you route inbound calls. Includes priority configuration settings. Limit: 3 VoiceConnectorItems per Voice Connector group.
    public struct VoiceConnectorItem: Swift.Equatable {
        /// The priority setting of a Voice Connector item. Calls are routed to hosts in priority order, with 1 as the highest priority. When hosts have equal priority, the system distributes calls among them based on their relative weight.
        /// This member is required.
        public var priority: Swift.Int?
        /// The Voice Connector ID.
        /// This member is required.
        public var voiceConnectorId: Swift.String?

        public init(
            priority: Swift.Int? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.priority = priority
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceConnectorSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdrBucket = "CdrBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdrBucket = self.cdrBucket {
            try encodeContainer.encode(cdrBucket, forKey: .cdrBucket)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdrBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdrBucket)
        cdrBucket = cdrBucketDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// The Amazon Chime SDK Voice Connector settings. Includes any Amazon S3 buckets designated for storing call detail records.
    public struct VoiceConnectorSettings: Swift.Equatable {
        /// The S3 bucket that stores the Voice Connector's call detail records.
        public var cdrBucket: Swift.String?

        public init(
            cdrBucket: Swift.String? = nil
        )
        {
            self.cdrBucket = cdrBucket
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case expirationTimestamp = "ExpirationTimestamp"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceProfileArn = "VoiceProfileArn"
        case voiceProfileDomainId = "VoiceProfileDomainId"
        case voiceProfileId = "VoiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let expirationTimestamp = self.expirationTimestamp {
            try encodeContainer.encodeTimestamp(expirationTimestamp, format: .dateTime, forKey: .expirationTimestamp)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceProfileArn = self.voiceProfileArn {
            try encodeContainer.encode(voiceProfileArn, forKey: .voiceProfileArn)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
        if let voiceProfileId = self.voiceProfileId {
            try encodeContainer.encode(voiceProfileId, forKey: .voiceProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileId)
        voiceProfileId = voiceProfileIdDecoded
        let voiceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileArn)
        voiceProfileArn = voiceProfileArnDecoded
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let expirationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expirationTimestamp)
        expirationTimestamp = expirationTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes.VoiceProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceProfile(createdTimestamp: \(Swift.String(describing: createdTimestamp)), expirationTimestamp: \(Swift.String(describing: expirationTimestamp)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceProfileDomainId: \(Swift.String(describing: voiceProfileDomainId)), voiceProfileId: \(Swift.String(describing: voiceProfileId)), voiceProfileArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// The combination of a voice print and caller ID.
    public struct VoiceProfile: Swift.Equatable {
        /// The time at which the voice profile was created and enrolled.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a voice profile expires unless you re-enroll the caller via the UpdateVoiceProfile API.
        public var expirationTimestamp: ClientRuntime.Date?
        /// The time at which the voice profile was last updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the voice profile.
        public var voiceProfileArn: Swift.String?
        /// The ID of the domain that contains the voice profile.
        public var voiceProfileDomainId: Swift.String?
        /// The ID of the voice profile.
        public var voiceProfileId: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            expirationTimestamp: ClientRuntime.Date? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceProfileArn: Swift.String? = nil,
            voiceProfileDomainId: Swift.String? = nil,
            voiceProfileId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.expirationTimestamp = expirationTimestamp
            self.updatedTimestamp = updatedTimestamp
            self.voiceProfileArn = voiceProfileArn
            self.voiceProfileDomainId = voiceProfileDomainId
            self.voiceProfileId = voiceProfileId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceProfileDomain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceProfileDomainArn = "VoiceProfileDomainArn"
        case voiceProfileDomainId = "VoiceProfileDomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceProfileDomainArn = self.voiceProfileDomainArn {
            try encodeContainer.encode(voiceProfileDomainArn, forKey: .voiceProfileDomainArn)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let voiceProfileDomainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainArn)
        voiceProfileDomainArn = voiceProfileDomainArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes.VoiceProfileDomain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceProfileDomain(createdTimestamp: \(Swift.String(describing: createdTimestamp)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceProfileDomainId: \(Swift.String(describing: voiceProfileDomainId)), voiceProfileDomainArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A collection of voice profiles.
    public struct VoiceProfileDomain: Swift.Equatable {
        /// The time at which the voice profile domain was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The description of the voice profile domain.
        public var description: Swift.String?
        /// The name of the voice profile domain.
        public var name: Swift.String?
        /// A structure that contains the configuration settings for server-side encryption.
        public var serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration?
        /// The time at which the voice profile was last updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The voice profile domain's Amazon Resource Number (ARN).
        public var voiceProfileDomainArn: Swift.String?
        /// The ID of the voice profile domain.
        public var voiceProfileDomainId: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: ChimeSDKVoiceClientTypes.ServerSideEncryptionConfiguration? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceProfileDomainArn: Swift.String? = nil,
            voiceProfileDomainId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.updatedTimestamp = updatedTimestamp
            self.voiceProfileDomainArn = voiceProfileDomainArn
            self.voiceProfileDomainId = voiceProfileDomainId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case description = "Description"
        case name = "Name"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceProfileDomainArn = "VoiceProfileDomainArn"
        case voiceProfileDomainId = "VoiceProfileDomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceProfileDomainArn = self.voiceProfileDomainArn {
            try encodeContainer.encode(voiceProfileDomainArn, forKey: .voiceProfileDomainArn)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let voiceProfileDomainArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainArn)
        voiceProfileDomainArn = voiceProfileDomainArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes.VoiceProfileDomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceProfileDomainSummary(createdTimestamp: \(Swift.String(describing: createdTimestamp)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceProfileDomainId: \(Swift.String(describing: voiceProfileDomainId)), voiceProfileDomainArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A high-level overview of a voice profile domain.
    public struct VoiceProfileDomainSummary: Swift.Equatable {
        /// The time at which the voice profile domain summary was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// Describes the voice profile domain summary.
        public var description: Swift.String?
        /// The name of the voice profile domain summary.
        public var name: Swift.String?
        /// The time at which the voice profile domain summary was last updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of a voice profile in a voice profile domain summary.
        public var voiceProfileDomainArn: Swift.String?
        /// The ID of the voice profile domain summary.
        public var voiceProfileDomainId: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceProfileDomainArn: Swift.String? = nil,
            voiceProfileDomainId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.description = description
            self.name = name
            self.updatedTimestamp = updatedTimestamp
            self.voiceProfileDomainArn = voiceProfileDomainArn
            self.voiceProfileDomainId = voiceProfileDomainId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case expirationTimestamp = "ExpirationTimestamp"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceProfileArn = "VoiceProfileArn"
        case voiceProfileDomainId = "VoiceProfileDomainId"
        case voiceProfileId = "VoiceProfileId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let expirationTimestamp = self.expirationTimestamp {
            try encodeContainer.encodeTimestamp(expirationTimestamp, format: .dateTime, forKey: .expirationTimestamp)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceProfileArn = self.voiceProfileArn {
            try encodeContainer.encode(voiceProfileArn, forKey: .voiceProfileArn)
        }
        if let voiceProfileDomainId = self.voiceProfileDomainId {
            try encodeContainer.encode(voiceProfileDomainId, forKey: .voiceProfileDomainId)
        }
        if let voiceProfileId = self.voiceProfileId {
            try encodeContainer.encode(voiceProfileId, forKey: .voiceProfileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileId)
        voiceProfileId = voiceProfileIdDecoded
        let voiceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileArn)
        voiceProfileArn = voiceProfileArnDecoded
        let voiceProfileDomainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceProfileDomainId)
        voiceProfileDomainId = voiceProfileDomainIdDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let expirationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expirationTimestamp)
        expirationTimestamp = expirationTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes.VoiceProfileSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VoiceProfileSummary(createdTimestamp: \(Swift.String(describing: createdTimestamp)), expirationTimestamp: \(Swift.String(describing: expirationTimestamp)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), voiceProfileDomainId: \(Swift.String(describing: voiceProfileDomainId)), voiceProfileId: \(Swift.String(describing: voiceProfileId)), voiceProfileArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    /// A high-level summary of a voice profile.
    public struct VoiceProfileSummary: Swift.Equatable {
        /// The time at which a voice profile summary was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// Extends the life of the voice profile. You can use UpdateVoiceProfile to refresh an existing voice profile's voice print and extend the life of the summary.
        public var expirationTimestamp: ClientRuntime.Date?
        /// The time at which a voice profile summary was last updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ARN of the voice profile in a voice profile summary.
        public var voiceProfileArn: Swift.String?
        /// The ID of the voice profile domain in a voice profile summary.
        public var voiceProfileDomainId: Swift.String?
        /// The ID of the voice profile in a voice profile summary.
        public var voiceProfileId: Swift.String?

        public init(
            createdTimestamp: ClientRuntime.Date? = nil,
            expirationTimestamp: ClientRuntime.Date? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceProfileArn: Swift.String? = nil,
            voiceProfileDomainId: Swift.String? = nil,
            voiceProfileId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.expirationTimestamp = expirationTimestamp
            self.updatedTimestamp = updatedTimestamp
            self.voiceProfileArn = voiceProfileArn
            self.voiceProfileDomainId = voiceProfileDomainId
            self.voiceProfileId = voiceProfileId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceToneAnalysisTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callDetails = "CallDetails"
        case createdTimestamp = "CreatedTimestamp"
        case startedTimestamp = "StartedTimestamp"
        case statusMessage = "StatusMessage"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceToneAnalysisTaskId = "VoiceToneAnalysisTaskId"
        case voiceToneAnalysisTaskStatus = "VoiceToneAnalysisTaskStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callDetails = self.callDetails {
            try encodeContainer.encode(callDetails, forKey: .callDetails)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let startedTimestamp = self.startedTimestamp {
            try encodeContainer.encodeTimestamp(startedTimestamp, format: .dateTime, forKey: .startedTimestamp)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceToneAnalysisTaskId = self.voiceToneAnalysisTaskId {
            try encodeContainer.encode(voiceToneAnalysisTaskId, forKey: .voiceToneAnalysisTaskId)
        }
        if let voiceToneAnalysisTaskStatus = self.voiceToneAnalysisTaskStatus {
            try encodeContainer.encode(voiceToneAnalysisTaskStatus, forKey: .voiceToneAnalysisTaskStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceToneAnalysisTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceToneAnalysisTaskId)
        voiceToneAnalysisTaskId = voiceToneAnalysisTaskIdDecoded
        let voiceToneAnalysisTaskStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceToneAnalysisTaskStatus)
        voiceToneAnalysisTaskStatus = voiceToneAnalysisTaskStatusDecoded
        let callDetailsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.CallDetails.self, forKey: .callDetails)
        callDetails = callDetailsDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let startedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedTimestamp)
        startedTimestamp = startedTimestampDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    /// A representation of an asynchronous request to perform voice tone analysis on a Voice Connector call.
    public struct VoiceToneAnalysisTask: Swift.Equatable {
        /// The call details of a voice tone analysis task.
        public var callDetails: ChimeSDKVoiceClientTypes.CallDetails?
        /// The time at which a voice tone analysis task was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which a voice tone analysis task started.
        public var startedTimestamp: ClientRuntime.Date?
        /// The status of a voice tone analysis task.
        public var statusMessage: Swift.String?
        /// The time at which a voice tone analysis task was updated.
        public var updatedTimestamp: ClientRuntime.Date?
        /// The ID of the voice tone analysis task.
        public var voiceToneAnalysisTaskId: Swift.String?
        /// The status of a voice tone analysis task, IN_QUEUE, IN_PROGRESS, PARTIAL_SUCCESS, SUCCEEDED, FAILED, or STOPPED.
        public var voiceToneAnalysisTaskStatus: Swift.String?

        public init(
            callDetails: ChimeSDKVoiceClientTypes.CallDetails? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            startedTimestamp: ClientRuntime.Date? = nil,
            statusMessage: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceToneAnalysisTaskId: Swift.String? = nil,
            voiceToneAnalysisTaskStatus: Swift.String? = nil
        )
        {
            self.callDetails = callDetails
            self.createdTimestamp = createdTimestamp
            self.startedTimestamp = startedTimestamp
            self.statusMessage = statusMessage
            self.updatedTimestamp = updatedTimestamp
            self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
            self.voiceToneAnalysisTaskStatus = voiceToneAnalysisTaskStatus
        }
    }

}
