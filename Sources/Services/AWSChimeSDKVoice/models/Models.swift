// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case country
        case postDirectional
        case postalCode
        case postalCodePlus4
        case preDirectional
        case state
        case streetName
        case streetNumber
        case streetSuffix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postDirectional = self.postDirectional {
            try encodeContainer.encode(postDirectional, forKey: .postDirectional)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let postalCodePlus4 = self.postalCodePlus4 {
            try encodeContainer.encode(postalCodePlus4, forKey: .postalCodePlus4)
        }
        if let preDirectional = self.preDirectional {
            try encodeContainer.encode(preDirectional, forKey: .preDirectional)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetName = self.streetName {
            try encodeContainer.encode(streetName, forKey: .streetName)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
        if let streetSuffix = self.streetSuffix {
            try encodeContainer.encode(streetSuffix, forKey: .streetSuffix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetName)
        streetName = streetNameDecoded
        let streetSuffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetSuffix)
        streetSuffix = streetSuffixDecoded
        let postDirectionalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postDirectional)
        postDirectional = postDirectionalDecoded
        let preDirectionalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preDirectional)
        preDirectional = preDirectionalDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let postalCodePlus4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCodePlus4)
        postalCodePlus4 = postalCodePlus4Decoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postDirectional: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", preDirectional: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetName: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\", streetSuffix: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct Address: Swift.Equatable {
        public var city: Swift.String?
        public var country: Swift.String?
        public var postDirectional: Swift.String?
        public var postalCode: Swift.String?
        public var postalCodePlus4: Swift.String?
        public var preDirectional: Swift.String?
        public var state: Swift.String?
        public var streetName: Swift.String?
        public var streetNumber: Swift.String?
        public var streetSuffix: Swift.String?

        public init (
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postDirectional: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            preDirectional: Swift.String? = nil,
            state: Swift.String? = nil,
            streetName: Swift.String? = nil,
            streetNumber: Swift.String? = nil,
            streetSuffix: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postDirectional = postDirectional
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.preDirectional = preDirectional
            self.state = state
            self.streetName = streetName
            self.streetNumber = streetNumber
            self.streetSuffix = streetSuffix
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum AlexaSkillStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AlexaSkillStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlexaSkillStatus(rawValue: rawValue) ?? AlexaSkillStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let forceAssociate = self.forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-numbers"))
            return items
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupInput: Swift.Equatable {
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    public var forceAssociate: Swift.Bool?
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
    let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociatePhoneNumbersWithVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponse: Swift.Equatable {
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let forceAssociate = self.forceAssociate {
            try encodeContainer.encode(forceAssociate, forKey: .forceAssociate)
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "associate-phone-numbers"))
            return items
        }
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorInput: Swift.Equatable {
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    public var forceAssociate: Swift.Bool?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        forceAssociate: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.forceAssociate = forceAssociate
        self.voiceConnectorId = voiceConnectorId
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
    let forceAssociate: Swift.Bool?
}

extension AssociatePhoneNumbersWithVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case forceAssociate = "ForceAssociate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let forceAssociateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceAssociate)
        forceAssociate = forceAssociateDecoded
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociatePhoneNumbersWithVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociatePhoneNumbersWithVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct AssociatePhoneNumbersWithVoiceConnectorOutputResponse: Swift.Equatable {
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct AssociatePhoneNumbersWithVoiceConnectorOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension AssociatePhoneNumbersWithVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchDeletePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumberIds = phoneNumberIds {
            var phoneNumberIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberIds)
            for string0 in phoneNumberIds {
                try phoneNumberIdsContainer.encode(string0)
            }
        }
    }
}

extension BatchDeletePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-delete"))
            return items
        }
    }
}

extension BatchDeletePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-numbers"
    }
}

public struct BatchDeletePhoneNumberInput: Swift.Equatable {
    /// This member is required.
    public var phoneNumberIds: [Swift.String]?

    public init (
        phoneNumberIds: [Swift.String]? = nil
    )
    {
        self.phoneNumberIds = phoneNumberIds
    }
}

struct BatchDeletePhoneNumberInputBody: Swift.Equatable {
    let phoneNumberIds: [Swift.String]?
}

extension BatchDeletePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberIds = "PhoneNumberIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberIds)
        var phoneNumberIdsDecoded0:[Swift.String]? = nil
        if let phoneNumberIdsContainer = phoneNumberIdsContainer {
            phoneNumberIdsDecoded0 = [Swift.String]()
            for string0 in phoneNumberIdsContainer {
                if let string0 = string0 {
                    phoneNumberIdsDecoded0?.append(string0)
                }
            }
        }
        phoneNumberIds = phoneNumberIdsDecoded0
    }
}

extension BatchDeletePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeletePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDeletePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeletePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDeletePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchDeletePhoneNumberOutputResponse: Swift.Equatable {
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchDeletePhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension BatchDeletePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension BatchUpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatePhoneNumberRequestItems = updatePhoneNumberRequestItems {
            var updatePhoneNumberRequestItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updatePhoneNumberRequestItems)
            for updatephonenumberrequestitem0 in updatePhoneNumberRequestItems {
                try updatePhoneNumberRequestItemsContainer.encode(updatephonenumberrequestitem0)
            }
        }
    }
}

extension BatchUpdatePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "batch-update"))
            return items
        }
    }
}

extension BatchUpdatePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-numbers"
    }
}

public struct BatchUpdatePhoneNumberInput: Swift.Equatable {
    /// This member is required.
    public var updatePhoneNumberRequestItems: [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]?

    public init (
        updatePhoneNumberRequestItems: [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]? = nil
    )
    {
        self.updatePhoneNumberRequestItems = updatePhoneNumberRequestItems
    }
}

struct BatchUpdatePhoneNumberInputBody: Swift.Equatable {
    let updatePhoneNumberRequestItems: [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]?
}

extension BatchUpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatePhoneNumberRequestItems = "UpdatePhoneNumberRequestItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatePhoneNumberRequestItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem?].self, forKey: .updatePhoneNumberRequestItems)
        var updatePhoneNumberRequestItemsDecoded0:[ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]? = nil
        if let updatePhoneNumberRequestItemsContainer = updatePhoneNumberRequestItemsContainer {
            updatePhoneNumberRequestItemsDecoded0 = [ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem]()
            for structure0 in updatePhoneNumberRequestItemsContainer {
                if let structure0 = structure0 {
                    updatePhoneNumberRequestItemsDecoded0?.append(structure0)
                }
            }
        }
        updatePhoneNumberRequestItems = updatePhoneNumberRequestItemsDecoded0
    }
}

extension BatchUpdatePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdatePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchUpdatePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdatePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchUpdatePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct BatchUpdatePhoneNumberOutputResponse: Swift.Equatable {
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct BatchUpdatePhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension BatchUpdatePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum CallingNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case unassigned
        case updatefailed
        case updateinprogress
        case updatesucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CallingNameStatus] {
            return [
                .unassigned,
                .updatefailed,
                .updateinprogress,
                .updatesucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .unassigned: return "Unassigned"
            case .updatefailed: return "UpdateFailed"
            case .updateinprogress: return "UpdateInProgress"
            case .updatesucceeded: return "UpdateSucceeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CallingNameStatus(rawValue: rawValue) ?? CallingNameStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.CandidateAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city
        case country
        case postalCode
        case postalCodePlus4
        case state
        case streetInfo
        case streetNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let postalCodePlus4 = self.postalCodePlus4 {
            try encodeContainer.encode(postalCodePlus4, forKey: .postalCodePlus4)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetInfo = self.streetInfo {
            try encodeContainer.encode(streetInfo, forKey: .streetInfo)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streetInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetInfo)
        streetInfo = streetInfoDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let postalCodePlus4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCodePlus4)
        postalCodePlus4 = postalCodePlus4Decoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
    }
}

extension ChimeSDKVoiceClientTypes.CandidateAddress: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CandidateAddress(city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", postalCodePlus4: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct CandidateAddress: Swift.Equatable {
        public var city: Swift.String?
        public var country: Swift.String?
        public var postalCode: Swift.String?
        public var postalCodePlus4: Swift.String?
        public var state: Swift.String?
        public var streetInfo: Swift.String?
        public var streetNumber: Swift.String?

        public init (
            city: Swift.String? = nil,
            country: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            postalCodePlus4: Swift.String? = nil,
            state: Swift.String? = nil,
            streetInfo: Swift.String? = nil,
            streetNumber: Swift.String? = nil
        )
        {
            self.city = city
            self.country = country
            self.postalCode = postalCode
            self.postalCodePlus4 = postalCodePlus4
            self.state = state
            self.streetInfo = streetInfo
            self.streetNumber = streetNumber
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum Capability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [Capability] {
            return [
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sms: return "SMS"
            case .voice: return "Voice"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Capability(rawValue: rawValue) ?? Capability.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreatePhoneNumberOrderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

extension CreatePhoneNumberOrderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number-orders"
    }
}

public struct CreatePhoneNumberOrderInput: Swift.Equatable {
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// This member is required.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.productType = productType
    }
}

struct CreatePhoneNumberOrderInputBody: Swift.Equatable {
    let productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
    let e164PhoneNumbers: [Swift.String]?
}

extension CreatePhoneNumberOrderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case productType = "ProductType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension CreatePhoneNumberOrderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePhoneNumberOrderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePhoneNumberOrderOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePhoneNumberOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePhoneNumberOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct CreatePhoneNumberOrderOutputResponse: Swift.Equatable {
    public var phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?

    public init (
        phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct CreatePhoneNumberOrderOutputResponseBody: Swift.Equatable {
    let phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?
}

extension CreatePhoneNumberOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

extension CreateProxySessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProxySessionInput(capabilities: \(Swift.String(describing: capabilities)), expiryMinutes: \(Swift.String(describing: expiryMinutes)), geoMatchLevel: \(Swift.String(describing: geoMatchLevel)), geoMatchParams: \(Swift.String(describing: geoMatchParams)), numberSelectionBehavior: \(Swift.String(describing: numberSelectionBehavior)), participantPhoneNumbers: \(Swift.String(describing: participantPhoneNumbers)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), name: \"CONTENT_REDACTED\")"}
}

extension CreateProxySessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = self.geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = self.geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = self.numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participantPhoneNumbers = participantPhoneNumbers {
            var participantPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participantPhoneNumbers)
            for e164phonenumber0 in participantPhoneNumbers {
                try participantPhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension CreateProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

public struct CreateProxySessionInput: Swift.Equatable {
    /// This member is required.
    public var capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    public var expiryMinutes: Swift.Int?
    public var geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel?
    public var geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams?
    public var name: Swift.String?
    public var numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior?
    /// This member is required.
    public var participantPhoneNumbers: [Swift.String]?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        capabilities: [ChimeSDKVoiceClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel? = nil,
        geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams? = nil,
        name: Swift.String? = nil,
        numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior? = nil,
        participantPhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.geoMatchLevel = geoMatchLevel
        self.geoMatchParams = geoMatchParams
        self.name = name
        self.numberSelectionBehavior = numberSelectionBehavior
        self.participantPhoneNumbers = participantPhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct CreateProxySessionInputBody: Swift.Equatable {
    let participantPhoneNumbers: [Swift.String]?
    let name: Swift.String?
    let expiryMinutes: Swift.Int?
    let capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    let numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior?
    let geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel?
    let geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams?
}

extension CreateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participantPhoneNumbers = "ParticipantPhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participantPhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .participantPhoneNumbers)
        var participantPhoneNumbersDecoded0:[Swift.String]? = nil
        if let participantPhoneNumbersContainer = participantPhoneNumbersContainer {
            participantPhoneNumbersDecoded0 = [Swift.String]()
            for string0 in participantPhoneNumbersContainer {
                if let string0 = string0 {
                    participantPhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        participantPhoneNumbers = participantPhoneNumbersDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeSDKVoiceClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeSDKVoiceClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

extension CreateProxySessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProxySessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProxySessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProxySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct CreateProxySessionOutputResponse: Swift.Equatable {
    public var proxySession: ChimeSDKVoiceClientTypes.ProxySession?

    public init (
        proxySession: ChimeSDKVoiceClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct CreateProxySessionOutputResponseBody: Swift.Equatable {
    let proxySession: ChimeSDKVoiceClientTypes.ProxySession?
}

extension CreateProxySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

extension CreateSipMediaApplicationCallInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSipMediaApplicationCallInput(argumentsMap: \(Swift.String(describing: argumentsMap)), sipHeaders: \(Swift.String(describing: sipHeaders)), sipMediaApplicationId: \(Swift.String(describing: sipMediaApplicationId)), fromPhoneNumber: \"CONTENT_REDACTED\", toPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension CreateSipMediaApplicationCallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case argumentsMap = "ArgumentsMap"
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let argumentsMap = argumentsMap {
            var argumentsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .argumentsMap)
            for (dictKey0, smaCreateCallArgumentsMap0) in argumentsMap {
                try argumentsMapContainer.encode(smaCreateCallArgumentsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let fromPhoneNumber = self.fromPhoneNumber {
            try encodeContainer.encode(fromPhoneNumber, forKey: .fromPhoneNumber)
        }
        if let sipHeaders = sipHeaders {
            var sipHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sipHeaders)
            for (dictKey0, sipHeadersMap0) in sipHeaders {
                try sipHeadersContainer.encode(sipHeadersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let toPhoneNumber = self.toPhoneNumber {
            try encodeContainer.encode(toPhoneNumber, forKey: .toPhoneNumber)
        }
    }
}

extension CreateSipMediaApplicationCallInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls"
    }
}

public struct CreateSipMediaApplicationCallInput: Swift.Equatable {
    public var argumentsMap: [Swift.String:Swift.String]?
    /// This member is required.
    public var fromPhoneNumber: Swift.String?
    public var sipHeaders: [Swift.String:Swift.String]?
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// This member is required.
    public var toPhoneNumber: Swift.String?

    public init (
        argumentsMap: [Swift.String:Swift.String]? = nil,
        fromPhoneNumber: Swift.String? = nil,
        sipHeaders: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        toPhoneNumber: Swift.String? = nil
    )
    {
        self.argumentsMap = argumentsMap
        self.fromPhoneNumber = fromPhoneNumber
        self.sipHeaders = sipHeaders
        self.sipMediaApplicationId = sipMediaApplicationId
        self.toPhoneNumber = toPhoneNumber
    }
}

struct CreateSipMediaApplicationCallInputBody: Swift.Equatable {
    let fromPhoneNumber: Swift.String?
    let toPhoneNumber: Swift.String?
    let sipHeaders: [Swift.String:Swift.String]?
    let argumentsMap: [Swift.String:Swift.String]?
}

extension CreateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case argumentsMap = "ArgumentsMap"
        case fromPhoneNumber = "FromPhoneNumber"
        case sipHeaders = "SipHeaders"
        case toPhoneNumber = "ToPhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPhoneNumber)
        fromPhoneNumber = fromPhoneNumberDecoded
        let toPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPhoneNumber)
        toPhoneNumber = toPhoneNumberDecoded
        let sipHeadersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sipHeaders)
        var sipHeadersDecoded0: [Swift.String:Swift.String]? = nil
        if let sipHeadersContainer = sipHeadersContainer {
            sipHeadersDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in sipHeadersContainer {
                if let sensitivestring0 = sensitivestring0 {
                    sipHeadersDecoded0?[key0] = sensitivestring0
                }
            }
        }
        sipHeaders = sipHeadersDecoded0
        let argumentsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .argumentsMap)
        var argumentsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let argumentsMapContainer = argumentsMapContainer {
            argumentsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in argumentsMapContainer {
                if let sensitivestring0 = sensitivestring0 {
                    argumentsMapDecoded0?[key0] = sensitivestring0
                }
            }
        }
        argumentsMap = argumentsMapDecoded0
    }
}

extension CreateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSipMediaApplicationCallOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSipMediaApplicationCallOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSipMediaApplicationCallOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSipMediaApplicationCallOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct CreateSipMediaApplicationCallOutputResponse: Swift.Equatable {
    public var sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?

    public init (
        sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct CreateSipMediaApplicationCallOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?
}

extension CreateSipMediaApplicationCallOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

extension CreateSipMediaApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-media-applications"
    }
}

public struct CreateSipMediaApplicationInput: Swift.Equatable {
    /// This member is required.
    public var awsRegion: Swift.String?
    /// This member is required.
    public var endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
    /// This member is required.
    public var name: Swift.String?

    public init (
        awsRegion: Swift.String? = nil,
        endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.endpoints = endpoints
        self.name = name
    }
}

struct CreateSipMediaApplicationInputBody: Swift.Equatable {
    let awsRegion: Swift.String?
    let name: Swift.String?
    let endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
}

extension CreateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension CreateSipMediaApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSipMediaApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSipMediaApplicationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSipMediaApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct CreateSipMediaApplicationOutputResponse: Swift.Equatable {
    public var sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?

    public init (
        sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct CreateSipMediaApplicationOutputResponseBody: Swift.Equatable {
    let sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?
}

extension CreateSipMediaApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

extension CreateSipRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = self.triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
    }
}

extension CreateSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-rules"
    }
}

public struct CreateSipRuleInput: Swift.Equatable {
    public var disabled: Swift.Bool?
    /// This member is required.
    public var name: Swift.String?
    public var targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
    /// This member is required.
    public var triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType?
    /// This member is required.
    public var triggerValue: Swift.String?

    public init (
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil,
        triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType? = nil,
        triggerValue: Swift.String? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.targetApplications = targetApplications
        self.triggerType = triggerType
        self.triggerValue = triggerValue
    }
}

struct CreateSipRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType?
    let triggerValue: Swift.String?
    let disabled: Swift.Bool?
    let targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
}

extension CreateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

extension CreateSipRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSipRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSipRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSipRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct CreateSipRuleOutputResponse: Swift.Equatable {
    public var sipRule: ChimeSDKVoiceClientTypes.SipRule?

    public init (
        sipRule: ChimeSDKVoiceClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct CreateSipRuleOutputResponseBody: Swift.Equatable {
    let sipRule: ChimeSDKVoiceClientTypes.SipRule?
}

extension CreateSipRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

extension CreateVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }
}

extension CreateVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connector-groups"
    }
}

public struct CreateVoiceConnectorGroupInput: Swift.Equatable {
    /// This member is required.
    public var name: Swift.String?
    public var voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?

    public init (
        name: Swift.String? = nil,
        voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct CreateVoiceConnectorGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?
}

extension CreateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

extension CreateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct CreateVoiceConnectorGroupOutputResponse: Swift.Equatable {
    public var voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?

    public init (
        voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct CreateVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?
}

extension CreateVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

extension CreateVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
    }
}

extension CreateVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connectors"
    }
}

public struct CreateVoiceConnectorInput: Swift.Equatable {
    public var awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?
    /// This member is required.
    public var name: Swift.String?
    /// This member is required.
    public var requireEncryption: Swift.Bool?

    public init (
        awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion? = nil,
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil
    )
    {
        self.awsRegion = awsRegion
        self.name = name
        self.requireEncryption = requireEncryption
    }
}

struct CreateVoiceConnectorInputBody: Swift.Equatable {
    let name: Swift.String?
    let awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?
    let requireEncryption: Swift.Bool?
}

extension CreateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
    }
}

extension CreateVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct CreateVoiceConnectorOutputResponse: Swift.Equatable {
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?

    public init (
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct CreateVoiceConnectorOutputResponseBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?
}

extension CreateVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Credential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Credential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Credential(password: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct Credential: Swift.Equatable {
        public var password: Swift.String?
        public var username: Swift.String?

        public init (
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingCountry = "CallingCountry"
        case emergencyPhoneNumber = "EmergencyPhoneNumber"
        case testPhoneNumber = "TestPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingCountry = self.callingCountry {
            try encodeContainer.encode(callingCountry, forKey: .callingCountry)
        }
        if let emergencyPhoneNumber = self.emergencyPhoneNumber {
            try encodeContainer.encode(emergencyPhoneNumber, forKey: .emergencyPhoneNumber)
        }
        if let testPhoneNumber = self.testPhoneNumber {
            try encodeContainer.encode(testPhoneNumber, forKey: .testPhoneNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emergencyPhoneNumber)
        emergencyPhoneNumber = emergencyPhoneNumberDecoded
        let testPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testPhoneNumber)
        testPhoneNumber = testPhoneNumberDecoded
        let callingCountryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingCountry)
        callingCountry = callingCountryDecoded
    }
}

extension ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DNISEmergencyCallingConfiguration(callingCountry: \(Swift.String(describing: callingCountry)), emergencyPhoneNumber: \"CONTENT_REDACTED\", testPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct DNISEmergencyCallingConfiguration: Swift.Equatable {
        /// This member is required.
        public var callingCountry: Swift.String?
        /// This member is required.
        public var emergencyPhoneNumber: Swift.String?
        public var testPhoneNumber: Swift.String?

        public init (
            callingCountry: Swift.String? = nil,
            emergencyPhoneNumber: Swift.String? = nil,
            testPhoneNumber: Swift.String? = nil
        )
        {
            self.callingCountry = callingCountry
            self.emergencyPhoneNumber = emergencyPhoneNumber
            self.testPhoneNumber = testPhoneNumber
        }
    }

}

extension DeletePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePhoneNumberInput(phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension DeletePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct DeletePhoneNumberInput: Swift.Equatable {
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init (
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct DeletePhoneNumberInputBody: Swift.Equatable {
}

extension DeletePhoneNumberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePhoneNumberOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct DeleteProxySessionInput: Swift.Equatable {
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteProxySessionInputBody: Swift.Equatable {
}

extension DeleteProxySessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProxySessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProxySessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProxySessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProxySessionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct DeleteSipMediaApplicationInput: Swift.Equatable {
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct DeleteSipMediaApplicationInputBody: Swift.Equatable {
}

extension DeleteSipMediaApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipMediaApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSipMediaApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSipMediaApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSipMediaApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipRuleId = sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct DeleteSipRuleInput: Swift.Equatable {
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init (
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct DeleteSipRuleInputBody: Swift.Equatable {
}

extension DeleteSipRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSipRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSipRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSipRuleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSipRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVoiceConnectorEmergencyCallingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceConnectorGroupInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init (
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DeleteVoiceConnectorGroupInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct DeleteVoiceConnectorInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOriginationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct DeleteVoiceConnectorOriginationInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorOriginationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorOriginationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVoiceConnectorOriginationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorOriginationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorOriginationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVoiceConnectorProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct DeleteVoiceConnectorProxyInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorProxyInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorProxyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVoiceConnectorProxyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorProxyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVoiceConnectorStreamingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorStreamingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVoiceConnectorStreamingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorStreamingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorStreamingConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let usernames = usernames {
            var usernamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usernames)
            for sensitivestring0 in usernames {
                try usernamesContainer.encode(sensitivestring0)
            }
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "delete"))
            return items
        }
    }
}

extension DeleteVoiceConnectorTerminationCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// This member is required.
    public var usernames: [Swift.String]?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        usernames: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.usernames = usernames
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
    let usernames: [Swift.String]?
}

extension DeleteVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

extension DeleteVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorTerminationCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVoiceConnectorTerminationCredentialsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorTerminationCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorTerminationCredentialsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVoiceConnectorTerminationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct DeleteVoiceConnectorTerminationInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DeleteVoiceConnectorTerminationInputBody: Swift.Equatable {
}

extension DeleteVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceConnectorTerminationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVoiceConnectorTerminationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceConnectorTerminationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVoiceConnectorTerminationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
            return items
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupInput: Swift.Equatable {
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociatePhoneNumbersFromVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponse: Swift.Equatable {
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumbers = e164PhoneNumbers {
            var e164PhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .e164PhoneNumbers)
            for e164phonenumber0 in e164PhoneNumbers {
                try e164PhoneNumbersContainer.encode(e164phonenumber0)
            }
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "disassociate-phone-numbers"))
            return items
        }
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorInput: Swift.Equatable {
    /// This member is required.
    public var e164PhoneNumbers: [Swift.String]?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.voiceConnectorId = voiceConnectorId
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorInputBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociatePhoneNumbersFromVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociatePhoneNumbersFromVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberErrors = output.phoneNumberErrors
        } else {
            self.phoneNumberErrors = nil
        }
    }
}

public struct DisassociatePhoneNumbersFromVoiceConnectorOutputResponse: Swift.Equatable {
    public var phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?

    public init (
        phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
    )
    {
        self.phoneNumberErrors = phoneNumberErrors
    }
}

struct DisassociatePhoneNumbersFromVoiceConnectorOutputResponseBody: Swift.Equatable {
    let phoneNumberErrors: [ChimeSDKVoiceClientTypes.PhoneNumberError]?
}

extension DisassociatePhoneNumbersFromVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberErrors = "PhoneNumberErrors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberErrorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberError?].self, forKey: .phoneNumberErrors)
        var phoneNumberErrorsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberError]? = nil
        if let phoneNumberErrorsContainer = phoneNumberErrorsContainer {
            phoneNumberErrorsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberError]()
            for structure0 in phoneNumberErrorsContainer {
                if let structure0 = structure0 {
                    phoneNumberErrorsDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberErrors = phoneNumberErrorsDecoded0
    }
}

extension ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dnis = "DNIS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dnis = dnis {
            var dnisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnis)
            for dnisemergencycallingconfiguration0 in dnis {
                try dnisContainer.encode(dnisemergencycallingconfiguration0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnisContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration?].self, forKey: .dnis)
        var dnisDecoded0:[ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]? = nil
        if let dnisContainer = dnisContainer {
            dnisDecoded0 = [ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]()
            for structure0 in dnisContainer {
                if let structure0 = structure0 {
                    dnisDecoded0?.append(structure0)
                }
            }
        }
        dnis = dnisDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct EmergencyCallingConfiguration: Swift.Equatable {
        public var dnis: [ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]?

        public init (
            dnis: [ChimeSDKVoiceClientTypes.DNISEmergencyCallingConfiguration]? = nil
        )
        {
            self.dnis = dnis
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case gone
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .gone,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .gone: return "Gone"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum GeoMatchLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case areacode
        case country
        case sdkUnknown(Swift.String)

        public static var allCases: [GeoMatchLevel] {
            return [
                .areacode,
                .country,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .areacode: return "AreaCode"
            case .country: return "Country"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GeoMatchLevel(rawValue: rawValue) ?? GeoMatchLevel.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.GeoMatchParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case areaCode = "AreaCode"
        case country = "Country"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let areaCode = self.areaCode {
            try encodeContainer.encode(areaCode, forKey: .areaCode)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let areaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .areaCode)
        areaCode = areaCodeDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct GeoMatchParams: Swift.Equatable {
        /// This member is required.
        public var areaCode: Swift.String?
        /// This member is required.
        public var country: Swift.String?

        public init (
            areaCode: Swift.String? = nil,
            country: Swift.String? = nil
        )
        {
            self.areaCode = areaCode
            self.country = country
        }
    }

}

extension GetGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings"
    }
}

public struct GetGlobalSettingsInput: Swift.Equatable {

    public init () { }
}

struct GetGlobalSettingsInputBody: Swift.Equatable {
}

extension GetGlobalSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGlobalSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGlobalSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGlobalSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGlobalSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct GetGlobalSettingsOutputResponse: Swift.Equatable {
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?

    public init (
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct GetGlobalSettingsOutputResponseBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?
}

extension GetGlobalSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension GetPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberInput(phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension GetPhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct GetPhoneNumberInput: Swift.Equatable {
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init (
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct GetPhoneNumberInputBody: Swift.Equatable {
}

extension GetPhoneNumberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberOrderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberOrderId = phoneNumberOrderId else {
            return nil
        }
        return "/phone-number-orders/\(phoneNumberOrderId.urlPercentEncoding())"
    }
}

public struct GetPhoneNumberOrderInput: Swift.Equatable {
    /// This member is required.
    public var phoneNumberOrderId: Swift.String?

    public init (
        phoneNumberOrderId: Swift.String? = nil
    )
    {
        self.phoneNumberOrderId = phoneNumberOrderId
    }
}

struct GetPhoneNumberOrderInputBody: Swift.Equatable {
}

extension GetPhoneNumberOrderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberOrderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPhoneNumberOrderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPhoneNumberOrderOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPhoneNumberOrderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPhoneNumberOrderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberOrder = output.phoneNumberOrder
        } else {
            self.phoneNumberOrder = nil
        }
    }
}

public struct GetPhoneNumberOrderOutputResponse: Swift.Equatable {
    public var phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?

    public init (
        phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder? = nil
    )
    {
        self.phoneNumberOrder = phoneNumberOrder
    }
}

struct GetPhoneNumberOrderOutputResponseBody: Swift.Equatable {
    let phoneNumberOrder: ChimeSDKVoiceClientTypes.PhoneNumberOrder?
}

extension GetPhoneNumberOrderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberOrder = "PhoneNumberOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrder.self, forKey: .phoneNumberOrder)
        phoneNumberOrder = phoneNumberOrderDecoded
    }
}

extension GetPhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct GetPhoneNumberOutputResponse: Swift.Equatable {
    public var phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?

    public init (
        phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct GetPhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?
}

extension GetPhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension GetPhoneNumberSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings/phone-number"
    }
}

public struct GetPhoneNumberSettingsInput: Swift.Equatable {

    public init () { }
}

struct GetPhoneNumberSettingsInputBody: Swift.Equatable {
}

extension GetPhoneNumberSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPhoneNumberSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPhoneNumberSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPhoneNumberSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPhoneNumberSettingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPhoneNumberSettingsOutputResponse(callingNameUpdatedTimestamp: \(Swift.String(describing: callingNameUpdatedTimestamp)), callingName: \"CONTENT_REDACTED\")"}
}

extension GetPhoneNumberSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPhoneNumberSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.callingName = output.callingName
            self.callingNameUpdatedTimestamp = output.callingNameUpdatedTimestamp
        } else {
            self.callingName = nil
            self.callingNameUpdatedTimestamp = nil
        }
    }
}

public struct GetPhoneNumberSettingsOutputResponse: Swift.Equatable {
    public var callingName: Swift.String?
    public var callingNameUpdatedTimestamp: ClientRuntime.Date?

    public init (
        callingName: Swift.String? = nil,
        callingNameUpdatedTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.callingName = callingName
        self.callingNameUpdatedTimestamp = callingNameUpdatedTimestamp
    }
}

struct GetPhoneNumberSettingsOutputResponseBody: Swift.Equatable {
    let callingName: Swift.String?
    let callingNameUpdatedTimestamp: ClientRuntime.Date?
}

extension GetPhoneNumberSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case callingNameUpdatedTimestamp = "CallingNameUpdatedTimestamp"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .callingNameUpdatedTimestamp)
        callingNameUpdatedTimestamp = callingNameUpdatedTimestampDecoded
    }
}

extension GetProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct GetProxySessionInput: Swift.Equatable {
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetProxySessionInputBody: Swift.Equatable {
}

extension GetProxySessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProxySessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProxySessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetProxySessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetProxySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct GetProxySessionOutputResponse: Swift.Equatable {
    public var proxySession: ChimeSDKVoiceClientTypes.ProxySession?

    public init (
        proxySession: ChimeSDKVoiceClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct GetProxySessionOutputResponseBody: Swift.Equatable {
    let proxySession: ChimeSDKVoiceClientTypes.ProxySession?
}

extension GetProxySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

extension GetSipMediaApplicationAlexaSkillConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/alexa-skill-configuration"
    }
}

public struct GetSipMediaApplicationAlexaSkillConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationAlexaSkillConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSipMediaApplicationAlexaSkillConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSipMediaApplicationAlexaSkillConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSipMediaApplicationAlexaSkillConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSipMediaApplicationAlexaSkillConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationAlexaSkillConfiguration = output.sipMediaApplicationAlexaSkillConfiguration
        } else {
            self.sipMediaApplicationAlexaSkillConfiguration = nil
        }
    }
}

public struct GetSipMediaApplicationAlexaSkillConfigurationOutputResponse: Swift.Equatable {
    public var sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?

    public init (
        sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration? = nil
    )
    {
        self.sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfiguration
    }
}

struct GetSipMediaApplicationAlexaSkillConfigurationOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
}

extension GetSipMediaApplicationAlexaSkillConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationAlexaSkillConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration.self, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfigurationDecoded
    }
}

extension GetSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct GetSipMediaApplicationInput: Swift.Equatable {
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

public struct GetSipMediaApplicationLoggingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct GetSipMediaApplicationLoggingConfigurationInputBody: Swift.Equatable {
}

extension GetSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSipMediaApplicationLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSipMediaApplicationLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSipMediaApplicationLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSipMediaApplicationLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct GetSipMediaApplicationLoggingConfigurationOutputResponse: Swift.Equatable {
    public var sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?

    public init (
        sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct GetSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension GetSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

extension GetSipMediaApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSipMediaApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSipMediaApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSipMediaApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct GetSipMediaApplicationOutputResponse: Swift.Equatable {
    public var sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?

    public init (
        sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct GetSipMediaApplicationOutputResponseBody: Swift.Equatable {
    let sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?
}

extension GetSipMediaApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

extension GetSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipRuleId = sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct GetSipRuleInput: Swift.Equatable {
    /// This member is required.
    public var sipRuleId: Swift.String?

    public init (
        sipRuleId: Swift.String? = nil
    )
    {
        self.sipRuleId = sipRuleId
    }
}

struct GetSipRuleInputBody: Swift.Equatable {
}

extension GetSipRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSipRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSipRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSipRuleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSipRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct GetSipRuleOutputResponse: Swift.Equatable {
    public var sipRule: ChimeSDKVoiceClientTypes.SipRule?

    public init (
        sipRule: ChimeSDKVoiceClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct GetSipRuleOutputResponseBody: Swift.Equatable {
    let sipRule: ChimeSDKVoiceClientTypes.SipRule?
}

extension GetSipRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVoiceConnectorEmergencyCallingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVoiceConnectorEmergencyCallingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.Equatable {
    public var emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?

    public init (
        emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct GetVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Equatable {
    let emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
}

extension GetVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

extension GetVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct GetVoiceConnectorGroupInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?

    public init (
        voiceConnectorGroupId: Swift.String? = nil
    )
    {
        self.voiceConnectorGroupId = voiceConnectorGroupId
    }
}

struct GetVoiceConnectorGroupInputBody: Swift.Equatable {
}

extension GetVoiceConnectorGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct GetVoiceConnectorGroupOutputResponse: Swift.Equatable {
    public var voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?

    public init (
        voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct GetVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?
}

extension GetVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

extension GetVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct GetVoiceConnectorInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorInputBody: Swift.Equatable {
}

extension GetVoiceConnectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

public struct GetVoiceConnectorLoggingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorLoggingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVoiceConnectorLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVoiceConnectorLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorLoggingConfigurationOutputResponse: Swift.Equatable {
    public var loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?

    public init (
        loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct GetVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
}

extension GetVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension GetVoiceConnectorOriginationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct GetVoiceConnectorOriginationInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorOriginationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorOriginationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorOriginationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVoiceConnectorOriginationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorOriginationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVoiceConnectorOriginationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct GetVoiceConnectorOriginationOutputResponse: Swift.Equatable {
    public var origination: ChimeSDKVoiceClientTypes.Origination?

    public init (
        origination: ChimeSDKVoiceClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct GetVoiceConnectorOriginationOutputResponseBody: Swift.Equatable {
    let origination: ChimeSDKVoiceClientTypes.Origination?
}

extension GetVoiceConnectorOriginationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

extension GetVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct GetVoiceConnectorOutputResponse: Swift.Equatable {
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?

    public init (
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct GetVoiceConnectorOutputResponseBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?
}

extension GetVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension GetVoiceConnectorProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct GetVoiceConnectorProxyInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorProxyInputBody: Swift.Equatable {
}

extension GetVoiceConnectorProxyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVoiceConnectorProxyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVoiceConnectorProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct GetVoiceConnectorProxyOutputResponse: Swift.Equatable {
    public var proxy: ChimeSDKVoiceClientTypes.Proxy?

    public init (
        proxy: ChimeSDKVoiceClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct GetVoiceConnectorProxyOutputResponseBody: Swift.Equatable {
    let proxy: ChimeSDKVoiceClientTypes.Proxy?
}

extension GetVoiceConnectorProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

extension GetVoiceConnectorStreamingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct GetVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorStreamingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVoiceConnectorStreamingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorStreamingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVoiceConnectorStreamingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct GetVoiceConnectorStreamingConfigurationOutputResponse: Swift.Equatable {
    public var streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?

    public init (
        streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct GetVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Equatable {
    let streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
}

extension GetVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension GetVoiceConnectorTerminationHealthInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/health"
    }
}

public struct GetVoiceConnectorTerminationHealthInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationHealthInputBody: Swift.Equatable {
}

extension GetVoiceConnectorTerminationHealthInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorTerminationHealthOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorTerminationHealthOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVoiceConnectorTerminationHealthOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorTerminationHealthOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVoiceConnectorTerminationHealthOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.terminationHealth = output.terminationHealth
        } else {
            self.terminationHealth = nil
        }
    }
}

public struct GetVoiceConnectorTerminationHealthOutputResponse: Swift.Equatable {
    public var terminationHealth: ChimeSDKVoiceClientTypes.TerminationHealth?

    public init (
        terminationHealth: ChimeSDKVoiceClientTypes.TerminationHealth? = nil
    )
    {
        self.terminationHealth = terminationHealth
    }
}

struct GetVoiceConnectorTerminationHealthOutputResponseBody: Swift.Equatable {
    let terminationHealth: ChimeSDKVoiceClientTypes.TerminationHealth?
}

extension GetVoiceConnectorTerminationHealthOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case terminationHealth = "TerminationHealth"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationHealthDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.TerminationHealth.self, forKey: .terminationHealth)
        terminationHealth = terminationHealthDecoded
    }
}

extension GetVoiceConnectorTerminationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct GetVoiceConnectorTerminationInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct GetVoiceConnectorTerminationInputBody: Swift.Equatable {
}

extension GetVoiceConnectorTerminationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceConnectorTerminationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVoiceConnectorTerminationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceConnectorTerminationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVoiceConnectorTerminationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct GetVoiceConnectorTerminationOutputResponse: Swift.Equatable {
    public var termination: ChimeSDKVoiceClientTypes.Termination?

    public init (
        termination: ChimeSDKVoiceClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct GetVoiceConnectorTerminationOutputResponseBody: Swift.Equatable {
    let termination: ChimeSDKVoiceClientTypes.Termination?
}

extension GetVoiceConnectorTerminationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension ListAvailableVoiceConnectorRegionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connector-regions"
    }
}

public struct ListAvailableVoiceConnectorRegionsInput: Swift.Equatable {

    public init () { }
}

struct ListAvailableVoiceConnectorRegionsInputBody: Swift.Equatable {
}

extension ListAvailableVoiceConnectorRegionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAvailableVoiceConnectorRegionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAvailableVoiceConnectorRegionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAvailableVoiceConnectorRegionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAvailableVoiceConnectorRegionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAvailableVoiceConnectorRegionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorRegions = output.voiceConnectorRegions
        } else {
            self.voiceConnectorRegions = nil
        }
    }
}

public struct ListAvailableVoiceConnectorRegionsOutputResponse: Swift.Equatable {
    public var voiceConnectorRegions: [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]?

    public init (
        voiceConnectorRegions: [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]? = nil
    )
    {
        self.voiceConnectorRegions = voiceConnectorRegions
    }
}

struct ListAvailableVoiceConnectorRegionsOutputResponseBody: Swift.Equatable {
    let voiceConnectorRegions: [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]?
}

extension ListAvailableVoiceConnectorRegionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorRegions = "VoiceConnectorRegions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorRegionsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?].self, forKey: .voiceConnectorRegions)
        var voiceConnectorRegionsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]? = nil
        if let voiceConnectorRegionsContainer = voiceConnectorRegionsContainer {
            voiceConnectorRegionsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion]()
            for enum0 in voiceConnectorRegionsContainer {
                if let enum0 = enum0 {
                    voiceConnectorRegionsDecoded0?.append(enum0)
                }
            }
        }
        voiceConnectorRegions = voiceConnectorRegionsDecoded0
    }
}

extension ListPhoneNumberOrdersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPhoneNumberOrdersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number-orders"
    }
}

public struct ListPhoneNumberOrdersInput: Swift.Equatable {
    public var maxResults: Swift.Int?
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPhoneNumberOrdersInputBody: Swift.Equatable {
}

extension ListPhoneNumberOrdersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumberOrdersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPhoneNumberOrdersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPhoneNumberOrdersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPhoneNumberOrdersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPhoneNumberOrdersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumberOrders = output.phoneNumberOrders
        } else {
            self.nextToken = nil
            self.phoneNumberOrders = nil
        }
    }
}

public struct ListPhoneNumberOrdersOutputResponse: Swift.Equatable {
    public var nextToken: Swift.String?
    public var phoneNumberOrders: [ChimeSDKVoiceClientTypes.PhoneNumberOrder]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumberOrders: [ChimeSDKVoiceClientTypes.PhoneNumberOrder]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumberOrders = phoneNumberOrders
    }
}

struct ListPhoneNumberOrdersOutputResponseBody: Swift.Equatable {
    let phoneNumberOrders: [ChimeSDKVoiceClientTypes.PhoneNumberOrder]?
    let nextToken: Swift.String?
}

extension ListPhoneNumberOrdersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumberOrders = "PhoneNumberOrders"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrdersContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberOrder?].self, forKey: .phoneNumberOrders)
        var phoneNumberOrdersDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberOrder]? = nil
        if let phoneNumberOrdersContainer = phoneNumberOrdersContainer {
            phoneNumberOrdersDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberOrder]()
            for structure0 in phoneNumberOrdersContainer {
                if let structure0 = structure0 {
                    phoneNumberOrdersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberOrders = phoneNumberOrdersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPhoneNumbersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let productType = productType {
                let productTypeQueryItem = ClientRuntime.URLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
                items.append(productTypeQueryItem)
            }
            if let filterName = filterName {
                let filterNameQueryItem = ClientRuntime.URLQueryItem(name: "filter-name".urlPercentEncoding(), value: Swift.String(filterName.rawValue).urlPercentEncoding())
                items.append(filterNameQueryItem)
            }
            if let filterValue = filterValue {
                let filterValueQueryItem = ClientRuntime.URLQueryItem(name: "filter-value".urlPercentEncoding(), value: Swift.String(filterValue).urlPercentEncoding())
                items.append(filterValueQueryItem)
            }
            return items
        }
    }
}

extension ListPhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-numbers"
    }
}

public struct ListPhoneNumbersInput: Swift.Equatable {
    public var filterName: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName?
    public var filterValue: Swift.String?
    public var maxResults: Swift.Int?
    public var nextToken: Swift.String?
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
    public var status: Swift.String?

    public init (
        filterName: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName? = nil,
        filterValue: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil,
        status: Swift.String? = nil
    )
    {
        self.filterName = filterName
        self.filterValue = filterValue
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productType = productType
        self.status = status
    }
}

struct ListPhoneNumbersInputBody: Swift.Equatable {
}

extension ListPhoneNumbersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPhoneNumbersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPhoneNumbersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPhoneNumbersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPhoneNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.phoneNumbers = output.phoneNumbers
        } else {
            self.nextToken = nil
            self.phoneNumbers = nil
        }
    }
}

public struct ListPhoneNumbersOutputResponse: Swift.Equatable {
    public var nextToken: Swift.String?
    public var phoneNumbers: [ChimeSDKVoiceClientTypes.PhoneNumber]?

    public init (
        nextToken: Swift.String? = nil,
        phoneNumbers: [ChimeSDKVoiceClientTypes.PhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

struct ListPhoneNumbersOutputResponseBody: Swift.Equatable {
    let phoneNumbers: [ChimeSDKVoiceClientTypes.PhoneNumber]?
    let nextToken: Swift.String?
}

extension ListPhoneNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case phoneNumbers = "PhoneNumbers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumbersContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProxySessionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProxySessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions"
    }
}

public struct ListProxySessionsInput: Swift.Equatable {
    public var maxResults: Swift.Int?
    public var nextToken: Swift.String?
    public var status: ChimeSDKVoiceClientTypes.ProxySessionStatus?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: ChimeSDKVoiceClientTypes.ProxySessionStatus? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListProxySessionsInputBody: Swift.Equatable {
}

extension ListProxySessionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProxySessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProxySessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProxySessionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProxySessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProxySessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.proxySessions = output.proxySessions
        } else {
            self.nextToken = nil
            self.proxySessions = nil
        }
    }
}

public struct ListProxySessionsOutputResponse: Swift.Equatable {
    public var nextToken: Swift.String?
    public var proxySessions: [ChimeSDKVoiceClientTypes.ProxySession]?

    public init (
        nextToken: Swift.String? = nil,
        proxySessions: [ChimeSDKVoiceClientTypes.ProxySession]? = nil
    )
    {
        self.nextToken = nextToken
        self.proxySessions = proxySessions
    }
}

struct ListProxySessionsOutputResponseBody: Swift.Equatable {
    let proxySessions: [ChimeSDKVoiceClientTypes.ProxySession]?
    let nextToken: Swift.String?
}

extension ListProxySessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case proxySessions = "ProxySessions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.ProxySession?].self, forKey: .proxySessions)
        var proxySessionsDecoded0:[ChimeSDKVoiceClientTypes.ProxySession]? = nil
        if let proxySessionsContainer = proxySessionsContainer {
            proxySessionsDecoded0 = [ChimeSDKVoiceClientTypes.ProxySession]()
            for structure0 in proxySessionsContainer {
                if let structure0 = structure0 {
                    proxySessionsDecoded0?.append(structure0)
                }
            }
        }
        proxySessions = proxySessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSipMediaApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSipMediaApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-media-applications"
    }
}

public struct ListSipMediaApplicationsInput: Swift.Equatable {
    public var maxResults: Swift.Int?
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSipMediaApplicationsInputBody: Swift.Equatable {
}

extension ListSipMediaApplicationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSipMediaApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSipMediaApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSipMediaApplicationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSipMediaApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSipMediaApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipMediaApplications = output.sipMediaApplications
        } else {
            self.nextToken = nil
            self.sipMediaApplications = nil
        }
    }
}

public struct ListSipMediaApplicationsOutputResponse: Swift.Equatable {
    public var nextToken: Swift.String?
    public var sipMediaApplications: [ChimeSDKVoiceClientTypes.SipMediaApplication]?

    public init (
        nextToken: Swift.String? = nil,
        sipMediaApplications: [ChimeSDKVoiceClientTypes.SipMediaApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipMediaApplications = sipMediaApplications
    }
}

struct ListSipMediaApplicationsOutputResponseBody: Swift.Equatable {
    let sipMediaApplications: [ChimeSDKVoiceClientTypes.SipMediaApplication]?
    let nextToken: Swift.String?
}

extension ListSipMediaApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipMediaApplications = "SipMediaApplications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplication?].self, forKey: .sipMediaApplications)
        var sipMediaApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplication]? = nil
        if let sipMediaApplicationsContainer = sipMediaApplicationsContainer {
            sipMediaApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplication]()
            for structure0 in sipMediaApplicationsContainer {
                if let structure0 = structure0 {
                    sipMediaApplicationsDecoded0?.append(structure0)
                }
            }
        }
        sipMediaApplications = sipMediaApplicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSipRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let sipMediaApplicationId = sipMediaApplicationId {
                let sipMediaApplicationIdQueryItem = ClientRuntime.URLQueryItem(name: "sip-media-application".urlPercentEncoding(), value: Swift.String(sipMediaApplicationId).urlPercentEncoding())
                items.append(sipMediaApplicationIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSipRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sip-rules"
    }
}

public struct ListSipRulesInput: Swift.Equatable {
    public var maxResults: Swift.Int?
    public var nextToken: Swift.String?
    public var sipMediaApplicationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct ListSipRulesInputBody: Swift.Equatable {
}

extension ListSipRulesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSipRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSipRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSipRulesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSipRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSipRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sipRules = output.sipRules
        } else {
            self.nextToken = nil
            self.sipRules = nil
        }
    }
}

public struct ListSipRulesOutputResponse: Swift.Equatable {
    public var nextToken: Swift.String?
    public var sipRules: [ChimeSDKVoiceClientTypes.SipRule]?

    public init (
        nextToken: Swift.String? = nil,
        sipRules: [ChimeSDKVoiceClientTypes.SipRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.sipRules = sipRules
    }
}

struct ListSipRulesOutputResponseBody: Swift.Equatable {
    let sipRules: [ChimeSDKVoiceClientTypes.SipRule]?
    let nextToken: Swift.String?
}

extension ListSipRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sipRules = "SipRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRulesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRule?].self, forKey: .sipRules)
        var sipRulesDecoded0:[ChimeSDKVoiceClientTypes.SipRule]? = nil
        if let sipRulesContainer = sipRulesContainer {
            sipRulesDecoded0 = [ChimeSDKVoiceClientTypes.SipRule]()
            for structure0 in sipRulesContainer {
                if let structure0 = structure0 {
                    sipRulesDecoded0?.append(structure0)
                }
            }
        }
        sipRules = sipRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSupportedPhoneNumberCountriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let productType = productType else {
                let message = "Creating a URL Query Item failed. productType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let productTypeQueryItem = ClientRuntime.URLQueryItem(name: "product-type".urlPercentEncoding(), value: Swift.String(productType.rawValue).urlPercentEncoding())
            items.append(productTypeQueryItem)
            return items
        }
    }
}

extension ListSupportedPhoneNumberCountriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/phone-number-countries"
    }
}

public struct ListSupportedPhoneNumberCountriesInput: Swift.Equatable {
    /// This member is required.
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

    public init (
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.productType = productType
    }
}

struct ListSupportedPhoneNumberCountriesInputBody: Swift.Equatable {
}

extension ListSupportedPhoneNumberCountriesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSupportedPhoneNumberCountriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSupportedPhoneNumberCountriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSupportedPhoneNumberCountriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSupportedPhoneNumberCountriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSupportedPhoneNumberCountriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumberCountries = output.phoneNumberCountries
        } else {
            self.phoneNumberCountries = nil
        }
    }
}

public struct ListSupportedPhoneNumberCountriesOutputResponse: Swift.Equatable {
    public var phoneNumberCountries: [ChimeSDKVoiceClientTypes.PhoneNumberCountry]?

    public init (
        phoneNumberCountries: [ChimeSDKVoiceClientTypes.PhoneNumberCountry]? = nil
    )
    {
        self.phoneNumberCountries = phoneNumberCountries
    }
}

struct ListSupportedPhoneNumberCountriesOutputResponseBody: Swift.Equatable {
    let phoneNumberCountries: [ChimeSDKVoiceClientTypes.PhoneNumberCountry]?
}

extension ListSupportedPhoneNumberCountriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberCountry?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberCountry]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberCountry]()
            for structure0 in phoneNumberCountriesContainer {
                if let structure0 = structure0 {
                    phoneNumberCountriesDecoded0?.append(structure0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

extension ListVoiceConnectorGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVoiceConnectorGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connector-groups"
    }
}

public struct ListVoiceConnectorGroupsInput: Swift.Equatable {
    public var maxResults: Swift.Int?
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorGroupsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVoiceConnectorGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVoiceConnectorGroupsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVoiceConnectorGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVoiceConnectorGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectorGroups = output.voiceConnectorGroups
        } else {
            self.nextToken = nil
            self.voiceConnectorGroups = nil
        }
    }
}

public struct ListVoiceConnectorGroupsOutputResponse: Swift.Equatable {
    public var nextToken: Swift.String?
    public var voiceConnectorGroups: [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]?

    public init (
        nextToken: Swift.String? = nil,
        voiceConnectorGroups: [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectorGroups = voiceConnectorGroups
    }
}

struct ListVoiceConnectorGroupsOutputResponseBody: Swift.Equatable {
    let voiceConnectorGroups: [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]?
    let nextToken: Swift.String?
}

extension ListVoiceConnectorGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectorGroups = "VoiceConnectorGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorGroup?].self, forKey: .voiceConnectorGroups)
        var voiceConnectorGroupsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorGroup]? = nil
        if let voiceConnectorGroupsContainer = voiceConnectorGroupsContainer {
            voiceConnectorGroupsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorGroup]()
            for structure0 in voiceConnectorGroupsContainer {
                if let structure0 = structure0 {
                    voiceConnectorGroupsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorGroups = voiceConnectorGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVoiceConnectorTerminationCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct ListVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.voiceConnectorId = voiceConnectorId
    }
}

struct ListVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVoiceConnectorTerminationCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVoiceConnectorTerminationCredentialsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVoiceConnectorTerminationCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVoiceConnectorTerminationCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.usernames = output.usernames
        } else {
            self.usernames = nil
        }
    }
}

public struct ListVoiceConnectorTerminationCredentialsOutputResponse: Swift.Equatable {
    public var usernames: [Swift.String]?

    public init (
        usernames: [Swift.String]? = nil
    )
    {
        self.usernames = usernames
    }
}

struct ListVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Equatable {
    let usernames: [Swift.String]?
}

extension ListVoiceConnectorTerminationCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case usernames = "Usernames"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usernames)
        var usernamesDecoded0:[Swift.String]? = nil
        if let usernamesContainer = usernamesContainer {
            usernamesDecoded0 = [Swift.String]()
            for string0 in usernamesContainer {
                if let string0 = string0 {
                    usernamesDecoded0?.append(string0)
                }
            }
        }
        usernames = usernamesDecoded0
    }
}

extension ListVoiceConnectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListVoiceConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/voice-connectors"
    }
}

public struct ListVoiceConnectorsInput: Swift.Equatable {
    public var maxResults: Swift.Int?
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVoiceConnectorsInputBody: Swift.Equatable {
}

extension ListVoiceConnectorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVoiceConnectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVoiceConnectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVoiceConnectorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVoiceConnectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVoiceConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.voiceConnectors = output.voiceConnectors
        } else {
            self.nextToken = nil
            self.voiceConnectors = nil
        }
    }
}

public struct ListVoiceConnectorsOutputResponse: Swift.Equatable {
    public var nextToken: Swift.String?
    public var voiceConnectors: [ChimeSDKVoiceClientTypes.VoiceConnector]?

    public init (
        nextToken: Swift.String? = nil,
        voiceConnectors: [ChimeSDKVoiceClientTypes.VoiceConnector]? = nil
    )
    {
        self.nextToken = nextToken
        self.voiceConnectors = voiceConnectors
    }
}

struct ListVoiceConnectorsOutputResponseBody: Swift.Equatable {
    let voiceConnectors: [ChimeSDKVoiceClientTypes.VoiceConnector]?
    let nextToken: Swift.String?
}

extension ListVoiceConnectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case voiceConnectors = "VoiceConnectors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnector?].self, forKey: .voiceConnectors)
        var voiceConnectorsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnector]? = nil
        if let voiceConnectorsContainer = voiceConnectorsContainer {
            voiceConnectorsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnector]()
            for structure0 in voiceConnectorsContainer {
                if let structure0 = structure0 {
                    voiceConnectorsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectors = voiceConnectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ChimeSDKVoiceClientTypes.LoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableMediaMetricLogs = "EnableMediaMetricLogs"
        case enableSIPLogs = "EnableSIPLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableMediaMetricLogs = self.enableMediaMetricLogs {
            try encodeContainer.encode(enableMediaMetricLogs, forKey: .enableMediaMetricLogs)
        }
        if let enableSIPLogs = self.enableSIPLogs {
            try encodeContainer.encode(enableSIPLogs, forKey: .enableSIPLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSIPLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSIPLogs)
        enableSIPLogs = enableSIPLogsDecoded
        let enableMediaMetricLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMediaMetricLogs)
        enableMediaMetricLogs = enableMediaMetricLogsDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct LoggingConfiguration: Swift.Equatable {
        public var enableMediaMetricLogs: Swift.Bool?
        public var enableSIPLogs: Swift.Bool?

        public init (
            enableMediaMetricLogs: Swift.Bool? = nil,
            enableSIPLogs: Swift.Bool? = nil
        )
        {
            self.enableMediaMetricLogs = enableMediaMetricLogs
            self.enableSIPLogs = enableSIPLogs
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum NotificationTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventbridge
        case sns
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationTarget] {
            return [
                .eventbridge,
                .sns,
                .sqs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventbridge: return "EventBridge"
            case .sns: return "SNS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationTarget(rawValue: rawValue) ?? NotificationTarget.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum NumberSelectionBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avoidsticky
        case prefersticky
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberSelectionBehavior] {
            return [
                .avoidsticky,
                .prefersticky,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avoidsticky: return "AvoidSticky"
            case .prefersticky: return "PreferSticky"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberSelectionBehavior(rawValue: rawValue) ?? NumberSelectionBehavior.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.OrderedPhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumber = "E164PhoneNumber"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let e164PhoneNumber = self.e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.OrderedPhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ChimeSDKVoiceClientTypes.OrderedPhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrderedPhoneNumber(status: \(Swift.String(describing: status)), e164PhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct OrderedPhoneNumber: Swift.Equatable {
        public var e164PhoneNumber: Swift.String?
        public var status: ChimeSDKVoiceClientTypes.OrderedPhoneNumberStatus?

        public init (
            e164PhoneNumber: Swift.String? = nil,
            status: ChimeSDKVoiceClientTypes.OrderedPhoneNumberStatus? = nil
        )
        {
            self.e164PhoneNumber = e164PhoneNumber
            self.status = status
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum OrderedPhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquired
        case failed
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderedPhoneNumberStatus] {
            return [
                .acquired,
                .failed,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquired: return "Acquired"
            case .failed: return "Failed"
            case .processing: return "Processing"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderedPhoneNumberStatus(rawValue: rawValue) ?? OrderedPhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Origination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case routes = "Routes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let routes = routes {
            var routesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routes)
            for originationroute0 in routes {
                try routesContainer.encode(originationroute0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.OriginationRoute?].self, forKey: .routes)
        var routesDecoded0:[ChimeSDKVoiceClientTypes.OriginationRoute]? = nil
        if let routesContainer = routesContainer {
            routesDecoded0 = [ChimeSDKVoiceClientTypes.OriginationRoute]()
            for structure0 in routesContainer {
                if let structure0 = structure0 {
                    routesDecoded0?.append(structure0)
                }
            }
        }
        routes = routesDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct Origination: Swift.Equatable {
        public var disabled: Swift.Bool?
        public var routes: [ChimeSDKVoiceClientTypes.OriginationRoute]?

        public init (
            disabled: Swift.Bool? = nil,
            routes: [ChimeSDKVoiceClientTypes.OriginationRoute]? = nil
        )
        {
            self.disabled = disabled
            self.routes = routes
        }
    }

}

extension ChimeSDKVoiceClientTypes.OriginationRoute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case port = "Port"
        case priority = "Priority"
        case `protocol` = "Protocol"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .host)
        host = hostDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.OriginationRouteProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct OriginationRoute: Swift.Equatable {
        public var host: Swift.String?
        public var port: Swift.Int?
        public var priority: Swift.Int?
        public var `protocol`: ChimeSDKVoiceClientTypes.OriginationRouteProtocol?
        public var weight: Swift.Int?

        public init (
            host: Swift.String? = nil,
            port: Swift.Int? = nil,
            priority: Swift.Int? = nil,
            `protocol`: ChimeSDKVoiceClientTypes.OriginationRouteProtocol? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.host = host
            self.port = port
            self.priority = priority
            self.`protocol` = `protocol`
            self.weight = weight
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum OriginationRouteProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tcp
        case udp
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginationRouteProtocol] {
            return [
                .tcp,
                .udp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case .udp: return "UDP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginationRouteProtocol(rawValue: rawValue) ?? OriginationRouteProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Participant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
        case proxyPhoneNumber = "ProxyPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let proxyPhoneNumber = self.proxyPhoneNumber {
            try encodeContainer.encode(proxyPhoneNumber, forKey: .proxyPhoneNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let proxyPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyPhoneNumber)
        proxyPhoneNumber = proxyPhoneNumberDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Participant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Participant(phoneNumber: \"CONTENT_REDACTED\", proxyPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct Participant: Swift.Equatable {
        public var phoneNumber: Swift.String?
        public var proxyPhoneNumber: Swift.String?

        public init (
            phoneNumber: Swift.String? = nil,
            proxyPhoneNumber: Swift.String? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.proxyPhoneNumber = proxyPhoneNumber
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case callingName = "CallingName"
        case callingNameStatus = "CallingNameStatus"
        case capabilities = "Capabilities"
        case country = "Country"
        case createdTimestamp = "CreatedTimestamp"
        case deletionTimestamp = "DeletionTimestamp"
        case e164PhoneNumber = "E164PhoneNumber"
        case orderId = "OrderId"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
        case status = "Status"
        case type = "Type"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for phonenumberassociation0 in associations {
                try associationsContainer.encode(phonenumberassociation0)
            }
        }
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let callingNameStatus = self.callingNameStatus {
            try encodeContainer.encode(callingNameStatus.rawValue, forKey: .callingNameStatus)
        }
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let deletionTimestamp = self.deletionTimestamp {
            try encodeContainer.encodeTimestamp(deletionTimestamp, format: .dateTime, forKey: .deletionTimestamp)
        }
        if let e164PhoneNumber = self.e164PhoneNumber {
            try encodeContainer.encode(e164PhoneNumber, forKey: .e164PhoneNumber)
        }
        if let orderId = self.orderId {
            try encodeContainer.encode(orderId, forKey: .orderId)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let e164PhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .e164PhoneNumber)
        e164PhoneNumber = e164PhoneNumberDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberType.self, forKey: .type)
        type = typeDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberStatus.self, forKey: .status)
        status = statusDecoded
        let capabilitiesDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberCapabilities.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
        let associationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberAssociation?].self, forKey: .associations)
        var associationsDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
        let callingNameStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.CallingNameStatus.self, forKey: .callingNameStatus)
        callingNameStatus = callingNameStatusDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let deletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .deletionTimestamp)
        deletionTimestamp = deletionTimestampDecoded
        let orderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orderId)
        orderId = orderIdDecoded
    }
}

extension ChimeSDKVoiceClientTypes.PhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumber(associations: \(Swift.String(describing: associations)), callingNameStatus: \(Swift.String(describing: callingNameStatus)), capabilities: \(Swift.String(describing: capabilities)), country: \(Swift.String(describing: country)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), deletionTimestamp: \(Swift.String(describing: deletionTimestamp)), orderId: \(Swift.String(describing: orderId)), productType: \(Swift.String(describing: productType)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), callingName: \"CONTENT_REDACTED\", e164PhoneNumber: \"CONTENT_REDACTED\", phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct PhoneNumber: Swift.Equatable {
        public var associations: [ChimeSDKVoiceClientTypes.PhoneNumberAssociation]?
        public var callingName: Swift.String?
        public var callingNameStatus: ChimeSDKVoiceClientTypes.CallingNameStatus?
        public var capabilities: ChimeSDKVoiceClientTypes.PhoneNumberCapabilities?
        public var country: Swift.String?
        public var createdTimestamp: ClientRuntime.Date?
        public var deletionTimestamp: ClientRuntime.Date?
        public var e164PhoneNumber: Swift.String?
        public var orderId: Swift.String?
        public var phoneNumberId: Swift.String?
        public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
        public var status: ChimeSDKVoiceClientTypes.PhoneNumberStatus?
        public var type: ChimeSDKVoiceClientTypes.PhoneNumberType?
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            associations: [ChimeSDKVoiceClientTypes.PhoneNumberAssociation]? = nil,
            callingName: Swift.String? = nil,
            callingNameStatus: ChimeSDKVoiceClientTypes.CallingNameStatus? = nil,
            capabilities: ChimeSDKVoiceClientTypes.PhoneNumberCapabilities? = nil,
            country: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            deletionTimestamp: ClientRuntime.Date? = nil,
            e164PhoneNumber: Swift.String? = nil,
            orderId: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil,
            status: ChimeSDKVoiceClientTypes.PhoneNumberStatus? = nil,
            type: ChimeSDKVoiceClientTypes.PhoneNumberType? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.associations = associations
            self.callingName = callingName
            self.callingNameStatus = callingNameStatus
            self.capabilities = capabilities
            self.country = country
            self.createdTimestamp = createdTimestamp
            self.deletionTimestamp = deletionTimestamp
            self.e164PhoneNumber = e164PhoneNumber
            self.orderId = orderId
            self.phoneNumberId = phoneNumberId
            self.productType = productType
            self.status = status
            self.type = type
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedTimestamp = "AssociatedTimestamp"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedTimestamp = self.associatedTimestamp {
            try encodeContainer.encodeTimestamp(associatedTimestamp, format: .dateTime, forKey: .associatedTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberAssociationName.self, forKey: .name)
        name = nameDecoded
        let associatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .associatedTimestamp)
        associatedTimestamp = associatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct PhoneNumberAssociation: Swift.Equatable {
        public var associatedTimestamp: ClientRuntime.Date?
        public var name: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName?
        public var value: Swift.String?

        public init (
            associatedTimestamp: ClientRuntime.Date? = nil,
            name: ChimeSDKVoiceClientTypes.PhoneNumberAssociationName? = nil,
            value: Swift.String? = nil
        )
        {
            self.associatedTimestamp = associatedTimestamp
            self.name = name
            self.value = value
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberAssociationName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sipruleid
        case voiceconnectorgroupid
        case voiceconnectorid
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberAssociationName] {
            return [
                .sipruleid,
                .voiceconnectorgroupid,
                .voiceconnectorid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sipruleid: return "SipRuleId"
            case .voiceconnectorgroupid: return "VoiceConnectorGroupId"
            case .voiceconnectorid: return "VoiceConnectorId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberAssociationName(rawValue: rawValue) ?? PhoneNumberAssociationName.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.PhoneNumberCapabilities: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundCall = "InboundCall"
        case inboundMMS = "InboundMMS"
        case inboundSMS = "InboundSMS"
        case outboundCall = "OutboundCall"
        case outboundMMS = "OutboundMMS"
        case outboundSMS = "OutboundSMS"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundCall = self.inboundCall {
            try encodeContainer.encode(inboundCall, forKey: .inboundCall)
        }
        if let inboundMMS = self.inboundMMS {
            try encodeContainer.encode(inboundMMS, forKey: .inboundMMS)
        }
        if let inboundSMS = self.inboundSMS {
            try encodeContainer.encode(inboundSMS, forKey: .inboundSMS)
        }
        if let outboundCall = self.outboundCall {
            try encodeContainer.encode(outboundCall, forKey: .outboundCall)
        }
        if let outboundMMS = self.outboundMMS {
            try encodeContainer.encode(outboundMMS, forKey: .outboundMMS)
        }
        if let outboundSMS = self.outboundSMS {
            try encodeContainer.encode(outboundSMS, forKey: .outboundSMS)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundCall)
        inboundCall = inboundCallDecoded
        let outboundCallDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundCall)
        outboundCall = outboundCallDecoded
        let inboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundSMS)
        inboundSMS = inboundSMSDecoded
        let outboundSMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundSMS)
        outboundSMS = outboundSMSDecoded
        let inboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inboundMMS)
        inboundMMS = inboundMMSDecoded
        let outboundMMSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .outboundMMS)
        outboundMMS = outboundMMSDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct PhoneNumberCapabilities: Swift.Equatable {
        public var inboundCall: Swift.Bool?
        public var inboundMMS: Swift.Bool?
        public var inboundSMS: Swift.Bool?
        public var outboundCall: Swift.Bool?
        public var outboundMMS: Swift.Bool?
        public var outboundSMS: Swift.Bool?

        public init (
            inboundCall: Swift.Bool? = nil,
            inboundMMS: Swift.Bool? = nil,
            inboundSMS: Swift.Bool? = nil,
            outboundCall: Swift.Bool? = nil,
            outboundMMS: Swift.Bool? = nil,
            outboundSMS: Swift.Bool? = nil
        )
        {
            self.inboundCall = inboundCall
            self.inboundMMS = inboundMMS
            self.inboundSMS = inboundSMS
            self.outboundCall = outboundCall
            self.outboundMMS = outboundMMS
            self.outboundSMS = outboundSMS
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberCountry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "CountryCode"
        case supportedPhoneNumberTypes = "SupportedPhoneNumberTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let supportedPhoneNumberTypes = supportedPhoneNumberTypes {
            var supportedPhoneNumberTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedPhoneNumberTypes)
            for phonenumbertype0 in supportedPhoneNumberTypes {
                try supportedPhoneNumberTypesContainer.encode(phonenumbertype0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let supportedPhoneNumberTypesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.PhoneNumberType?].self, forKey: .supportedPhoneNumberTypes)
        var supportedPhoneNumberTypesDecoded0:[ChimeSDKVoiceClientTypes.PhoneNumberType]? = nil
        if let supportedPhoneNumberTypesContainer = supportedPhoneNumberTypesContainer {
            supportedPhoneNumberTypesDecoded0 = [ChimeSDKVoiceClientTypes.PhoneNumberType]()
            for enum0 in supportedPhoneNumberTypesContainer {
                if let enum0 = enum0 {
                    supportedPhoneNumberTypesDecoded0?.append(enum0)
                }
            }
        }
        supportedPhoneNumberTypes = supportedPhoneNumberTypesDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct PhoneNumberCountry: Swift.Equatable {
        public var countryCode: Swift.String?
        public var supportedPhoneNumberTypes: [ChimeSDKVoiceClientTypes.PhoneNumberType]?

        public init (
            countryCode: Swift.String? = nil,
            supportedPhoneNumberTypes: [ChimeSDKVoiceClientTypes.PhoneNumberType]? = nil
        )
        {
            self.countryCode = countryCode
            self.supportedPhoneNumberTypes = supportedPhoneNumberTypes
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case phoneNumberId = "PhoneNumberId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ChimeSDKVoiceClientTypes.PhoneNumberError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct PhoneNumberError: Swift.Equatable {
        public var errorCode: ChimeSDKVoiceClientTypes.ErrorCode?
        public var errorMessage: Swift.String?
        public var phoneNumberId: Swift.String?

        public init (
            errorCode: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.phoneNumberId = phoneNumberId
        }
    }

}

extension ChimeSDKVoiceClientTypes.PhoneNumberOrder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case orderType = "OrderType"
        case orderedPhoneNumbers = "OrderedPhoneNumbers"
        case phoneNumberOrderId = "PhoneNumberOrderId"
        case productType = "ProductType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let orderType = self.orderType {
            try encodeContainer.encode(orderType.rawValue, forKey: .orderType)
        }
        if let orderedPhoneNumbers = orderedPhoneNumbers {
            var orderedPhoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .orderedPhoneNumbers)
            for orderedphonenumber0 in orderedPhoneNumbers {
                try orderedPhoneNumbersContainer.encode(orderedphonenumber0)
            }
        }
        if let phoneNumberOrderId = self.phoneNumberOrderId {
            try encodeContainer.encode(phoneNumberOrderId, forKey: .phoneNumberOrderId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberOrderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberOrderId)
        phoneNumberOrderId = phoneNumberOrderIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrderStatus.self, forKey: .status)
        status = statusDecoded
        let orderTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberOrderType.self, forKey: .orderType)
        orderType = orderTypeDecoded
        let orderedPhoneNumbersContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.OrderedPhoneNumber?].self, forKey: .orderedPhoneNumbers)
        var orderedPhoneNumbersDecoded0:[ChimeSDKVoiceClientTypes.OrderedPhoneNumber]? = nil
        if let orderedPhoneNumbersContainer = orderedPhoneNumbersContainer {
            orderedPhoneNumbersDecoded0 = [ChimeSDKVoiceClientTypes.OrderedPhoneNumber]()
            for structure0 in orderedPhoneNumbersContainer {
                if let structure0 = structure0 {
                    orderedPhoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        orderedPhoneNumbers = orderedPhoneNumbersDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct PhoneNumberOrder: Swift.Equatable {
        public var createdTimestamp: ClientRuntime.Date?
        public var orderType: ChimeSDKVoiceClientTypes.PhoneNumberOrderType?
        public var orderedPhoneNumbers: [ChimeSDKVoiceClientTypes.OrderedPhoneNumber]?
        public var phoneNumberOrderId: Swift.String?
        public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
        public var status: ChimeSDKVoiceClientTypes.PhoneNumberOrderStatus?
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            orderType: ChimeSDKVoiceClientTypes.PhoneNumberOrderType? = nil,
            orderedPhoneNumbers: [ChimeSDKVoiceClientTypes.OrderedPhoneNumber]? = nil,
            phoneNumberOrderId: Swift.String? = nil,
            productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil,
            status: ChimeSDKVoiceClientTypes.PhoneNumberOrderStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.orderType = orderType
            self.orderedPhoneNumbers = orderedPhoneNumbers
            self.phoneNumberOrderId = phoneNumberOrderId
            self.productType = productType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberOrderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelrequested
        case cancelled
        case changerequested
        case exception
        case foc
        case failed
        case partial
        case pendingdocuments
        case processing
        case submitted
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberOrderStatus] {
            return [
                .cancelrequested,
                .cancelled,
                .changerequested,
                .exception,
                .foc,
                .failed,
                .partial,
                .pendingdocuments,
                .processing,
                .submitted,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelrequested: return "CancelRequested"
            case .cancelled: return "Cancelled"
            case .changerequested: return "ChangeRequested"
            case .exception: return "Exception"
            case .foc: return "FOC"
            case .failed: return "Failed"
            case .partial: return "Partial"
            case .pendingdocuments: return "PendingDocuments"
            case .processing: return "Processing"
            case .submitted: return "Submitted"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberOrderStatus(rawValue: rawValue) ?? PhoneNumberOrderStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberOrderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case new
        case porting
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberOrderType] {
            return [
                .new,
                .porting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .new: return "New"
            case .porting: return "Porting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberOrderType(rawValue: rawValue) ?? PhoneNumberOrderType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberProductType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sipmediaapplicationdialin
        case voiceconnector
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberProductType] {
            return [
                .sipmediaapplicationdialin,
                .voiceconnector,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sipmediaapplicationdialin: return "SipMediaApplicationDialIn"
            case .voiceconnector: return "VoiceConnector"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberProductType(rawValue: rawValue) ?? PhoneNumberProductType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acquirefailed
        case acquireinprogress
        case assigned
        case cancelled
        case deletefailed
        case deleteinprogress
        case portincancelrequested
        case portininprogress
        case releasefailed
        case releaseinprogress
        case unassigned
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberStatus] {
            return [
                .acquirefailed,
                .acquireinprogress,
                .assigned,
                .cancelled,
                .deletefailed,
                .deleteinprogress,
                .portincancelrequested,
                .portininprogress,
                .releasefailed,
                .releaseinprogress,
                .unassigned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acquirefailed: return "AcquireFailed"
            case .acquireinprogress: return "AcquireInProgress"
            case .assigned: return "Assigned"
            case .cancelled: return "Cancelled"
            case .deletefailed: return "DeleteFailed"
            case .deleteinprogress: return "DeleteInProgress"
            case .portincancelrequested: return "PortinCancelRequested"
            case .portininprogress: return "PortinInProgress"
            case .releasefailed: return "ReleaseFailed"
            case .releaseinprogress: return "ReleaseInProgress"
            case .unassigned: return "Unassigned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberStatus(rawValue: rawValue) ?? PhoneNumberStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes {
    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case local
        case tollfree
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .local,
                .tollfree,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .local: return "Local"
            case .tollfree: return "TollFree"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.Proxy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberCountries = "PhoneNumberCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = self.defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = self.fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberCountries = phoneNumberCountries {
            var phoneNumberCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberCountries)
            for string0 in phoneNumberCountries {
                try phoneNumberCountriesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let phoneNumberCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberCountries)
        var phoneNumberCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberCountriesContainer = phoneNumberCountriesContainer {
            phoneNumberCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberCountriesContainer {
                if let string0 = string0 {
                    phoneNumberCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberCountries = phoneNumberCountriesDecoded0
    }
}

extension ChimeSDKVoiceClientTypes.Proxy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Proxy(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberCountries: \(Swift.String(describing: phoneNumberCountries)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct Proxy: Swift.Equatable {
        public var defaultSessionExpiryMinutes: Swift.Int?
        public var disabled: Swift.Bool?
        public var fallBackPhoneNumber: Swift.String?
        public var phoneNumberCountries: [Swift.String]?

        public init (
            defaultSessionExpiryMinutes: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            fallBackPhoneNumber: Swift.String? = nil,
            phoneNumberCountries: [Swift.String]? = nil
        )
        {
            self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
            self.disabled = disabled
            self.fallBackPhoneNumber = fallBackPhoneNumber
            self.phoneNumberCountries = phoneNumberCountries
        }
    }

}

extension ChimeSDKVoiceClientTypes.ProxySession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case createdTimestamp = "CreatedTimestamp"
        case endedTimestamp = "EndedTimestamp"
        case expiryMinutes = "ExpiryMinutes"
        case geoMatchLevel = "GeoMatchLevel"
        case geoMatchParams = "GeoMatchParams"
        case name = "Name"
        case numberSelectionBehavior = "NumberSelectionBehavior"
        case participants = "Participants"
        case proxySessionId = "ProxySessionId"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let endedTimestamp = self.endedTimestamp {
            try encodeContainer.encodeTimestamp(endedTimestamp, format: .dateTime, forKey: .endedTimestamp)
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
        if let geoMatchLevel = self.geoMatchLevel {
            try encodeContainer.encode(geoMatchLevel.rawValue, forKey: .geoMatchLevel)
        }
        if let geoMatchParams = self.geoMatchParams {
            try encodeContainer.encode(geoMatchParams, forKey: .geoMatchParams)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberSelectionBehavior = self.numberSelectionBehavior {
            try encodeContainer.encode(numberSelectionBehavior.rawValue, forKey: .numberSelectionBehavior)
        }
        if let participants = participants {
            var participantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participants)
            for participant0 in participants {
                try participantsContainer.encode(participant0)
            }
        }
        if let proxySessionId = self.proxySessionId {
            try encodeContainer.encode(proxySessionId, forKey: .proxySessionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let proxySessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxySessionId)
        proxySessionId = proxySessionIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySessionStatus.self, forKey: .status)
        status = statusDecoded
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeSDKVoiceClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeSDKVoiceClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let endedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endedTimestamp)
        endedTimestamp = endedTimestampDecoded
        let participantsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Participant?].self, forKey: .participants)
        var participantsDecoded0:[ChimeSDKVoiceClientTypes.Participant]? = nil
        if let participantsContainer = participantsContainer {
            participantsDecoded0 = [ChimeSDKVoiceClientTypes.Participant]()
            for structure0 in participantsContainer {
                if let structure0 = structure0 {
                    participantsDecoded0?.append(structure0)
                }
            }
        }
        participants = participantsDecoded0
        let numberSelectionBehaviorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.NumberSelectionBehavior.self, forKey: .numberSelectionBehavior)
        numberSelectionBehavior = numberSelectionBehaviorDecoded
        let geoMatchLevelDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchLevel.self, forKey: .geoMatchLevel)
        geoMatchLevel = geoMatchLevelDecoded
        let geoMatchParamsDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.GeoMatchParams.self, forKey: .geoMatchParams)
        geoMatchParams = geoMatchParamsDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct ProxySession: Swift.Equatable {
        public var capabilities: [ChimeSDKVoiceClientTypes.Capability]?
        public var createdTimestamp: ClientRuntime.Date?
        public var endedTimestamp: ClientRuntime.Date?
        public var expiryMinutes: Swift.Int?
        public var geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel?
        public var geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams?
        public var name: Swift.String?
        public var numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior?
        public var participants: [ChimeSDKVoiceClientTypes.Participant]?
        public var proxySessionId: Swift.String?
        public var status: ChimeSDKVoiceClientTypes.ProxySessionStatus?
        public var updatedTimestamp: ClientRuntime.Date?
        public var voiceConnectorId: Swift.String?

        public init (
            capabilities: [ChimeSDKVoiceClientTypes.Capability]? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endedTimestamp: ClientRuntime.Date? = nil,
            expiryMinutes: Swift.Int? = nil,
            geoMatchLevel: ChimeSDKVoiceClientTypes.GeoMatchLevel? = nil,
            geoMatchParams: ChimeSDKVoiceClientTypes.GeoMatchParams? = nil,
            name: Swift.String? = nil,
            numberSelectionBehavior: ChimeSDKVoiceClientTypes.NumberSelectionBehavior? = nil,
            participants: [ChimeSDKVoiceClientTypes.Participant]? = nil,
            proxySessionId: Swift.String? = nil,
            status: ChimeSDKVoiceClientTypes.ProxySessionStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.createdTimestamp = createdTimestamp
            self.endedTimestamp = endedTimestamp
            self.expiryMinutes = expiryMinutes
            self.geoMatchLevel = geoMatchLevel
            self.geoMatchParams = geoMatchParams
            self.name = name
            self.numberSelectionBehavior = numberSelectionBehavior
            self.participants = participants
            self.proxySessionId = proxySessionId
            self.status = status
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum ProxySessionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case inprogress
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [ProxySessionStatus] {
            return [
                .closed,
                .inprogress,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "Closed"
            case .inprogress: return "InProgress"
            case .open: return "Open"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProxySessionStatus(rawValue: rawValue) ?? ProxySessionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sipMediaApplicationAlexaSkillConfiguration = self.sipMediaApplicationAlexaSkillConfiguration {
            try encodeContainer.encode(sipMediaApplicationAlexaSkillConfiguration, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        }
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/alexa-skill-configuration"
    }
}

public struct PutSipMediaApplicationAlexaSkillConfigurationInput: Swift.Equatable {
    public var sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfiguration
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct PutSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Equatable {
    let sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
}

extension PutSipMediaApplicationAlexaSkillConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationAlexaSkillConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration.self, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfigurationDecoded
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSipMediaApplicationAlexaSkillConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutSipMediaApplicationAlexaSkillConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSipMediaApplicationAlexaSkillConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutSipMediaApplicationAlexaSkillConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationAlexaSkillConfiguration = output.sipMediaApplicationAlexaSkillConfiguration
        } else {
            self.sipMediaApplicationAlexaSkillConfiguration = nil
        }
    }
}

public struct PutSipMediaApplicationAlexaSkillConfigurationOutputResponse: Swift.Equatable {
    public var sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?

    public init (
        sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration? = nil
    )
    {
        self.sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfiguration
    }
}

struct PutSipMediaApplicationAlexaSkillConfigurationOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationAlexaSkillConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration?
}

extension PutSipMediaApplicationAlexaSkillConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationAlexaSkillConfiguration = "SipMediaApplicationAlexaSkillConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationAlexaSkillConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration.self, forKey: .sipMediaApplicationAlexaSkillConfiguration)
        sipMediaApplicationAlexaSkillConfiguration = sipMediaApplicationAlexaSkillConfigurationDecoded
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sipMediaApplicationLoggingConfiguration = self.sipMediaApplicationLoggingConfiguration {
            try encodeContainer.encode(sipMediaApplicationLoggingConfiguration, forKey: .sipMediaApplicationLoggingConfiguration)
        }
    }
}

extension PutSipMediaApplicationLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/logging-configuration"
    }
}

public struct PutSipMediaApplicationLoggingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    public var sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?

    public init (
        sipMediaApplicationId: Swift.String? = nil,
        sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationId = sipMediaApplicationId
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationInputBody: Swift.Equatable {
    let sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

extension PutSipMediaApplicationLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSipMediaApplicationLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutSipMediaApplicationLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSipMediaApplicationLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutSipMediaApplicationLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationLoggingConfiguration = output.sipMediaApplicationLoggingConfiguration
        } else {
            self.sipMediaApplicationLoggingConfiguration = nil
        }
    }
}

public struct PutSipMediaApplicationLoggingConfigurationOutputResponse: Swift.Equatable {
    public var sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?

    public init (
        sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration? = nil
    )
    {
        self.sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfiguration
    }
}

struct PutSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationLoggingConfiguration: ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration?
}

extension PutSipMediaApplicationLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationLoggingConfiguration = "SipMediaApplicationLoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationLoggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration.self, forKey: .sipMediaApplicationLoggingConfiguration)
        sipMediaApplicationLoggingConfiguration = sipMediaApplicationLoggingConfigurationDecoded
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyCallingConfiguration = self.emergencyCallingConfiguration {
            try encodeContainer.encode(emergencyCallingConfiguration, forKey: .emergencyCallingConfiguration)
        }
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/emergency-calling-configuration"
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Equatable {
    let emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutVoiceConnectorEmergencyCallingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutVoiceConnectorEmergencyCallingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.emergencyCallingConfiguration = output.emergencyCallingConfiguration
        } else {
            self.emergencyCallingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorEmergencyCallingConfigurationOutputResponse: Swift.Equatable {
    public var emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?

    public init (
        emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration? = nil
    )
    {
        self.emergencyCallingConfiguration = emergencyCallingConfiguration
    }
}

struct PutVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Equatable {
    let emergencyCallingConfiguration: ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration?
}

extension PutVoiceConnectorEmergencyCallingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyCallingConfiguration = "EmergencyCallingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyCallingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.EmergencyCallingConfiguration.self, forKey: .emergencyCallingConfiguration)
        emergencyCallingConfiguration = emergencyCallingConfigurationDecoded
    }
}

extension PutVoiceConnectorLoggingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfiguration = self.loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
    }
}

extension PutVoiceConnectorLoggingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/logging-configuration"
    }
}

public struct PutVoiceConnectorLoggingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorLoggingConfigurationInputBody: Swift.Equatable {
    let loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension PutVoiceConnectorLoggingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorLoggingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutVoiceConnectorLoggingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorLoggingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutVoiceConnectorLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorLoggingConfigurationOutputResponse: Swift.Equatable {
    public var loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?

    public init (
        loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct PutVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Equatable {
    let loggingConfiguration: ChimeSDKVoiceClientTypes.LoggingConfiguration?
}

extension PutVoiceConnectorLoggingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension PutVoiceConnectorOriginationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let origination = self.origination {
            try encodeContainer.encode(origination, forKey: .origination)
        }
    }
}

extension PutVoiceConnectorOriginationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/origination"
    }
}

public struct PutVoiceConnectorOriginationInput: Swift.Equatable {
    /// This member is required.
    public var origination: ChimeSDKVoiceClientTypes.Origination?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        origination: ChimeSDKVoiceClientTypes.Origination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.origination = origination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorOriginationInputBody: Swift.Equatable {
    let origination: ChimeSDKVoiceClientTypes.Origination?
}

extension PutVoiceConnectorOriginationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

extension PutVoiceConnectorOriginationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorOriginationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutVoiceConnectorOriginationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorOriginationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutVoiceConnectorOriginationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.origination = output.origination
        } else {
            self.origination = nil
        }
    }
}

public struct PutVoiceConnectorOriginationOutputResponse: Swift.Equatable {
    public var origination: ChimeSDKVoiceClientTypes.Origination?

    public init (
        origination: ChimeSDKVoiceClientTypes.Origination? = nil
    )
    {
        self.origination = origination
    }
}

struct PutVoiceConnectorOriginationOutputResponseBody: Swift.Equatable {
    let origination: ChimeSDKVoiceClientTypes.Origination?
}

extension PutVoiceConnectorOriginationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origination = "Origination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Origination.self, forKey: .origination)
        origination = originationDecoded
    }
}

extension PutVoiceConnectorProxyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutVoiceConnectorProxyInput(defaultSessionExpiryMinutes: \(Swift.String(describing: defaultSessionExpiryMinutes)), disabled: \(Swift.String(describing: disabled)), phoneNumberPoolCountries: \(Swift.String(describing: phoneNumberPoolCountries)), voiceConnectorId: \(Swift.String(describing: voiceConnectorId)), fallBackPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension PutVoiceConnectorProxyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSessionExpiryMinutes = self.defaultSessionExpiryMinutes {
            try encodeContainer.encode(defaultSessionExpiryMinutes, forKey: .defaultSessionExpiryMinutes)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let fallBackPhoneNumber = self.fallBackPhoneNumber {
            try encodeContainer.encode(fallBackPhoneNumber, forKey: .fallBackPhoneNumber)
        }
        if let phoneNumberPoolCountries = phoneNumberPoolCountries {
            var phoneNumberPoolCountriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumberPoolCountries)
            for country0 in phoneNumberPoolCountries {
                try phoneNumberPoolCountriesContainer.encode(country0)
            }
        }
    }
}

extension PutVoiceConnectorProxyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/programmable-numbers/proxy"
    }
}

public struct PutVoiceConnectorProxyInput: Swift.Equatable {
    /// This member is required.
    public var defaultSessionExpiryMinutes: Swift.Int?
    public var disabled: Swift.Bool?
    public var fallBackPhoneNumber: Swift.String?
    /// This member is required.
    public var phoneNumberPoolCountries: [Swift.String]?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        defaultSessionExpiryMinutes: Swift.Int? = nil,
        disabled: Swift.Bool? = nil,
        fallBackPhoneNumber: Swift.String? = nil,
        phoneNumberPoolCountries: [Swift.String]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.defaultSessionExpiryMinutes = defaultSessionExpiryMinutes
        self.disabled = disabled
        self.fallBackPhoneNumber = fallBackPhoneNumber
        self.phoneNumberPoolCountries = phoneNumberPoolCountries
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorProxyInputBody: Swift.Equatable {
    let defaultSessionExpiryMinutes: Swift.Int?
    let phoneNumberPoolCountries: [Swift.String]?
    let fallBackPhoneNumber: Swift.String?
    let disabled: Swift.Bool?
}

extension PutVoiceConnectorProxyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultSessionExpiryMinutes = "DefaultSessionExpiryMinutes"
        case disabled = "Disabled"
        case fallBackPhoneNumber = "FallBackPhoneNumber"
        case phoneNumberPoolCountries = "PhoneNumberPoolCountries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSessionExpiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultSessionExpiryMinutes)
        defaultSessionExpiryMinutes = defaultSessionExpiryMinutesDecoded
        let phoneNumberPoolCountriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phoneNumberPoolCountries)
        var phoneNumberPoolCountriesDecoded0:[Swift.String]? = nil
        if let phoneNumberPoolCountriesContainer = phoneNumberPoolCountriesContainer {
            phoneNumberPoolCountriesDecoded0 = [Swift.String]()
            for string0 in phoneNumberPoolCountriesContainer {
                if let string0 = string0 {
                    phoneNumberPoolCountriesDecoded0?.append(string0)
                }
            }
        }
        phoneNumberPoolCountries = phoneNumberPoolCountriesDecoded0
        let fallBackPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fallBackPhoneNumber)
        fallBackPhoneNumber = fallBackPhoneNumberDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension PutVoiceConnectorProxyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorProxyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutVoiceConnectorProxyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorProxyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutVoiceConnectorProxyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxy = output.proxy
        } else {
            self.proxy = nil
        }
    }
}

public struct PutVoiceConnectorProxyOutputResponse: Swift.Equatable {
    public var proxy: ChimeSDKVoiceClientTypes.Proxy?

    public init (
        proxy: ChimeSDKVoiceClientTypes.Proxy? = nil
    )
    {
        self.proxy = proxy
    }
}

struct PutVoiceConnectorProxyOutputResponseBody: Swift.Equatable {
    let proxy: ChimeSDKVoiceClientTypes.Proxy?
}

extension PutVoiceConnectorProxyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxy = "Proxy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxyDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Proxy.self, forKey: .proxy)
        proxy = proxyDecoded
    }
}

extension PutVoiceConnectorStreamingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamingConfiguration = self.streamingConfiguration {
            try encodeContainer.encode(streamingConfiguration, forKey: .streamingConfiguration)
        }
    }
}

extension PutVoiceConnectorStreamingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/streaming-configuration"
    }
}

public struct PutVoiceConnectorStreamingConfigurationInput: Swift.Equatable {
    /// This member is required.
    public var streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorStreamingConfigurationInputBody: Swift.Equatable {
    let streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension PutVoiceConnectorStreamingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorStreamingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutVoiceConnectorStreamingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorStreamingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutVoiceConnectorStreamingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamingConfiguration = output.streamingConfiguration
        } else {
            self.streamingConfiguration = nil
        }
    }
}

public struct PutVoiceConnectorStreamingConfigurationOutputResponse: Swift.Equatable {
    public var streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?

    public init (
        streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration? = nil
    )
    {
        self.streamingConfiguration = streamingConfiguration
    }
}

struct PutVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Equatable {
    let streamingConfiguration: ChimeSDKVoiceClientTypes.StreamingConfiguration?
}

extension PutVoiceConnectorStreamingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingConfiguration = "StreamingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.StreamingConfiguration.self, forKey: .streamingConfiguration)
        streamingConfiguration = streamingConfigurationDecoded
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentials = credentials {
            var credentialsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .credentials)
            for credential0 in credentials {
                try credentialsContainer.encode(credential0)
            }
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "put"))
            return items
        }
    }
}

extension PutVoiceConnectorTerminationCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination/credentials"
    }
}

public struct PutVoiceConnectorTerminationCredentialsInput: Swift.Equatable {
    public var credentials: [ChimeSDKVoiceClientTypes.Credential]?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        credentials: [ChimeSDKVoiceClientTypes.Credential]? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationCredentialsInputBody: Swift.Equatable {
    let credentials: [ChimeSDKVoiceClientTypes.Credential]?
}

extension PutVoiceConnectorTerminationCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials = "Credentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Credential?].self, forKey: .credentials)
        var credentialsDecoded0:[ChimeSDKVoiceClientTypes.Credential]? = nil
        if let credentialsContainer = credentialsContainer {
            credentialsDecoded0 = [ChimeSDKVoiceClientTypes.Credential]()
            for structure0 in credentialsContainer {
                if let structure0 = structure0 {
                    credentialsDecoded0?.append(structure0)
                }
            }
        }
        credentials = credentialsDecoded0
    }
}

extension PutVoiceConnectorTerminationCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorTerminationCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutVoiceConnectorTerminationCredentialsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorTerminationCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutVoiceConnectorTerminationCredentialsOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutVoiceConnectorTerminationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let termination = self.termination {
            try encodeContainer.encode(termination, forKey: .termination)
        }
    }
}

extension PutVoiceConnectorTerminationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/termination"
    }
}

public struct PutVoiceConnectorTerminationInput: Swift.Equatable {
    /// This member is required.
    public var termination: ChimeSDKVoiceClientTypes.Termination?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        termination: ChimeSDKVoiceClientTypes.Termination? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.termination = termination
        self.voiceConnectorId = voiceConnectorId
    }
}

struct PutVoiceConnectorTerminationInputBody: Swift.Equatable {
    let termination: ChimeSDKVoiceClientTypes.Termination?
}

extension PutVoiceConnectorTerminationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension PutVoiceConnectorTerminationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutVoiceConnectorTerminationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutVoiceConnectorTerminationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutVoiceConnectorTerminationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutVoiceConnectorTerminationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.termination = output.termination
        } else {
            self.termination = nil
        }
    }
}

public struct PutVoiceConnectorTerminationOutputResponse: Swift.Equatable {
    public var termination: ChimeSDKVoiceClientTypes.Termination?

    public init (
        termination: ChimeSDKVoiceClientTypes.Termination? = nil
    )
    {
        self.termination = termination
    }
}

struct PutVoiceConnectorTerminationOutputResponseBody: Swift.Equatable {
    let termination: ChimeSDKVoiceClientTypes.Termination?
}

extension PutVoiceConnectorTerminationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case termination = "Termination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let terminationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Termination.self, forKey: .termination)
        termination = terminationDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RestorePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestorePhoneNumberInput(phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension RestorePhoneNumberInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "restore"))
            return items
        }
    }
}

extension RestorePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct RestorePhoneNumberInput: Swift.Equatable {
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init (
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

struct RestorePhoneNumberInputBody: Swift.Equatable {
}

extension RestorePhoneNumberInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RestorePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestorePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RestorePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestorePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RestorePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct RestorePhoneNumberOutputResponse: Swift.Equatable {
    public var phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?

    public init (
        phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct RestorePhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?
}

extension RestorePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension SearchAvailablePhoneNumbersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "type", value: "phone-numbers"))
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let areaCode = areaCode {
                let areaCodeQueryItem = ClientRuntime.URLQueryItem(name: "area-code".urlPercentEncoding(), value: Swift.String(areaCode).urlPercentEncoding())
                items.append(areaCodeQueryItem)
            }
            if let country = country {
                let countryQueryItem = ClientRuntime.URLQueryItem(name: "country".urlPercentEncoding(), value: Swift.String(country).urlPercentEncoding())
                items.append(countryQueryItem)
            }
            if let city = city {
                let cityQueryItem = ClientRuntime.URLQueryItem(name: "city".urlPercentEncoding(), value: Swift.String(city).urlPercentEncoding())
                items.append(cityQueryItem)
            }
            if let phoneNumberType = phoneNumberType {
                let phoneNumberTypeQueryItem = ClientRuntime.URLQueryItem(name: "phone-number-type".urlPercentEncoding(), value: Swift.String(phoneNumberType.rawValue).urlPercentEncoding())
                items.append(phoneNumberTypeQueryItem)
            }
            if let tollFreePrefix = tollFreePrefix {
                let tollFreePrefixQueryItem = ClientRuntime.URLQueryItem(name: "toll-free-prefix".urlPercentEncoding(), value: Swift.String(tollFreePrefix).urlPercentEncoding())
                items.append(tollFreePrefixQueryItem)
            }
            return items
        }
    }
}

extension SearchAvailablePhoneNumbersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/search"
    }
}

public struct SearchAvailablePhoneNumbersInput: Swift.Equatable {
    public var areaCode: Swift.String?
    public var city: Swift.String?
    public var country: Swift.String?
    public var maxResults: Swift.Int?
    public var nextToken: Swift.String?
    public var phoneNumberType: ChimeSDKVoiceClientTypes.PhoneNumberType?
    public var state: Swift.String?
    public var tollFreePrefix: Swift.String?

    public init (
        areaCode: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        phoneNumberType: ChimeSDKVoiceClientTypes.PhoneNumberType? = nil,
        state: Swift.String? = nil,
        tollFreePrefix: Swift.String? = nil
    )
    {
        self.areaCode = areaCode
        self.city = city
        self.country = country
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.phoneNumberType = phoneNumberType
        self.state = state
        self.tollFreePrefix = tollFreePrefix
    }
}

struct SearchAvailablePhoneNumbersInputBody: Swift.Equatable {
}

extension SearchAvailablePhoneNumbersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SearchAvailablePhoneNumbersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchAvailablePhoneNumbersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SearchAvailablePhoneNumbersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchAvailablePhoneNumbersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SearchAvailablePhoneNumbersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.e164PhoneNumbers = output.e164PhoneNumbers
            self.nextToken = output.nextToken
        } else {
            self.e164PhoneNumbers = nil
            self.nextToken = nil
        }
    }
}

public struct SearchAvailablePhoneNumbersOutputResponse: Swift.Equatable {
    public var e164PhoneNumbers: [Swift.String]?
    public var nextToken: Swift.String?

    public init (
        e164PhoneNumbers: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.e164PhoneNumbers = e164PhoneNumbers
        self.nextToken = nextToken
    }
}

struct SearchAvailablePhoneNumbersOutputResponseBody: Swift.Equatable {
    let e164PhoneNumbers: [Swift.String]?
    let nextToken: Swift.String?
}

extension SearchAvailablePhoneNumbersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case e164PhoneNumbers = "E164PhoneNumbers"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let e164PhoneNumbersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .e164PhoneNumbers)
        var e164PhoneNumbersDecoded0:[Swift.String]? = nil
        if let e164PhoneNumbersContainer = e164PhoneNumbersContainer {
            e164PhoneNumbersDecoded0 = [Swift.String]()
            for string0 in e164PhoneNumbersContainer {
                if let string0 = string0 {
                    e164PhoneNumbersDecoded0?.append(string0)
                }
            }
        }
        e164PhoneNumbers = e164PhoneNumbersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKVoiceClientTypes.SipMediaApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case endpoints = "Endpoints"
        case name = "Name"
        case sipMediaApplicationId = "SipMediaApplicationId"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipMediaApplicationId = self.sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct SipMediaApplication: Swift.Equatable {
        public var awsRegion: Swift.String?
        public var createdTimestamp: ClientRuntime.Date?
        public var endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
        public var name: Swift.String?
        public var sipMediaApplicationId: Swift.String?
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            awsRegion: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil,
            name: Swift.String? = nil,
            sipMediaApplicationId: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.endpoints = endpoints
            self.name = name
            self.sipMediaApplicationId = sipMediaApplicationId
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationAlexaSkillConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alexaSkillIds = "AlexaSkillIds"
        case alexaSkillStatus = "AlexaSkillStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alexaSkillIds = alexaSkillIds {
            var alexaSkillIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alexaSkillIds)
            for alexaskillid0 in alexaSkillIds {
                try alexaSkillIdsContainer.encode(alexaskillid0)
            }
        }
        if let alexaSkillStatus = self.alexaSkillStatus {
            try encodeContainer.encode(alexaSkillStatus.rawValue, forKey: .alexaSkillStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alexaSkillStatusDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.AlexaSkillStatus.self, forKey: .alexaSkillStatus)
        alexaSkillStatus = alexaSkillStatusDecoded
        let alexaSkillIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .alexaSkillIds)
        var alexaSkillIdsDecoded0:[Swift.String]? = nil
        if let alexaSkillIdsContainer = alexaSkillIdsContainer {
            alexaSkillIdsDecoded0 = [Swift.String]()
            for string0 in alexaSkillIdsContainer {
                if let string0 = string0 {
                    alexaSkillIdsDecoded0?.append(string0)
                }
            }
        }
        alexaSkillIds = alexaSkillIdsDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct SipMediaApplicationAlexaSkillConfiguration: Swift.Equatable {
        /// This member is required.
        public var alexaSkillIds: [Swift.String]?
        /// This member is required.
        public var alexaSkillStatus: ChimeSDKVoiceClientTypes.AlexaSkillStatus?

        public init (
            alexaSkillIds: [Swift.String]? = nil,
            alexaSkillStatus: ChimeSDKVoiceClientTypes.AlexaSkillStatus? = nil
        )
        {
            self.alexaSkillIds = alexaSkillIds
            self.alexaSkillStatus = alexaSkillStatus
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationCall: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId = "TransactionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct SipMediaApplicationCall: Swift.Equatable {
        public var transactionId: Swift.String?

        public init (
            transactionId: Swift.String? = nil
        )
        {
            self.transactionId = transactionId
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SipMediaApplicationEndpoint(lambdaArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct SipMediaApplicationEndpoint: Swift.Equatable {
        public var lambdaArn: Swift.String?

        public init (
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipMediaApplicationLoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableSipMediaApplicationMessageLogs = "EnableSipMediaApplicationMessageLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enableSipMediaApplicationMessageLogs = self.enableSipMediaApplicationMessageLogs {
            try encodeContainer.encode(enableSipMediaApplicationMessageLogs, forKey: .enableSipMediaApplicationMessageLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableSipMediaApplicationMessageLogsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableSipMediaApplicationMessageLogs)
        enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogsDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct SipMediaApplicationLoggingConfiguration: Swift.Equatable {
        public var enableSipMediaApplicationMessageLogs: Swift.Bool?

        public init (
            enableSipMediaApplicationMessageLogs: Swift.Bool? = nil
        )
        {
            self.enableSipMediaApplicationMessageLogs = enableSipMediaApplicationMessageLogs
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case disabled = "Disabled"
        case name = "Name"
        case sipRuleId = "SipRuleId"
        case targetApplications = "TargetApplications"
        case triggerType = "TriggerType"
        case triggerValue = "TriggerValue"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sipRuleId = self.sipRuleId {
            try encodeContainer.encode(sipRuleId, forKey: .sipRuleId)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
        if let triggerValue = self.triggerValue {
            try encodeContainer.encode(triggerValue, forKey: .triggerValue)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipRuleId)
        sipRuleId = sipRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRuleTriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerValue)
        triggerValue = triggerValueDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct SipRule: Swift.Equatable {
        public var createdTimestamp: ClientRuntime.Date?
        public var disabled: Swift.Bool?
        public var name: Swift.String?
        public var sipRuleId: Swift.String?
        public var targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
        public var triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType?
        public var triggerValue: Swift.String?
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            disabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            sipRuleId: Swift.String? = nil,
            targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil,
            triggerType: ChimeSDKVoiceClientTypes.SipRuleTriggerType? = nil,
            triggerValue: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.disabled = disabled
            self.name = name
            self.sipRuleId = sipRuleId
            self.targetApplications = targetApplications
            self.triggerType = triggerType
            self.triggerValue = triggerValue
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSDKVoiceClientTypes.SipRuleTargetApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case priority = "Priority"
        case sipMediaApplicationId = "SipMediaApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let sipMediaApplicationId = self.sipMediaApplicationId {
            try encodeContainer.encode(sipMediaApplicationId, forKey: .sipMediaApplicationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sipMediaApplicationId)
        sipMediaApplicationId = sipMediaApplicationIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct SipRuleTargetApplication: Swift.Equatable {
        public var awsRegion: Swift.String?
        public var priority: Swift.Int?
        public var sipMediaApplicationId: Swift.String?

        public init (
            awsRegion: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sipMediaApplicationId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.priority = priority
            self.sipMediaApplicationId = sipMediaApplicationId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum SipRuleTriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case requesturihostname
        case tophonenumber
        case sdkUnknown(Swift.String)

        public static var allCases: [SipRuleTriggerType] {
            return [
                .requesturihostname,
                .tophonenumber,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .requesturihostname: return "RequestUriHostname"
            case .tophonenumber: return "ToPhoneNumber"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SipRuleTriggerType(rawValue: rawValue) ?? SipRuleTriggerType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.StreamingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case disabled = "Disabled"
        case streamingNotificationTargets = "StreamingNotificationTargets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let streamingNotificationTargets = streamingNotificationTargets {
            var streamingNotificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingNotificationTargets)
            for streamingnotificationtarget0 in streamingNotificationTargets {
                try streamingNotificationTargetsContainer.encode(streamingnotificationtarget0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let streamingNotificationTargetsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.StreamingNotificationTarget?].self, forKey: .streamingNotificationTargets)
        var streamingNotificationTargetsDecoded0:[ChimeSDKVoiceClientTypes.StreamingNotificationTarget]? = nil
        if let streamingNotificationTargetsContainer = streamingNotificationTargetsContainer {
            streamingNotificationTargetsDecoded0 = [ChimeSDKVoiceClientTypes.StreamingNotificationTarget]()
            for structure0 in streamingNotificationTargetsContainer {
                if let structure0 = structure0 {
                    streamingNotificationTargetsDecoded0?.append(structure0)
                }
            }
        }
        streamingNotificationTargets = streamingNotificationTargetsDecoded0
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct StreamingConfiguration: Swift.Equatable {
        /// This member is required.
        public var dataRetentionInHours: Swift.Int?
        /// This member is required.
        public var disabled: Swift.Bool?
        public var streamingNotificationTargets: [ChimeSDKVoiceClientTypes.StreamingNotificationTarget]?

        public init (
            dataRetentionInHours: Swift.Int? = nil,
            disabled: Swift.Bool? = nil,
            streamingNotificationTargets: [ChimeSDKVoiceClientTypes.StreamingNotificationTarget]? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
            self.disabled = disabled
            self.streamingNotificationTargets = streamingNotificationTargets
        }
    }

}

extension ChimeSDKVoiceClientTypes.StreamingNotificationTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationTarget = "NotificationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationTarget = self.notificationTarget {
            try encodeContainer.encode(notificationTarget.rawValue, forKey: .notificationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationTargetDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.NotificationTarget.self, forKey: .notificationTarget)
        notificationTarget = notificationTargetDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct StreamingNotificationTarget: Swift.Equatable {
        public var notificationTarget: ChimeSDKVoiceClientTypes.NotificationTarget?

        public init (
            notificationTarget: ChimeSDKVoiceClientTypes.NotificationTarget? = nil
        )
        {
            self.notificationTarget = notificationTarget
        }
    }

}

extension ChimeSDKVoiceClientTypes.Termination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingRegions = "CallingRegions"
        case cidrAllowedList = "CidrAllowedList"
        case cpsLimit = "CpsLimit"
        case defaultPhoneNumber = "DefaultPhoneNumber"
        case disabled = "Disabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingRegions = callingRegions {
            var callingRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .callingRegions)
            for callingregion0 in callingRegions {
                try callingRegionsContainer.encode(callingregion0)
            }
        }
        if let cidrAllowedList = cidrAllowedList {
            var cidrAllowedListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowedList)
            for string0 in cidrAllowedList {
                try cidrAllowedListContainer.encode(string0)
            }
        }
        if let cpsLimit = self.cpsLimit {
            try encodeContainer.encode(cpsLimit, forKey: .cpsLimit)
        }
        if let defaultPhoneNumber = self.defaultPhoneNumber {
            try encodeContainer.encode(defaultPhoneNumber, forKey: .defaultPhoneNumber)
        }
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpsLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpsLimit)
        cpsLimit = cpsLimitDecoded
        let defaultPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultPhoneNumber)
        defaultPhoneNumber = defaultPhoneNumberDecoded
        let callingRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .callingRegions)
        var callingRegionsDecoded0:[Swift.String]? = nil
        if let callingRegionsContainer = callingRegionsContainer {
            callingRegionsDecoded0 = [Swift.String]()
            for string0 in callingRegionsContainer {
                if let string0 = string0 {
                    callingRegionsDecoded0?.append(string0)
                }
            }
        }
        callingRegions = callingRegionsDecoded0
        let cidrAllowedListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowedList)
        var cidrAllowedListDecoded0:[Swift.String]? = nil
        if let cidrAllowedListContainer = cidrAllowedListContainer {
            cidrAllowedListDecoded0 = [Swift.String]()
            for string0 in cidrAllowedListContainer {
                if let string0 = string0 {
                    cidrAllowedListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowedList = cidrAllowedListDecoded0
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
    }
}

extension ChimeSDKVoiceClientTypes.Termination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Termination(callingRegions: \(Swift.String(describing: callingRegions)), cidrAllowedList: \(Swift.String(describing: cidrAllowedList)), cpsLimit: \(Swift.String(describing: cpsLimit)), disabled: \(Swift.String(describing: disabled)), defaultPhoneNumber: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct Termination: Swift.Equatable {
        public var callingRegions: [Swift.String]?
        public var cidrAllowedList: [Swift.String]?
        public var cpsLimit: Swift.Int?
        public var defaultPhoneNumber: Swift.String?
        public var disabled: Swift.Bool?

        public init (
            callingRegions: [Swift.String]? = nil,
            cidrAllowedList: [Swift.String]? = nil,
            cpsLimit: Swift.Int? = nil,
            defaultPhoneNumber: Swift.String? = nil,
            disabled: Swift.Bool? = nil
        )
        {
            self.callingRegions = callingRegions
            self.cidrAllowedList = cidrAllowedList
            self.cpsLimit = cpsLimit
            self.defaultPhoneNumber = defaultPhoneNumber
            self.disabled = disabled
        }
    }

}

extension ChimeSDKVoiceClientTypes.TerminationHealth: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .dateTime, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .timestamp)
        timestamp = timestampDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct TerminationHealth: Swift.Equatable {
        public var source: Swift.String?
        public var timestamp: ClientRuntime.Date?

        public init (
            source: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.source = source
            self.timestamp = timestamp
        }
    }

}

extension ThrottledClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ThrottledClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSDKVoiceClientTypes.ErrorCode?
    public var message: Swift.String?

    public init (
        code: ChimeSDKVoiceClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKVoiceClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateGlobalSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceConnector = self.voiceConnector {
            try encodeContainer.encode(voiceConnector, forKey: .voiceConnector)
        }
    }
}

extension UpdateGlobalSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings"
    }
}

public struct UpdateGlobalSettingsInput: Swift.Equatable {
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?

    public init (
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct UpdateGlobalSettingsInputBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnectorSettings?
}

extension UpdateGlobalSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorSettings.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension UpdateGlobalSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGlobalSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGlobalSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGlobalSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGlobalSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberInput(productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\", phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension UpdatePhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }
}

extension UpdatePhoneNumberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let phoneNumberId = phoneNumberId else {
            return nil
        }
        return "/phone-numbers/\(phoneNumberId.urlPercentEncoding())"
    }
}

public struct UpdatePhoneNumberInput: Swift.Equatable {
    public var callingName: Swift.String?
    /// This member is required.
    public var phoneNumberId: Swift.String?
    public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

    public init (
        callingName: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
    )
    {
        self.callingName = callingName
        self.phoneNumberId = phoneNumberId
        self.productType = productType
    }
}

struct UpdatePhoneNumberInputBody: Swift.Equatable {
    let productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?
    let callingName: Swift.String?
}

extension UpdatePhoneNumberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case productType = "ProductType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension UpdatePhoneNumberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePhoneNumberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePhoneNumberOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePhoneNumberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePhoneNumberOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.phoneNumber = output.phoneNumber
        } else {
            self.phoneNumber = nil
        }
    }
}

public struct UpdatePhoneNumberOutputResponse: Swift.Equatable {
    public var phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?

    public init (
        phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

struct UpdatePhoneNumberOutputResponseBody: Swift.Equatable {
    let phoneNumber: ChimeSDKVoiceClientTypes.PhoneNumber?
}

extension UpdatePhoneNumberOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumber.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
        case phoneNumberId = "PhoneNumberId"
        case productType = "ProductType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
        if let phoneNumberId = self.phoneNumberId {
            try encodeContainer.encode(phoneNumberId, forKey: .phoneNumberId)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let phoneNumberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumberId)
        phoneNumberId = phoneNumberIdDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.PhoneNumberProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension ChimeSDKVoiceClientTypes.UpdatePhoneNumberRequestItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberRequestItem(productType: \(Swift.String(describing: productType)), callingName: \"CONTENT_REDACTED\", phoneNumberId: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKVoiceClientTypes {
    public struct UpdatePhoneNumberRequestItem: Swift.Equatable {
        public var callingName: Swift.String?
        /// This member is required.
        public var phoneNumberId: Swift.String?
        public var productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType?

        public init (
            callingName: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            productType: ChimeSDKVoiceClientTypes.PhoneNumberProductType? = nil
        )
        {
            self.callingName = callingName
            self.phoneNumberId = phoneNumberId
            self.productType = productType
        }
    }

}

extension UpdatePhoneNumberSettingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePhoneNumberSettingsInput(callingName: \"CONTENT_REDACTED\")"}
}

extension UpdatePhoneNumberSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callingName = self.callingName {
            try encodeContainer.encode(callingName, forKey: .callingName)
        }
    }
}

extension UpdatePhoneNumberSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/settings/phone-number"
    }
}

public struct UpdatePhoneNumberSettingsInput: Swift.Equatable {
    /// This member is required.
    public var callingName: Swift.String?

    public init (
        callingName: Swift.String? = nil
    )
    {
        self.callingName = callingName
    }
}

struct UpdatePhoneNumberSettingsInputBody: Swift.Equatable {
    let callingName: Swift.String?
}

extension UpdatePhoneNumberSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callingName = "CallingName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callingName)
        callingName = callingNameDecoded
    }
}

extension UpdatePhoneNumberSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePhoneNumberSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePhoneNumberSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePhoneNumberSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePhoneNumberSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateProxySessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capability0 in capabilities {
                try capabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let expiryMinutes = self.expiryMinutes {
            try encodeContainer.encode(expiryMinutes, forKey: .expiryMinutes)
        }
    }
}

extension UpdateProxySessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        guard let proxySessionId = proxySessionId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())/proxy-sessions/\(proxySessionId.urlPercentEncoding())"
    }
}

public struct UpdateProxySessionInput: Swift.Equatable {
    /// This member is required.
    public var capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    public var expiryMinutes: Swift.Int?
    /// This member is required.
    public var proxySessionId: Swift.String?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        capabilities: [ChimeSDKVoiceClientTypes.Capability]? = nil,
        expiryMinutes: Swift.Int? = nil,
        proxySessionId: Swift.String? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.expiryMinutes = expiryMinutes
        self.proxySessionId = proxySessionId
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateProxySessionInputBody: Swift.Equatable {
    let capabilities: [ChimeSDKVoiceClientTypes.Capability]?
    let expiryMinutes: Swift.Int?
}

extension UpdateProxySessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case expiryMinutes = "ExpiryMinutes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.Capability?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[ChimeSDKVoiceClientTypes.Capability]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [ChimeSDKVoiceClientTypes.Capability]()
            for enum0 in capabilitiesContainer {
                if let enum0 = enum0 {
                    capabilitiesDecoded0?.append(enum0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let expiryMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiryMinutes)
        expiryMinutes = expiryMinutesDecoded
    }
}

extension UpdateProxySessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProxySessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateProxySessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProxySessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateProxySessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.proxySession = output.proxySession
        } else {
            self.proxySession = nil
        }
    }
}

public struct UpdateProxySessionOutputResponse: Swift.Equatable {
    public var proxySession: ChimeSDKVoiceClientTypes.ProxySession?

    public init (
        proxySession: ChimeSDKVoiceClientTypes.ProxySession? = nil
    )
    {
        self.proxySession = proxySession
    }
}

struct UpdateProxySessionOutputResponseBody: Swift.Equatable {
    let proxySession: ChimeSDKVoiceClientTypes.ProxySession?
}

extension UpdateProxySessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proxySession = "ProxySession"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proxySessionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.ProxySession.self, forKey: .proxySession)
        proxySession = proxySessionDecoded
    }
}

extension UpdateSipMediaApplicationCallInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arguments = arguments {
            var argumentsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .arguments)
            for (dictKey0, smaUpdateCallArgumentsMap0) in arguments {
                try argumentsContainer.encode(smaUpdateCallArgumentsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateSipMediaApplicationCallInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        guard let transactionId = transactionId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())/calls/\(transactionId.urlPercentEncoding())"
    }
}

public struct UpdateSipMediaApplicationCallInput: Swift.Equatable {
    /// This member is required.
    public var arguments: [Swift.String:Swift.String]?
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?
    /// This member is required.
    public var transactionId: Swift.String?

    public init (
        arguments: [Swift.String:Swift.String]? = nil,
        sipMediaApplicationId: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.arguments = arguments
        self.sipMediaApplicationId = sipMediaApplicationId
        self.transactionId = transactionId
    }
}

struct UpdateSipMediaApplicationCallInputBody: Swift.Equatable {
    let arguments: [Swift.String:Swift.String]?
}

extension UpdateSipMediaApplicationCallInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arguments = "Arguments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let argumentsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .arguments)
        var argumentsDecoded0: [Swift.String:Swift.String]? = nil
        if let argumentsContainer = argumentsContainer {
            argumentsDecoded0 = [Swift.String:Swift.String]()
            for (key0, sensitivestring0) in argumentsContainer {
                if let sensitivestring0 = sensitivestring0 {
                    argumentsDecoded0?[key0] = sensitivestring0
                }
            }
        }
        arguments = argumentsDecoded0
    }
}

extension UpdateSipMediaApplicationCallOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSipMediaApplicationCallOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSipMediaApplicationCallOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSipMediaApplicationCallOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSipMediaApplicationCallOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplicationCall = output.sipMediaApplicationCall
        } else {
            self.sipMediaApplicationCall = nil
        }
    }
}

public struct UpdateSipMediaApplicationCallOutputResponse: Swift.Equatable {
    public var sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?

    public init (
        sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall? = nil
    )
    {
        self.sipMediaApplicationCall = sipMediaApplicationCall
    }
}

struct UpdateSipMediaApplicationCallOutputResponseBody: Swift.Equatable {
    let sipMediaApplicationCall: ChimeSDKVoiceClientTypes.SipMediaApplicationCall?
}

extension UpdateSipMediaApplicationCallOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplicationCall = "SipMediaApplicationCall"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationCallDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplicationCall.self, forKey: .sipMediaApplicationCall)
        sipMediaApplicationCall = sipMediaApplicationCallDecoded
    }
}

extension UpdateSipMediaApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for sipmediaapplicationendpoint0 in endpoints {
                try endpointsContainer.encode(sipmediaapplicationendpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateSipMediaApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipMediaApplicationId = sipMediaApplicationId else {
            return nil
        }
        return "/sip-media-applications/\(sipMediaApplicationId.urlPercentEncoding())"
    }
}

public struct UpdateSipMediaApplicationInput: Swift.Equatable {
    public var endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
    public var name: Swift.String?
    /// This member is required.
    public var sipMediaApplicationId: Swift.String?

    public init (
        endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil,
        name: Swift.String? = nil,
        sipMediaApplicationId: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.name = name
        self.sipMediaApplicationId = sipMediaApplicationId
    }
}

struct UpdateSipMediaApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let endpoints: [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]?
}

extension UpdateSipMediaApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints = "Endpoints"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [ChimeSDKVoiceClientTypes.SipMediaApplicationEndpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension UpdateSipMediaApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSipMediaApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSipMediaApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSipMediaApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSipMediaApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipMediaApplication = output.sipMediaApplication
        } else {
            self.sipMediaApplication = nil
        }
    }
}

public struct UpdateSipMediaApplicationOutputResponse: Swift.Equatable {
    public var sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?

    public init (
        sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication? = nil
    )
    {
        self.sipMediaApplication = sipMediaApplication
    }
}

struct UpdateSipMediaApplicationOutputResponseBody: Swift.Equatable {
    let sipMediaApplication: ChimeSDKVoiceClientTypes.SipMediaApplication?
}

extension UpdateSipMediaApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipMediaApplication = "SipMediaApplication"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipMediaApplicationDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipMediaApplication.self, forKey: .sipMediaApplication)
        sipMediaApplication = sipMediaApplicationDecoded
    }
}

extension UpdateSipRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabled = self.disabled {
            try encodeContainer.encode(disabled, forKey: .disabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetApplications = targetApplications {
            var targetApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetApplications)
            for sipruletargetapplication0 in targetApplications {
                try targetApplicationsContainer.encode(sipruletargetapplication0)
            }
        }
    }
}

extension UpdateSipRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sipRuleId = sipRuleId else {
            return nil
        }
        return "/sip-rules/\(sipRuleId.urlPercentEncoding())"
    }
}

public struct UpdateSipRuleInput: Swift.Equatable {
    public var disabled: Swift.Bool?
    /// This member is required.
    public var name: Swift.String?
    /// This member is required.
    public var sipRuleId: Swift.String?
    public var targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?

    public init (
        disabled: Swift.Bool? = nil,
        name: Swift.String? = nil,
        sipRuleId: Swift.String? = nil,
        targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
    )
    {
        self.disabled = disabled
        self.name = name
        self.sipRuleId = sipRuleId
        self.targetApplications = targetApplications
    }
}

struct UpdateSipRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let disabled: Swift.Bool?
    let targetApplications: [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]?
}

extension UpdateSipRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabled = "Disabled"
        case name = "Name"
        case targetApplications = "TargetApplications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let disabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disabled)
        disabled = disabledDecoded
        let targetApplicationsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.SipRuleTargetApplication?].self, forKey: .targetApplications)
        var targetApplicationsDecoded0:[ChimeSDKVoiceClientTypes.SipRuleTargetApplication]? = nil
        if let targetApplicationsContainer = targetApplicationsContainer {
            targetApplicationsDecoded0 = [ChimeSDKVoiceClientTypes.SipRuleTargetApplication]()
            for structure0 in targetApplicationsContainer {
                if let structure0 = structure0 {
                    targetApplicationsDecoded0?.append(structure0)
                }
            }
        }
        targetApplications = targetApplicationsDecoded0
    }
}

extension UpdateSipRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSipRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSipRuleOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSipRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSipRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sipRule = output.sipRule
        } else {
            self.sipRule = nil
        }
    }
}

public struct UpdateSipRuleOutputResponse: Swift.Equatable {
    public var sipRule: ChimeSDKVoiceClientTypes.SipRule?

    public init (
        sipRule: ChimeSDKVoiceClientTypes.SipRule? = nil
    )
    {
        self.sipRule = sipRule
    }
}

struct UpdateSipRuleOutputResponseBody: Swift.Equatable {
    let sipRule: ChimeSDKVoiceClientTypes.SipRule?
}

extension UpdateSipRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sipRule = "SipRule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sipRuleDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.SipRule.self, forKey: .sipRule)
        sipRule = sipRuleDecoded
    }
}

extension UpdateVoiceConnectorGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }
}

extension UpdateVoiceConnectorGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorGroupId = voiceConnectorGroupId else {
            return nil
        }
        return "/voice-connector-groups/\(voiceConnectorGroupId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceConnectorGroupInput: Swift.Equatable {
    /// This member is required.
    public var name: Swift.String?
    /// This member is required.
    public var voiceConnectorGroupId: Swift.String?
    /// This member is required.
    public var voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?

    public init (
        name: Swift.String? = nil,
        voiceConnectorGroupId: Swift.String? = nil,
        voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
    )
    {
        self.name = name
        self.voiceConnectorGroupId = voiceConnectorGroupId
        self.voiceConnectorItems = voiceConnectorItems
    }
}

struct UpdateVoiceConnectorGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?
}

extension UpdateVoiceConnectorGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
    }
}

extension UpdateVoiceConnectorGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVoiceConnectorGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVoiceConnectorGroupOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVoiceConnectorGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVoiceConnectorGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnectorGroup = output.voiceConnectorGroup
        } else {
            self.voiceConnectorGroup = nil
        }
    }
}

public struct UpdateVoiceConnectorGroupOutputResponse: Swift.Equatable {
    public var voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?

    public init (
        voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup? = nil
    )
    {
        self.voiceConnectorGroup = voiceConnectorGroup
    }
}

struct UpdateVoiceConnectorGroupOutputResponseBody: Swift.Equatable {
    let voiceConnectorGroup: ChimeSDKVoiceClientTypes.VoiceConnectorGroup?
}

extension UpdateVoiceConnectorGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnectorGroup = "VoiceConnectorGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorGroup.self, forKey: .voiceConnectorGroup)
        voiceConnectorGroup = voiceConnectorGroupDecoded
    }
}

extension UpdateVoiceConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
    }
}

extension UpdateVoiceConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let voiceConnectorId = voiceConnectorId else {
            return nil
        }
        return "/voice-connectors/\(voiceConnectorId.urlPercentEncoding())"
    }
}

public struct UpdateVoiceConnectorInput: Swift.Equatable {
    /// This member is required.
    public var name: Swift.String?
    /// This member is required.
    public var requireEncryption: Swift.Bool?
    /// This member is required.
    public var voiceConnectorId: Swift.String?

    public init (
        name: Swift.String? = nil,
        requireEncryption: Swift.Bool? = nil,
        voiceConnectorId: Swift.String? = nil
    )
    {
        self.name = name
        self.requireEncryption = requireEncryption
        self.voiceConnectorId = voiceConnectorId
    }
}

struct UpdateVoiceConnectorInputBody: Swift.Equatable {
    let name: Swift.String?
    let requireEncryption: Swift.Bool?
}

extension UpdateVoiceConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case requireEncryption = "RequireEncryption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
    }
}

extension UpdateVoiceConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVoiceConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVoiceConnectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVoiceConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVoiceConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.voiceConnector = output.voiceConnector
        } else {
            self.voiceConnector = nil
        }
    }
}

public struct UpdateVoiceConnectorOutputResponse: Swift.Equatable {
    public var voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?

    public init (
        voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector? = nil
    )
    {
        self.voiceConnector = voiceConnector
    }
}

struct UpdateVoiceConnectorOutputResponseBody: Swift.Equatable {
    let voiceConnector: ChimeSDKVoiceClientTypes.VoiceConnector?
}

extension UpdateVoiceConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case voiceConnector = "VoiceConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnector.self, forKey: .voiceConnector)
        voiceConnector = voiceConnectorDecoded
    }
}

extension ValidateE911AddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateE911AddressInput(awsAccountId: \(Swift.String(describing: awsAccountId)), city: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", state: \"CONTENT_REDACTED\", streetInfo: \"CONTENT_REDACTED\", streetNumber: \"CONTENT_REDACTED\")"}
}

extension ValidateE911AddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case city = "City"
        case country = "Country"
        case postalCode = "PostalCode"
        case state = "State"
        case streetInfo = "StreetInfo"
        case streetNumber = "StreetNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let streetInfo = self.streetInfo {
            try encodeContainer.encode(streetInfo, forKey: .streetInfo)
        }
        if let streetNumber = self.streetNumber {
            try encodeContainer.encode(streetNumber, forKey: .streetNumber)
        }
    }
}

extension ValidateE911AddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/emergency-calling/address"
    }
}

public struct ValidateE911AddressInput: Swift.Equatable {
    /// This member is required.
    public var awsAccountId: Swift.String?
    /// This member is required.
    public var city: Swift.String?
    /// This member is required.
    public var country: Swift.String?
    /// This member is required.
    public var postalCode: Swift.String?
    /// This member is required.
    public var state: Swift.String?
    /// This member is required.
    public var streetInfo: Swift.String?
    /// This member is required.
    public var streetNumber: Swift.String?

    public init (
        awsAccountId: Swift.String? = nil,
        city: Swift.String? = nil,
        country: Swift.String? = nil,
        postalCode: Swift.String? = nil,
        state: Swift.String? = nil,
        streetInfo: Swift.String? = nil,
        streetNumber: Swift.String? = nil
    )
    {
        self.awsAccountId = awsAccountId
        self.city = city
        self.country = country
        self.postalCode = postalCode
        self.state = state
        self.streetInfo = streetInfo
        self.streetNumber = streetNumber
    }
}

struct ValidateE911AddressInputBody: Swift.Equatable {
    let awsAccountId: Swift.String?
    let streetNumber: Swift.String?
    let streetInfo: Swift.String?
    let city: Swift.String?
    let state: Swift.String?
    let country: Swift.String?
    let postalCode: Swift.String?
}

extension ValidateE911AddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case city = "City"
        case country = "Country"
        case postalCode = "PostalCode"
        case state = "State"
        case streetInfo = "StreetInfo"
        case streetNumber = "StreetNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let streetNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetNumber)
        streetNumber = streetNumberDecoded
        let streetInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streetInfo)
        streetInfo = streetInfoDecoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
    }
}

extension ValidateE911AddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateE911AddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ValidateE911AddressOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateE911AddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidateE911AddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
            self.addressExternalId = output.addressExternalId
            self.candidateAddressList = output.candidateAddressList
            self.validationResult = output.validationResult
        } else {
            self.address = nil
            self.addressExternalId = nil
            self.candidateAddressList = nil
            self.validationResult = 0
        }
    }
}

public struct ValidateE911AddressOutputResponse: Swift.Equatable {
    public var address: ChimeSDKVoiceClientTypes.Address?
    public var addressExternalId: Swift.String?
    public var candidateAddressList: [ChimeSDKVoiceClientTypes.CandidateAddress]?
    public var validationResult: Swift.Int

    public init (
        address: ChimeSDKVoiceClientTypes.Address? = nil,
        addressExternalId: Swift.String? = nil,
        candidateAddressList: [ChimeSDKVoiceClientTypes.CandidateAddress]? = nil,
        validationResult: Swift.Int = 0
    )
    {
        self.address = address
        self.addressExternalId = addressExternalId
        self.candidateAddressList = candidateAddressList
        self.validationResult = validationResult
    }
}

struct ValidateE911AddressOutputResponseBody: Swift.Equatable {
    let validationResult: Swift.Int
    let addressExternalId: Swift.String?
    let address: ChimeSDKVoiceClientTypes.Address?
    let candidateAddressList: [ChimeSDKVoiceClientTypes.CandidateAddress]?
}

extension ValidateE911AddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressExternalId = "AddressExternalId"
        case candidateAddressList = "CandidateAddressList"
        case validationResult = "ValidationResult"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationResultDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validationResult) ?? 0
        validationResult = validationResultDecoded
        let addressExternalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressExternalId)
        addressExternalId = addressExternalIdDecoded
        let addressDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.Address.self, forKey: .address)
        address = addressDecoded
        let candidateAddressListContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.CandidateAddress?].self, forKey: .candidateAddressList)
        var candidateAddressListDecoded0:[ChimeSDKVoiceClientTypes.CandidateAddress]? = nil
        if let candidateAddressListContainer = candidateAddressListContainer {
            candidateAddressListDecoded0 = [ChimeSDKVoiceClientTypes.CandidateAddress]()
            for structure0 in candidateAddressListContainer {
                if let structure0 = structure0 {
                    candidateAddressListDecoded0?.append(structure0)
                }
            }
        }
        candidateAddressList = candidateAddressListDecoded0
    }
}

extension ChimeSDKVoiceClientTypes.VoiceConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsRegion = "AwsRegion"
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case outboundHostName = "OutboundHostName"
        case requireEncryption = "RequireEncryption"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorArn = "VoiceConnectorArn"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = self.awsRegion {
            try encodeContainer.encode(awsRegion.rawValue, forKey: .awsRegion)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outboundHostName = self.outboundHostName {
            try encodeContainer.encode(outboundHostName, forKey: .outboundHostName)
        }
        if let requireEncryption = self.requireEncryption {
            try encodeContainer.encode(requireEncryption, forKey: .requireEncryption)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorArn = self.voiceConnectorArn {
            try encodeContainer.encode(voiceConnectorArn, forKey: .voiceConnectorArn)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outboundHostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundHostName)
        outboundHostName = outboundHostNameDecoded
        let requireEncryptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireEncryption)
        requireEncryption = requireEncryptionDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let voiceConnectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorArn)
        voiceConnectorArn = voiceConnectorArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct VoiceConnector: Swift.Equatable {
        public var awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion?
        public var createdTimestamp: ClientRuntime.Date?
        public var name: Swift.String?
        public var outboundHostName: Swift.String?
        public var requireEncryption: Swift.Bool?
        public var updatedTimestamp: ClientRuntime.Date?
        public var voiceConnectorArn: Swift.String?
        public var voiceConnectorId: Swift.String?

        public init (
            awsRegion: ChimeSDKVoiceClientTypes.VoiceConnectorAwsRegion? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            outboundHostName: Swift.String? = nil,
            requireEncryption: Swift.Bool? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorArn: Swift.String? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.awsRegion = awsRegion
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.outboundHostName = outboundHostName
            self.requireEncryption = requireEncryption
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorArn = voiceConnectorArn
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes {
    public enum VoiceConnectorAwsRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apNortheast1
        case apNortheast2
        case apSoutheast1
        case apSoutheast2
        case caCentral1
        case euCentral1
        case euWest1
        case euWest2
        case usEast1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceConnectorAwsRegion] {
            return [
                .apNortheast1,
                .apNortheast2,
                .apSoutheast1,
                .apSoutheast2,
                .caCentral1,
                .euCentral1,
                .euWest1,
                .euWest2,
                .usEast1,
                .usWest2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .caCentral1: return "ca-central-1"
            case .euCentral1: return "eu-central-1"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .usEast1: return "us-east-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VoiceConnectorAwsRegion(rawValue: rawValue) ?? VoiceConnectorAwsRegion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKVoiceClientTypes.VoiceConnectorGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case name = "Name"
        case updatedTimestamp = "UpdatedTimestamp"
        case voiceConnectorGroupArn = "VoiceConnectorGroupArn"
        case voiceConnectorGroupId = "VoiceConnectorGroupId"
        case voiceConnectorItems = "VoiceConnectorItems"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .dateTime, forKey: .createdTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encodeTimestamp(updatedTimestamp, format: .dateTime, forKey: .updatedTimestamp)
        }
        if let voiceConnectorGroupArn = self.voiceConnectorGroupArn {
            try encodeContainer.encode(voiceConnectorGroupArn, forKey: .voiceConnectorGroupArn)
        }
        if let voiceConnectorGroupId = self.voiceConnectorGroupId {
            try encodeContainer.encode(voiceConnectorGroupId, forKey: .voiceConnectorGroupId)
        }
        if let voiceConnectorItems = voiceConnectorItems {
            var voiceConnectorItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .voiceConnectorItems)
            for voiceconnectoritem0 in voiceConnectorItems {
                try voiceConnectorItemsContainer.encode(voiceconnectoritem0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorGroupId)
        voiceConnectorGroupId = voiceConnectorGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let voiceConnectorItemsContainer = try containerValues.decodeIfPresent([ChimeSDKVoiceClientTypes.VoiceConnectorItem?].self, forKey: .voiceConnectorItems)
        var voiceConnectorItemsDecoded0:[ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        if let voiceConnectorItemsContainer = voiceConnectorItemsContainer {
            voiceConnectorItemsDecoded0 = [ChimeSDKVoiceClientTypes.VoiceConnectorItem]()
            for structure0 in voiceConnectorItemsContainer {
                if let structure0 = structure0 {
                    voiceConnectorItemsDecoded0?.append(structure0)
                }
            }
        }
        voiceConnectorItems = voiceConnectorItemsDecoded0
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let voiceConnectorGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorGroupArn)
        voiceConnectorGroupArn = voiceConnectorGroupArnDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct VoiceConnectorGroup: Swift.Equatable {
        public var createdTimestamp: ClientRuntime.Date?
        public var name: Swift.String?
        public var updatedTimestamp: ClientRuntime.Date?
        public var voiceConnectorGroupArn: Swift.String?
        public var voiceConnectorGroupId: Swift.String?
        public var voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil,
            voiceConnectorGroupArn: Swift.String? = nil,
            voiceConnectorGroupId: Swift.String? = nil,
            voiceConnectorItems: [ChimeSDKVoiceClientTypes.VoiceConnectorItem]? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.name = name
            self.updatedTimestamp = updatedTimestamp
            self.voiceConnectorGroupArn = voiceConnectorGroupArn
            self.voiceConnectorGroupId = voiceConnectorGroupId
            self.voiceConnectorItems = voiceConnectorItems
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceConnectorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case voiceConnectorId = "VoiceConnectorId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let voiceConnectorId = self.voiceConnectorId {
            try encodeContainer.encode(voiceConnectorId, forKey: .voiceConnectorId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceConnectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceConnectorId)
        voiceConnectorId = voiceConnectorIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct VoiceConnectorItem: Swift.Equatable {
        /// This member is required.
        public var priority: Swift.Int?
        /// This member is required.
        public var voiceConnectorId: Swift.String?

        public init (
            priority: Swift.Int? = nil,
            voiceConnectorId: Swift.String? = nil
        )
        {
            self.priority = priority
            self.voiceConnectorId = voiceConnectorId
        }
    }

}

extension ChimeSDKVoiceClientTypes.VoiceConnectorSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cdrBucket = "CdrBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdrBucket = self.cdrBucket {
            try encodeContainer.encode(cdrBucket, forKey: .cdrBucket)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdrBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdrBucket)
        cdrBucket = cdrBucketDecoded
    }
}

extension ChimeSDKVoiceClientTypes {
    public struct VoiceConnectorSettings: Swift.Equatable {
        public var cdrBucket: Swift.String?

        public init (
            cdrBucket: Swift.String? = nil
        )
        {
            self.cdrBucket = cdrBucket
        }
    }

}
