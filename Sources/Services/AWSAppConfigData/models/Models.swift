// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppConfigDataClientTypes.BadRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidparameters = "InvalidParameters"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .invalidparameters(invalidparameters):
                var invalidparametersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .invalidparameters)
                for (dictKey0, invalidParameterMap0) in invalidparameters {
                    try invalidparametersContainer.encode(invalidParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let invalidparametersContainer = try values.decodeIfPresent([Swift.String: AppConfigDataClientTypes.InvalidParameterDetail?].self, forKey: .invalidparameters)
        var invalidparametersDecoded0: [Swift.String:AppConfigDataClientTypes.InvalidParameterDetail]? = nil
        if let invalidparametersContainer = invalidparametersContainer {
            invalidparametersDecoded0 = [Swift.String:AppConfigDataClientTypes.InvalidParameterDetail]()
            for (key0, invalidparameterdetail0) in invalidparametersContainer {
                if let invalidparameterdetail0 = invalidparameterdetail0 {
                    invalidparametersDecoded0?[key0] = invalidparameterdetail0
                }
            }
        }
        if let invalidparameters = invalidparametersDecoded0 {
            self = .invalidparameters(invalidparameters)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppConfigDataClientTypes {
    /// Detailed information about the input that failed to satisfy the constraints specified by a call.
    public enum BadRequestDetails: Swift.Equatable {
        /// One or more specified parameters are not valid for the call.
        case invalidparameters([Swift.String:AppConfigDataClientTypes.InvalidParameterDetail])
        case sdkUnknown(Swift.String)
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.message = output.message
            self.reason = output.reason
        } else {
            self.details = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by the service.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Details describing why the request was invalid.
    public var details: AppConfigDataClientTypes.BadRequestDetails?
    public var message: Swift.String?
    /// Code indicating the reason the request was invalid.
    public var reason: AppConfigDataClientTypes.BadRequestReason?

    public init (
        details: AppConfigDataClientTypes.BadRequestDetails? = nil,
        message: Swift.String? = nil,
        reason: AppConfigDataClientTypes.BadRequestReason? = nil
    )
    {
        self.details = details
        self.message = message
        self.reason = reason
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AppConfigDataClientTypes.BadRequestReason?
    let details: AppConfigDataClientTypes.BadRequestDetails?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AppConfigDataClientTypes.BadRequestReason.self, forKey: .reason)
        reason = reasonDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(AppConfigDataClientTypes.BadRequestDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension AppConfigDataClientTypes {
    public enum BadRequestReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates there was a problem with one or more of the parameters. See InvalidParameters in the BadRequestDetails for more information.
        case invalidParameters
        case sdkUnknown(Swift.String)

        public static var allCases: [BadRequestReason] {
            return [
                .invalidParameters,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidParameters: return "InvalidParameters"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BadRequestReason(rawValue: rawValue) ?? BadRequestReason.sdkUnknown(rawValue)
        }
    }
}

extension GetLatestConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let configurationToken = configurationToken else {
                let message = "Creating a URL Query Item failed. configurationToken is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let configurationTokenQueryItem = ClientRuntime.URLQueryItem(name: "configuration_token".urlPercentEncoding(), value: Swift.String(configurationToken).urlPercentEncoding())
            items.append(configurationTokenQueryItem)
            return items
        }
    }
}

extension GetLatestConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration"
    }
}

public struct GetLatestConfigurationInput: Swift.Equatable {
    /// Token describing the current state of the configuration session. To obtain a token, first call the [StartConfigurationSession] API. Note that every call to GetLatestConfiguration will return a new ConfigurationToken (NextPollConfigurationToken in the response) and must be provided to subsequent GetLatestConfiguration API calls. This token should only be used once. To support long poll use cases, the token is valid for up to 24 hours. If a GetLatestConfiguration call uses an expired token, the system returns BadRequestException.
    /// This member is required.
    public var configurationToken: Swift.String?

    public init (
        configurationToken: Swift.String? = nil
    )
    {
        self.configurationToken = configurationToken
    }
}

struct GetLatestConfigurationInputBody: Swift.Equatable {
}

extension GetLatestConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLatestConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLatestConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLatestConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLatestConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLatestConfigurationOutputResponse(contentType: \(Swift.String(describing: contentType)), nextPollConfigurationToken: \(Swift.String(describing: nextPollConfigurationToken)), nextPollIntervalInSeconds: \(Swift.String(describing: nextPollIntervalInSeconds)), versionLabel: \(Swift.String(describing: versionLabel)), configuration: \"CONTENT_REDACTED\")"}
}

extension GetLatestConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let nextPollConfigurationTokenHeaderValue = httpResponse.headers.value(for: "Next-Poll-Configuration-Token") {
            self.nextPollConfigurationToken = nextPollConfigurationTokenHeaderValue
        } else {
            self.nextPollConfigurationToken = nil
        }
        if let nextPollIntervalInSecondsHeaderValue = httpResponse.headers.value(for: "Next-Poll-Interval-In-Seconds") {
            self.nextPollIntervalInSeconds = Swift.Int(nextPollIntervalInSecondsHeaderValue) ?? 0
        } else {
            self.nextPollIntervalInSeconds = 0
        }
        if let versionLabelHeaderValue = httpResponse.headers.value(for: "Version-Label") {
            self.versionLabel = versionLabelHeaderValue
        } else {
            self.versionLabel = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.configuration = data
        } else {
            self.configuration = nil
        }
    }
}

public struct GetLatestConfigurationOutputResponse: Swift.Equatable {
    /// The data of the configuration. This may be empty if the client already has the latest version of configuration.
    public var configuration: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content.
    public var contentType: Swift.String?
    /// The latest token describing the current state of the configuration session. This must be provided to the next call to GetLatestConfiguration. This token should only be used once. To support long poll use cases, the token is valid for up to 24 hours. If a GetLatestConfiguration call uses an expired token, the system returns BadRequestException.
    public var nextPollConfigurationToken: Swift.String?
    /// The amount of time the client should wait before polling for configuration updates again. Use RequiredMinimumPollIntervalInSeconds to set the desired poll interval.
    public var nextPollIntervalInSeconds: Swift.Int
    /// The user-defined label for the AppConfig hosted configuration version. This attribute doesn't apply if the configuration is not from an AppConfig hosted configuration version. If the client already has the latest version of the configuration data, this value is empty.
    public var versionLabel: Swift.String?

    public init (
        configuration: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        nextPollConfigurationToken: Swift.String? = nil,
        nextPollIntervalInSeconds: Swift.Int = 0,
        versionLabel: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.contentType = contentType
        self.nextPollConfigurationToken = nextPollConfigurationToken
        self.nextPollIntervalInSeconds = nextPollIntervalInSeconds
        self.versionLabel = versionLabel
    }
}

struct GetLatestConfigurationOutputResponseBody: Swift.Equatable {
    let configuration: ClientRuntime.Data?
}

extension GetLatestConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an internal failure in the service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppConfigDataClientTypes.InvalidParameterDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case problem = "Problem"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let problem = self.problem {
            try encodeContainer.encode(problem.rawValue, forKey: .problem)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemDecoded = try containerValues.decodeIfPresent(AppConfigDataClientTypes.InvalidParameterProblem.self, forKey: .problem)
        problem = problemDecoded
    }
}

extension AppConfigDataClientTypes {
    /// Information about an invalid parameter.
    public struct InvalidParameterDetail: Swift.Equatable {
        /// The reason the parameter is invalid.
        public var problem: AppConfigDataClientTypes.InvalidParameterProblem?

        public init (
            problem: AppConfigDataClientTypes.InvalidParameterProblem? = nil
        )
        {
            self.problem = problem
        }
    }

}

extension AppConfigDataClientTypes {
    public enum InvalidParameterProblem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The parameter was corrupted and could not be understood by the service.
        case corrupted
        /// The parameter was expired and can no longer be used.
        case expired
        /// The client called the service before the time specified in the poll interval.
        case pollIntervalNotSatisfied
        case sdkUnknown(Swift.String)

        public static var allCases: [InvalidParameterProblem] {
            return [
                .corrupted,
                .expired,
                .pollIntervalNotSatisfied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .corrupted: return "Corrupted"
            case .expired: return "Expired"
            case .pollIntervalNotSatisfied: return "PollIntervalNotSatisfied"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InvalidParameterProblem(rawValue: rawValue) ?? InvalidParameterProblem.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.referencedBy = output.referencedBy
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.referencedBy = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// A map indicating which parameters in the request reference the resource that was not found.
    public var referencedBy: [Swift.String:Swift.String]?
    /// The type of resource that was not found.
    public var resourceType: AppConfigDataClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        referencedBy: [Swift.String:Swift.String]? = nil,
        resourceType: AppConfigDataClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.referencedBy = referencedBy
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: AppConfigDataClientTypes.ResourceType?
    let referencedBy: [Swift.String:Swift.String]?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case referencedBy = "ReferencedBy"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AppConfigDataClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let referencedByContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .referencedBy)
        var referencedByDecoded0: [Swift.String:Swift.String]? = nil
        if let referencedByContainer = referencedByContainer {
            referencedByDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in referencedByContainer {
                if let string0 = string0 {
                    referencedByDecoded0?[key0] = string0
                }
            }
        }
        referencedBy = referencedByDecoded0
    }
}

extension AppConfigDataClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Resource type value for the Application resource.
        case application
        /// Resource type value for the Configuration resource.
        case configuration
        /// Resource type value for the ConfigurationProfile resource.
        case configurationProfile
        /// Resource type value for the Deployment resource.
        case deployment
        /// Resource type value for the Environment resource.
        case environment
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .application,
                .configuration,
                .configurationProfile,
                .deployment,
                .environment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "Application"
            case .configuration: return "Configuration"
            case .configurationProfile: return "ConfigurationProfile"
            case .deployment: return "Deployment"
            case .environment: return "Environment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartConfigurationSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIdentifier = "ApplicationIdentifier"
        case configurationProfileIdentifier = "ConfigurationProfileIdentifier"
        case environmentIdentifier = "EnvironmentIdentifier"
        case requiredMinimumPollIntervalInSeconds = "RequiredMinimumPollIntervalInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIdentifier = self.applicationIdentifier {
            try encodeContainer.encode(applicationIdentifier, forKey: .applicationIdentifier)
        }
        if let configurationProfileIdentifier = self.configurationProfileIdentifier {
            try encodeContainer.encode(configurationProfileIdentifier, forKey: .configurationProfileIdentifier)
        }
        if let environmentIdentifier = self.environmentIdentifier {
            try encodeContainer.encode(environmentIdentifier, forKey: .environmentIdentifier)
        }
        if let requiredMinimumPollIntervalInSeconds = self.requiredMinimumPollIntervalInSeconds {
            try encodeContainer.encode(requiredMinimumPollIntervalInSeconds, forKey: .requiredMinimumPollIntervalInSeconds)
        }
    }
}

extension StartConfigurationSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configurationsessions"
    }
}

public struct StartConfigurationSessionInput: Swift.Equatable {
    /// The application ID or the application name.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// The configuration profile ID or the configuration profile name.
    /// This member is required.
    public var configurationProfileIdentifier: Swift.String?
    /// The environment ID or the environment name.
    /// This member is required.
    public var environmentIdentifier: Swift.String?
    /// Sets a constraint on a session. If you specify a value of, for example, 60 seconds, then the client that established the session can't call [GetLatestConfiguration] more frequently than every 60 seconds.
    public var requiredMinimumPollIntervalInSeconds: Swift.Int?

    public init (
        applicationIdentifier: Swift.String? = nil,
        configurationProfileIdentifier: Swift.String? = nil,
        environmentIdentifier: Swift.String? = nil,
        requiredMinimumPollIntervalInSeconds: Swift.Int? = nil
    )
    {
        self.applicationIdentifier = applicationIdentifier
        self.configurationProfileIdentifier = configurationProfileIdentifier
        self.environmentIdentifier = environmentIdentifier
        self.requiredMinimumPollIntervalInSeconds = requiredMinimumPollIntervalInSeconds
    }
}

struct StartConfigurationSessionInputBody: Swift.Equatable {
    let applicationIdentifier: Swift.String?
    let environmentIdentifier: Swift.String?
    let configurationProfileIdentifier: Swift.String?
    let requiredMinimumPollIntervalInSeconds: Swift.Int?
}

extension StartConfigurationSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIdentifier = "ApplicationIdentifier"
        case configurationProfileIdentifier = "ConfigurationProfileIdentifier"
        case environmentIdentifier = "EnvironmentIdentifier"
        case requiredMinimumPollIntervalInSeconds = "RequiredMinimumPollIntervalInSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationIdentifier)
        applicationIdentifier = applicationIdentifierDecoded
        let environmentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentIdentifier)
        environmentIdentifier = environmentIdentifierDecoded
        let configurationProfileIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileIdentifier)
        configurationProfileIdentifier = configurationProfileIdentifierDecoded
        let requiredMinimumPollIntervalInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requiredMinimumPollIntervalInSeconds)
        requiredMinimumPollIntervalInSeconds = requiredMinimumPollIntervalInSecondsDecoded
    }
}

extension StartConfigurationSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartConfigurationSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartConfigurationSessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartConfigurationSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartConfigurationSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initialConfigurationToken = output.initialConfigurationToken
        } else {
            self.initialConfigurationToken = nil
        }
    }
}

public struct StartConfigurationSessionOutputResponse: Swift.Equatable {
    /// Token encapsulating state about the configuration session. Provide this token to the GetLatestConfiguration API to retrieve configuration data. This token should only be used once in your first call to GetLatestConfiguration. You must use the new token in the GetLatestConfiguration response (NextPollConfigurationToken) in each subsequent call to GetLatestConfiguration. The InitialConfigurationToken and NextPollConfigurationToken should only be used once. To support long poll use cases, the tokens are valid for up to 24 hours. If a GetLatestConfiguration call uses an expired token, the system returns BadRequestException.
    public var initialConfigurationToken: Swift.String?

    public init (
        initialConfigurationToken: Swift.String? = nil
    )
    {
        self.initialConfigurationToken = initialConfigurationToken
    }
}

struct StartConfigurationSessionOutputResponseBody: Swift.Equatable {
    let initialConfigurationToken: Swift.String?
}

extension StartConfigurationSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialConfigurationToken = "InitialConfigurationToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialConfigurationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialConfigurationToken)
        initialConfigurationToken = initialConfigurationTokenDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
