// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AmplifyUIBuilderClientTypes.ActionParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anchor
        case fields
        case global
        case id
        case model
        case state
        case target
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anchor = self.anchor {
            try encodeContainer.encode(anchor, forKey: .anchor)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, componentProperties0) in fields {
                try fieldsContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let global = self.global {
            try encodeContainer.encode(global, forKey: .global)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .url)
        url = urlDecoded
        let anchorDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .anchor)
        anchor = anchorDecoded
        let targetDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .target)
        target = targetDecoded
        let globalDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .global)
        global = globalDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let idDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .id)
        id = idDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in fieldsContainer {
                if let componentproperty0 = componentproperty0 {
                    fieldsDecoded0?[key0] = componentproperty0
                }
            }
        }
        fields = fieldsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.MutationActionSetStateParameter.self, forKey: .state)
        state = stateDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the event action configuration for an element of a Component or ComponentChild. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components. ActionParameters defines the action that is performed when an event occurs on the component.
    public struct ActionParameters: Swift.Equatable {
        /// The HTML anchor link to the location to open. Specify this value for a navigation action.
        public var anchor: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// A dictionary of key-value pairs mapping Amplify Studio properties to fields in a data model. Use when the action performs an operation on an Amplify DataStore model.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// Specifies whether the user should be signed out globally. Specify this value for an auth sign out action.
        public var global: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// The unique ID of the component that the ActionParameters apply to.
        public var id: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// The name of the data model. Use when the action performs an operation on an Amplify DataStore model.
        public var model: Swift.String?
        /// A key-value pair that specifies the state property name and its initial value.
        public var state: AmplifyUIBuilderClientTypes.MutationActionSetStateParameter?
        /// The element within the same component to modify when the action occurs.
        public var target: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// The type of navigation action. Valid values are url and anchor. This value is required for a navigation action.
        public var type: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// The URL to the location to open. Specify this value for a navigation action.
        public var url: AmplifyUIBuilderClientTypes.ComponentProperty?

        public init (
            anchor: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            fields: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            global: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            id: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            model: Swift.String? = nil,
            state: AmplifyUIBuilderClientTypes.MutationActionSetStateParameter? = nil,
            target: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            type: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            url: AmplifyUIBuilderClientTypes.ComponentProperty? = nil
        )
        {
            self.anchor = anchor
            self.fields = fields
            self.global = global
            self.id = id
            self.model = model
            self.state = state
            self.target = target
            self.type = type
            self.url = url
        }
    }

}

extension AmplifyUIBuilderClientTypes.Component: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case bindingProperties
        case children
        case collectionProperties
        case componentType
        case createdAt
        case environmentName
        case events
        case id
        case modifiedAt
        case name
        case overrides
        case properties
        case schemaVersion
        case sourceId
        case tags
        case variants
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, componentBindingProperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(componentBindingProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchild0 in children {
                try childrenContainer.encode(componentchild0)
            }
        }
        if let collectionProperties = collectionProperties {
            var collectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .collectionProperties)
            for (dictKey0, componentCollectionProperties0) in collectionProperties {
                try collectionPropertiesContainer.encode(componentCollectionProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, componentEvents0) in events {
                try eventsContainer.encode(componentEvents0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentOverrides0) in overrides {
                var componentOverrides0Container = overridesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, componentOverridesValue1) in componentOverrides0 {
                    try componentOverrides0Container.encode(componentOverridesValue1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentProperties0) in properties {
                try propertiesContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let variants = variants {
            var variantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variants)
            for componentvariant0 in variants {
                try variantsContainer.encode(componentvariant0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let variantsContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentVariant?].self, forKey: .variants)
        var variantsDecoded0:[AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        if let variantsContainer = variantsContainer {
            variantsDecoded0 = [AmplifyUIBuilderClientTypes.ComponentVariant]()
            for structure0 in variantsContainer {
                if let structure0 = structure0 {
                    variantsDecoded0?.append(structure0)
                }
            }
        }
        variants = variantsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]()
            for (key0, componentbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let componentbindingpropertiesvalue0 = componentbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = componentbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
        let collectionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentDataConfiguration?].self, forKey: .collectionProperties)
        var collectionPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil
        if let collectionPropertiesContainer = collectionPropertiesContainer {
            collectionPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]()
            for (key0, componentdataconfiguration0) in collectionPropertiesContainer {
                if let componentdataconfiguration0 = componentdataconfiguration0 {
                    collectionPropertiesDecoded0?[key0] = componentdataconfiguration0
                }
            }
        }
        collectionProperties = collectionPropertiesDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentEvent?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]()
            for (key0, componentevent0) in eventsContainer {
                if let componentevent0 = componentevent0 {
                    eventsDecoded0?[key0] = componentevent0
                }
            }
        }
        events = eventsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Contains the configuration settings for a user interface (UI) element for an Amplify app. A component is configured as a primary, stand-alone UI element. Use ComponentChild to configure an instance of a Component. A ComponentChild instance inherits the configuration of the main Component.
    public struct Component: Swift.Equatable {
        /// The unique ID of the Amplify app associated with the component.
        /// This member is required.
        public var appId: Swift.String?
        /// The information to connect a component's properties to data at runtime. You can't specify tags as a valid property for bindingProperties.
        /// This member is required.
        public var bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]?
        /// A list of the component's ComponentChild instances.
        public var children: [AmplifyUIBuilderClientTypes.ComponentChild]?
        /// The data binding configuration for the component's properties. Use this for a collection component. You can't specify tags as a valid property for collectionProperties.
        public var collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]?
        /// The type of the component. This can be an Amplify custom UI component or another custom component.
        /// This member is required.
        public var componentType: Swift.String?
        /// The time that the component was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// Describes the events that can be raised on the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public var events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]?
        /// The unique ID of the component.
        /// This member is required.
        public var id: Swift.String?
        /// The time that the component was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The name of the component.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the component's properties that can be overriden in a customized instance of the component. You can't specify tags as a valid property for overrides.
        /// This member is required.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// Describes the component's properties. You can't specify tags as a valid property for properties.
        /// This member is required.
        public var properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The schema version of the component when it was imported.
        public var schemaVersion: Swift.String?
        /// The unique ID of the component in its original source system, such as Figma.
        public var sourceId: Swift.String?
        /// One or more key-value pairs to use when tagging the component.
        public var tags: [Swift.String:Swift.String]?
        /// A list of the component's variants. A variant is a unique style configuration of a main component.
        /// This member is required.
        public var variants: [AmplifyUIBuilderClientTypes.ComponentVariant]?

        public init (
            appId: Swift.String? = nil,
            bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil,
            children: [AmplifyUIBuilderClientTypes.ComponentChild]? = nil,
            collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil,
            componentType: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            environmentName: Swift.String? = nil,
            events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil,
            id: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            schemaVersion: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            variants: [AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        )
        {
            self.appId = appId
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.events = events
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.schemaVersion = schemaVersion
            self.sourceId = sourceId
            self.tags = tags
            self.variants = variants
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case defaultValue
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = self.bindingProperties {
            try encodeContainer.encode(bindingProperties, forKey: .bindingProperties)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValueProperties.self, forKey: .bindingProperties)
        bindingProperties = bindingPropertiesDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the data binding configuration for a component at runtime. You can use ComponentBindingPropertiesValue to add exposed properties to a component to allow different values to be entered when a component is reused in different places in an app.
    public struct ComponentBindingPropertiesValue: Swift.Equatable {
        /// Describes the properties to customize with data at runtime.
        public var bindingProperties: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValueProperties?
        /// The default value of the property.
        public var defaultValue: Swift.String?
        /// The property type.
        public var type: Swift.String?

        public init (
            bindingProperties: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValueProperties? = nil,
            defaultValue: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.defaultValue = defaultValue
            self.type = type
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValueProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case defaultValue
        case field
        case key
        case model
        case predicates
        case slotName
        case userAttribute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let predicates = predicates {
            var predicatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predicates)
            for predicate0 in predicates {
                try predicatesContainer.encode(predicate0)
            }
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let userAttribute = self.userAttribute {
            try encodeContainer.encode(userAttribute, forKey: .userAttribute)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let predicatesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Predicate?].self, forKey: .predicates)
        var predicatesDecoded0:[AmplifyUIBuilderClientTypes.Predicate]? = nil
        if let predicatesContainer = predicatesContainer {
            predicatesDecoded0 = [AmplifyUIBuilderClientTypes.Predicate]()
            for structure0 in predicatesContainer {
                if let structure0 = structure0 {
                    predicatesDecoded0?.append(structure0)
                }
            }
        }
        predicates = predicatesDecoded0
        let userAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAttribute)
        userAttribute = userAttributeDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the data binding configuration for a specific property using data stored in Amazon Web Services. For Amazon Web Services connected properties, you can bind a property to data stored in an Amazon S3 bucket, an Amplify DataStore model or an authenticated user attribute.
    public struct ComponentBindingPropertiesValueProperties: Swift.Equatable {
        /// An Amazon S3 bucket.
        public var bucket: Swift.String?
        /// The default value to assign to the property.
        public var defaultValue: Swift.String?
        /// The field to bind the data to.
        public var field: Swift.String?
        /// The storage key for an Amazon S3 bucket.
        public var key: Swift.String?
        /// An Amplify DataStore model.
        public var model: Swift.String?
        /// A list of predicates for binding a component's properties to data.
        public var predicates: [AmplifyUIBuilderClientTypes.Predicate]?
        /// The name of a component slot.
        public var slotName: Swift.String?
        /// An authenticated user attribute.
        public var userAttribute: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            field: Swift.String? = nil,
            key: Swift.String? = nil,
            model: Swift.String? = nil,
            predicates: [AmplifyUIBuilderClientTypes.Predicate]? = nil,
            slotName: Swift.String? = nil,
            userAttribute: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.defaultValue = defaultValue
            self.field = field
            self.key = key
            self.model = model
            self.predicates = predicates
            self.slotName = slotName
            self.userAttribute = userAttribute
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentChild: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children
        case componentType
        case events
        case name
        case properties
        case sourceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchild0 in children {
                try childrenContainer.encode(componentchild0)
            }
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, componentEvents0) in events {
                try eventsContainer.encode(componentEvents0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentProperties0) in properties {
                try propertiesContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentEvent?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]()
            for (key0, componentevent0) in eventsContainer {
                if let componentevent0 = componentevent0 {
                    eventsDecoded0?[key0] = componentevent0
                }
            }
        }
        events = eventsDecoded0
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// A nested UI configuration within a parent Component.
    public struct ComponentChild: Swift.Equatable {
        /// The list of ComponentChild instances for this component.
        public var children: [AmplifyUIBuilderClientTypes.ComponentChild]?
        /// The type of the child component.
        /// This member is required.
        public var componentType: Swift.String?
        /// Describes the events that can be raised on the child component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public var events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]?
        /// The name of the child component.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the properties of the child component. You can't specify tags as a valid property for properties.
        /// This member is required.
        public var properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The unique ID of the child component in its original source system, such as Figma.
        public var sourceId: Swift.String?

        public init (
            children: [AmplifyUIBuilderClientTypes.ComponentChild]? = nil,
            componentType: Swift.String? = nil,
            events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil,
            name: Swift.String? = nil,
            properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            sourceId: Swift.String? = nil
        )
        {
            self.children = children
            self.componentType = componentType
            self.events = events
            self.name = name
            self.properties = properties
            self.sourceId = sourceId
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentConditionProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `else` = "else"
        case field
        case operand
        case operandType
        case `operator` = "operator"
        case property
        case then
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `else` = self.`else` {
            try encodeContainer.encode(`else`.value, forKey: .`else`)
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let operand = self.operand {
            try encodeContainer.encode(operand, forKey: .operand)
        }
        if let operandType = self.operandType {
            try encodeContainer.encode(operandType, forKey: .operandType)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
        if let then = self.then {
            try encodeContainer.encode(then.value, forKey: .then)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operator)
        `operator` = operatorDecoded
        let operandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operand)
        operand = operandDecoded
        let thenDecoded = try containerValues.decodeIfPresent(Box<AmplifyUIBuilderClientTypes.ComponentProperty>.self, forKey: .then)
        then = thenDecoded
        let elseDecoded = try containerValues.decodeIfPresent(Box<AmplifyUIBuilderClientTypes.ComponentProperty>.self, forKey: .else)
        `else` = elseDecoded
        let operandTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operandType)
        operandType = operandTypeDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents a conditional expression to set a component property. Use ComponentConditionProperty to set a property to different values conditionally, based on the value of another property.
    public struct ComponentConditionProperty: Swift.Equatable {
        /// The value to assign to the property if the condition is not met.
        public var `else`: Box<AmplifyUIBuilderClientTypes.ComponentProperty>?
        /// The name of a field. Specify this when the property is a data model.
        public var field: Swift.String?
        /// The value of the property to evaluate.
        public var operand: Swift.String?
        /// The type of the property to evaluate.
        public var operandType: Swift.String?
        /// The operator to use to perform the evaluation, such as eq to represent equals.
        public var `operator`: Swift.String?
        /// The name of the conditional property.
        public var property: Swift.String?
        /// The value to assign to the property if the condition is met.
        public var then: Box<AmplifyUIBuilderClientTypes.ComponentProperty>?

        public init (
            `else`: Box<AmplifyUIBuilderClientTypes.ComponentProperty>? = nil,
            field: Swift.String? = nil,
            operand: Swift.String? = nil,
            operandType: Swift.String? = nil,
            `operator`: Swift.String? = nil,
            property: Swift.String? = nil,
            then: Box<AmplifyUIBuilderClientTypes.ComponentProperty>? = nil
        )
        {
            self.`else` = `else`
            self.field = field
            self.operand = operand
            self.operandType = operandType
            self.`operator` = `operator`
            self.property = property
            self.then = then
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentDataConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifiers
        case model
        case predicate
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifiers = identifiers {
            var identifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identifiers)
            for string0 in identifiers {
                try identifiersContainer.encode(string0)
            }
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let predicate = self.predicate {
            try encodeContainer.encode(predicate, forKey: .predicate)
        }
        if let sort = sort {
            var sortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sort)
            for sortproperty0 in sort {
                try sortContainer.encode(sortproperty0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let sortContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.SortProperty?].self, forKey: .sort)
        var sortDecoded0:[AmplifyUIBuilderClientTypes.SortProperty]? = nil
        if let sortContainer = sortContainer {
            sortDecoded0 = [AmplifyUIBuilderClientTypes.SortProperty]()
            for structure0 in sortContainer {
                if let structure0 = structure0 {
                    sortDecoded0?.append(structure0)
                }
            }
        }
        sort = sortDecoded0
        let predicateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Predicate.self, forKey: .predicate)
        predicate = predicateDecoded
        let identifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identifiers)
        var identifiersDecoded0:[Swift.String]? = nil
        if let identifiersContainer = identifiersContainer {
            identifiersDecoded0 = [Swift.String]()
            for string0 in identifiersContainer {
                if let string0 = string0 {
                    identifiersDecoded0?.append(string0)
                }
            }
        }
        identifiers = identifiersDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for binding a component's properties to data.
    public struct ComponentDataConfiguration: Swift.Equatable {
        /// A list of IDs to use to bind data to a component. Use this property to bind specifically chosen data, rather than data retrieved from a query.
        public var identifiers: [Swift.String]?
        /// The name of the data model to use to bind data to a component.
        /// This member is required.
        public var model: Swift.String?
        /// Represents the conditional logic to use when binding data to a component. Use this property to retrieve only a subset of the data in a collection.
        public var predicate: AmplifyUIBuilderClientTypes.Predicate?
        /// Describes how to sort the component's properties.
        public var sort: [AmplifyUIBuilderClientTypes.SortProperty]?

        public init (
            identifiers: [Swift.String]? = nil,
            model: Swift.String? = nil,
            predicate: AmplifyUIBuilderClientTypes.Predicate? = nil,
            sort: [AmplifyUIBuilderClientTypes.SortProperty]? = nil
        )
        {
            self.identifiers = identifiers
            self.model = model
            self.predicate = predicate
            self.sort = sort
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case bindingEvent
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let bindingEvent = self.bindingEvent {
            try encodeContainer.encode(bindingEvent, forKey: .bindingEvent)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ActionParameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let bindingEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bindingEvent)
        bindingEvent = bindingEventDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration of an event. You can bind an event and a corresponding action to a Component or a ComponentChild. A button click is an example of an event.
    public struct ComponentEvent: Swift.Equatable {
        /// The action to perform when a specific event is raised.
        public var action: Swift.String?
        /// Binds an event to an action on a component. When you specify a bindingEvent, the event is called when the action is performed.
        public var bindingEvent: Swift.String?
        /// Describes information about the action.
        public var parameters: AmplifyUIBuilderClientTypes.ActionParameters?

        public init (
            action: Swift.String? = nil,
            bindingEvent: Swift.String? = nil,
            parameters: AmplifyUIBuilderClientTypes.ActionParameters? = nil
        )
        {
            self.action = action
            self.bindingEvent = bindingEvent
            self.parameters = parameters
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case bindings
        case collectionBindingProperties
        case componentName
        case concat
        case condition
        case configured
        case defaultValue
        case event
        case importedValue
        case model
        case property
        case type
        case userAttribute
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = self.bindingProperties {
            try encodeContainer.encode(bindingProperties, forKey: .bindingProperties)
        }
        if let bindings = bindings {
            var bindingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindings)
            for (dictKey0, formBindings0) in bindings {
                try bindingsContainer.encode(formBindings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let collectionBindingProperties = self.collectionBindingProperties {
            try encodeContainer.encode(collectionBindingProperties, forKey: .collectionBindingProperties)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let concat = concat {
            var concatContainer = encodeContainer.nestedUnkeyedContainer(forKey: .concat)
            for componentproperty0 in concat {
                try concatContainer.encode(componentproperty0)
            }
        }
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let configured = self.configured {
            try encodeContainer.encode(configured, forKey: .configured)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let importedValue = self.importedValue {
            try encodeContainer.encode(importedValue, forKey: .importedValue)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userAttribute = self.userAttribute {
            try encodeContainer.encode(userAttribute, forKey: .userAttribute)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let bindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties.self, forKey: .bindingProperties)
        bindingProperties = bindingPropertiesDecoded
        let collectionBindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties.self, forKey: .collectionBindingProperties)
        collectionBindingProperties = collectionBindingPropertiesDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let bindingsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.FormBindingElement?].self, forKey: .bindings)
        var bindingsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.FormBindingElement]? = nil
        if let bindingsContainer = bindingsContainer {
            bindingsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.FormBindingElement]()
            for (key0, formbindingelement0) in bindingsContainer {
                if let formbindingelement0 = formbindingelement0 {
                    bindingsDecoded0?[key0] = formbindingelement0
                }
            }
        }
        bindings = bindingsDecoded0
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
        let userAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAttribute)
        userAttribute = userAttributeDecoded
        let concatContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .concat)
        var concatDecoded0:[AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let concatContainer = concatContainer {
            concatDecoded0 = [AmplifyUIBuilderClientTypes.ComponentProperty]()
            for structure0 in concatContainer {
                if let structure0 = structure0 {
                    concatDecoded0?.append(structure0)
                }
            }
        }
        concat = concatDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentConditionProperty.self, forKey: .condition)
        condition = conditionDecoded
        let configuredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .configured)
        configured = configuredDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let importedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importedValue)
        importedValue = importedValueDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for all of a component's properties. Use ComponentProperty to specify the values to render or bind by default.
    public struct ComponentProperty: Swift.Equatable {
        /// The information to bind the component property to data at runtime.
        public var bindingProperties: AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties?
        /// The information to bind the component property to form data.
        public var bindings: [Swift.String:AmplifyUIBuilderClientTypes.FormBindingElement]?
        /// The information to bind the component property to data at runtime. Use this for collection components.
        public var collectionBindingProperties: AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties?
        /// The name of the component that is affected by an event.
        public var componentName: Swift.String?
        /// A list of component properties to concatenate to create the value to assign to this component property.
        public var concat: [AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The conditional expression to use to assign a value to the component property.
        public var condition: AmplifyUIBuilderClientTypes.ComponentConditionProperty?
        /// Specifies whether the user configured the property in Amplify Studio after importing it.
        public var configured: Swift.Bool?
        /// The default value to assign to the component property.
        public var defaultValue: Swift.String?
        /// An event that occurs in your app. Use this for workflow data binding.
        public var event: Swift.String?
        /// The default value assigned to the property when the component is imported into an app.
        public var importedValue: Swift.String?
        /// The data model to use to assign a value to the component property.
        public var model: Swift.String?
        /// The name of the component's property that is affected by an event.
        public var property: Swift.String?
        /// The component type.
        public var type: Swift.String?
        /// An authenticated user attribute to use to assign a value to the component property.
        public var userAttribute: Swift.String?
        /// The value to assign to the component property.
        public var value: Swift.String?

        public init (
            bindingProperties: AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties? = nil,
            bindings: [Swift.String:AmplifyUIBuilderClientTypes.FormBindingElement]? = nil,
            collectionBindingProperties: AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties? = nil,
            componentName: Swift.String? = nil,
            concat: [AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            condition: AmplifyUIBuilderClientTypes.ComponentConditionProperty? = nil,
            configured: Swift.Bool? = nil,
            defaultValue: Swift.String? = nil,
            event: Swift.String? = nil,
            importedValue: Swift.String? = nil,
            model: Swift.String? = nil,
            property: Swift.String? = nil,
            type: Swift.String? = nil,
            userAttribute: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.bindings = bindings
            self.collectionBindingProperties = collectionBindingProperties
            self.componentName = componentName
            self.concat = concat
            self.condition = condition
            self.configured = configured
            self.defaultValue = defaultValue
            self.event = event
            self.importedValue = importedValue
            self.model = model
            self.property = property
            self.type = type
            self.userAttribute = userAttribute
            self.value = value
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case property
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Associates a component property to a binding property. This enables exposed properties on the top level component to propagate data to the component's property values.
    public struct ComponentPropertyBindingProperties: Swift.Equatable {
        /// The data field to bind the property to.
        public var field: Swift.String?
        /// The component property to bind to the data field.
        /// This member is required.
        public var property: Swift.String?

        public init (
            field: Swift.String? = nil,
            property: Swift.String? = nil
        )
        {
            self.field = field
            self.property = property
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case componentType
        case environmentName
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Contains a summary of a component. This is a read-only data type that is returned by ListComponents.
    public struct ComponentSummary: Swift.Equatable {
        /// The unique ID of the Amplify app associated with the component.
        /// This member is required.
        public var appId: Swift.String?
        /// The component type.
        /// This member is required.
        public var componentType: Swift.String?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The unique ID of the component.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the component.
        /// This member is required.
        public var name: Swift.String?

        public init (
            appId: Swift.String? = nil,
            componentType: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appId = appId
            self.componentType = componentType
            self.environmentName = environmentName
            self.id = id
            self.name = name
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentVariant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
        case variantValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentOverrides0) in overrides {
                var componentOverrides0Container = overridesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, componentOverridesValue1) in componentOverrides0 {
                    try componentOverrides0Container.encode(componentOverridesValue1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let variantValues = variantValues {
            var variantValuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variantValues)
            for (dictKey0, componentVariantValues0) in variantValues {
                try variantValuesContainer.encode(componentVariantValues0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variantValuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variantValues)
        var variantValuesDecoded0: [Swift.String:Swift.String]? = nil
        if let variantValuesContainer = variantValuesContainer {
            variantValuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variantValuesContainer {
                if let string0 = string0 {
                    variantValuesDecoded0?[key0] = string0
                }
            }
        }
        variantValues = variantValuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the style configuration of a unique variation of a main component.
    public struct ComponentVariant: Swift.Equatable {
        /// The properties of the component variant that can be overriden when customizing an instance of the component. You can't specify tags as a valid property for overrides.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// The combination of variants that comprise this variant. You can't specify tags as a valid property for variantValues.
        public var variantValues: [Swift.String:Swift.String]?

        public init (
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            variantValues: [Swift.String:Swift.String]? = nil
        )
        {
            self.overrides = overrides
            self.variantValues = variantValues
        }
    }

}

extension AmplifyUIBuilderClientTypes.CreateComponentData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case children
        case collectionProperties
        case componentType
        case events
        case name
        case overrides
        case properties
        case schemaVersion
        case sourceId
        case tags
        case variants
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, componentBindingProperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(componentBindingProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchild0 in children {
                try childrenContainer.encode(componentchild0)
            }
        }
        if let collectionProperties = collectionProperties {
            var collectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .collectionProperties)
            for (dictKey0, componentCollectionProperties0) in collectionProperties {
                try collectionPropertiesContainer.encode(componentCollectionProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, componentEvents0) in events {
                try eventsContainer.encode(componentEvents0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentOverrides0) in overrides {
                var componentOverrides0Container = overridesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, componentOverridesValue1) in componentOverrides0 {
                    try componentOverrides0Container.encode(componentOverridesValue1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentProperties0) in properties {
                try propertiesContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let variants = variants {
            var variantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variants)
            for componentvariant0 in variants {
                try variantsContainer.encode(componentvariant0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let variantsContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentVariant?].self, forKey: .variants)
        var variantsDecoded0:[AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        if let variantsContainer = variantsContainer {
            variantsDecoded0 = [AmplifyUIBuilderClientTypes.ComponentVariant]()
            for structure0 in variantsContainer {
                if let structure0 = structure0 {
                    variantsDecoded0?.append(structure0)
                }
            }
        }
        variants = variantsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]()
            for (key0, componentbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let componentbindingpropertiesvalue0 = componentbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = componentbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
        let collectionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentDataConfiguration?].self, forKey: .collectionProperties)
        var collectionPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil
        if let collectionPropertiesContainer = collectionPropertiesContainer {
            collectionPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]()
            for (key0, componentdataconfiguration0) in collectionPropertiesContainer {
                if let componentdataconfiguration0 = componentdataconfiguration0 {
                    collectionPropertiesDecoded0?[key0] = componentdataconfiguration0
                }
            }
        }
        collectionProperties = collectionPropertiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentEvent?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]()
            for (key0, componentevent0) in eventsContainer {
                if let componentevent0 = componentevent0 {
                    eventsDecoded0?[key0] = componentevent0
                }
            }
        }
        events = eventsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents all of the information that is required to create a component.
    public struct CreateComponentData: Swift.Equatable {
        /// The data binding information for the component's properties.
        /// This member is required.
        public var bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]?
        /// A list of child components that are instances of the main component.
        public var children: [AmplifyUIBuilderClientTypes.ComponentChild]?
        /// The data binding configuration for customizing a component's properties. Use this for a collection component.
        public var collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]?
        /// The component type. This can be an Amplify custom UI component or another custom component.
        /// This member is required.
        public var componentType: Swift.String?
        /// The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public var events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]?
        /// The name of the component
        /// This member is required.
        public var name: Swift.String?
        /// Describes the component properties that can be overriden to customize an instance of the component.
        /// This member is required.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// Describes the component's properties.
        /// This member is required.
        public var properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The schema version of the component when it was imported.
        public var schemaVersion: Swift.String?
        /// The unique ID of the component in its original source system, such as Figma.
        public var sourceId: Swift.String?
        /// One or more key-value pairs to use when tagging the component data.
        public var tags: [Swift.String:Swift.String]?
        /// A list of the unique variants of this component.
        /// This member is required.
        public var variants: [AmplifyUIBuilderClientTypes.ComponentVariant]?

        public init (
            bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil,
            children: [AmplifyUIBuilderClientTypes.ComponentChild]? = nil,
            collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil,
            componentType: Swift.String? = nil,
            events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil,
            name: Swift.String? = nil,
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            schemaVersion: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            variants: [AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.events = events
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.schemaVersion = schemaVersion
            self.sourceId = sourceId
            self.tags = tags
            self.variants = variants
        }
    }

}

public struct CreateComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateComponentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateComponentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let componentToCreate = input.operationInput.componentToCreate {
                let componentToCreatedata = try encoder.encode(componentToCreate)
                let componentToCreatebody = ClientRuntime.HttpBody.data(componentToCreatedata)
                input.builder.withBody(componentToCreatebody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let componentToCreatedata = "{}".data(using: .utf8)!
                    let componentToCreatebody = ClientRuntime.HttpBody.data(componentToCreatedata)
                    input.builder.withBody(componentToCreatebody)
                }
            }
        } catch let err {
            throw SdkError<CreateComponentOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentToCreate = self.componentToCreate {
            try encodeContainer.encode(componentToCreate, forKey: .componentToCreate)
        }
    }
}

extension CreateComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension CreateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components"
    }
}

public struct CreateComponentInput: Swift.Equatable {
    /// The unique ID of the Amplify app to associate with the component.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// Represents the configuration of the component to create.
    /// This member is required.
    public var componentToCreate: AmplifyUIBuilderClientTypes.CreateComponentData?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        componentToCreate: AmplifyUIBuilderClientTypes.CreateComponentData? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.componentToCreate = componentToCreate
        self.environmentName = environmentName
    }
}

struct CreateComponentInputBody: Swift.Equatable {
    let componentToCreate: AmplifyUIBuilderClientTypes.CreateComponentData?
}

extension CreateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentToCreate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentToCreateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CreateComponentData.self, forKey: .componentToCreate)
        componentToCreate = componentToCreateDecoded
    }
}

extension CreateComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AmplifyUIBuilderClientTypes.Component = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct CreateComponentOutputResponse: Swift.Equatable {
    /// Describes the configuration of the new component.
    public var entity: AmplifyUIBuilderClientTypes.Component?

    public init (
        entity: AmplifyUIBuilderClientTypes.Component? = nil
    )
    {
        self.entity = entity
    }
}

struct CreateComponentOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Component?
}

extension CreateComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Component.self, forKey: .entity)
        entity = entityDecoded
    }
}

extension AmplifyUIBuilderClientTypes.CreateFormData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cta
        case dataType
        case fields
        case formActionType
        case name
        case schemaVersion
        case sectionalElements
        case style
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cta = self.cta {
            try encodeContainer.encode(cta, forKey: .cta)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, fieldsMap0) in fields {
                try fieldsContainer.encode(fieldsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let formActionType = self.formActionType {
            try encodeContainer.encode(formActionType.rawValue, forKey: .formActionType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sectionalElements = sectionalElements {
            var sectionalElementsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sectionalElements)
            for (dictKey0, sectionalElementMap0) in sectionalElements {
                try sectionalElementsContainer.encode(sectionalElementMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataTypeConfig.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let formActionTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormActionType.self, forKey: .formActionType)
        formActionType = formActionTypeDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.FieldConfig?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]()
            for (key0, fieldconfig0) in fieldsContainer {
                if let fieldconfig0 = fieldconfig0 {
                    fieldsDecoded0?[key0] = fieldconfig0
                }
            }
        }
        fields = fieldsDecoded0
        let styleDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyle.self, forKey: .style)
        style = styleDecoded
        let sectionalElementsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.SectionalElement?].self, forKey: .sectionalElements)
        var sectionalElementsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil
        if let sectionalElementsContainer = sectionalElementsContainer {
            sectionalElementsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]()
            for (key0, sectionalelement0) in sectionalElementsContainer {
                if let sectionalelement0 = sectionalelement0 {
                    sectionalElementsDecoded0?[key0] = sectionalelement0
                }
            }
        }
        sectionalElements = sectionalElementsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let ctaDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormCTA.self, forKey: .cta)
        cta = ctaDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents all of the information that is required to create a form.
    public struct CreateFormData: Swift.Equatable {
        /// The FormCTA object that stores the call to action configuration for the form.
        public var cta: AmplifyUIBuilderClientTypes.FormCTA?
        /// The type of data source to use to create the form.
        /// This member is required.
        public var dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig?
        /// The configuration information for the form's fields.
        /// This member is required.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]?
        /// Specifies whether to perform a create or update action on the form.
        /// This member is required.
        public var formActionType: AmplifyUIBuilderClientTypes.FormActionType?
        /// The name of the form.
        /// This member is required.
        public var name: Swift.String?
        /// The schema version of the form.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The configuration information for the visual helper elements for the form. These elements are not associated with any data.
        /// This member is required.
        public var sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]?
        /// The configuration for the form's style.
        /// This member is required.
        public var style: AmplifyUIBuilderClientTypes.FormStyle?
        /// One or more key-value pairs to use when tagging the form data.
        public var tags: [Swift.String:Swift.String]?

        public init (
            cta: AmplifyUIBuilderClientTypes.FormCTA? = nil,
            dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig? = nil,
            fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil,
            formActionType: AmplifyUIBuilderClientTypes.FormActionType? = nil,
            name: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil,
            style: AmplifyUIBuilderClientTypes.FormStyle? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.cta = cta
            self.dataType = dataType
            self.fields = fields
            self.formActionType = formActionType
            self.name = name
            self.schemaVersion = schemaVersion
            self.sectionalElements = sectionalElements
            self.style = style
            self.tags = tags
        }
    }

}

public struct CreateFormInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFormInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFormInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateFormOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let formToCreate = input.operationInput.formToCreate {
                let formToCreatedata = try encoder.encode(formToCreate)
                let formToCreatebody = ClientRuntime.HttpBody.data(formToCreatedata)
                input.builder.withBody(formToCreatebody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let formToCreatedata = "{}".data(using: .utf8)!
                    let formToCreatebody = ClientRuntime.HttpBody.data(formToCreatedata)
                    input.builder.withBody(formToCreatebody)
                }
            }
        } catch let err {
            throw SdkError<CreateFormOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFormInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateFormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formToCreate = self.formToCreate {
            try encodeContainer.encode(formToCreate, forKey: .formToCreate)
        }
    }
}

extension CreateFormInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension CreateFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms"
    }
}

public struct CreateFormInput: Swift.Equatable {
    /// The unique ID of the Amplify app to associate with the form.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// Represents the configuration of the form to create.
    /// This member is required.
    public var formToCreate: AmplifyUIBuilderClientTypes.CreateFormData?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        formToCreate: AmplifyUIBuilderClientTypes.CreateFormData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.formToCreate = formToCreate
    }
}

struct CreateFormInputBody: Swift.Equatable {
    let formToCreate: AmplifyUIBuilderClientTypes.CreateFormData?
}

extension CreateFormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formToCreate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formToCreateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CreateFormData.self, forKey: .formToCreate)
        formToCreate = formToCreateDecoded
    }
}

extension CreateFormOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFormOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFormOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFormOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AmplifyUIBuilderClientTypes.Form = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct CreateFormOutputResponse: Swift.Equatable {
    /// Describes the configuration of the new form.
    public var entity: AmplifyUIBuilderClientTypes.Form?

    public init (
        entity: AmplifyUIBuilderClientTypes.Form? = nil
    )
    {
        self.entity = entity
    }
}

struct CreateFormOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Form?
}

extension CreateFormOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Form.self, forKey: .entity)
        entity = entityDecoded
    }
}

extension AmplifyUIBuilderClientTypes.CreateThemeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case overrides
        case tags
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for themevalues0 in overrides {
                try overridesContainer.encode(themevalues0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for themevalues0 in values {
                try valuesContainer.encode(themevalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .overrides)
        var overridesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents all of the information that is required to create a theme.
    public struct CreateThemeData: Swift.Equatable {
        /// The name of the theme.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize an instance of the theme.
        public var overrides: [AmplifyUIBuilderClientTypes.ThemeValues]?
        /// One or more key-value pairs to use when tagging the theme data.
        public var tags: [Swift.String:Swift.String]?
        /// A list of key-value pairs that deﬁnes the properties of the theme.
        /// This member is required.
        public var values: [AmplifyUIBuilderClientTypes.ThemeValues]?

        public init (
            name: Swift.String? = nil,
            overrides: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            values: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        )
        {
            self.name = name
            self.overrides = overrides
            self.tags = tags
            self.values = values
        }
    }

}

public struct CreateThemeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateThemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateThemeInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateThemeOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let themeToCreate = input.operationInput.themeToCreate {
                let themeToCreatedata = try encoder.encode(themeToCreate)
                let themeToCreatebody = ClientRuntime.HttpBody.data(themeToCreatedata)
                input.builder.withBody(themeToCreatebody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let themeToCreatedata = "{}".data(using: .utf8)!
                    let themeToCreatebody = ClientRuntime.HttpBody.data(themeToCreatedata)
                    input.builder.withBody(themeToCreatebody)
                }
            }
        } catch let err {
            throw SdkError<CreateThemeOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateThemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let themeToCreate = self.themeToCreate {
            try encodeContainer.encode(themeToCreate, forKey: .themeToCreate)
        }
    }
}

extension CreateThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension CreateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes"
    }
}

public struct CreateThemeInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the theme.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// Represents the configuration of the theme to create.
    /// This member is required.
    public var themeToCreate: AmplifyUIBuilderClientTypes.CreateThemeData?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        themeToCreate: AmplifyUIBuilderClientTypes.CreateThemeData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.themeToCreate = themeToCreate
    }
}

struct CreateThemeInputBody: Swift.Equatable {
    let themeToCreate: AmplifyUIBuilderClientTypes.CreateThemeData?
}

extension CreateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeToCreate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeToCreateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CreateThemeData.self, forKey: .themeToCreate)
        themeToCreate = themeToCreateDecoded
    }
}

extension CreateThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateThemeOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AmplifyUIBuilderClientTypes.Theme = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct CreateThemeOutputResponse: Swift.Equatable {
    /// Describes the configuration of the new theme.
    public var entity: AmplifyUIBuilderClientTypes.Theme?

    public init (
        entity: AmplifyUIBuilderClientTypes.Theme? = nil
    )
    {
        self.entity = entity
    }
}

struct CreateThemeOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Theme?
}

extension CreateThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Theme.self, forKey: .entity)
        entity = entityDecoded
    }
}

extension DeleteComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components/\(id.urlPercentEncoding())"
    }
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the component to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the component to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
}

extension DeleteComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteComponentOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFormInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the form to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the form to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct DeleteFormInputBody: Swift.Equatable {
}

extension DeleteFormInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFormOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFormOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFormOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFormOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFormOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes/\(id.urlPercentEncoding())"
    }
}

public struct DeleteThemeInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the theme to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the theme to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct DeleteThemeInputBody: Swift.Equatable {
}

extension DeleteThemeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteThemeOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteThemeOutputResponse: Swift.Equatable {

    public init () { }
}

public struct ExchangeCodeForTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExchangeCodeForTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExchangeCodeForTokenInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ExchangeCodeForTokenOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let request = input.operationInput.request {
                let requestdata = try encoder.encode(request)
                let requestbody = ClientRuntime.HttpBody.data(requestdata)
                input.builder.withBody(requestbody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let requestdata = "{}".data(using: .utf8)!
                    let requestbody = ClientRuntime.HttpBody.data(requestdata)
                    input.builder.withBody(requestbody)
                }
            }
        } catch let err {
            throw SdkError<ExchangeCodeForTokenOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExchangeCodeForTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExchangeCodeForTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension ExchangeCodeForTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case request
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let request = self.request {
            try encodeContainer.encode(request, forKey: .request)
        }
    }
}

extension ExchangeCodeForTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let provider = provider else {
            return nil
        }
        return "/tokens/\(provider.rawValue.urlPercentEncoding())"
    }
}

public struct ExchangeCodeForTokenInput: Swift.Equatable {
    /// The third-party provider for the token. The only valid value is figma.
    /// This member is required.
    public var provider: AmplifyUIBuilderClientTypes.TokenProviders?
    /// Describes the configuration of the request.
    /// This member is required.
    public var request: AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody?

    public init (
        provider: AmplifyUIBuilderClientTypes.TokenProviders? = nil,
        request: AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody? = nil
    )
    {
        self.provider = provider
        self.request = request
    }
}

struct ExchangeCodeForTokenInputBody: Swift.Equatable {
    let request: AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody?
}

extension ExchangeCodeForTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case request
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody.self, forKey: .request)
        request = requestDecoded
    }
}

extension ExchangeCodeForTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExchangeCodeForTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExchangeCodeForTokenOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExchangeCodeForTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExchangeCodeForTokenOutputResponse(expiresIn: \(Swift.String(describing: expiresIn)), accessToken: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

extension ExchangeCodeForTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExchangeCodeForTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
            self.refreshToken = output.refreshToken
        } else {
            self.accessToken = nil
            self.expiresIn = nil
            self.refreshToken = nil
        }
    }
}

public struct ExchangeCodeForTokenOutputResponse: Swift.Equatable {
    /// The access token.
    /// This member is required.
    public var accessToken: Swift.String?
    /// The date and time when the new access token expires.
    /// This member is required.
    public var expiresIn: Swift.Int?
    /// The token to use to refresh a previously issued access token that might have expired.
    /// This member is required.
    public var refreshToken: Swift.String?

    public init (
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int? = nil,
        refreshToken: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.refreshToken = refreshToken
    }
}

struct ExchangeCodeForTokenOutputResponseBody: Swift.Equatable {
    let accessToken: Swift.String?
    let expiresIn: Swift.Int?
    let refreshToken: Swift.String?
}

extension ExchangeCodeForTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
        case refreshToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
    }
}

extension AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case redirectUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let redirectUri = self.redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExchangeCodeForTokenRequestBody(redirectUri: \(Swift.String(describing: redirectUri)), code: \"CONTENT_REDACTED\")"}
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration of a request to exchange an access code for a token.
    public struct ExchangeCodeForTokenRequestBody: Swift.Equatable {
        /// The access code to send in the request.
        /// This member is required.
        public var code: Swift.String?
        /// The location of the application that will receive the access code.
        /// This member is required.
        public var redirectUri: Swift.String?

        public init (
            code: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.code = code
            self.redirectUri = redirectUri
        }
    }

}

extension ExportComponentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ExportComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/export/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components"
    }
}

public struct ExportComponentsInput: Swift.Equatable {
    /// The unique ID of the Amplify app to export components to.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ExportComponentsInputBody: Swift.Equatable {
}

extension ExportComponentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportComponentsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ExportComponentsOutputResponse: Swift.Equatable {
    /// Represents the configuration of the exported components.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.Component]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        entities: [AmplifyUIBuilderClientTypes.Component]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ExportComponentsOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.Component]?
    let nextToken: Swift.String?
}

extension ExportComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Component?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.Component]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.Component]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ExportFormsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ExportFormsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/export/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms"
    }
}

public struct ExportFormsInput: Swift.Equatable {
    /// The unique ID of the Amplify app to export forms to.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ExportFormsInputBody: Swift.Equatable {
}

extension ExportFormsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportFormsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportFormsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportFormsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportFormsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportFormsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ExportFormsOutputResponse: Swift.Equatable {
    /// Represents the configuration of the exported forms.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.Form]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        entities: [AmplifyUIBuilderClientTypes.Form]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ExportFormsOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.Form]?
    let nextToken: Swift.String?
}

extension ExportFormsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Form?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.Form]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.Form]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ExportThemesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ExportThemesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/export/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes"
    }
}

public struct ExportThemesInput: Swift.Equatable {
    /// The unique ID of the Amplify app to export the themes to.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ExportThemesInputBody: Swift.Equatable {
}

extension ExportThemesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportThemesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportThemesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExportThemesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportThemesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExportThemesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ExportThemesOutputResponse: Swift.Equatable {
    /// Represents the configuration of the exported themes.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.Theme]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        entities: [AmplifyUIBuilderClientTypes.Theme]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ExportThemesOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.Theme]?
    let nextToken: Swift.String?
}

extension ExportThemesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Theme?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.Theme]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.Theme]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AmplifyUIBuilderClientTypes.FieldConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excluded
        case inputType
        case label
        case position
        case validations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let inputType = self.inputType {
            try encodeContainer.encode(inputType, forKey: .inputType)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let validations = validations {
            var validationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validations)
            for fieldvalidationconfiguration0 in validations {
                try validationsContainer.encode(fieldvalidationconfiguration0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let positionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FieldPosition.self, forKey: .position)
        position = positionDecoded
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
        let inputTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FieldInputConfig.self, forKey: .inputType)
        inputType = inputTypeDecoded
        let validationsContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.FieldValidationConfiguration?].self, forKey: .validations)
        var validationsDecoded0:[AmplifyUIBuilderClientTypes.FieldValidationConfiguration]? = nil
        if let validationsContainer = validationsContainer {
            validationsDecoded0 = [AmplifyUIBuilderClientTypes.FieldValidationConfiguration]()
            for structure0 in validationsContainer {
                if let structure0 = structure0 {
                    validationsDecoded0?.append(structure0)
                }
            }
        }
        validations = validationsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration information for a field in a table.
    public struct FieldConfig: Swift.Equatable {
        /// Specifies whether to hide a field.
        public var excluded: Swift.Bool?
        /// Describes the configuration for the default input value to display for a field.
        public var inputType: AmplifyUIBuilderClientTypes.FieldInputConfig?
        /// The label for the field.
        public var label: Swift.String?
        /// Specifies the field position.
        public var position: AmplifyUIBuilderClientTypes.FieldPosition?
        /// The validations to perform on the value in the field.
        public var validations: [AmplifyUIBuilderClientTypes.FieldValidationConfiguration]?

        public init (
            excluded: Swift.Bool? = nil,
            inputType: AmplifyUIBuilderClientTypes.FieldInputConfig? = nil,
            label: Swift.String? = nil,
            position: AmplifyUIBuilderClientTypes.FieldPosition? = nil,
            validations: [AmplifyUIBuilderClientTypes.FieldValidationConfiguration]? = nil
        )
        {
            self.excluded = excluded
            self.inputType = inputType
            self.label = label
            self.position = position
            self.validations = validations
        }
    }

}

extension AmplifyUIBuilderClientTypes.FieldInputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultChecked
        case defaultCountryCode
        case defaultValue
        case descriptiveText
        case isArray
        case maxValue
        case minValue
        case name
        case placeholder
        case readOnly
        case `required` = "required"
        case step
        case type
        case value
        case valueMappings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultChecked = self.defaultChecked {
            try encodeContainer.encode(defaultChecked, forKey: .defaultChecked)
        }
        if let defaultCountryCode = self.defaultCountryCode {
            try encodeContainer.encode(defaultCountryCode, forKey: .defaultCountryCode)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let descriptiveText = self.descriptiveText {
            try encodeContainer.encode(descriptiveText, forKey: .descriptiveText)
        }
        if let isArray = self.isArray {
            try encodeContainer.encode(isArray, forKey: .isArray)
        }
        if let maxValue = self.maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = self.minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let placeholder = self.placeholder {
            try encodeContainer.encode(placeholder, forKey: .placeholder)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if let step = self.step {
            try encodeContainer.encode(step, forKey: .step)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let valueMappings = self.valueMappings {
            try encodeContainer.encode(valueMappings, forKey: .valueMappings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let placeholderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeholder)
        placeholder = placeholderDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptiveTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .descriptiveText)
        descriptiveText = descriptiveTextDecoded
        let defaultCheckedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultChecked)
        defaultChecked = defaultCheckedDecoded
        let defaultCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultCountryCode)
        defaultCountryCode = defaultCountryCodeDecoded
        let valueMappingsDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ValueMappings.self, forKey: .valueMappings)
        valueMappings = valueMappingsDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let stepDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .step)
        step = stepDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let isArrayDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArray)
        isArray = isArrayDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for the default input values to display for a field.
    public struct FieldInputConfig: Swift.Equatable {
        /// Specifies whether a field has a default value.
        public var defaultChecked: Swift.Bool?
        /// The default country code for a phone number.
        public var defaultCountryCode: Swift.String?
        /// The default value for the field.
        public var defaultValue: Swift.String?
        /// The text to display to describe the field.
        public var descriptiveText: Swift.String?
        /// Specifies whether to render the field as an array. This property is ignored if the dataSourceType for the form is a Data Store.
        public var isArray: Swift.Bool?
        /// The maximum value to display for the field.
        public var maxValue: Swift.Float?
        /// The minimum value to display for the field.
        public var minValue: Swift.Float?
        /// The name of the field.
        public var name: Swift.String?
        /// The text to display as a placeholder for the field.
        public var placeholder: Swift.String?
        /// Specifies a read only field.
        public var readOnly: Swift.Bool?
        /// Specifies a field that requires input.
        public var `required`: Swift.Bool?
        /// The stepping increment for a numeric value in a field.
        public var step: Swift.Float?
        /// The input type for the field.
        /// This member is required.
        public var type: Swift.String?
        /// The value for the field.
        public var value: Swift.String?
        /// The information to use to customize the input fields with data at runtime.
        public var valueMappings: AmplifyUIBuilderClientTypes.ValueMappings?

        public init (
            defaultChecked: Swift.Bool? = nil,
            defaultCountryCode: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            descriptiveText: Swift.String? = nil,
            isArray: Swift.Bool? = nil,
            maxValue: Swift.Float? = nil,
            minValue: Swift.Float? = nil,
            name: Swift.String? = nil,
            placeholder: Swift.String? = nil,
            readOnly: Swift.Bool? = nil,
            `required`: Swift.Bool? = nil,
            step: Swift.Float? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil,
            valueMappings: AmplifyUIBuilderClientTypes.ValueMappings? = nil
        )
        {
            self.defaultChecked = defaultChecked
            self.defaultCountryCode = defaultCountryCode
            self.defaultValue = defaultValue
            self.descriptiveText = descriptiveText
            self.isArray = isArray
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.placeholder = placeholder
            self.readOnly = readOnly
            self.`required` = `required`
            self.step = step
            self.type = type
            self.value = value
            self.valueMappings = valueMappings
        }
    }

}

extension AmplifyUIBuilderClientTypes.FieldPosition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case below
        case fixed
        case rightof = "rightOf"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .below(below):
                try container.encode(below, forKey: .below)
            case let .fixed(fixed):
                try container.encode(fixed.rawValue, forKey: .fixed)
            case let .rightof(rightof):
                try container.encode(rightof, forKey: .rightof)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fixedDecoded = try values.decodeIfPresent(AmplifyUIBuilderClientTypes.FixedPosition.self, forKey: .fixed)
        if let fixed = fixedDecoded {
            self = .fixed(fixed)
            return
        }
        let rightofDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .rightof)
        if let rightof = rightofDecoded {
            self = .rightof(rightof)
            return
        }
        let belowDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .below)
        if let below = belowDecoded {
            self = .below(below)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the field position.
    public enum FieldPosition: Swift.Equatable {
        /// The field position is fixed and doesn't change in relation to other fields.
        case fixed(AmplifyUIBuilderClientTypes.FixedPosition)
        /// The field position is to the right of the field specified by the string.
        case rightof(Swift.String)
        /// The field position is below the field specified by the string.
        case below(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AmplifyUIBuilderClientTypes.FieldValidationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numValues
        case strValues
        case type
        case validationMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numValues = numValues {
            var numValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numValues)
            for integer0 in numValues {
                try numValuesContainer.encode(integer0)
            }
        }
        if let strValues = strValues {
            var strValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .strValues)
            for string0 in strValues {
                try strValuesContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let validationMessage = self.validationMessage {
            try encodeContainer.encode(validationMessage, forKey: .validationMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let strValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .strValues)
        var strValuesDecoded0:[Swift.String]? = nil
        if let strValuesContainer = strValuesContainer {
            strValuesDecoded0 = [Swift.String]()
            for string0 in strValuesContainer {
                if let string0 = string0 {
                    strValuesDecoded0?.append(string0)
                }
            }
        }
        strValues = strValuesDecoded0
        let numValuesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .numValues)
        var numValuesDecoded0:[Swift.Int]? = nil
        if let numValuesContainer = numValuesContainer {
            numValuesDecoded0 = [Swift.Int]()
            for integer0 in numValuesContainer {
                if let integer0 = integer0 {
                    numValuesDecoded0?.append(integer0)
                }
            }
        }
        numValues = numValuesDecoded0
        let validationMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationMessage)
        validationMessage = validationMessageDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the validation configuration for a field.
    public struct FieldValidationConfiguration: Swift.Equatable {
        /// The validation to perform on a number value.
        public var numValues: [Swift.Int]?
        /// The validation to perform on a string value.
        public var strValues: [Swift.String]?
        /// The validation to perform on an object type.
        /// This member is required.
        public var type: Swift.String?
        /// The validation message to display.
        public var validationMessage: Swift.String?

        public init (
            numValues: [Swift.Int]? = nil,
            strValues: [Swift.String]? = nil,
            type: Swift.String? = nil,
            validationMessage: Swift.String? = nil
        )
        {
            self.numValues = numValues
            self.strValues = strValues
            self.type = type
            self.validationMessage = validationMessage
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum FixedPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case first
        case sdkUnknown(Swift.String)

        public static var allCases: [FixedPosition] {
            return [
                .first,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .first: return "first"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FixedPosition(rawValue: rawValue) ?? FixedPosition.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.Form: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case cta
        case dataType
        case environmentName
        case fields
        case formActionType
        case id
        case name
        case schemaVersion
        case sectionalElements
        case style
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let cta = self.cta {
            try encodeContainer.encode(cta, forKey: .cta)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, fieldsMap0) in fields {
                try fieldsContainer.encode(fieldsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let formActionType = self.formActionType {
            try encodeContainer.encode(formActionType.rawValue, forKey: .formActionType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sectionalElements = sectionalElements {
            var sectionalElementsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sectionalElements)
            for (dictKey0, sectionalElementMap0) in sectionalElements {
                try sectionalElementsContainer.encode(sectionalElementMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formActionTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormActionType.self, forKey: .formActionType)
        formActionType = formActionTypeDecoded
        let styleDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyle.self, forKey: .style)
        style = styleDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataTypeConfig.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.FieldConfig?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]()
            for (key0, fieldconfig0) in fieldsContainer {
                if let fieldconfig0 = fieldconfig0 {
                    fieldsDecoded0?[key0] = fieldconfig0
                }
            }
        }
        fields = fieldsDecoded0
        let sectionalElementsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.SectionalElement?].self, forKey: .sectionalElements)
        var sectionalElementsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil
        if let sectionalElementsContainer = sectionalElementsContainer {
            sectionalElementsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]()
            for (key0, sectionalelement0) in sectionalElementsContainer {
                if let sectionalelement0 = sectionalelement0 {
                    sectionalElementsDecoded0?[key0] = sectionalelement0
                }
            }
        }
        sectionalElements = sectionalElementsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ctaDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormCTA.self, forKey: .cta)
        cta = ctaDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Contains the configuration settings for a Form user interface (UI) element for an Amplify app. A form is a component you can add to your project by specifying a data source as the default configuration for the form.
    public struct Form: Swift.Equatable {
        /// The unique ID of the Amplify app associated with the form.
        /// This member is required.
        public var appId: Swift.String?
        /// Stores the call to action configuration for the form.
        public var cta: AmplifyUIBuilderClientTypes.FormCTA?
        /// The type of data source to use to create the form.
        /// This member is required.
        public var dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// Stores the information about the form's fields.
        /// This member is required.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]?
        /// The operation to perform on the specified form.
        /// This member is required.
        public var formActionType: AmplifyUIBuilderClientTypes.FormActionType?
        /// The unique ID of the form.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the form.
        /// This member is required.
        public var name: Swift.String?
        /// The schema version of the form when it was imported.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// Stores the visual helper elements for the form that are not associated with any data.
        /// This member is required.
        public var sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]?
        /// Stores the configuration for the form's style.
        /// This member is required.
        public var style: AmplifyUIBuilderClientTypes.FormStyle?
        /// One or more key-value pairs to use when tagging the form.
        public var tags: [Swift.String:Swift.String]?

        public init (
            appId: Swift.String? = nil,
            cta: AmplifyUIBuilderClientTypes.FormCTA? = nil,
            dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig? = nil,
            environmentName: Swift.String? = nil,
            fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil,
            formActionType: AmplifyUIBuilderClientTypes.FormActionType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil,
            style: AmplifyUIBuilderClientTypes.FormStyle? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appId = appId
            self.cta = cta
            self.dataType = dataType
            self.environmentName = environmentName
            self.fields = fields
            self.formActionType = formActionType
            self.id = id
            self.name = name
            self.schemaVersion = schemaVersion
            self.sectionalElements = sectionalElements
            self.style = style
            self.tags = tags
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum FormActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [FormActionType] {
            return [
                .create,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "create"
            case .update: return "update"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormActionType(rawValue: rawValue) ?? FormActionType.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.FormBindingElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case element
        case property
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let element = self.element {
            try encodeContainer.encode(element, forKey: .element)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .element)
        element = elementDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes how to bind a component property to form data.
    public struct FormBindingElement: Swift.Equatable {
        /// The name of the component to retrieve a value from.
        /// This member is required.
        public var element: Swift.String?
        /// The property to retrieve a value from.
        /// This member is required.
        public var property: Swift.String?

        public init (
            element: Swift.String? = nil,
            property: Swift.String? = nil
        )
        {
            self.element = element
            self.property = property
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormButton: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children
        case excluded
        case position
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = self.children {
            try encodeContainer.encode(children, forKey: .children)
        }
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
        let childrenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .children)
        children = childrenDecoded
        let positionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FieldPosition.self, forKey: .position)
        position = positionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for a button UI element that is a part of a form.
    public struct FormButton: Swift.Equatable {
        /// Describes the button's properties.
        public var children: Swift.String?
        /// Specifies whether the button is visible on the form.
        public var excluded: Swift.Bool?
        /// The position of the button.
        public var position: AmplifyUIBuilderClientTypes.FieldPosition?

        public init (
            children: Swift.String? = nil,
            excluded: Swift.Bool? = nil,
            position: AmplifyUIBuilderClientTypes.FieldPosition? = nil
        )
        {
            self.children = children
            self.excluded = excluded
            self.position = position
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum FormButtonsPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottom
        case top
        case topAndBottom
        case sdkUnknown(Swift.String)

        public static var allCases: [FormButtonsPosition] {
            return [
                .bottom,
                .top,
                .topAndBottom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottom: return "bottom"
            case .top: return "top"
            case .topAndBottom: return "top_and_bottom"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormButtonsPosition(rawValue: rawValue) ?? FormButtonsPosition.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.FormCTA: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancel
        case clear
        case position
        case submit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cancel = self.cancel {
            try encodeContainer.encode(cancel, forKey: .cancel)
        }
        if let clear = self.clear {
            try encodeContainer.encode(clear, forKey: .clear)
        }
        if let position = self.position {
            try encodeContainer.encode(position.rawValue, forKey: .position)
        }
        if let submit = self.submit {
            try encodeContainer.encode(submit, forKey: .submit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormButtonsPosition.self, forKey: .position)
        position = positionDecoded
        let clearDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormButton.self, forKey: .clear)
        clear = clearDecoded
        let cancelDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormButton.self, forKey: .cancel)
        cancel = cancelDecoded
        let submitDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormButton.self, forKey: .submit)
        submit = submitDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the call to action button configuration for the form.
    public struct FormCTA: Swift.Equatable {
        /// Displays a cancel button.
        public var cancel: AmplifyUIBuilderClientTypes.FormButton?
        /// Displays a clear button.
        public var clear: AmplifyUIBuilderClientTypes.FormButton?
        /// The position of the button.
        public var position: AmplifyUIBuilderClientTypes.FormButtonsPosition?
        /// Displays a submit button.
        public var submit: AmplifyUIBuilderClientTypes.FormButton?

        public init (
            cancel: AmplifyUIBuilderClientTypes.FormButton? = nil,
            clear: AmplifyUIBuilderClientTypes.FormButton? = nil,
            position: AmplifyUIBuilderClientTypes.FormButtonsPosition? = nil,
            submit: AmplifyUIBuilderClientTypes.FormButton? = nil
        )
        {
            self.cancel = cancel
            self.clear = clear
            self.position = position
            self.submit = submit
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum FormDataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Will use passed in hooks to use when creating a form from scratch
        case custom
        /// Will use a provided Amplify DataStore enabled API
        case datastore
        case sdkUnknown(Swift.String)

        public static var allCases: [FormDataSourceType] {
            return [
                .custom,
                .datastore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .datastore: return "DataStore"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormDataSourceType(rawValue: rawValue) ?? FormDataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.FormDataTypeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceType
        case dataTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceType = self.dataSourceType {
            try encodeContainer.encode(dataSourceType.rawValue, forKey: .dataSourceType)
        }
        if let dataTypeName = self.dataTypeName {
            try encodeContainer.encode(dataTypeName, forKey: .dataTypeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataSourceType.self, forKey: .dataSourceType)
        dataSourceType = dataSourceTypeDecoded
        let dataTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeName)
        dataTypeName = dataTypeNameDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the data type configuration for the data source associated with a form.
    public struct FormDataTypeConfig: Swift.Equatable {
        /// The data source type, either an Amplify DataStore model or a custom data type.
        /// This member is required.
        public var dataSourceType: AmplifyUIBuilderClientTypes.FormDataSourceType?
        /// The unique name of the data type you are using as the data source for the form.
        /// This member is required.
        public var dataTypeName: Swift.String?

        public init (
            dataSourceType: AmplifyUIBuilderClientTypes.FormDataSourceType? = nil,
            dataTypeName: Swift.String? = nil
        )
        {
            self.dataSourceType = dataSourceType
            self.dataTypeName = dataTypeName
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormInputValueProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for an input field on a form. Use FormInputValueProperty to specify the values to render or bind by default.
    public struct FormInputValueProperty: Swift.Equatable {
        /// The value to assign to the input field.
        public var value: Swift.String?

        public init (
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case horizontalGap
        case outerPadding
        case verticalGap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let horizontalGap = self.horizontalGap {
            try encodeContainer.encode(horizontalGap, forKey: .horizontalGap)
        }
        if let outerPadding = self.outerPadding {
            try encodeContainer.encode(outerPadding, forKey: .outerPadding)
        }
        if let verticalGap = self.verticalGap {
            try encodeContainer.encode(verticalGap, forKey: .verticalGap)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let horizontalGapDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyleConfig.self, forKey: .horizontalGap)
        horizontalGap = horizontalGapDecoded
        let verticalGapDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyleConfig.self, forKey: .verticalGap)
        verticalGap = verticalGapDecoded
        let outerPaddingDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyleConfig.self, forKey: .outerPadding)
        outerPadding = outerPaddingDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for the form's style.
    public struct FormStyle: Swift.Equatable {
        /// The spacing for the horizontal gap.
        public var horizontalGap: AmplifyUIBuilderClientTypes.FormStyleConfig?
        /// The size of the outer padding for the form.
        public var outerPadding: AmplifyUIBuilderClientTypes.FormStyleConfig?
        /// The spacing for the vertical gap.
        public var verticalGap: AmplifyUIBuilderClientTypes.FormStyleConfig?

        public init (
            horizontalGap: AmplifyUIBuilderClientTypes.FormStyleConfig? = nil,
            outerPadding: AmplifyUIBuilderClientTypes.FormStyleConfig? = nil,
            verticalGap: AmplifyUIBuilderClientTypes.FormStyleConfig? = nil
        )
        {
            self.horizontalGap = horizontalGap
            self.outerPadding = outerPadding
            self.verticalGap = verticalGap
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormStyleConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case tokenreference = "tokenReference"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .tokenreference(tokenreference):
                try container.encode(tokenreference, forKey: .tokenreference)
            case let .value(value):
                try container.encode(value, forKey: .value)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tokenreferenceDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .tokenreference)
        if let tokenreference = tokenreferenceDecoded {
            self = .tokenreference(tokenreference)
            return
        }
        let valueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .value)
        if let value = valueDecoded {
            self = .value(value)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration settings for the form's style properties.
    public enum FormStyleConfig: Swift.Equatable, Swift.Hashable {
        /// A reference to a design token to use to bind the form's style properties to an existing theme.
        case tokenreference(Swift.String)
        /// The value of the style setting.
        case value(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AmplifyUIBuilderClientTypes.FormSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case dataType
        case environmentName
        case formActionType
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let formActionType = self.formActionType {
            try encodeContainer.encode(formActionType.rawValue, forKey: .formActionType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataTypeConfig.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let formActionTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormActionType.self, forKey: .formActionType)
        formActionType = formActionTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the basic information about a form.
    public struct FormSummary: Swift.Equatable {
        /// The unique ID for the app associated with the form summary.
        /// This member is required.
        public var appId: Swift.String?
        /// The form's data source type.
        /// This member is required.
        public var dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig?
        /// The name of the backend environment that is part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The type of operation to perform on the form.
        /// This member is required.
        public var formActionType: AmplifyUIBuilderClientTypes.FormActionType?
        /// The ID of the form.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the form.
        /// This member is required.
        public var name: Swift.String?

        public init (
            appId: Swift.String? = nil,
            dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig? = nil,
            environmentName: Swift.String? = nil,
            formActionType: AmplifyUIBuilderClientTypes.FormActionType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appId = appId
            self.dataType = dataType
            self.environmentName = environmentName
            self.formActionType = formActionType
            self.id = id
            self.name = name
        }
    }

}

extension GetComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components/\(id.urlPercentEncoding())"
    }
}

public struct GetComponentInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the component.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct GetComponentInputBody: Swift.Equatable {
}

extension GetComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AmplifyUIBuilderClientTypes.Component = try responseDecoder.decode(responseBody: data)
                self.component = output
            } else {
                self.component = nil
            }
        } else {
            self.component = nil
        }
    }
}

public struct GetComponentOutputResponse: Swift.Equatable {
    /// Represents the configuration settings for the component.
    public var component: AmplifyUIBuilderClientTypes.Component?

    public init (
        component: AmplifyUIBuilderClientTypes.Component? = nil
    )
    {
        self.component = component
    }
}

struct GetComponentOutputResponseBody: Swift.Equatable {
    let component: AmplifyUIBuilderClientTypes.Component?
}

extension GetComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

extension GetFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms/\(id.urlPercentEncoding())"
    }
}

public struct GetFormInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the form.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct GetFormInputBody: Swift.Equatable {
}

extension GetFormInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFormOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFormOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFormOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFormOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AmplifyUIBuilderClientTypes.Form = try responseDecoder.decode(responseBody: data)
                self.form = output
            } else {
                self.form = nil
            }
        } else {
            self.form = nil
        }
    }
}

public struct GetFormOutputResponse: Swift.Equatable {
    /// Represents the configuration settings for the form.
    public var form: AmplifyUIBuilderClientTypes.Form?

    public init (
        form: AmplifyUIBuilderClientTypes.Form? = nil
    )
    {
        self.form = form
    }
}

struct GetFormOutputResponseBody: Swift.Equatable {
    let form: AmplifyUIBuilderClientTypes.Form?
}

extension GetFormOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case form
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Form.self, forKey: .form)
        form = formDecoded
    }
}

extension GetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/metadata"
    }
}

public struct GetMetadataInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

struct GetMetadataInputBody: Swift.Equatable {
}

extension GetMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMetadataOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.features = output.features
        } else {
            self.features = nil
        }
    }
}

public struct GetMetadataOutputResponse: Swift.Equatable {
    /// Represents the configuration settings for the features metadata.
    /// This member is required.
    public var features: [Swift.String:Swift.String]?

    public init (
        features: [Swift.String:Swift.String]? = nil
    )
    {
        self.features = features
    }
}

struct GetMetadataOutputResponseBody: Swift.Equatable {
    let features: [Swift.String:Swift.String]?
}

extension GetMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case features
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featuresContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .features)
        var featuresDecoded0: [Swift.String:Swift.String]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?[key0] = string0
                }
            }
        }
        features = featuresDecoded0
    }
}

extension GetThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes/\(id.urlPercentEncoding())"
    }
}

public struct GetThemeInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the theme.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct GetThemeInputBody: Swift.Equatable {
}

extension GetThemeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetThemeOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AmplifyUIBuilderClientTypes.Theme = try responseDecoder.decode(responseBody: data)
                self.theme = output
            } else {
                self.theme = nil
            }
        } else {
            self.theme = nil
        }
    }
}

public struct GetThemeOutputResponse: Swift.Equatable {
    /// Represents the configuration settings for the theme.
    public var theme: AmplifyUIBuilderClientTypes.Theme?

    public init (
        theme: AmplifyUIBuilderClientTypes.Theme? = nil
    )
    {
        self.theme = theme
    }
}

struct GetThemeOutputResponseBody: Swift.Equatable {
    let theme: AmplifyUIBuilderClientTypes.Theme?
}

extension GetThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case theme
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Theme.self, forKey: .theme)
        theme = themeDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error has occurred. Please retry your request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid or out-of-range value was supplied for the input parameter.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListComponentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The maximum number of components to retrieve.
    public var maxResults: Swift.Int
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentsInputBody: Swift.Equatable {
}

extension ListComponentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListComponentsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutputResponse: Swift.Equatable {
    /// The list of components for the Amplify app.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.ComponentSummary]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        entities: [AmplifyUIBuilderClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.ComponentSummary]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentSummary?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.ComponentSummary]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.ComponentSummary]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFormsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFormsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms"
    }
}

public struct ListFormsInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The maximum number of forms to retrieve.
    public var maxResults: Swift.Int
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFormsInputBody: Swift.Equatable {
}

extension ListFormsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFormsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFormsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFormsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFormsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFormsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ListFormsOutputResponse: Swift.Equatable {
    /// The list of forms for the Amplify app.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.FormSummary]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        entities: [AmplifyUIBuilderClientTypes.FormSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ListFormsOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.FormSummary]?
    let nextToken: Swift.String?
}

extension ListFormsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.FormSummary?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.FormSummary]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.FormSummary]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThemesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThemesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes"
    }
}

public struct ListThemesInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The maximum number of theme results to return in the response.
    public var maxResults: Swift.Int
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThemesInputBody: Swift.Equatable {
}

extension ListThemesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThemesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListThemesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListThemesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ListThemesOutputResponse: Swift.Equatable {
    /// The list of themes for the Amplify app.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.ThemeSummary]?
    /// The pagination token that's returned if more results are available.
    public var nextToken: Swift.String?

    public init (
        entities: [AmplifyUIBuilderClientTypes.ThemeSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ListThemesOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.ThemeSummary]?
    let nextToken: Swift.String?
}

extension ListThemesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeSummary?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.ThemeSummary]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeSummary]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AmplifyUIBuilderClientTypes.MutationActionSetStateParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case property
        case `set` = "set"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
        if let `set` = self.`set` {
            try encodeContainer.encode(`set`, forKey: .`set`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
        let setDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .set)
        `set` = setDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the state configuration when an action modifies a property of another element within the same component.
    public struct MutationActionSetStateParameter: Swift.Equatable {
        /// The name of the component that is being modified.
        /// This member is required.
        public var componentName: Swift.String?
        /// The name of the component property to apply the state configuration to.
        /// This member is required.
        public var property: Swift.String?
        /// The state configuration to assign to the property.
        /// This member is required.
        public var `set`: AmplifyUIBuilderClientTypes.ComponentProperty?

        public init (
            componentName: Swift.String? = nil,
            property: Swift.String? = nil,
            `set`: AmplifyUIBuilderClientTypes.ComponentProperty? = nil
        )
        {
            self.componentName = componentName
            self.property = property
            self.`set` = `set`
        }
    }

}

extension AmplifyUIBuilderClientTypes.Predicate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and
        case field
        case operand
        case `operator` = "operator"
        case or
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for predicate0 in and {
                try andContainer.encode(predicate0)
            }
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let operand = self.operand {
            try encodeContainer.encode(operand, forKey: .operand)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
        if let or = or {
            var orContainer = encodeContainer.nestedUnkeyedContainer(forKey: .or)
            for predicate0 in or {
                try orContainer.encode(predicate0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Predicate?].self, forKey: .or)
        var orDecoded0:[AmplifyUIBuilderClientTypes.Predicate]? = nil
        if let orContainer = orContainer {
            orDecoded0 = [AmplifyUIBuilderClientTypes.Predicate]()
            for structure0 in orContainer {
                if let structure0 = structure0 {
                    orDecoded0?.append(structure0)
                }
            }
        }
        or = orDecoded0
        let andContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Predicate?].self, forKey: .and)
        var andDecoded0:[AmplifyUIBuilderClientTypes.Predicate]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [AmplifyUIBuilderClientTypes.Predicate]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operator)
        `operator` = operatorDecoded
        let operandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operand)
        operand = operandDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Stores information for generating Amplify DataStore queries. Use a Predicate to retrieve a subset of the data in a collection.
    public struct Predicate: Swift.Equatable {
        /// A list of predicates to combine logically.
        public var and: [AmplifyUIBuilderClientTypes.Predicate]?
        /// The field to query.
        public var field: Swift.String?
        /// The value to use when performing the evaluation.
        public var operand: Swift.String?
        /// The operator to use to perform the evaluation.
        public var `operator`: Swift.String?
        /// A list of predicates to combine logically.
        public var or: [AmplifyUIBuilderClientTypes.Predicate]?

        public init (
            and: [AmplifyUIBuilderClientTypes.Predicate]? = nil,
            field: Swift.String? = nil,
            operand: Swift.String? = nil,
            `operator`: Swift.String? = nil,
            or: [AmplifyUIBuilderClientTypes.Predicate]? = nil
        )
        {
            self.and = and
            self.field = field
            self.operand = operand
            self.`operator` = `operator`
            self.or = or
        }
    }

}

extension AmplifyUIBuilderClientTypes.PutMetadataFlagBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newValue = self.newValue {
            try encodeContainer.encode(newValue, forKey: .newValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let newValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newValue)
        newValue = newValueDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Stores the metadata information about a feature on a form or view.
    public struct PutMetadataFlagBody: Swift.Equatable {
        /// The new information to store.
        /// This member is required.
        public var newValue: Swift.String?

        public init (
            newValue: Swift.String? = nil
        )
        {
            self.newValue = newValue
        }
    }

}

public struct PutMetadataFlagInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMetadataFlagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMetadataFlagInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutMetadataFlagOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let body = input.operationInput.body {
                let bodydata = try encoder.encode(body)
                let bodybody = ClientRuntime.HttpBody.data(bodydata)
                input.builder.withBody(bodybody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let bodydata = "{}".data(using: .utf8)!
                    let bodybody = ClientRuntime.HttpBody.data(bodydata)
                    input.builder.withBody(bodybody)
                }
            }
        } catch let err {
            throw SdkError<PutMetadataFlagOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMetadataFlagInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMetadataFlagOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutMetadataFlagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

extension PutMetadataFlagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let featureName = featureName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/metadata/features/\(featureName.urlPercentEncoding())"
    }
}

public struct PutMetadataFlagInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The metadata information to store.
    /// This member is required.
    public var body: AmplifyUIBuilderClientTypes.PutMetadataFlagBody?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The name of the feature associated with the metadata.
    /// This member is required.
    public var featureName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        body: AmplifyUIBuilderClientTypes.PutMetadataFlagBody? = nil,
        environmentName: Swift.String? = nil,
        featureName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.body = body
        self.environmentName = environmentName
        self.featureName = featureName
    }
}

struct PutMetadataFlagInputBody: Swift.Equatable {
    let body: AmplifyUIBuilderClientTypes.PutMetadataFlagBody?
}

extension PutMetadataFlagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.PutMetadataFlagBody.self, forKey: .body)
        body = bodyDecoded
    }
}

extension PutMetadataFlagOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMetadataFlagOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutMetadataFlagOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMetadataFlagOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutMetadataFlagOutputResponse: Swift.Equatable {

    public init () { }
}

public struct RefreshTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshTokenInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<RefreshTokenOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let refreshTokenBody = input.operationInput.refreshTokenBody {
                let refreshTokenBodydata = try encoder.encode(refreshTokenBody)
                let refreshTokenBodybody = ClientRuntime.HttpBody.data(refreshTokenBodydata)
                input.builder.withBody(refreshTokenBodybody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let refreshTokenBodydata = "{}".data(using: .utf8)!
                    let refreshTokenBodybody = ClientRuntime.HttpBody.data(refreshTokenBodydata)
                    input.builder.withBody(refreshTokenBodybody)
                }
            }
        } catch let err {
            throw SdkError<RefreshTokenOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension RefreshTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshTokenBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let refreshTokenBody = self.refreshTokenBody {
            try encodeContainer.encode(refreshTokenBody, forKey: .refreshTokenBody)
        }
    }
}

extension RefreshTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let provider = provider else {
            return nil
        }
        return "/tokens/\(provider.rawValue.urlPercentEncoding())/refresh"
    }
}

public struct RefreshTokenInput: Swift.Equatable {
    /// The third-party provider for the token. The only valid value is figma.
    /// This member is required.
    public var provider: AmplifyUIBuilderClientTypes.TokenProviders?
    /// Information about the refresh token request.
    /// This member is required.
    public var refreshTokenBody: AmplifyUIBuilderClientTypes.RefreshTokenRequestBody?

    public init (
        provider: AmplifyUIBuilderClientTypes.TokenProviders? = nil,
        refreshTokenBody: AmplifyUIBuilderClientTypes.RefreshTokenRequestBody? = nil
    )
    {
        self.provider = provider
        self.refreshTokenBody = refreshTokenBody
    }
}

struct RefreshTokenInputBody: Swift.Equatable {
    let refreshTokenBody: AmplifyUIBuilderClientTypes.RefreshTokenRequestBody?
}

extension RefreshTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshTokenBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshTokenBodyDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.RefreshTokenRequestBody.self, forKey: .refreshTokenBody)
        refreshTokenBody = refreshTokenBodyDecoded
    }
}

extension RefreshTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RefreshTokenOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTokenOutputResponse(expiresIn: \(Swift.String(describing: expiresIn)), accessToken: \"CONTENT_REDACTED\")"}
}

extension RefreshTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RefreshTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
        } else {
            self.accessToken = nil
            self.expiresIn = nil
        }
    }
}

public struct RefreshTokenOutputResponse: Swift.Equatable {
    /// The access token.
    /// This member is required.
    public var accessToken: Swift.String?
    /// The date and time when the new access token expires.
    /// This member is required.
    public var expiresIn: Swift.Int?

    public init (
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
    }
}

struct RefreshTokenOutputResponseBody: Swift.Equatable {
    let accessToken: Swift.String?
    let expiresIn: Swift.Int?
}

extension RefreshTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
    }
}

extension AmplifyUIBuilderClientTypes.RefreshTokenRequestBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension AmplifyUIBuilderClientTypes.RefreshTokenRequestBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTokenRequestBody(token: \"CONTENT_REDACTED\")"}
}

extension AmplifyUIBuilderClientTypes {
    /// Describes a refresh token.
    public struct RefreshTokenRequestBody: Swift.Equatable {
        /// The token to use to refresh a previously issued access token that might have expired.
        /// This member is required.
        public var token: Swift.String?

        public init (
            token: Swift.String? = nil
        )
        {
            self.token = token
        }
    }

}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request conflicts with an existing resource.
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist, or access was denied.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyUIBuilderClientTypes.SectionalElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case level
        case orientation
        case position
        case text
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let level = self.level {
            try encodeContainer.encode(level, forKey: .level)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation, forKey: .orientation)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let positionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FieldPosition.self, forKey: .position)
        position = positionDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let levelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .level)
        level = levelDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orientation)
        orientation = orientationDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Stores the configuration information for a visual helper element for a form. A sectional element can be a header, a text block, or a divider. These elements are static and not associated with any data.
    public struct SectionalElement: Swift.Equatable {
        /// Specifies the size of the font for a Heading sectional element. Valid values are 1 | 2 | 3 | 4 | 5 | 6.
        public var level: Swift.Int?
        /// Specifies the orientation for a Divider sectional element. Valid values are horizontal or vertical.
        public var orientation: Swift.String?
        /// Specifies the position of the text in a field for a Text sectional element.
        public var position: AmplifyUIBuilderClientTypes.FieldPosition?
        /// The text for a Text sectional element.
        public var text: Swift.String?
        /// The type of sectional element. Valid values are Heading, Text, and Divider.
        /// This member is required.
        public var type: Swift.String?

        public init (
            level: Swift.Int? = nil,
            orientation: Swift.String? = nil,
            position: AmplifyUIBuilderClientTypes.FieldPosition? = nil,
            text: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.level = level
            self.orientation = orientation
            self.position = position
            self.text = text
            self.type = type
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your Amazon Web Services account.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    public enum SortDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortDirection] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortDirection(rawValue: rawValue) ?? SortDirection.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.SortProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case direction
        case field
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let direction = self.direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let directionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.SortDirection.self, forKey: .direction)
        direction = directionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes how to sort the data that you bind to a component.
    public struct SortProperty: Swift.Equatable {
        /// The direction of the sort, either ascending or descending.
        /// This member is required.
        public var direction: AmplifyUIBuilderClientTypes.SortDirection?
        /// The field to perform the sort on.
        /// This member is required.
        public var field: Swift.String?

        public init (
            direction: AmplifyUIBuilderClientTypes.SortDirection? = nil,
            field: Swift.String? = nil
        )
        {
            self.direction = direction
            self.field = field
        }
    }

}

extension AmplifyUIBuilderClientTypes.Theme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case createdAt
        case environmentName
        case id
        case modifiedAt
        case name
        case overrides
        case tags
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for themevalues0 in overrides {
                try overridesContainer.encode(themevalues0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for themevalues0 in values {
                try valuesContainer.encode(themevalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .overrides)
        var overridesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// A theme is a collection of style settings that apply globally to the components associated with an Amplify application.
    public struct Theme: Swift.Equatable {
        /// The unique ID for the Amplify app associated with the theme.
        /// This member is required.
        public var appId: Swift.String?
        /// The time that the theme was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID for the theme.
        /// This member is required.
        public var id: Swift.String?
        /// The time that the theme was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The name of the theme.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize a theme.
        public var overrides: [AmplifyUIBuilderClientTypes.ThemeValues]?
        /// One or more key-value pairs to use when tagging the theme.
        public var tags: [Swift.String:Swift.String]?
        /// A list of key-value pairs that defines the properties of the theme.
        /// This member is required.
        public var values: [AmplifyUIBuilderClientTypes.ThemeValues]?

        public init (
            appId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            overrides: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            values: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        )
        {
            self.appId = appId
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.overrides = overrides
            self.tags = tags
            self.values = values
        }
    }

}

extension AmplifyUIBuilderClientTypes.ThemeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case environmentName
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the basic information about a theme.
    public struct ThemeSummary: Swift.Equatable {
        /// The unique ID for the app associated with the theme summary.
        /// This member is required.
        public var appId: Swift.String?
        /// The name of the backend environment that is part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the theme.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the theme.
        /// This member is required.
        public var name: Swift.String?

        public init (
            appId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
            self.name = name
        }
    }

}

extension AmplifyUIBuilderClientTypes.ThemeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for themevalues0 in children {
                try childrenContainer.encode(themevalues0)
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration of a theme's properties.
    public struct ThemeValue: Swift.Equatable {
        /// A list of key-value pairs that define the theme's properties.
        public var children: [AmplifyUIBuilderClientTypes.ThemeValues]?
        /// The value of a theme property.
        public var value: Swift.String?

        public init (
            children: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil,
            value: Swift.String? = nil
        )
        {
            self.children = children
            self.value = value
        }
    }

}

extension AmplifyUIBuilderClientTypes.ThemeValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ThemeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// A key-value pair that defines a property of a theme.
    public struct ThemeValues: Swift.Equatable {
        /// The name of the property.
        public var key: Swift.String?
        /// The value of the property.
        public var value: AmplifyUIBuilderClientTypes.ThemeValue?

        public init (
            key: Swift.String? = nil,
            value: AmplifyUIBuilderClientTypes.ThemeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum TokenProviders: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The figma token provider.
        case figma
        case sdkUnknown(Swift.String)

        public static var allCases: [TokenProviders] {
            return [
                .figma,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .figma: return "figma"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TokenProviders(rawValue: rawValue) ?? TokenProviders.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have permission to perform this operation.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyUIBuilderClientTypes.UpdateComponentData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case children
        case collectionProperties
        case componentType
        case events
        case id
        case name
        case overrides
        case properties
        case schemaVersion
        case sourceId
        case variants
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, componentBindingProperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(componentBindingProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchild0 in children {
                try childrenContainer.encode(componentchild0)
            }
        }
        if let collectionProperties = collectionProperties {
            var collectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .collectionProperties)
            for (dictKey0, componentCollectionProperties0) in collectionProperties {
                try collectionPropertiesContainer.encode(componentCollectionProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, componentEvents0) in events {
                try eventsContainer.encode(componentEvents0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentOverrides0) in overrides {
                var componentOverrides0Container = overridesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, componentOverridesValue1) in componentOverrides0 {
                    try componentOverrides0Container.encode(componentOverridesValue1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentProperties0) in properties {
                try propertiesContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let variants = variants {
            var variantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variants)
            for componentvariant0 in variants {
                try variantsContainer.encode(componentvariant0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let variantsContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentVariant?].self, forKey: .variants)
        var variantsDecoded0:[AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        if let variantsContainer = variantsContainer {
            variantsDecoded0 = [AmplifyUIBuilderClientTypes.ComponentVariant]()
            for structure0 in variantsContainer {
                if let structure0 = structure0 {
                    variantsDecoded0?.append(structure0)
                }
            }
        }
        variants = variantsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]()
            for (key0, componentbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let componentbindingpropertiesvalue0 = componentbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = componentbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
        let collectionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentDataConfiguration?].self, forKey: .collectionProperties)
        var collectionPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil
        if let collectionPropertiesContainer = collectionPropertiesContainer {
            collectionPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]()
            for (key0, componentdataconfiguration0) in collectionPropertiesContainer {
                if let componentdataconfiguration0 = componentdataconfiguration0 {
                    collectionPropertiesDecoded0?[key0] = componentdataconfiguration0
                }
            }
        }
        collectionProperties = collectionPropertiesDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentEvent?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]()
            for (key0, componentevent0) in eventsContainer {
                if let componentevent0 = componentevent0 {
                    eventsDecoded0?[key0] = componentevent0
                }
            }
        }
        events = eventsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Updates and saves all of the information about a component, based on component ID.
    public struct UpdateComponentData: Swift.Equatable {
        /// The data binding information for the component's properties.
        public var bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]?
        /// The components that are instances of the main component.
        public var children: [AmplifyUIBuilderClientTypes.ComponentChild]?
        /// The configuration for binding a component's properties to a data model. Use this for a collection component.
        public var collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]?
        /// The type of the component. This can be an Amplify custom UI component or another custom component.
        public var componentType: Swift.String?
        /// The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public var events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]?
        /// The unique ID of the component to update.
        public var id: Swift.String?
        /// The name of the component to update.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize the component.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// Describes the component's properties.
        public var properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The schema version of the component when it was imported.
        public var schemaVersion: Swift.String?
        /// The unique ID of the component in its original source system, such as Figma.
        public var sourceId: Swift.String?
        /// A list of the unique variants of the main component being updated.
        public var variants: [AmplifyUIBuilderClientTypes.ComponentVariant]?

        public init (
            bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil,
            children: [AmplifyUIBuilderClientTypes.ComponentChild]? = nil,
            collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil,
            componentType: Swift.String? = nil,
            events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            schemaVersion: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            variants: [AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.events = events
            self.id = id
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.schemaVersion = schemaVersion
            self.sourceId = sourceId
            self.variants = variants
        }
    }

}

public struct UpdateComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateComponentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateComponentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let updatedComponent = input.operationInput.updatedComponent {
                let updatedComponentdata = try encoder.encode(updatedComponent)
                let updatedComponentbody = ClientRuntime.HttpBody.data(updatedComponentdata)
                input.builder.withBody(updatedComponentbody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let updatedComponentdata = "{}".data(using: .utf8)!
                    let updatedComponentbody = ClientRuntime.HttpBody.data(updatedComponentdata)
                    input.builder.withBody(updatedComponentbody)
                }
            }
        } catch let err {
            throw SdkError<UpdateComponentOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedComponent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatedComponent = self.updatedComponent {
            try encodeContainer.encode(updatedComponent, forKey: .updatedComponent)
        }
    }
}

extension UpdateComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components/\(id.urlPercentEncoding())"
    }
}

public struct UpdateComponentInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the component.
    /// This member is required.
    public var id: Swift.String?
    /// The configuration of the updated component.
    /// This member is required.
    public var updatedComponent: AmplifyUIBuilderClientTypes.UpdateComponentData?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil,
        updatedComponent: AmplifyUIBuilderClientTypes.UpdateComponentData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.id = id
        self.updatedComponent = updatedComponent
    }
}

struct UpdateComponentInputBody: Swift.Equatable {
    let updatedComponent: AmplifyUIBuilderClientTypes.UpdateComponentData?
}

extension UpdateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedComponent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatedComponentDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.UpdateComponentData.self, forKey: .updatedComponent)
        updatedComponent = updatedComponentDecoded
    }
}

extension UpdateComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AmplifyUIBuilderClientTypes.Component = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct UpdateComponentOutputResponse: Swift.Equatable {
    /// Describes the configuration of the updated component.
    public var entity: AmplifyUIBuilderClientTypes.Component?

    public init (
        entity: AmplifyUIBuilderClientTypes.Component? = nil
    )
    {
        self.entity = entity
    }
}

struct UpdateComponentOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Component?
}

extension UpdateComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Component.self, forKey: .entity)
        entity = entityDecoded
    }
}

extension AmplifyUIBuilderClientTypes.UpdateFormData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cta
        case dataType
        case fields
        case formActionType
        case name
        case schemaVersion
        case sectionalElements
        case style
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cta = self.cta {
            try encodeContainer.encode(cta, forKey: .cta)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, fieldsMap0) in fields {
                try fieldsContainer.encode(fieldsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let formActionType = self.formActionType {
            try encodeContainer.encode(formActionType.rawValue, forKey: .formActionType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sectionalElements = sectionalElements {
            var sectionalElementsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sectionalElements)
            for (dictKey0, sectionalElementMap0) in sectionalElements {
                try sectionalElementsContainer.encode(sectionalElementMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataTypeConfig.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let formActionTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormActionType.self, forKey: .formActionType)
        formActionType = formActionTypeDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.FieldConfig?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]()
            for (key0, fieldconfig0) in fieldsContainer {
                if let fieldconfig0 = fieldconfig0 {
                    fieldsDecoded0?[key0] = fieldconfig0
                }
            }
        }
        fields = fieldsDecoded0
        let styleDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyle.self, forKey: .style)
        style = styleDecoded
        let sectionalElementsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.SectionalElement?].self, forKey: .sectionalElements)
        var sectionalElementsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil
        if let sectionalElementsContainer = sectionalElementsContainer {
            sectionalElementsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]()
            for (key0, sectionalelement0) in sectionalElementsContainer {
                if let sectionalelement0 = sectionalelement0 {
                    sectionalElementsDecoded0?[key0] = sectionalelement0
                }
            }
        }
        sectionalElements = sectionalElementsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let ctaDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormCTA.self, forKey: .cta)
        cta = ctaDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Updates and saves all of the information about a form, based on form ID.
    public struct UpdateFormData: Swift.Equatable {
        /// The FormCTA object that stores the call to action configuration for the form.
        public var cta: AmplifyUIBuilderClientTypes.FormCTA?
        /// The type of data source to use to create the form.
        public var dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig?
        /// The configuration information for the form's fields.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]?
        /// Specifies whether to perform a create or update action on the form.
        public var formActionType: AmplifyUIBuilderClientTypes.FormActionType?
        /// The name of the form.
        public var name: Swift.String?
        /// The schema version of the form.
        public var schemaVersion: Swift.String?
        /// The configuration information for the visual helper elements for the form. These elements are not associated with any data.
        public var sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]?
        /// The configuration for the form's style.
        public var style: AmplifyUIBuilderClientTypes.FormStyle?

        public init (
            cta: AmplifyUIBuilderClientTypes.FormCTA? = nil,
            dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig? = nil,
            fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil,
            formActionType: AmplifyUIBuilderClientTypes.FormActionType? = nil,
            name: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil,
            style: AmplifyUIBuilderClientTypes.FormStyle? = nil
        )
        {
            self.cta = cta
            self.dataType = dataType
            self.fields = fields
            self.formActionType = formActionType
            self.name = name
            self.schemaVersion = schemaVersion
            self.sectionalElements = sectionalElements
            self.style = style
        }
    }

}

public struct UpdateFormInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFormInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFormInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateFormOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let updatedForm = input.operationInput.updatedForm {
                let updatedFormdata = try encoder.encode(updatedForm)
                let updatedFormbody = ClientRuntime.HttpBody.data(updatedFormdata)
                input.builder.withBody(updatedFormbody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let updatedFormdata = "{}".data(using: .utf8)!
                    let updatedFormbody = ClientRuntime.HttpBody.data(updatedFormdata)
                    input.builder.withBody(updatedFormbody)
                }
            }
        } catch let err {
            throw SdkError<UpdateFormOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFormInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFormOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateFormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedForm
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatedForm = self.updatedForm {
            try encodeContainer.encode(updatedForm, forKey: .updatedForm)
        }
    }
}

extension UpdateFormInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdateFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms/\(id.urlPercentEncoding())"
    }
}

public struct UpdateFormInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the form.
    /// This member is required.
    public var id: Swift.String?
    /// The request accepts the following data in JSON format.
    /// This member is required.
    public var updatedForm: AmplifyUIBuilderClientTypes.UpdateFormData?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil,
        updatedForm: AmplifyUIBuilderClientTypes.UpdateFormData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.id = id
        self.updatedForm = updatedForm
    }
}

struct UpdateFormInputBody: Swift.Equatable {
    let updatedForm: AmplifyUIBuilderClientTypes.UpdateFormData?
}

extension UpdateFormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedForm
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatedFormDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.UpdateFormData.self, forKey: .updatedForm)
        updatedForm = updatedFormDecoded
    }
}

extension UpdateFormOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFormOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFormOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFormOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AmplifyUIBuilderClientTypes.Form = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct UpdateFormOutputResponse: Swift.Equatable {
    /// Describes the configuration of the updated form.
    public var entity: AmplifyUIBuilderClientTypes.Form?

    public init (
        entity: AmplifyUIBuilderClientTypes.Form? = nil
    )
    {
        self.entity = entity
    }
}

struct UpdateFormOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Form?
}

extension UpdateFormOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Form.self, forKey: .entity)
        entity = entityDecoded
    }
}

extension AmplifyUIBuilderClientTypes.UpdateThemeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case overrides
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for themevalues0 in overrides {
                try overridesContainer.encode(themevalues0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for themevalues0 in values {
                try valuesContainer.encode(themevalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .overrides)
        var overridesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Saves the data binding information for a theme.
    public struct UpdateThemeData: Swift.Equatable {
        /// The unique ID of the theme to update.
        public var id: Swift.String?
        /// The name of the theme to update.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize the theme.
        public var overrides: [AmplifyUIBuilderClientTypes.ThemeValues]?
        /// A list of key-value pairs that define the theme's properties.
        /// This member is required.
        public var values: [AmplifyUIBuilderClientTypes.ThemeValues]?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            overrides: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil,
            values: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        )
        {
            self.id = id
            self.name = name
            self.overrides = overrides
            self.values = values
        }
    }

}

public struct UpdateThemeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateThemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateThemeInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateThemeOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let updatedTheme = input.operationInput.updatedTheme {
                let updatedThemedata = try encoder.encode(updatedTheme)
                let updatedThemebody = ClientRuntime.HttpBody.data(updatedThemedata)
                input.builder.withBody(updatedThemebody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let updatedThemedata = "{}".data(using: .utf8)!
                    let updatedThemebody = ClientRuntime.HttpBody.data(updatedThemedata)
                    input.builder.withBody(updatedThemebody)
                }
            }
        } catch let err {
            throw SdkError<UpdateThemeOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateThemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedTheme
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatedTheme = self.updatedTheme {
            try encodeContainer.encode(updatedTheme, forKey: .updatedTheme)
        }
    }
}

extension UpdateThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes/\(id.urlPercentEncoding())"
    }
}

public struct UpdateThemeInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the theme.
    /// This member is required.
    public var id: Swift.String?
    /// The configuration of the updated theme.
    /// This member is required.
    public var updatedTheme: AmplifyUIBuilderClientTypes.UpdateThemeData?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil,
        updatedTheme: AmplifyUIBuilderClientTypes.UpdateThemeData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.id = id
        self.updatedTheme = updatedTheme
    }
}

struct UpdateThemeInputBody: Swift.Equatable {
    let updatedTheme: AmplifyUIBuilderClientTypes.UpdateThemeData?
}

extension UpdateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedTheme
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatedThemeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.UpdateThemeData.self, forKey: .updatedTheme)
        updatedTheme = updatedThemeDecoded
    }
}

extension UpdateThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateThemeOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            if let responseDecoder = decoder {
                let output: AmplifyUIBuilderClientTypes.Theme = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct UpdateThemeOutputResponse: Swift.Equatable {
    /// Describes the configuration of the updated theme.
    public var entity: AmplifyUIBuilderClientTypes.Theme?

    public init (
        entity: AmplifyUIBuilderClientTypes.Theme? = nil
    )
    {
        self.entity = entity
    }
}

struct UpdateThemeOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Theme?
}

extension UpdateThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Theme.self, forKey: .entity)
        entity = entityDecoded
    }
}

extension AmplifyUIBuilderClientTypes.ValueMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayValue
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayValue = self.displayValue {
            try encodeContainer.encode(displayValue, forKey: .displayValue)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayValueDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormInputValueProperty.self, forKey: .displayValue)
        displayValue = displayValueDecoded
        let valueDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormInputValueProperty.self, forKey: .value)
        value = valueDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Associates a complex object with a display value. Use ValueMapping to store how to represent complex objects when they are displayed.
    public struct ValueMapping: Swift.Equatable {
        /// The value to display for the complex object.
        public var displayValue: AmplifyUIBuilderClientTypes.FormInputValueProperty?
        /// The complex object.
        /// This member is required.
        public var value: AmplifyUIBuilderClientTypes.FormInputValueProperty?

        public init (
            displayValue: AmplifyUIBuilderClientTypes.FormInputValueProperty? = nil,
            value: AmplifyUIBuilderClientTypes.FormInputValueProperty? = nil
        )
        {
            self.displayValue = displayValue
            self.value = value
        }
    }

}

extension AmplifyUIBuilderClientTypes.ValueMappings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valuemapping0 in values {
                try valuesContainer.encode(valuemapping0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ValueMapping?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUIBuilderClientTypes.ValueMapping]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUIBuilderClientTypes.ValueMapping]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the data binding configuration for a value map.
    public struct ValueMappings: Swift.Equatable {
        /// The value and display value pairs.
        /// This member is required.
        public var values: [AmplifyUIBuilderClientTypes.ValueMapping]?

        public init (
            values: [AmplifyUIBuilderClientTypes.ValueMapping]? = nil
        )
        {
            self.values = values
        }
    }

}
