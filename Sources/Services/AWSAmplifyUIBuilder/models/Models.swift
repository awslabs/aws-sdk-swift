// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AmplifyUIBuilderClientTypes.ActionParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anchor
        case fields
        case global
        case id
        case model
        case state
        case target
        case type
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anchor = self.anchor {
            try encodeContainer.encode(anchor, forKey: .anchor)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, componentProperties0) in fields {
                try fieldsContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let global = self.global {
            try encodeContainer.encode(global, forKey: .global)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .type)
        type = typeDecoded
        let urlDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .url)
        url = urlDecoded
        let anchorDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .anchor)
        anchor = anchorDecoded
        let targetDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .target)
        target = targetDecoded
        let globalDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .global)
        global = globalDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let idDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .id)
        id = idDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in fieldsContainer {
                if let componentproperty0 = componentproperty0 {
                    fieldsDecoded0?[key0] = componentproperty0
                }
            }
        }
        fields = fieldsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.MutationActionSetStateParameter.self, forKey: .state)
        state = stateDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the event action configuration for an element of a Component or ComponentChild. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components. ActionParameters defines the action that is performed when an event occurs on the component.
    public struct ActionParameters: Swift.Equatable {
        /// The HTML anchor link to the location to open. Specify this value for a navigation action.
        public var anchor: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// A dictionary of key-value pairs mapping Amplify Studio properties to fields in a data model. Use when the action performs an operation on an Amplify DataStore model.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// Specifies whether the user should be signed out globally. Specify this value for an auth sign out action.
        public var global: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// The unique ID of the component that the ActionParameters apply to.
        public var id: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// The name of the data model. Use when the action performs an operation on an Amplify DataStore model.
        public var model: Swift.String?
        /// A key-value pair that specifies the state property name and its initial value.
        public var state: AmplifyUIBuilderClientTypes.MutationActionSetStateParameter?
        /// The element within the same component to modify when the action occurs.
        public var target: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// The type of navigation action. Valid values are url and anchor. This value is required for a navigation action.
        public var type: AmplifyUIBuilderClientTypes.ComponentProperty?
        /// The URL to the location to open. Specify this value for a navigation action.
        public var url: AmplifyUIBuilderClientTypes.ComponentProperty?

        public init(
            anchor: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            fields: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            global: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            id: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            model: Swift.String? = nil,
            state: AmplifyUIBuilderClientTypes.MutationActionSetStateParameter? = nil,
            target: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            type: AmplifyUIBuilderClientTypes.ComponentProperty? = nil,
            url: AmplifyUIBuilderClientTypes.ComponentProperty? = nil
        )
        {
            self.anchor = anchor
            self.fields = fields
            self.global = global
            self.id = id
            self.model = model
            self.state = state
            self.target = target
            self.type = type
            self.url = url
        }
    }

}

extension AmplifyUIBuilderClientTypes.ApiConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datastoreconfig = "dataStoreConfig"
        case graphqlconfig = "graphQLConfig"
        case noapiconfig = "noApiConfig"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .datastoreconfig(datastoreconfig):
                try container.encode(datastoreconfig, forKey: .datastoreconfig)
            case let .graphqlconfig(graphqlconfig):
                try container.encode(graphqlconfig, forKey: .graphqlconfig)
            case let .noapiconfig(noapiconfig):
                try container.encode(noapiconfig, forKey: .noapiconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlconfigDecoded = try values.decodeIfPresent(AmplifyUIBuilderClientTypes.GraphQLRenderConfig.self, forKey: .graphqlconfig)
        if let graphqlconfig = graphqlconfigDecoded {
            self = .graphqlconfig(graphqlconfig)
            return
        }
        let datastoreconfigDecoded = try values.decodeIfPresent(AmplifyUIBuilderClientTypes.DataStoreRenderConfig.self, forKey: .datastoreconfig)
        if let datastoreconfig = datastoreconfigDecoded {
            self = .datastoreconfig(datastoreconfig)
            return
        }
        let noapiconfigDecoded = try values.decodeIfPresent(AmplifyUIBuilderClientTypes.NoApiRenderConfig.self, forKey: .noapiconfig)
        if let noapiconfig = noapiconfigDecoded {
            self = .noapiconfig(noapiconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the API configuration for a code generation job.
    public enum ApiConfiguration: Swift.Equatable {
        /// The configuration for an application using GraphQL APIs.
        case graphqlconfig(AmplifyUIBuilderClientTypes.GraphQLRenderConfig)
        /// The configuration for an application using DataStore APIs.
        case datastoreconfig(AmplifyUIBuilderClientTypes.DataStoreRenderConfig)
        /// The configuration for an application with no API being used.
        case noapiconfig(AmplifyUIBuilderClientTypes.NoApiRenderConfig)
        case sdkUnknown(Swift.String)
    }

}

extension AmplifyUIBuilderClientTypes.CodegenDependency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isSemVer
        case name
        case reason
        case supportedVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isSemVer = self.isSemVer {
            try encodeContainer.encode(isSemVer, forKey: .isSemVer)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let supportedVersion = self.supportedVersion {
            try encodeContainer.encode(supportedVersion, forKey: .supportedVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let supportedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportedVersion)
        supportedVersion = supportedVersionDecoded
        let isSemVerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSemVer)
        isSemVer = isSemVerDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Dependency package that may be required for the project code to run.
    public struct CodegenDependency: Swift.Equatable {
        /// Determines if the dependency package is using Semantic versioning. If set to true, it indicates that the dependency package uses Semantic versioning.
        public var isSemVer: Swift.Bool?
        /// Name of the dependency package.
        public var name: Swift.String?
        /// Indicates the reason to include the dependency package in your project code.
        public var reason: Swift.String?
        /// Indicates the version of the supported dependency package.
        public var supportedVersion: Swift.String?

        public init(
            isSemVer: Swift.Bool? = nil,
            name: Swift.String? = nil,
            reason: Swift.String? = nil,
            supportedVersion: Swift.String? = nil
        )
        {
            self.isSemVer = isSemVer
            self.name = name
            self.reason = reason
            self.supportedVersion = supportedVersion
        }
    }

}

extension AmplifyUIBuilderClientTypes.CodegenFeatureFlags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isNonModelSupported
        case isRelationshipSupported
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isNonModelSupported = self.isNonModelSupported {
            try encodeContainer.encode(isNonModelSupported, forKey: .isNonModelSupported)
        }
        if let isRelationshipSupported = self.isRelationshipSupported {
            try encodeContainer.encode(isRelationshipSupported, forKey: .isRelationshipSupported)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isRelationshipSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRelationshipSupported)
        isRelationshipSupported = isRelationshipSupportedDecoded
        let isNonModelSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isNonModelSupported)
        isNonModelSupported = isNonModelSupportedDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the feature flags that you can specify for a code generation job.
    public struct CodegenFeatureFlags: Swift.Equatable {
        /// Specifies whether a code generation job supports non models.
        public var isNonModelSupported: Swift.Bool?
        /// Specifes whether a code generation job supports data relationships.
        public var isRelationshipSupported: Swift.Bool?

        public init(
            isNonModelSupported: Swift.Bool? = nil,
            isRelationshipSupported: Swift.Bool? = nil
        )
        {
            self.isNonModelSupported = isNonModelSupported
            self.isRelationshipSupported = isRelationshipSupported
        }
    }

}

extension AmplifyUIBuilderClientTypes.CodegenGenericDataEnum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the enums in a generic data schema.
    public struct CodegenGenericDataEnum: Swift.Equatable {
        /// The list of enum values in the generic data schema.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            values: [Swift.String]? = nil
        )
        {
            self.values = values
        }
    }

}

extension AmplifyUIBuilderClientTypes.CodegenGenericDataField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case dataTypeValue
        case isArray
        case readOnly
        case relationship
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeValue = self.dataTypeValue {
            try encodeContainer.encode(dataTypeValue, forKey: .dataTypeValue)
        }
        if let isArray = self.isArray {
            try encodeContainer.encode(isArray, forKey: .isArray)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let relationship = self.relationship {
            try encodeContainer.encode(relationship, forKey: .relationship)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenGenericDataFieldDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeValue)
        dataTypeValue = dataTypeValueDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let isArrayDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArray)
        isArray = isArrayDecoded
        let relationshipDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenGenericDataRelationshipType.self, forKey: .relationship)
        relationship = relationshipDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes a field in a generic data schema.
    public struct CodegenGenericDataField: Swift.Equatable {
        /// The data type for the generic data field.
        /// This member is required.
        public var dataType: AmplifyUIBuilderClientTypes.CodegenGenericDataFieldDataType?
        /// The value of the data type for the generic data field.
        /// This member is required.
        public var dataTypeValue: Swift.String?
        /// Specifies whether the generic data field is an array.
        /// This member is required.
        public var isArray: Swift.Bool?
        /// Specifies whether the generic data field is read-only.
        /// This member is required.
        public var readOnly: Swift.Bool?
        /// The relationship of the generic data schema.
        public var relationship: AmplifyUIBuilderClientTypes.CodegenGenericDataRelationshipType?
        /// Specifies whether the generic data field is required.
        /// This member is required.
        public var `required`: Swift.Bool?

        public init(
            dataType: AmplifyUIBuilderClientTypes.CodegenGenericDataFieldDataType? = nil,
            dataTypeValue: Swift.String? = nil,
            isArray: Swift.Bool? = nil,
            readOnly: Swift.Bool? = nil,
            relationship: AmplifyUIBuilderClientTypes.CodegenGenericDataRelationshipType? = nil,
            `required`: Swift.Bool? = nil
        )
        {
            self.dataType = dataType
            self.dataTypeValue = dataTypeValue
            self.isArray = isArray
            self.readOnly = readOnly
            self.relationship = relationship
            self.`required` = `required`
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum CodegenGenericDataFieldDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsDate
        case awsDateTime
        case awsEmail
        case awsIpAddress
        case awsJson
        case awsPhone
        case awsTime
        case awsTimestamp
        case awsUrl
        case boolean
        case `enum`
        case float
        case id
        case int
        case model
        case nonModel
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [CodegenGenericDataFieldDataType] {
            return [
                .awsDate,
                .awsDateTime,
                .awsEmail,
                .awsIpAddress,
                .awsJson,
                .awsPhone,
                .awsTime,
                .awsTimestamp,
                .awsUrl,
                .boolean,
                .enum,
                .float,
                .id,
                .int,
                .model,
                .nonModel,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsDate: return "AWSDate"
            case .awsDateTime: return "AWSDateTime"
            case .awsEmail: return "AWSEmail"
            case .awsIpAddress: return "AWSIPAddress"
            case .awsJson: return "AWSJSON"
            case .awsPhone: return "AWSPhone"
            case .awsTime: return "AWSTime"
            case .awsTimestamp: return "AWSTimestamp"
            case .awsUrl: return "AWSURL"
            case .boolean: return "Boolean"
            case .enum: return "Enum"
            case .float: return "Float"
            case .id: return "ID"
            case .int: return "Int"
            case .model: return "Model"
            case .nonModel: return "NonModel"
            case .string: return "String"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodegenGenericDataFieldDataType(rawValue: rawValue) ?? CodegenGenericDataFieldDataType.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.CodegenGenericDataModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case isJoinTable
        case primaryKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, codegenGenericDataFields0) in fields {
                try fieldsContainer.encode(codegenGenericDataFields0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isJoinTable = self.isJoinTable {
            try encodeContainer.encode(isJoinTable, forKey: .isJoinTable)
        }
        if let primaryKeys = primaryKeys {
            var primaryKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .primaryKeys)
            for string0 in primaryKeys {
                try primaryKeysContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.CodegenGenericDataField?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataField]()
            for (key0, codegengenericdatafield0) in fieldsContainer {
                if let codegengenericdatafield0 = codegengenericdatafield0 {
                    fieldsDecoded0?[key0] = codegengenericdatafield0
                }
            }
        }
        fields = fieldsDecoded0
        let isJoinTableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isJoinTable)
        isJoinTable = isJoinTableDecoded
        let primaryKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .primaryKeys)
        var primaryKeysDecoded0:[Swift.String]? = nil
        if let primaryKeysContainer = primaryKeysContainer {
            primaryKeysDecoded0 = [Swift.String]()
            for string0 in primaryKeysContainer {
                if let string0 = string0 {
                    primaryKeysDecoded0?.append(string0)
                }
            }
        }
        primaryKeys = primaryKeysDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes a model in a generic data schema.
    public struct CodegenGenericDataModel: Swift.Equatable {
        /// The fields in the generic data model.
        /// This member is required.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataField]?
        /// Specifies whether the generic data model is a join table.
        public var isJoinTable: Swift.Bool?
        /// The primary keys of the generic data model.
        /// This member is required.
        public var primaryKeys: [Swift.String]?

        public init(
            fields: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataField]? = nil,
            isJoinTable: Swift.Bool? = nil,
            primaryKeys: [Swift.String]? = nil
        )
        {
            self.fields = fields
            self.isJoinTable = isJoinTable
            self.primaryKeys = primaryKeys
        }
    }

}

extension AmplifyUIBuilderClientTypes.CodegenGenericDataNonModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, codegenGenericDataNonModelFields0) in fields {
                try fieldsContainer.encode(codegenGenericDataNonModelFields0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.CodegenGenericDataField?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataField]()
            for (key0, codegengenericdatafield0) in fieldsContainer {
                if let codegengenericdatafield0 = codegengenericdatafield0 {
                    fieldsDecoded0?[key0] = codegengenericdatafield0
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes a non-model in a generic data schema.
    public struct CodegenGenericDataNonModel: Swift.Equatable {
        /// The fields in a generic data schema non model.
        /// This member is required.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataField]?

        public init(
            fields: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataField]? = nil
        )
        {
            self.fields = fields
        }
    }

}

extension AmplifyUIBuilderClientTypes.CodegenGenericDataRelationshipType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedFields
        case belongsToFieldOnRelatedModel
        case canUnlinkAssociatedModel
        case isHasManyIndex
        case relatedJoinFieldName
        case relatedJoinTableName
        case relatedModelFields
        case relatedModelName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedFields = associatedFields {
            var associatedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedFields)
            for string0 in associatedFields {
                try associatedFieldsContainer.encode(string0)
            }
        }
        if let belongsToFieldOnRelatedModel = self.belongsToFieldOnRelatedModel {
            try encodeContainer.encode(belongsToFieldOnRelatedModel, forKey: .belongsToFieldOnRelatedModel)
        }
        if let canUnlinkAssociatedModel = self.canUnlinkAssociatedModel {
            try encodeContainer.encode(canUnlinkAssociatedModel, forKey: .canUnlinkAssociatedModel)
        }
        if let isHasManyIndex = self.isHasManyIndex {
            try encodeContainer.encode(isHasManyIndex, forKey: .isHasManyIndex)
        }
        if let relatedJoinFieldName = self.relatedJoinFieldName {
            try encodeContainer.encode(relatedJoinFieldName, forKey: .relatedJoinFieldName)
        }
        if let relatedJoinTableName = self.relatedJoinTableName {
            try encodeContainer.encode(relatedJoinTableName, forKey: .relatedJoinTableName)
        }
        if let relatedModelFields = relatedModelFields {
            var relatedModelFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedModelFields)
            for string0 in relatedModelFields {
                try relatedModelFieldsContainer.encode(string0)
            }
        }
        if let relatedModelName = self.relatedModelName {
            try encodeContainer.encode(relatedModelName, forKey: .relatedModelName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.GenericDataRelationshipType.self, forKey: .type)
        type = typeDecoded
        let relatedModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedModelName)
        relatedModelName = relatedModelNameDecoded
        let relatedModelFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedModelFields)
        var relatedModelFieldsDecoded0:[Swift.String]? = nil
        if let relatedModelFieldsContainer = relatedModelFieldsContainer {
            relatedModelFieldsDecoded0 = [Swift.String]()
            for string0 in relatedModelFieldsContainer {
                if let string0 = string0 {
                    relatedModelFieldsDecoded0?.append(string0)
                }
            }
        }
        relatedModelFields = relatedModelFieldsDecoded0
        let canUnlinkAssociatedModelDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canUnlinkAssociatedModel)
        canUnlinkAssociatedModel = canUnlinkAssociatedModelDecoded
        let relatedJoinFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedJoinFieldName)
        relatedJoinFieldName = relatedJoinFieldNameDecoded
        let relatedJoinTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedJoinTableName)
        relatedJoinTableName = relatedJoinTableNameDecoded
        let belongsToFieldOnRelatedModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .belongsToFieldOnRelatedModel)
        belongsToFieldOnRelatedModel = belongsToFieldOnRelatedModelDecoded
        let associatedFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedFields)
        var associatedFieldsDecoded0:[Swift.String]? = nil
        if let associatedFieldsContainer = associatedFieldsContainer {
            associatedFieldsDecoded0 = [Swift.String]()
            for string0 in associatedFieldsContainer {
                if let string0 = string0 {
                    associatedFieldsDecoded0?.append(string0)
                }
            }
        }
        associatedFields = associatedFieldsDecoded0
        let isHasManyIndexDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isHasManyIndex)
        isHasManyIndex = isHasManyIndexDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the relationship between generic data models.
    public struct CodegenGenericDataRelationshipType: Swift.Equatable {
        /// The associated fields of the data relationship.
        public var associatedFields: [Swift.String]?
        /// The value of the belongsTo field on the related data model.
        public var belongsToFieldOnRelatedModel: Swift.String?
        /// Specifies whether the relationship can unlink the associated model.
        public var canUnlinkAssociatedModel: Swift.Bool?
        /// Specifies whether the @index directive is supported for a hasMany data relationship.
        public var isHasManyIndex: Swift.Bool?
        /// The name of the related join field in the data relationship.
        public var relatedJoinFieldName: Swift.String?
        /// The name of the related join table in the data relationship.
        public var relatedJoinTableName: Swift.String?
        /// The related model fields in the data relationship.
        public var relatedModelFields: [Swift.String]?
        /// The name of the related model in the data relationship.
        /// This member is required.
        public var relatedModelName: Swift.String?
        /// The data relationship type.
        /// This member is required.
        public var type: AmplifyUIBuilderClientTypes.GenericDataRelationshipType?

        public init(
            associatedFields: [Swift.String]? = nil,
            belongsToFieldOnRelatedModel: Swift.String? = nil,
            canUnlinkAssociatedModel: Swift.Bool? = nil,
            isHasManyIndex: Swift.Bool? = nil,
            relatedJoinFieldName: Swift.String? = nil,
            relatedJoinTableName: Swift.String? = nil,
            relatedModelFields: [Swift.String]? = nil,
            relatedModelName: Swift.String? = nil,
            type: AmplifyUIBuilderClientTypes.GenericDataRelationshipType? = nil
        )
        {
            self.associatedFields = associatedFields
            self.belongsToFieldOnRelatedModel = belongsToFieldOnRelatedModel
            self.canUnlinkAssociatedModel = canUnlinkAssociatedModel
            self.isHasManyIndex = isHasManyIndex
            self.relatedJoinFieldName = relatedJoinFieldName
            self.relatedJoinTableName = relatedJoinTableName
            self.relatedModelFields = relatedModelFields
            self.relatedModelName = relatedModelName
            self.type = type
        }
    }

}

extension AmplifyUIBuilderClientTypes.CodegenJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case asset
        case autoGenerateForms
        case createdAt
        case dependencies
        case environmentName
        case features
        case genericDataSchema
        case id
        case modifiedAt
        case renderConfig
        case status
        case statusMessage
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let asset = self.asset {
            try encodeContainer.encode(asset, forKey: .asset)
        }
        if let autoGenerateForms = self.autoGenerateForms {
            try encodeContainer.encode(autoGenerateForms, forKey: .autoGenerateForms)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let dependencies = dependencies {
            var dependenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependencies)
            for codegendependency0 in dependencies {
                try dependenciesContainer.encode(codegendependency0)
            }
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let features = self.features {
            try encodeContainer.encode(features, forKey: .features)
        }
        if let genericDataSchema = self.genericDataSchema {
            try encodeContainer.encode(genericDataSchema, forKey: .genericDataSchema)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
        if let renderConfig = self.renderConfig {
            try encodeContainer.encode(renderConfig, forKey: .renderConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let renderConfigDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenJobRenderConfig.self, forKey: .renderConfig)
        renderConfig = renderConfigDecoded
        let genericDataSchemaDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenJobGenericDataSchema.self, forKey: .genericDataSchema)
        genericDataSchema = genericDataSchemaDecoded
        let autoGenerateFormsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoGenerateForms)
        autoGenerateForms = autoGenerateFormsDecoded
        let featuresDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenFeatureFlags.self, forKey: .features)
        features = featuresDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let assetDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenJobAsset.self, forKey: .asset)
        asset = assetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let dependenciesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.CodegenDependency?].self, forKey: .dependencies)
        var dependenciesDecoded0:[AmplifyUIBuilderClientTypes.CodegenDependency]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [AmplifyUIBuilderClientTypes.CodegenDependency]()
            for structure0 in dependenciesContainer {
                if let structure0 = structure0 {
                    dependenciesDecoded0?.append(structure0)
                }
            }
        }
        dependencies = dependenciesDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for a code generation job that is associated with an Amplify app.
    public struct CodegenJob: Swift.Equatable {
        /// The ID of the Amplify app associated with the code generation job.
        /// This member is required.
        public var appId: Swift.String?
        /// The CodegenJobAsset to use for the code generation job.
        public var asset: AmplifyUIBuilderClientTypes.CodegenJobAsset?
        /// Specifies whether to autogenerate forms in the code generation job.
        public var autoGenerateForms: Swift.Bool?
        /// The time that the code generation job was created.
        public var createdAt: ClientRuntime.Date?
        /// Lists the dependency packages that may be required for the project code to run.
        public var dependencies: [AmplifyUIBuilderClientTypes.CodegenDependency]?
        /// The name of the backend environment associated with the code generation job.
        /// This member is required.
        public var environmentName: Swift.String?
        /// Describes the feature flags that you can specify for a code generation job.
        public var features: AmplifyUIBuilderClientTypes.CodegenFeatureFlags?
        /// Describes the data schema for a code generation job.
        public var genericDataSchema: AmplifyUIBuilderClientTypes.CodegenJobGenericDataSchema?
        /// The unique ID for the code generation job.
        /// This member is required.
        public var id: Swift.String?
        /// The time that the code generation job was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// Describes the configuration information for rendering the UI component associated with the code generation job.
        public var renderConfig: AmplifyUIBuilderClientTypes.CodegenJobRenderConfig?
        /// The status of the code generation job.
        public var status: AmplifyUIBuilderClientTypes.CodegenJobStatus?
        /// The customized status message for the code generation job.
        public var statusMessage: Swift.String?
        /// One or more key-value pairs to use when tagging the code generation job.
        public var tags: [Swift.String:Swift.String]?

        public init(
            appId: Swift.String? = nil,
            asset: AmplifyUIBuilderClientTypes.CodegenJobAsset? = nil,
            autoGenerateForms: Swift.Bool? = nil,
            createdAt: ClientRuntime.Date? = nil,
            dependencies: [AmplifyUIBuilderClientTypes.CodegenDependency]? = nil,
            environmentName: Swift.String? = nil,
            features: AmplifyUIBuilderClientTypes.CodegenFeatureFlags? = nil,
            genericDataSchema: AmplifyUIBuilderClientTypes.CodegenJobGenericDataSchema? = nil,
            id: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            renderConfig: AmplifyUIBuilderClientTypes.CodegenJobRenderConfig? = nil,
            status: AmplifyUIBuilderClientTypes.CodegenJobStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appId = appId
            self.asset = asset
            self.autoGenerateForms = autoGenerateForms
            self.createdAt = createdAt
            self.dependencies = dependencies
            self.environmentName = environmentName
            self.features = features
            self.genericDataSchema = genericDataSchema
            self.id = id
            self.modifiedAt = modifiedAt
            self.renderConfig = renderConfig
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension AmplifyUIBuilderClientTypes.CodegenJobAsset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downloadUrl = self.downloadUrl {
            try encodeContainer.encode(downloadUrl, forKey: .downloadUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes an asset for a code generation job.
    public struct CodegenJobAsset: Swift.Equatable {
        /// The URL to use to access the asset.
        public var downloadUrl: Swift.String?

        public init(
            downloadUrl: Swift.String? = nil
        )
        {
            self.downloadUrl = downloadUrl
        }
    }

}

extension AmplifyUIBuilderClientTypes.CodegenJobGenericDataSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceType
        case enums
        case models
        case nonModels
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceType = self.dataSourceType {
            try encodeContainer.encode(dataSourceType.rawValue, forKey: .dataSourceType)
        }
        if let enums = enums {
            var enumsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .enums)
            for (dictKey0, codegenGenericDataEnums0) in enums {
                try enumsContainer.encode(codegenGenericDataEnums0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let models = models {
            var modelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .models)
            for (dictKey0, codegenGenericDataModels0) in models {
                try modelsContainer.encode(codegenGenericDataModels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let nonModels = nonModels {
            var nonModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .nonModels)
            for (dictKey0, codegenGenericDataNonModels0) in nonModels {
                try nonModelsContainer.encode(codegenGenericDataNonModels0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenJobGenericDataSourceType.self, forKey: .dataSourceType)
        dataSourceType = dataSourceTypeDecoded
        let modelsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.CodegenGenericDataModel?].self, forKey: .models)
        var modelsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataModel]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataModel]()
            for (key0, codegengenericdatamodel0) in modelsContainer {
                if let codegengenericdatamodel0 = codegengenericdatamodel0 {
                    modelsDecoded0?[key0] = codegengenericdatamodel0
                }
            }
        }
        models = modelsDecoded0
        let enumsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.CodegenGenericDataEnum?].self, forKey: .enums)
        var enumsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataEnum]? = nil
        if let enumsContainer = enumsContainer {
            enumsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataEnum]()
            for (key0, codegengenericdataenum0) in enumsContainer {
                if let codegengenericdataenum0 = codegengenericdataenum0 {
                    enumsDecoded0?[key0] = codegengenericdataenum0
                }
            }
        }
        enums = enumsDecoded0
        let nonModelsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.CodegenGenericDataNonModel?].self, forKey: .nonModels)
        var nonModelsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataNonModel]? = nil
        if let nonModelsContainer = nonModelsContainer {
            nonModelsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataNonModel]()
            for (key0, codegengenericdatanonmodel0) in nonModelsContainer {
                if let codegengenericdatanonmodel0 = codegengenericdatanonmodel0 {
                    nonModelsDecoded0?[key0] = codegengenericdatanonmodel0
                }
            }
        }
        nonModels = nonModelsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the data schema for a code generation job.
    public struct CodegenJobGenericDataSchema: Swift.Equatable {
        /// The type of the data source for the schema. Currently, the only valid value is an Amplify DataStore.
        /// This member is required.
        public var dataSourceType: AmplifyUIBuilderClientTypes.CodegenJobGenericDataSourceType?
        /// The name of a CodegenGenericDataEnum.
        /// This member is required.
        public var enums: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataEnum]?
        /// The name of a CodegenGenericDataModel.
        /// This member is required.
        public var models: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataModel]?
        /// The name of a CodegenGenericDataNonModel.
        /// This member is required.
        public var nonModels: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataNonModel]?

        public init(
            dataSourceType: AmplifyUIBuilderClientTypes.CodegenJobGenericDataSourceType? = nil,
            enums: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataEnum]? = nil,
            models: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataModel]? = nil,
            nonModels: [Swift.String:AmplifyUIBuilderClientTypes.CodegenGenericDataNonModel]? = nil
        )
        {
            self.dataSourceType = dataSourceType
            self.enums = enums
            self.models = models
            self.nonModels = nonModels
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum CodegenJobGenericDataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dataStore
        case sdkUnknown(Swift.String)

        public static var allCases: [CodegenJobGenericDataSourceType] {
            return [
                .dataStore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dataStore: return "DataStore"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodegenJobGenericDataSourceType(rawValue: rawValue) ?? CodegenJobGenericDataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.CodegenJobRenderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case react
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .react(react):
                try container.encode(react, forKey: .react)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let reactDecoded = try values.decodeIfPresent(AmplifyUIBuilderClientTypes.ReactStartCodegenJobData.self, forKey: .react)
        if let react = reactDecoded {
            self = .react(react)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration information for rendering the UI component associated with the code generation job.
    public enum CodegenJobRenderConfig: Swift.Equatable {
        /// The name of the ReactStartCodegenJobData object.
        case react(AmplifyUIBuilderClientTypes.ReactStartCodegenJobData)
        case sdkUnknown(Swift.String)
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum CodegenJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CodegenJobStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "failed"
            case .inProgress: return "in_progress"
            case .succeeded: return "succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CodegenJobStatus(rawValue: rawValue) ?? CodegenJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.CodegenJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case createdAt
        case environmentName
        case id
        case modifiedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// A summary of the basic information about the code generation job.
    public struct CodegenJobSummary: Swift.Equatable {
        /// The unique ID of the Amplify app associated with the code generation job.
        /// This member is required.
        public var appId: Swift.String?
        /// The time that the code generation job summary was created.
        public var createdAt: ClientRuntime.Date?
        /// The name of the backend environment associated with the code generation job.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The unique ID for the code generation job summary.
        /// This member is required.
        public var id: Swift.String?
        /// The time that the code generation job summary was modified.
        public var modifiedAt: ClientRuntime.Date?

        public init(
            appId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil
        )
        {
            self.appId = appId
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.id = id
            self.modifiedAt = modifiedAt
        }
    }

}

extension AmplifyUIBuilderClientTypes.Component: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case bindingProperties
        case children
        case collectionProperties
        case componentType
        case createdAt
        case environmentName
        case events
        case id
        case modifiedAt
        case name
        case overrides
        case properties
        case schemaVersion
        case sourceId
        case tags
        case variants
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, componentBindingProperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(componentBindingProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchild0 in children {
                try childrenContainer.encode(componentchild0)
            }
        }
        if let collectionProperties = collectionProperties {
            var collectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .collectionProperties)
            for (dictKey0, componentCollectionProperties0) in collectionProperties {
                try collectionPropertiesContainer.encode(componentCollectionProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, componentEvents0) in events {
                try eventsContainer.encode(componentEvents0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentOverrides0) in overrides {
                var componentOverrides0Container = overridesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, componentOverridesValue1) in componentOverrides0 {
                    try componentOverrides0Container.encode(componentOverridesValue1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentProperties0) in properties {
                try propertiesContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let variants = variants {
            var variantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variants)
            for componentvariant0 in variants {
                try variantsContainer.encode(componentvariant0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let variantsContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentVariant?].self, forKey: .variants)
        var variantsDecoded0:[AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        if let variantsContainer = variantsContainer {
            variantsDecoded0 = [AmplifyUIBuilderClientTypes.ComponentVariant]()
            for structure0 in variantsContainer {
                if let structure0 = structure0 {
                    variantsDecoded0?.append(structure0)
                }
            }
        }
        variants = variantsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]()
            for (key0, componentbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let componentbindingpropertiesvalue0 = componentbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = componentbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
        let collectionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentDataConfiguration?].self, forKey: .collectionProperties)
        var collectionPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil
        if let collectionPropertiesContainer = collectionPropertiesContainer {
            collectionPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]()
            for (key0, componentdataconfiguration0) in collectionPropertiesContainer {
                if let componentdataconfiguration0 = componentdataconfiguration0 {
                    collectionPropertiesDecoded0?[key0] = componentdataconfiguration0
                }
            }
        }
        collectionProperties = collectionPropertiesDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentEvent?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]()
            for (key0, componentevent0) in eventsContainer {
                if let componentevent0 = componentevent0 {
                    eventsDecoded0?[key0] = componentevent0
                }
            }
        }
        events = eventsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Contains the configuration settings for a user interface (UI) element for an Amplify app. A component is configured as a primary, stand-alone UI element. Use ComponentChild to configure an instance of a Component. A ComponentChild instance inherits the configuration of the main Component.
    public struct Component: Swift.Equatable {
        /// The unique ID of the Amplify app associated with the component.
        /// This member is required.
        public var appId: Swift.String?
        /// The information to connect a component's properties to data at runtime. You can't specify tags as a valid property for bindingProperties.
        /// This member is required.
        public var bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]?
        /// A list of the component's ComponentChild instances.
        public var children: [AmplifyUIBuilderClientTypes.ComponentChild]?
        /// The data binding configuration for the component's properties. Use this for a collection component. You can't specify tags as a valid property for collectionProperties.
        public var collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]?
        /// The type of the component. This can be an Amplify custom UI component or another custom component.
        /// This member is required.
        public var componentType: Swift.String?
        /// The time that the component was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// Describes the events that can be raised on the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public var events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]?
        /// The unique ID of the component.
        /// This member is required.
        public var id: Swift.String?
        /// The time that the component was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The name of the component.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the component's properties that can be overriden in a customized instance of the component. You can't specify tags as a valid property for overrides.
        /// This member is required.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// Describes the component's properties. You can't specify tags as a valid property for properties.
        /// This member is required.
        public var properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The schema version of the component when it was imported.
        public var schemaVersion: Swift.String?
        /// The unique ID of the component in its original source system, such as Figma.
        public var sourceId: Swift.String?
        /// One or more key-value pairs to use when tagging the component.
        public var tags: [Swift.String:Swift.String]?
        /// A list of the component's variants. A variant is a unique style configuration of a main component.
        /// This member is required.
        public var variants: [AmplifyUIBuilderClientTypes.ComponentVariant]?

        public init(
            appId: Swift.String? = nil,
            bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil,
            children: [AmplifyUIBuilderClientTypes.ComponentChild]? = nil,
            collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil,
            componentType: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            environmentName: Swift.String? = nil,
            events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil,
            id: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            schemaVersion: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            variants: [AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        )
        {
            self.appId = appId
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.events = events
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.schemaVersion = schemaVersion
            self.sourceId = sourceId
            self.tags = tags
            self.variants = variants
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case defaultValue
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = self.bindingProperties {
            try encodeContainer.encode(bindingProperties, forKey: .bindingProperties)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValueProperties.self, forKey: .bindingProperties)
        bindingProperties = bindingPropertiesDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the data binding configuration for a component at runtime. You can use ComponentBindingPropertiesValue to add exposed properties to a component to allow different values to be entered when a component is reused in different places in an app.
    public struct ComponentBindingPropertiesValue: Swift.Equatable {
        /// Describes the properties to customize with data at runtime.
        public var bindingProperties: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValueProperties?
        /// The default value of the property.
        public var defaultValue: Swift.String?
        /// The property type.
        public var type: Swift.String?

        public init(
            bindingProperties: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValueProperties? = nil,
            defaultValue: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.defaultValue = defaultValue
            self.type = type
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValueProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case defaultValue
        case field
        case key
        case model
        case predicates
        case slotName
        case userAttribute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let predicates = predicates {
            var predicatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predicates)
            for predicate0 in predicates {
                try predicatesContainer.encode(predicate0)
            }
        }
        if let slotName = self.slotName {
            try encodeContainer.encode(slotName, forKey: .slotName)
        }
        if let userAttribute = self.userAttribute {
            try encodeContainer.encode(userAttribute, forKey: .userAttribute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let predicatesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Predicate?].self, forKey: .predicates)
        var predicatesDecoded0:[AmplifyUIBuilderClientTypes.Predicate]? = nil
        if let predicatesContainer = predicatesContainer {
            predicatesDecoded0 = [AmplifyUIBuilderClientTypes.Predicate]()
            for structure0 in predicatesContainer {
                if let structure0 = structure0 {
                    predicatesDecoded0?.append(structure0)
                }
            }
        }
        predicates = predicatesDecoded0
        let userAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAttribute)
        userAttribute = userAttributeDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let slotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotName)
        slotName = slotNameDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the data binding configuration for a specific property using data stored in Amazon Web Services. For Amazon Web Services connected properties, you can bind a property to data stored in an Amazon S3 bucket, an Amplify DataStore model or an authenticated user attribute.
    public struct ComponentBindingPropertiesValueProperties: Swift.Equatable {
        /// An Amazon S3 bucket.
        public var bucket: Swift.String?
        /// The default value to assign to the property.
        public var defaultValue: Swift.String?
        /// The field to bind the data to.
        public var field: Swift.String?
        /// The storage key for an Amazon S3 bucket.
        public var key: Swift.String?
        /// An Amplify DataStore model.
        public var model: Swift.String?
        /// A list of predicates for binding a component's properties to data.
        public var predicates: [AmplifyUIBuilderClientTypes.Predicate]?
        /// The name of a component slot.
        public var slotName: Swift.String?
        /// An authenticated user attribute.
        public var userAttribute: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            field: Swift.String? = nil,
            key: Swift.String? = nil,
            model: Swift.String? = nil,
            predicates: [AmplifyUIBuilderClientTypes.Predicate]? = nil,
            slotName: Swift.String? = nil,
            userAttribute: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.defaultValue = defaultValue
            self.field = field
            self.key = key
            self.model = model
            self.predicates = predicates
            self.slotName = slotName
            self.userAttribute = userAttribute
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentChild: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children
        case componentType
        case events
        case name
        case properties
        case sourceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchild0 in children {
                try childrenContainer.encode(componentchild0)
            }
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, componentEvents0) in events {
                try eventsContainer.encode(componentEvents0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentProperties0) in properties {
                try propertiesContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentEvent?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]()
            for (key0, componentevent0) in eventsContainer {
                if let componentevent0 = componentevent0 {
                    eventsDecoded0?[key0] = componentevent0
                }
            }
        }
        events = eventsDecoded0
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// A nested UI configuration within a parent Component.
    public struct ComponentChild: Swift.Equatable {
        /// The list of ComponentChild instances for this component.
        public var children: [AmplifyUIBuilderClientTypes.ComponentChild]?
        /// The type of the child component.
        /// This member is required.
        public var componentType: Swift.String?
        /// Describes the events that can be raised on the child component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public var events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]?
        /// The name of the child component.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the properties of the child component. You can't specify tags as a valid property for properties.
        /// This member is required.
        public var properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The unique ID of the child component in its original source system, such as Figma.
        public var sourceId: Swift.String?

        public init(
            children: [AmplifyUIBuilderClientTypes.ComponentChild]? = nil,
            componentType: Swift.String? = nil,
            events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil,
            name: Swift.String? = nil,
            properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            sourceId: Swift.String? = nil
        )
        {
            self.children = children
            self.componentType = componentType
            self.events = events
            self.name = name
            self.properties = properties
            self.sourceId = sourceId
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentConditionProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `else` = "else"
        case field
        case operand
        case operandType
        case `operator` = "operator"
        case property
        case then
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `else` = self.`else` {
            try encodeContainer.encode(`else`.value, forKey: .`else`)
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let operand = self.operand {
            try encodeContainer.encode(operand, forKey: .operand)
        }
        if let operandType = self.operandType {
            try encodeContainer.encode(operandType, forKey: .operandType)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
        if let then = self.then {
            try encodeContainer.encode(then.value, forKey: .then)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operator)
        `operator` = operatorDecoded
        let operandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operand)
        operand = operandDecoded
        let thenDecoded = try containerValues.decodeIfPresent(Box<AmplifyUIBuilderClientTypes.ComponentProperty>.self, forKey: .then)
        then = thenDecoded
        let elseDecoded = try containerValues.decodeIfPresent(Box<AmplifyUIBuilderClientTypes.ComponentProperty>.self, forKey: .else)
        `else` = elseDecoded
        let operandTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operandType)
        operandType = operandTypeDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents a conditional expression to set a component property. Use ComponentConditionProperty to set a property to different values conditionally, based on the value of another property.
    public struct ComponentConditionProperty: Swift.Equatable {
        /// The value to assign to the property if the condition is not met.
        public var `else`: Box<AmplifyUIBuilderClientTypes.ComponentProperty>?
        /// The name of a field. Specify this when the property is a data model.
        public var field: Swift.String?
        /// The value of the property to evaluate.
        public var operand: Swift.String?
        /// The type of the property to evaluate.
        public var operandType: Swift.String?
        /// The operator to use to perform the evaluation, such as eq to represent equals.
        public var `operator`: Swift.String?
        /// The name of the conditional property.
        public var property: Swift.String?
        /// The value to assign to the property if the condition is met.
        public var then: Box<AmplifyUIBuilderClientTypes.ComponentProperty>?

        public init(
            `else`: Box<AmplifyUIBuilderClientTypes.ComponentProperty>? = nil,
            field: Swift.String? = nil,
            operand: Swift.String? = nil,
            operandType: Swift.String? = nil,
            `operator`: Swift.String? = nil,
            property: Swift.String? = nil,
            then: Box<AmplifyUIBuilderClientTypes.ComponentProperty>? = nil
        )
        {
            self.`else` = `else`
            self.field = field
            self.operand = operand
            self.operandType = operandType
            self.`operator` = `operator`
            self.property = property
            self.then = then
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentDataConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifiers
        case model
        case predicate
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifiers = identifiers {
            var identifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identifiers)
            for string0 in identifiers {
                try identifiersContainer.encode(string0)
            }
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let predicate = self.predicate {
            try encodeContainer.encode(predicate, forKey: .predicate)
        }
        if let sort = sort {
            var sortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sort)
            for sortproperty0 in sort {
                try sortContainer.encode(sortproperty0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let sortContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.SortProperty?].self, forKey: .sort)
        var sortDecoded0:[AmplifyUIBuilderClientTypes.SortProperty]? = nil
        if let sortContainer = sortContainer {
            sortDecoded0 = [AmplifyUIBuilderClientTypes.SortProperty]()
            for structure0 in sortContainer {
                if let structure0 = structure0 {
                    sortDecoded0?.append(structure0)
                }
            }
        }
        sort = sortDecoded0
        let predicateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Predicate.self, forKey: .predicate)
        predicate = predicateDecoded
        let identifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identifiers)
        var identifiersDecoded0:[Swift.String]? = nil
        if let identifiersContainer = identifiersContainer {
            identifiersDecoded0 = [Swift.String]()
            for string0 in identifiersContainer {
                if let string0 = string0 {
                    identifiersDecoded0?.append(string0)
                }
            }
        }
        identifiers = identifiersDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for binding a component's properties to data.
    public struct ComponentDataConfiguration: Swift.Equatable {
        /// A list of IDs to use to bind data to a component. Use this property to bind specifically chosen data, rather than data retrieved from a query.
        public var identifiers: [Swift.String]?
        /// The name of the data model to use to bind data to a component.
        /// This member is required.
        public var model: Swift.String?
        /// Represents the conditional logic to use when binding data to a component. Use this property to retrieve only a subset of the data in a collection.
        public var predicate: AmplifyUIBuilderClientTypes.Predicate?
        /// Describes how to sort the component's properties.
        public var sort: [AmplifyUIBuilderClientTypes.SortProperty]?

        public init(
            identifiers: [Swift.String]? = nil,
            model: Swift.String? = nil,
            predicate: AmplifyUIBuilderClientTypes.Predicate? = nil,
            sort: [AmplifyUIBuilderClientTypes.SortProperty]? = nil
        )
        {
            self.identifiers = identifiers
            self.model = model
            self.predicate = predicate
            self.sort = sort
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case bindingEvent
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let bindingEvent = self.bindingEvent {
            try encodeContainer.encode(bindingEvent, forKey: .bindingEvent)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ActionParameters.self, forKey: .parameters)
        parameters = parametersDecoded
        let bindingEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bindingEvent)
        bindingEvent = bindingEventDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration of an event. You can bind an event and a corresponding action to a Component or a ComponentChild. A button click is an example of an event.
    public struct ComponentEvent: Swift.Equatable {
        /// The action to perform when a specific event is raised.
        public var action: Swift.String?
        /// Binds an event to an action on a component. When you specify a bindingEvent, the event is called when the action is performed.
        public var bindingEvent: Swift.String?
        /// Describes information about the action.
        public var parameters: AmplifyUIBuilderClientTypes.ActionParameters?

        public init(
            action: Swift.String? = nil,
            bindingEvent: Swift.String? = nil,
            parameters: AmplifyUIBuilderClientTypes.ActionParameters? = nil
        )
        {
            self.action = action
            self.bindingEvent = bindingEvent
            self.parameters = parameters
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case bindings
        case collectionBindingProperties
        case componentName
        case concat
        case condition
        case configured
        case defaultValue
        case event
        case importedValue
        case model
        case property
        case type
        case userAttribute
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = self.bindingProperties {
            try encodeContainer.encode(bindingProperties, forKey: .bindingProperties)
        }
        if let bindings = bindings {
            var bindingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindings)
            for (dictKey0, formBindings0) in bindings {
                try bindingsContainer.encode(formBindings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let collectionBindingProperties = self.collectionBindingProperties {
            try encodeContainer.encode(collectionBindingProperties, forKey: .collectionBindingProperties)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let concat = concat {
            var concatContainer = encodeContainer.nestedUnkeyedContainer(forKey: .concat)
            for componentproperty0 in concat {
                try concatContainer.encode(componentproperty0)
            }
        }
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let configured = self.configured {
            try encodeContainer.encode(configured, forKey: .configured)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let importedValue = self.importedValue {
            try encodeContainer.encode(importedValue, forKey: .importedValue)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userAttribute = self.userAttribute {
            try encodeContainer.encode(userAttribute, forKey: .userAttribute)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let bindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties.self, forKey: .bindingProperties)
        bindingProperties = bindingPropertiesDecoded
        let collectionBindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties.self, forKey: .collectionBindingProperties)
        collectionBindingProperties = collectionBindingPropertiesDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let bindingsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.FormBindingElement?].self, forKey: .bindings)
        var bindingsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.FormBindingElement]? = nil
        if let bindingsContainer = bindingsContainer {
            bindingsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.FormBindingElement]()
            for (key0, formbindingelement0) in bindingsContainer {
                if let formbindingelement0 = formbindingelement0 {
                    bindingsDecoded0?[key0] = formbindingelement0
                }
            }
        }
        bindings = bindingsDecoded0
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
        let userAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAttribute)
        userAttribute = userAttributeDecoded
        let concatContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .concat)
        var concatDecoded0:[AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let concatContainer = concatContainer {
            concatDecoded0 = [AmplifyUIBuilderClientTypes.ComponentProperty]()
            for structure0 in concatContainer {
                if let structure0 = structure0 {
                    concatDecoded0?.append(structure0)
                }
            }
        }
        concat = concatDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentConditionProperty.self, forKey: .condition)
        condition = conditionDecoded
        let configuredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .configured)
        configured = configuredDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let importedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importedValue)
        importedValue = importedValueDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for all of a component's properties. Use ComponentProperty to specify the values to render or bind by default.
    public struct ComponentProperty: Swift.Equatable {
        /// The information to bind the component property to data at runtime.
        public var bindingProperties: AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties?
        /// The information to bind the component property to form data.
        public var bindings: [Swift.String:AmplifyUIBuilderClientTypes.FormBindingElement]?
        /// The information to bind the component property to data at runtime. Use this for collection components.
        public var collectionBindingProperties: AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties?
        /// The name of the component that is affected by an event.
        public var componentName: Swift.String?
        /// A list of component properties to concatenate to create the value to assign to this component property.
        public var concat: [AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The conditional expression to use to assign a value to the component property.
        public var condition: AmplifyUIBuilderClientTypes.ComponentConditionProperty?
        /// Specifies whether the user configured the property in Amplify Studio after importing it.
        public var configured: Swift.Bool?
        /// The default value to assign to the component property.
        public var defaultValue: Swift.String?
        /// An event that occurs in your app. Use this for workflow data binding.
        public var event: Swift.String?
        /// The default value assigned to the property when the component is imported into an app.
        public var importedValue: Swift.String?
        /// The data model to use to assign a value to the component property.
        public var model: Swift.String?
        /// The name of the component's property that is affected by an event.
        public var property: Swift.String?
        /// The component type.
        public var type: Swift.String?
        /// An authenticated user attribute to use to assign a value to the component property.
        public var userAttribute: Swift.String?
        /// The value to assign to the component property.
        public var value: Swift.String?

        public init(
            bindingProperties: AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties? = nil,
            bindings: [Swift.String:AmplifyUIBuilderClientTypes.FormBindingElement]? = nil,
            collectionBindingProperties: AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties? = nil,
            componentName: Swift.String? = nil,
            concat: [AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            condition: AmplifyUIBuilderClientTypes.ComponentConditionProperty? = nil,
            configured: Swift.Bool? = nil,
            defaultValue: Swift.String? = nil,
            event: Swift.String? = nil,
            importedValue: Swift.String? = nil,
            model: Swift.String? = nil,
            property: Swift.String? = nil,
            type: Swift.String? = nil,
            userAttribute: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.bindings = bindings
            self.collectionBindingProperties = collectionBindingProperties
            self.componentName = componentName
            self.concat = concat
            self.condition = condition
            self.configured = configured
            self.defaultValue = defaultValue
            self.event = event
            self.importedValue = importedValue
            self.model = model
            self.property = property
            self.type = type
            self.userAttribute = userAttribute
            self.value = value
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentPropertyBindingProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case property
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Associates a component property to a binding property. This enables exposed properties on the top level component to propagate data to the component's property values.
    public struct ComponentPropertyBindingProperties: Swift.Equatable {
        /// The data field to bind the property to.
        public var field: Swift.String?
        /// The component property to bind to the data field.
        /// This member is required.
        public var property: Swift.String?

        public init(
            field: Swift.String? = nil,
            property: Swift.String? = nil
        )
        {
            self.field = field
            self.property = property
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case componentType
        case environmentName
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Contains a summary of a component. This is a read-only data type that is returned by ListComponents.
    public struct ComponentSummary: Swift.Equatable {
        /// The unique ID of the Amplify app associated with the component.
        /// This member is required.
        public var appId: Swift.String?
        /// The component type.
        /// This member is required.
        public var componentType: Swift.String?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The unique ID of the component.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the component.
        /// This member is required.
        public var name: Swift.String?

        public init(
            appId: Swift.String? = nil,
            componentType: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appId = appId
            self.componentType = componentType
            self.environmentName = environmentName
            self.id = id
            self.name = name
        }
    }

}

extension AmplifyUIBuilderClientTypes.ComponentVariant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
        case variantValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentOverrides0) in overrides {
                var componentOverrides0Container = overridesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, componentOverridesValue1) in componentOverrides0 {
                    try componentOverrides0Container.encode(componentOverridesValue1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let variantValues = variantValues {
            var variantValuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variantValues)
            for (dictKey0, componentVariantValues0) in variantValues {
                try variantValuesContainer.encode(componentVariantValues0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variantValuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variantValues)
        var variantValuesDecoded0: [Swift.String:Swift.String]? = nil
        if let variantValuesContainer = variantValuesContainer {
            variantValuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variantValuesContainer {
                if let string0 = string0 {
                    variantValuesDecoded0?[key0] = string0
                }
            }
        }
        variantValues = variantValuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the style configuration of a unique variation of a main component.
    public struct ComponentVariant: Swift.Equatable {
        /// The properties of the component variant that can be overriden when customizing an instance of the component. You can't specify tags as a valid property for overrides.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// The combination of variants that comprise this variant. You can't specify tags as a valid property for variantValues.
        public var variantValues: [Swift.String:Swift.String]?

        public init(
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            variantValues: [Swift.String:Swift.String]? = nil
        )
        {
            self.overrides = overrides
            self.variantValues = variantValues
        }
    }

}

extension AmplifyUIBuilderClientTypes.CreateComponentData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case children
        case collectionProperties
        case componentType
        case events
        case name
        case overrides
        case properties
        case schemaVersion
        case sourceId
        case tags
        case variants
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, componentBindingProperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(componentBindingProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchild0 in children {
                try childrenContainer.encode(componentchild0)
            }
        }
        if let collectionProperties = collectionProperties {
            var collectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .collectionProperties)
            for (dictKey0, componentCollectionProperties0) in collectionProperties {
                try collectionPropertiesContainer.encode(componentCollectionProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, componentEvents0) in events {
                try eventsContainer.encode(componentEvents0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentOverrides0) in overrides {
                var componentOverrides0Container = overridesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, componentOverridesValue1) in componentOverrides0 {
                    try componentOverrides0Container.encode(componentOverridesValue1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentProperties0) in properties {
                try propertiesContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let variants = variants {
            var variantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variants)
            for componentvariant0 in variants {
                try variantsContainer.encode(componentvariant0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let variantsContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentVariant?].self, forKey: .variants)
        var variantsDecoded0:[AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        if let variantsContainer = variantsContainer {
            variantsDecoded0 = [AmplifyUIBuilderClientTypes.ComponentVariant]()
            for structure0 in variantsContainer {
                if let structure0 = structure0 {
                    variantsDecoded0?.append(structure0)
                }
            }
        }
        variants = variantsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]()
            for (key0, componentbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let componentbindingpropertiesvalue0 = componentbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = componentbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
        let collectionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentDataConfiguration?].self, forKey: .collectionProperties)
        var collectionPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil
        if let collectionPropertiesContainer = collectionPropertiesContainer {
            collectionPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]()
            for (key0, componentdataconfiguration0) in collectionPropertiesContainer {
                if let componentdataconfiguration0 = componentdataconfiguration0 {
                    collectionPropertiesDecoded0?[key0] = componentdataconfiguration0
                }
            }
        }
        collectionProperties = collectionPropertiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentEvent?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]()
            for (key0, componentevent0) in eventsContainer {
                if let componentevent0 = componentevent0 {
                    eventsDecoded0?[key0] = componentevent0
                }
            }
        }
        events = eventsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents all of the information that is required to create a component.
    public struct CreateComponentData: Swift.Equatable {
        /// The data binding information for the component's properties.
        /// This member is required.
        public var bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]?
        /// A list of child components that are instances of the main component.
        public var children: [AmplifyUIBuilderClientTypes.ComponentChild]?
        /// The data binding configuration for customizing a component's properties. Use this for a collection component.
        public var collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]?
        /// The component type. This can be an Amplify custom UI component or another custom component.
        /// This member is required.
        public var componentType: Swift.String?
        /// The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public var events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]?
        /// The name of the component
        /// This member is required.
        public var name: Swift.String?
        /// Describes the component properties that can be overriden to customize an instance of the component.
        /// This member is required.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// Describes the component's properties.
        /// This member is required.
        public var properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The schema version of the component when it was imported.
        public var schemaVersion: Swift.String?
        /// The unique ID of the component in its original source system, such as Figma.
        public var sourceId: Swift.String?
        /// One or more key-value pairs to use when tagging the component data.
        public var tags: [Swift.String:Swift.String]?
        /// A list of the unique variants of this component.
        /// This member is required.
        public var variants: [AmplifyUIBuilderClientTypes.ComponentVariant]?

        public init(
            bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil,
            children: [AmplifyUIBuilderClientTypes.ComponentChild]? = nil,
            collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil,
            componentType: Swift.String? = nil,
            events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil,
            name: Swift.String? = nil,
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            schemaVersion: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            variants: [AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.events = events
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.schemaVersion = schemaVersion
            self.sourceId = sourceId
            self.tags = tags
            self.variants = variants
        }
    }

}

public struct CreateComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateComponentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateComponentOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let componentToCreate = input.operationInput.componentToCreate {
                let componentToCreateData = try encoder.encode(componentToCreate)
                let componentToCreateBody = ClientRuntime.HttpBody.data(componentToCreateData)
                input.builder.withBody(componentToCreateBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let componentToCreateData = "{}".data(using: .utf8)!
                    let componentToCreateBody = ClientRuntime.HttpBody.data(componentToCreateData)
                    input.builder.withBody(componentToCreateBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentToCreate = self.componentToCreate {
            try encodeContainer.encode(componentToCreate, forKey: .componentToCreate)
        }
    }
}

extension CreateComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension CreateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components"
    }
}

public struct CreateComponentInput: Swift.Equatable {
    /// The unique ID of the Amplify app to associate with the component.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// Represents the configuration of the component to create.
    /// This member is required.
    public var componentToCreate: AmplifyUIBuilderClientTypes.CreateComponentData?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        componentToCreate: AmplifyUIBuilderClientTypes.CreateComponentData? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.componentToCreate = componentToCreate
        self.environmentName = environmentName
    }
}

struct CreateComponentInputBody: Swift.Equatable {
    let componentToCreate: AmplifyUIBuilderClientTypes.CreateComponentData?
}

extension CreateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentToCreate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentToCreateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CreateComponentData.self, forKey: .componentToCreate)
        componentToCreate = componentToCreateDecoded
    }
}

extension CreateComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.Component = try responseDecoder.decode(responseBody: data)
            self.entity = output
        } else {
            self.entity = nil
        }
    }
}

public struct CreateComponentOutput: Swift.Equatable {
    /// Describes the configuration of the new component.
    public var entity: AmplifyUIBuilderClientTypes.Component?

    public init(
        entity: AmplifyUIBuilderClientTypes.Component? = nil
    )
    {
        self.entity = entity
    }
}

struct CreateComponentOutputBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Component?
}

extension CreateComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Component.self, forKey: .entity)
        entity = entityDecoded
    }
}

enum CreateComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.CreateFormData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cta
        case dataType
        case fields
        case formActionType
        case labelDecorator
        case name
        case schemaVersion
        case sectionalElements
        case style
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cta = self.cta {
            try encodeContainer.encode(cta, forKey: .cta)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, fieldsMap0) in fields {
                try fieldsContainer.encode(fieldsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let formActionType = self.formActionType {
            try encodeContainer.encode(formActionType.rawValue, forKey: .formActionType)
        }
        if let labelDecorator = self.labelDecorator {
            try encodeContainer.encode(labelDecorator.rawValue, forKey: .labelDecorator)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sectionalElements = sectionalElements {
            var sectionalElementsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sectionalElements)
            for (dictKey0, sectionalElementMap0) in sectionalElements {
                try sectionalElementsContainer.encode(sectionalElementMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataTypeConfig.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let formActionTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormActionType.self, forKey: .formActionType)
        formActionType = formActionTypeDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.FieldConfig?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]()
            for (key0, fieldconfig0) in fieldsContainer {
                if let fieldconfig0 = fieldconfig0 {
                    fieldsDecoded0?[key0] = fieldconfig0
                }
            }
        }
        fields = fieldsDecoded0
        let styleDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyle.self, forKey: .style)
        style = styleDecoded
        let sectionalElementsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.SectionalElement?].self, forKey: .sectionalElements)
        var sectionalElementsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil
        if let sectionalElementsContainer = sectionalElementsContainer {
            sectionalElementsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]()
            for (key0, sectionalelement0) in sectionalElementsContainer {
                if let sectionalelement0 = sectionalelement0 {
                    sectionalElementsDecoded0?[key0] = sectionalelement0
                }
            }
        }
        sectionalElements = sectionalElementsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let ctaDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormCTA.self, forKey: .cta)
        cta = ctaDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let labelDecoratorDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.LabelDecorator.self, forKey: .labelDecorator)
        labelDecorator = labelDecoratorDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents all of the information that is required to create a form.
    public struct CreateFormData: Swift.Equatable {
        /// The FormCTA object that stores the call to action configuration for the form.
        public var cta: AmplifyUIBuilderClientTypes.FormCTA?
        /// The type of data source to use to create the form.
        /// This member is required.
        public var dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig?
        /// The configuration information for the form's fields.
        /// This member is required.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]?
        /// Specifies whether to perform a create or update action on the form.
        /// This member is required.
        public var formActionType: AmplifyUIBuilderClientTypes.FormActionType?
        /// Specifies an icon or decoration to display on the form.
        public var labelDecorator: AmplifyUIBuilderClientTypes.LabelDecorator?
        /// The name of the form.
        /// This member is required.
        public var name: Swift.String?
        /// The schema version of the form.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The configuration information for the visual helper elements for the form. These elements are not associated with any data.
        /// This member is required.
        public var sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]?
        /// The configuration for the form's style.
        /// This member is required.
        public var style: AmplifyUIBuilderClientTypes.FormStyle?
        /// One or more key-value pairs to use when tagging the form data.
        public var tags: [Swift.String:Swift.String]?

        public init(
            cta: AmplifyUIBuilderClientTypes.FormCTA? = nil,
            dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig? = nil,
            fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil,
            formActionType: AmplifyUIBuilderClientTypes.FormActionType? = nil,
            labelDecorator: AmplifyUIBuilderClientTypes.LabelDecorator? = nil,
            name: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil,
            style: AmplifyUIBuilderClientTypes.FormStyle? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.cta = cta
            self.dataType = dataType
            self.fields = fields
            self.formActionType = formActionType
            self.labelDecorator = labelDecorator
            self.name = name
            self.schemaVersion = schemaVersion
            self.sectionalElements = sectionalElements
            self.style = style
            self.tags = tags
        }
    }

}

public struct CreateFormInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateFormInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateFormInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateFormOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let formToCreate = input.operationInput.formToCreate {
                let formToCreateData = try encoder.encode(formToCreate)
                let formToCreateBody = ClientRuntime.HttpBody.data(formToCreateData)
                input.builder.withBody(formToCreateBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let formToCreateData = "{}".data(using: .utf8)!
                    let formToCreateBody = ClientRuntime.HttpBody.data(formToCreateData)
                    input.builder.withBody(formToCreateBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateFormInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateFormOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateFormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formToCreate = self.formToCreate {
            try encodeContainer.encode(formToCreate, forKey: .formToCreate)
        }
    }
}

extension CreateFormInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension CreateFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms"
    }
}

public struct CreateFormInput: Swift.Equatable {
    /// The unique ID of the Amplify app to associate with the form.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// Represents the configuration of the form to create.
    /// This member is required.
    public var formToCreate: AmplifyUIBuilderClientTypes.CreateFormData?

    public init(
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        formToCreate: AmplifyUIBuilderClientTypes.CreateFormData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.formToCreate = formToCreate
    }
}

struct CreateFormInputBody: Swift.Equatable {
    let formToCreate: AmplifyUIBuilderClientTypes.CreateFormData?
}

extension CreateFormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formToCreate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formToCreateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CreateFormData.self, forKey: .formToCreate)
        formToCreate = formToCreateDecoded
    }
}

extension CreateFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.Form = try responseDecoder.decode(responseBody: data)
            self.entity = output
        } else {
            self.entity = nil
        }
    }
}

public struct CreateFormOutput: Swift.Equatable {
    /// Describes the configuration of the new form.
    public var entity: AmplifyUIBuilderClientTypes.Form?

    public init(
        entity: AmplifyUIBuilderClientTypes.Form? = nil
    )
    {
        self.entity = entity
    }
}

struct CreateFormOutputBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Form?
}

extension CreateFormOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Form.self, forKey: .entity)
        entity = entityDecoded
    }
}

enum CreateFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.CreateThemeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case overrides
        case tags
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for themevalues0 in overrides {
                try overridesContainer.encode(themevalues0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for themevalues0 in values {
                try valuesContainer.encode(themevalues0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .overrides)
        var overridesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents all of the information that is required to create a theme.
    public struct CreateThemeData: Swift.Equatable {
        /// The name of the theme.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize an instance of the theme.
        public var overrides: [AmplifyUIBuilderClientTypes.ThemeValues]?
        /// One or more key-value pairs to use when tagging the theme data.
        public var tags: [Swift.String:Swift.String]?
        /// A list of key-value pairs that denes the properties of the theme.
        /// This member is required.
        public var values: [AmplifyUIBuilderClientTypes.ThemeValues]?

        public init(
            name: Swift.String? = nil,
            overrides: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            values: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        )
        {
            self.name = name
            self.overrides = overrides
            self.tags = tags
            self.values = values
        }
    }

}

public struct CreateThemeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateThemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateThemeInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateThemeOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let themeToCreate = input.operationInput.themeToCreate {
                let themeToCreateData = try encoder.encode(themeToCreate)
                let themeToCreateBody = ClientRuntime.HttpBody.data(themeToCreateData)
                input.builder.withBody(themeToCreateBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let themeToCreateData = "{}".data(using: .utf8)!
                    let themeToCreateBody = ClientRuntime.HttpBody.data(themeToCreateData)
                    input.builder.withBody(themeToCreateBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateThemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateThemeOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let themeToCreate = self.themeToCreate {
            try encodeContainer.encode(themeToCreate, forKey: .themeToCreate)
        }
    }
}

extension CreateThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension CreateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes"
    }
}

public struct CreateThemeInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the theme.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// Represents the configuration of the theme to create.
    /// This member is required.
    public var themeToCreate: AmplifyUIBuilderClientTypes.CreateThemeData?

    public init(
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        themeToCreate: AmplifyUIBuilderClientTypes.CreateThemeData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.themeToCreate = themeToCreate
    }
}

struct CreateThemeInputBody: Swift.Equatable {
    let themeToCreate: AmplifyUIBuilderClientTypes.CreateThemeData?
}

extension CreateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeToCreate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeToCreateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CreateThemeData.self, forKey: .themeToCreate)
        themeToCreate = themeToCreateDecoded
    }
}

extension CreateThemeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.Theme = try responseDecoder.decode(responseBody: data)
            self.entity = output
        } else {
            self.entity = nil
        }
    }
}

public struct CreateThemeOutput: Swift.Equatable {
    /// Describes the configuration of the new theme.
    public var entity: AmplifyUIBuilderClientTypes.Theme?

    public init(
        entity: AmplifyUIBuilderClientTypes.Theme? = nil
    )
    {
        self.entity = entity
    }
}

struct CreateThemeOutputBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Theme?
}

extension CreateThemeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Theme.self, forKey: .entity)
        entity = entityDecoded
    }
}

enum CreateThemeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.DataStoreRenderConfig: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the DataStore configuration for an API for a code generation job.
    public struct DataStoreRenderConfig: Swift.Equatable {

        public init() { }
    }

}

extension DeleteComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components/\(id.urlPercentEncoding())"
    }
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the component to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the component to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
}

extension DeleteComponentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteComponentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms/\(id.urlPercentEncoding())"
    }
}

public struct DeleteFormInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the form to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the form to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct DeleteFormInputBody: Swift.Equatable {
}

extension DeleteFormInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFormOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes/\(id.urlPercentEncoding())"
    }
}

public struct DeleteThemeInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the theme to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the theme to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct DeleteThemeInputBody: Swift.Equatable {
}

extension DeleteThemeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThemeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteThemeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteThemeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public struct ExchangeCodeForTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExchangeCodeForTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExchangeCodeForTokenInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ExchangeCodeForTokenOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let request = input.operationInput.request {
                let requestData = try encoder.encode(request)
                let requestBody = ClientRuntime.HttpBody.data(requestData)
                input.builder.withBody(requestBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let requestData = "{}".data(using: .utf8)!
                    let requestBody = ClientRuntime.HttpBody.data(requestData)
                    input.builder.withBody(requestBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExchangeCodeForTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExchangeCodeForTokenOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension ExchangeCodeForTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case request
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let request = self.request {
            try encodeContainer.encode(request, forKey: .request)
        }
    }
}

extension ExchangeCodeForTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let provider = provider else {
            return nil
        }
        return "/tokens/\(provider.rawValue.urlPercentEncoding())"
    }
}

public struct ExchangeCodeForTokenInput: Swift.Equatable {
    /// The third-party provider for the token. The only valid value is figma.
    /// This member is required.
    public var provider: AmplifyUIBuilderClientTypes.TokenProviders?
    /// Describes the configuration of the request.
    /// This member is required.
    public var request: AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody?

    public init(
        provider: AmplifyUIBuilderClientTypes.TokenProviders? = nil,
        request: AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody? = nil
    )
    {
        self.provider = provider
        self.request = request
    }
}

struct ExchangeCodeForTokenInputBody: Swift.Equatable {
    let request: AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody?
}

extension ExchangeCodeForTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case request
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody.self, forKey: .request)
        request = requestDecoded
    }
}

extension ExchangeCodeForTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExchangeCodeForTokenOutput(expiresIn: \(Swift.String(describing: expiresIn)), accessToken: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

extension ExchangeCodeForTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExchangeCodeForTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
            self.refreshToken = output.refreshToken
        } else {
            self.accessToken = nil
            self.expiresIn = nil
            self.refreshToken = nil
        }
    }
}

public struct ExchangeCodeForTokenOutput: Swift.Equatable {
    /// The access token.
    /// This member is required.
    public var accessToken: Swift.String?
    /// The date and time when the new access token expires.
    /// This member is required.
    public var expiresIn: Swift.Int?
    /// The token to use to refresh a previously issued access token that might have expired.
    /// This member is required.
    public var refreshToken: Swift.String?

    public init(
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int? = nil,
        refreshToken: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.refreshToken = refreshToken
    }
}

struct ExchangeCodeForTokenOutputBody: Swift.Equatable {
    let accessToken: Swift.String?
    let expiresIn: Swift.Int?
    let refreshToken: Swift.String?
}

extension ExchangeCodeForTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
        case refreshToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
    }
}

enum ExchangeCodeForTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case code
        case redirectUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let redirectUri = self.redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
    }
}

extension AmplifyUIBuilderClientTypes.ExchangeCodeForTokenRequestBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExchangeCodeForTokenRequestBody(redirectUri: \(Swift.String(describing: redirectUri)), clientId: \"CONTENT_REDACTED\", code: \"CONTENT_REDACTED\")"}
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration of a request to exchange an access code for a token.
    public struct ExchangeCodeForTokenRequestBody: Swift.Equatable {
        /// The ID of the client to request the token from.
        public var clientId: Swift.String?
        /// The access code to send in the request.
        /// This member is required.
        public var code: Swift.String?
        /// The location of the application that will receive the access code.
        /// This member is required.
        public var redirectUri: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            code: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.code = code
            self.redirectUri = redirectUri
        }
    }

}

extension ExportComponentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ExportComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/export/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components"
    }
}

public struct ExportComponentsInput: Swift.Equatable {
    /// The unique ID of the Amplify app to export components to.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ExportComponentsInputBody: Swift.Equatable {
}

extension ExportComponentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ExportComponentsOutput: Swift.Equatable {
    /// Represents the configuration of the exported components.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.Component]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        entities: [AmplifyUIBuilderClientTypes.Component]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ExportComponentsOutputBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.Component]?
    let nextToken: Swift.String?
}

extension ExportComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Component?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.Component]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.Component]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ExportComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExportFormsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ExportFormsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/export/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms"
    }
}

public struct ExportFormsInput: Swift.Equatable {
    /// The unique ID of the Amplify app to export forms to.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ExportFormsInputBody: Swift.Equatable {
}

extension ExportFormsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportFormsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportFormsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ExportFormsOutput: Swift.Equatable {
    /// Represents the configuration of the exported forms.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.Form]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        entities: [AmplifyUIBuilderClientTypes.Form]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ExportFormsOutputBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.Form]?
    let nextToken: Swift.String?
}

extension ExportFormsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Form?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.Form]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.Form]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ExportFormsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExportThemesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ExportThemesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/export/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes"
    }
}

public struct ExportThemesInput: Swift.Equatable {
    /// The unique ID of the Amplify app to export the themes to.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.nextToken = nextToken
    }
}

struct ExportThemesInputBody: Swift.Equatable {
}

extension ExportThemesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportThemesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportThemesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ExportThemesOutput: Swift.Equatable {
    /// Represents the configuration of the exported themes.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.Theme]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        entities: [AmplifyUIBuilderClientTypes.Theme]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ExportThemesOutputBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.Theme]?
    let nextToken: Swift.String?
}

extension ExportThemesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Theme?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.Theme]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.Theme]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ExportThemesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.FieldConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excluded
        case inputType
        case label
        case position
        case validations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let inputType = self.inputType {
            try encodeContainer.encode(inputType, forKey: .inputType)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let validations = validations {
            var validationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validations)
            for fieldvalidationconfiguration0 in validations {
                try validationsContainer.encode(fieldvalidationconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let positionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FieldPosition.self, forKey: .position)
        position = positionDecoded
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
        let inputTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FieldInputConfig.self, forKey: .inputType)
        inputType = inputTypeDecoded
        let validationsContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.FieldValidationConfiguration?].self, forKey: .validations)
        var validationsDecoded0:[AmplifyUIBuilderClientTypes.FieldValidationConfiguration]? = nil
        if let validationsContainer = validationsContainer {
            validationsDecoded0 = [AmplifyUIBuilderClientTypes.FieldValidationConfiguration]()
            for structure0 in validationsContainer {
                if let structure0 = structure0 {
                    validationsDecoded0?.append(structure0)
                }
            }
        }
        validations = validationsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration information for a field in a table.
    public struct FieldConfig: Swift.Equatable {
        /// Specifies whether to hide a field.
        public var excluded: Swift.Bool?
        /// Describes the configuration for the default input value to display for a field.
        public var inputType: AmplifyUIBuilderClientTypes.FieldInputConfig?
        /// The label for the field.
        public var label: Swift.String?
        /// Specifies the field position.
        public var position: AmplifyUIBuilderClientTypes.FieldPosition?
        /// The validations to perform on the value in the field.
        public var validations: [AmplifyUIBuilderClientTypes.FieldValidationConfiguration]?

        public init(
            excluded: Swift.Bool? = nil,
            inputType: AmplifyUIBuilderClientTypes.FieldInputConfig? = nil,
            label: Swift.String? = nil,
            position: AmplifyUIBuilderClientTypes.FieldPosition? = nil,
            validations: [AmplifyUIBuilderClientTypes.FieldValidationConfiguration]? = nil
        )
        {
            self.excluded = excluded
            self.inputType = inputType
            self.label = label
            self.position = position
            self.validations = validations
        }
    }

}

extension AmplifyUIBuilderClientTypes.FieldInputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultChecked
        case defaultCountryCode
        case defaultValue
        case descriptiveText
        case fileUploaderConfig
        case isArray
        case maxValue
        case minValue
        case name
        case placeholder
        case readOnly
        case `required` = "required"
        case step
        case type
        case value
        case valueMappings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultChecked = self.defaultChecked {
            try encodeContainer.encode(defaultChecked, forKey: .defaultChecked)
        }
        if let defaultCountryCode = self.defaultCountryCode {
            try encodeContainer.encode(defaultCountryCode, forKey: .defaultCountryCode)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let descriptiveText = self.descriptiveText {
            try encodeContainer.encode(descriptiveText, forKey: .descriptiveText)
        }
        if let fileUploaderConfig = self.fileUploaderConfig {
            try encodeContainer.encode(fileUploaderConfig, forKey: .fileUploaderConfig)
        }
        if let isArray = self.isArray {
            try encodeContainer.encode(isArray, forKey: .isArray)
        }
        if let maxValue = self.maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = self.minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let placeholder = self.placeholder {
            try encodeContainer.encode(placeholder, forKey: .placeholder)
        }
        if let readOnly = self.readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if let step = self.step {
            try encodeContainer.encode(step, forKey: .step)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let valueMappings = self.valueMappings {
            try encodeContainer.encode(valueMappings, forKey: .valueMappings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let placeholderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placeholder)
        placeholder = placeholderDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptiveTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .descriptiveText)
        descriptiveText = descriptiveTextDecoded
        let defaultCheckedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultChecked)
        defaultChecked = defaultCheckedDecoded
        let defaultCountryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultCountryCode)
        defaultCountryCode = defaultCountryCodeDecoded
        let valueMappingsDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ValueMappings.self, forKey: .valueMappings)
        valueMappings = valueMappingsDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .minValue)
        minValue = minValueDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let stepDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .step)
        step = stepDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let isArrayDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArray)
        isArray = isArrayDecoded
        let fileUploaderConfigDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FileUploaderFieldConfig.self, forKey: .fileUploaderConfig)
        fileUploaderConfig = fileUploaderConfigDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for the default input values to display for a field.
    public struct FieldInputConfig: Swift.Equatable {
        /// Specifies whether a field has a default value.
        public var defaultChecked: Swift.Bool?
        /// The default country code for a phone number.
        public var defaultCountryCode: Swift.String?
        /// The default value for the field.
        public var defaultValue: Swift.String?
        /// The text to display to describe the field.
        public var descriptiveText: Swift.String?
        /// The configuration for the file uploader field.
        public var fileUploaderConfig: AmplifyUIBuilderClientTypes.FileUploaderFieldConfig?
        /// Specifies whether to render the field as an array. This property is ignored if the dataSourceType for the form is a Data Store.
        public var isArray: Swift.Bool?
        /// The maximum value to display for the field.
        public var maxValue: Swift.Float?
        /// The minimum value to display for the field.
        public var minValue: Swift.Float?
        /// The name of the field.
        public var name: Swift.String?
        /// The text to display as a placeholder for the field.
        public var placeholder: Swift.String?
        /// Specifies a read only field.
        public var readOnly: Swift.Bool?
        /// Specifies a field that requires input.
        public var `required`: Swift.Bool?
        /// The stepping increment for a numeric value in a field.
        public var step: Swift.Float?
        /// The input type for the field.
        /// This member is required.
        public var type: Swift.String?
        /// The value for the field.
        public var value: Swift.String?
        /// The information to use to customize the input fields with data at runtime.
        public var valueMappings: AmplifyUIBuilderClientTypes.ValueMappings?

        public init(
            defaultChecked: Swift.Bool? = nil,
            defaultCountryCode: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            descriptiveText: Swift.String? = nil,
            fileUploaderConfig: AmplifyUIBuilderClientTypes.FileUploaderFieldConfig? = nil,
            isArray: Swift.Bool? = nil,
            maxValue: Swift.Float? = nil,
            minValue: Swift.Float? = nil,
            name: Swift.String? = nil,
            placeholder: Swift.String? = nil,
            readOnly: Swift.Bool? = nil,
            `required`: Swift.Bool? = nil,
            step: Swift.Float? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil,
            valueMappings: AmplifyUIBuilderClientTypes.ValueMappings? = nil
        )
        {
            self.defaultChecked = defaultChecked
            self.defaultCountryCode = defaultCountryCode
            self.defaultValue = defaultValue
            self.descriptiveText = descriptiveText
            self.fileUploaderConfig = fileUploaderConfig
            self.isArray = isArray
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.placeholder = placeholder
            self.readOnly = readOnly
            self.`required` = `required`
            self.step = step
            self.type = type
            self.value = value
            self.valueMappings = valueMappings
        }
    }

}

extension AmplifyUIBuilderClientTypes.FieldPosition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case below
        case fixed
        case rightof = "rightOf"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .below(below):
                try container.encode(below, forKey: .below)
            case let .fixed(fixed):
                try container.encode(fixed.rawValue, forKey: .fixed)
            case let .rightof(rightof):
                try container.encode(rightof, forKey: .rightof)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fixedDecoded = try values.decodeIfPresent(AmplifyUIBuilderClientTypes.FixedPosition.self, forKey: .fixed)
        if let fixed = fixedDecoded {
            self = .fixed(fixed)
            return
        }
        let rightofDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .rightof)
        if let rightof = rightofDecoded {
            self = .rightof(rightof)
            return
        }
        let belowDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .below)
        if let below = belowDecoded {
            self = .below(below)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the field position.
    public enum FieldPosition: Swift.Equatable {
        /// The field position is fixed and doesn't change in relation to other fields.
        case fixed(AmplifyUIBuilderClientTypes.FixedPosition)
        /// The field position is to the right of the field specified by the string.
        case rightof(Swift.String)
        /// The field position is below the field specified by the string.
        case below(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AmplifyUIBuilderClientTypes.FieldValidationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numValues
        case strValues
        case type
        case validationMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numValues = numValues {
            var numValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .numValues)
            for integer0 in numValues {
                try numValuesContainer.encode(integer0)
            }
        }
        if let strValues = strValues {
            var strValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .strValues)
            for string0 in strValues {
                try strValuesContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let validationMessage = self.validationMessage {
            try encodeContainer.encode(validationMessage, forKey: .validationMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let strValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .strValues)
        var strValuesDecoded0:[Swift.String]? = nil
        if let strValuesContainer = strValuesContainer {
            strValuesDecoded0 = [Swift.String]()
            for string0 in strValuesContainer {
                if let string0 = string0 {
                    strValuesDecoded0?.append(string0)
                }
            }
        }
        strValues = strValuesDecoded0
        let numValuesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .numValues)
        var numValuesDecoded0:[Swift.Int]? = nil
        if let numValuesContainer = numValuesContainer {
            numValuesDecoded0 = [Swift.Int]()
            for integer0 in numValuesContainer {
                if let integer0 = integer0 {
                    numValuesDecoded0?.append(integer0)
                }
            }
        }
        numValues = numValuesDecoded0
        let validationMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationMessage)
        validationMessage = validationMessageDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the validation configuration for a field.
    public struct FieldValidationConfiguration: Swift.Equatable {
        /// The validation to perform on a number value.
        public var numValues: [Swift.Int]?
        /// The validation to perform on a string value.
        public var strValues: [Swift.String]?
        /// The validation to perform on an object type.
        /// This member is required.
        public var type: Swift.String?
        /// The validation message to display.
        public var validationMessage: Swift.String?

        public init(
            numValues: [Swift.Int]? = nil,
            strValues: [Swift.String]? = nil,
            type: Swift.String? = nil,
            validationMessage: Swift.String? = nil
        )
        {
            self.numValues = numValues
            self.strValues = strValues
            self.type = type
            self.validationMessage = validationMessage
        }
    }

}

extension AmplifyUIBuilderClientTypes.FileUploaderFieldConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedFileTypes
        case accessLevel
        case isResumable
        case maxFileCount
        case maxSize
        case showThumbnails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptedFileTypes = acceptedFileTypes {
            var acceptedFileTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceptedFileTypes)
            for string0 in acceptedFileTypes {
                try acceptedFileTypesContainer.encode(string0)
            }
        }
        if let accessLevel = self.accessLevel {
            try encodeContainer.encode(accessLevel.rawValue, forKey: .accessLevel)
        }
        if let isResumable = self.isResumable {
            try encodeContainer.encode(isResumable, forKey: .isResumable)
        }
        if let maxFileCount = self.maxFileCount {
            try encodeContainer.encode(maxFileCount, forKey: .maxFileCount)
        }
        if let maxSize = self.maxSize {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if let showThumbnails = self.showThumbnails {
            try encodeContainer.encode(showThumbnails, forKey: .showThumbnails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLevelDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.StorageAccessLevel.self, forKey: .accessLevel)
        accessLevel = accessLevelDecoded
        let acceptedFileTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .acceptedFileTypes)
        var acceptedFileTypesDecoded0:[Swift.String]? = nil
        if let acceptedFileTypesContainer = acceptedFileTypesContainer {
            acceptedFileTypesDecoded0 = [Swift.String]()
            for string0 in acceptedFileTypesContainer {
                if let string0 = string0 {
                    acceptedFileTypesDecoded0?.append(string0)
                }
            }
        }
        acceptedFileTypes = acceptedFileTypesDecoded0
        let showThumbnailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .showThumbnails)
        showThumbnails = showThumbnailsDecoded
        let isResumableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isResumable)
        isResumable = isResumableDecoded
        let maxFileCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileCount)
        maxFileCount = maxFileCountDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for the file uploader field.
    public struct FileUploaderFieldConfig: Swift.Equatable {
        /// The file types that are allowed to be uploaded by the file uploader. Provide this information in an array of strings specifying the valid file extensions.
        /// This member is required.
        public var acceptedFileTypes: [Swift.String]?
        /// The access level to assign to the uploaded files in the Amazon S3 bucket where they are stored. The valid values for this property are private, protected, or public. For detailed information about the permissions associated with each access level, see [File access levels](https://docs.amplify.aws/lib/storage/configureaccess/q/platform/js/) in the Amplify documentation.
        /// This member is required.
        public var accessLevel: AmplifyUIBuilderClientTypes.StorageAccessLevel?
        /// Allows the file upload operation to be paused and resumed. The default value is false. When isResumable is set to true, the file uploader uses a multipart upload to break the files into chunks before upload. The progress of the upload isn't continuous, because the file uploader uploads a chunk at a time.
        public var isResumable: Swift.Bool?
        /// Specifies the maximum number of files that can be selected to upload. The default value is an unlimited number of files.
        public var maxFileCount: Swift.Int?
        /// The maximum file size in bytes that the file uploader will accept. The default value is an unlimited file size.
        public var maxSize: Swift.Int?
        /// Specifies whether to display or hide the image preview after selecting a file for upload. The default value is true to display the image preview.
        public var showThumbnails: Swift.Bool?

        public init(
            acceptedFileTypes: [Swift.String]? = nil,
            accessLevel: AmplifyUIBuilderClientTypes.StorageAccessLevel? = nil,
            isResumable: Swift.Bool? = nil,
            maxFileCount: Swift.Int? = nil,
            maxSize: Swift.Int? = nil,
            showThumbnails: Swift.Bool? = nil
        )
        {
            self.acceptedFileTypes = acceptedFileTypes
            self.accessLevel = accessLevel
            self.isResumable = isResumable
            self.maxFileCount = maxFileCount
            self.maxSize = maxSize
            self.showThumbnails = showThumbnails
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum FixedPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case first
        case sdkUnknown(Swift.String)

        public static var allCases: [FixedPosition] {
            return [
                .first,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .first: return "first"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FixedPosition(rawValue: rawValue) ?? FixedPosition.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.Form: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case cta
        case dataType
        case environmentName
        case fields
        case formActionType
        case id
        case labelDecorator
        case name
        case schemaVersion
        case sectionalElements
        case style
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let cta = self.cta {
            try encodeContainer.encode(cta, forKey: .cta)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, fieldsMap0) in fields {
                try fieldsContainer.encode(fieldsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let formActionType = self.formActionType {
            try encodeContainer.encode(formActionType.rawValue, forKey: .formActionType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let labelDecorator = self.labelDecorator {
            try encodeContainer.encode(labelDecorator.rawValue, forKey: .labelDecorator)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sectionalElements = sectionalElements {
            var sectionalElementsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sectionalElements)
            for (dictKey0, sectionalElementMap0) in sectionalElements {
                try sectionalElementsContainer.encode(sectionalElementMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formActionTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormActionType.self, forKey: .formActionType)
        formActionType = formActionTypeDecoded
        let styleDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyle.self, forKey: .style)
        style = styleDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataTypeConfig.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.FieldConfig?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]()
            for (key0, fieldconfig0) in fieldsContainer {
                if let fieldconfig0 = fieldconfig0 {
                    fieldsDecoded0?[key0] = fieldconfig0
                }
            }
        }
        fields = fieldsDecoded0
        let sectionalElementsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.SectionalElement?].self, forKey: .sectionalElements)
        var sectionalElementsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil
        if let sectionalElementsContainer = sectionalElementsContainer {
            sectionalElementsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]()
            for (key0, sectionalelement0) in sectionalElementsContainer {
                if let sectionalelement0 = sectionalelement0 {
                    sectionalElementsDecoded0?[key0] = sectionalelement0
                }
            }
        }
        sectionalElements = sectionalElementsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ctaDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormCTA.self, forKey: .cta)
        cta = ctaDecoded
        let labelDecoratorDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.LabelDecorator.self, forKey: .labelDecorator)
        labelDecorator = labelDecoratorDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Contains the configuration settings for a Form user interface (UI) element for an Amplify app. A form is a component you can add to your project by specifying a data source as the default configuration for the form.
    public struct Form: Swift.Equatable {
        /// The unique ID of the Amplify app associated with the form.
        /// This member is required.
        public var appId: Swift.String?
        /// Stores the call to action configuration for the form.
        public var cta: AmplifyUIBuilderClientTypes.FormCTA?
        /// The type of data source to use to create the form.
        /// This member is required.
        public var dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// Stores the information about the form's fields.
        /// This member is required.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]?
        /// The operation to perform on the specified form.
        /// This member is required.
        public var formActionType: AmplifyUIBuilderClientTypes.FormActionType?
        /// The unique ID of the form.
        /// This member is required.
        public var id: Swift.String?
        /// Specifies an icon or decoration to display on the form.
        public var labelDecorator: AmplifyUIBuilderClientTypes.LabelDecorator?
        /// The name of the form.
        /// This member is required.
        public var name: Swift.String?
        /// The schema version of the form when it was imported.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// Stores the visual helper elements for the form that are not associated with any data.
        /// This member is required.
        public var sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]?
        /// Stores the configuration for the form's style.
        /// This member is required.
        public var style: AmplifyUIBuilderClientTypes.FormStyle?
        /// One or more key-value pairs to use when tagging the form.
        public var tags: [Swift.String:Swift.String]?

        public init(
            appId: Swift.String? = nil,
            cta: AmplifyUIBuilderClientTypes.FormCTA? = nil,
            dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig? = nil,
            environmentName: Swift.String? = nil,
            fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil,
            formActionType: AmplifyUIBuilderClientTypes.FormActionType? = nil,
            id: Swift.String? = nil,
            labelDecorator: AmplifyUIBuilderClientTypes.LabelDecorator? = nil,
            name: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil,
            style: AmplifyUIBuilderClientTypes.FormStyle? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.appId = appId
            self.cta = cta
            self.dataType = dataType
            self.environmentName = environmentName
            self.fields = fields
            self.formActionType = formActionType
            self.id = id
            self.labelDecorator = labelDecorator
            self.name = name
            self.schemaVersion = schemaVersion
            self.sectionalElements = sectionalElements
            self.style = style
            self.tags = tags
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum FormActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [FormActionType] {
            return [
                .create,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "create"
            case .update: return "update"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormActionType(rawValue: rawValue) ?? FormActionType.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.FormBindingElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case element
        case property
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let element = self.element {
            try encodeContainer.encode(element, forKey: .element)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .element)
        element = elementDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes how to bind a component property to form data.
    public struct FormBindingElement: Swift.Equatable {
        /// The name of the component to retrieve a value from.
        /// This member is required.
        public var element: Swift.String?
        /// The property to retrieve a value from.
        /// This member is required.
        public var property: Swift.String?

        public init(
            element: Swift.String? = nil,
            property: Swift.String? = nil
        )
        {
            self.element = element
            self.property = property
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormButton: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children
        case excluded
        case position
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = self.children {
            try encodeContainer.encode(children, forKey: .children)
        }
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
        let childrenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .children)
        children = childrenDecoded
        let positionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FieldPosition.self, forKey: .position)
        position = positionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for a button UI element that is a part of a form.
    public struct FormButton: Swift.Equatable {
        /// Describes the button's properties.
        public var children: Swift.String?
        /// Specifies whether the button is visible on the form.
        public var excluded: Swift.Bool?
        /// The position of the button.
        public var position: AmplifyUIBuilderClientTypes.FieldPosition?

        public init(
            children: Swift.String? = nil,
            excluded: Swift.Bool? = nil,
            position: AmplifyUIBuilderClientTypes.FieldPosition? = nil
        )
        {
            self.children = children
            self.excluded = excluded
            self.position = position
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum FormButtonsPosition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bottom
        case top
        case topAndBottom
        case sdkUnknown(Swift.String)

        public static var allCases: [FormButtonsPosition] {
            return [
                .bottom,
                .top,
                .topAndBottom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bottom: return "bottom"
            case .top: return "top"
            case .topAndBottom: return "top_and_bottom"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormButtonsPosition(rawValue: rawValue) ?? FormButtonsPosition.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.FormCTA: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cancel
        case clear
        case position
        case submit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cancel = self.cancel {
            try encodeContainer.encode(cancel, forKey: .cancel)
        }
        if let clear = self.clear {
            try encodeContainer.encode(clear, forKey: .clear)
        }
        if let position = self.position {
            try encodeContainer.encode(position.rawValue, forKey: .position)
        }
        if let submit = self.submit {
            try encodeContainer.encode(submit, forKey: .submit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let positionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormButtonsPosition.self, forKey: .position)
        position = positionDecoded
        let clearDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormButton.self, forKey: .clear)
        clear = clearDecoded
        let cancelDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormButton.self, forKey: .cancel)
        cancel = cancelDecoded
        let submitDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormButton.self, forKey: .submit)
        submit = submitDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the call to action button configuration for the form.
    public struct FormCTA: Swift.Equatable {
        /// Displays a cancel button.
        public var cancel: AmplifyUIBuilderClientTypes.FormButton?
        /// Displays a clear button.
        public var clear: AmplifyUIBuilderClientTypes.FormButton?
        /// The position of the button.
        public var position: AmplifyUIBuilderClientTypes.FormButtonsPosition?
        /// Displays a submit button.
        public var submit: AmplifyUIBuilderClientTypes.FormButton?

        public init(
            cancel: AmplifyUIBuilderClientTypes.FormButton? = nil,
            clear: AmplifyUIBuilderClientTypes.FormButton? = nil,
            position: AmplifyUIBuilderClientTypes.FormButtonsPosition? = nil,
            submit: AmplifyUIBuilderClientTypes.FormButton? = nil
        )
        {
            self.cancel = cancel
            self.clear = clear
            self.position = position
            self.submit = submit
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum FormDataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Will use passed in hooks to use when creating a form from scratch
        case custom
        /// Will use a provided Amplify DataStore enabled API
        case datastore
        case sdkUnknown(Swift.String)

        public static var allCases: [FormDataSourceType] {
            return [
                .custom,
                .datastore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "Custom"
            case .datastore: return "DataStore"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormDataSourceType(rawValue: rawValue) ?? FormDataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.FormDataTypeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceType
        case dataTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceType = self.dataSourceType {
            try encodeContainer.encode(dataSourceType.rawValue, forKey: .dataSourceType)
        }
        if let dataTypeName = self.dataTypeName {
            try encodeContainer.encode(dataTypeName, forKey: .dataTypeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataSourceType.self, forKey: .dataSourceType)
        dataSourceType = dataSourceTypeDecoded
        let dataTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeName)
        dataTypeName = dataTypeNameDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the data type configuration for the data source associated with a form.
    public struct FormDataTypeConfig: Swift.Equatable {
        /// The data source type, either an Amplify DataStore model or a custom data type.
        /// This member is required.
        public var dataSourceType: AmplifyUIBuilderClientTypes.FormDataSourceType?
        /// The unique name of the data type you are using as the data source for the form.
        /// This member is required.
        public var dataTypeName: Swift.String?

        public init(
            dataSourceType: AmplifyUIBuilderClientTypes.FormDataSourceType? = nil,
            dataTypeName: Swift.String? = nil
        )
        {
            self.dataSourceType = dataSourceType
            self.dataTypeName = dataTypeName
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = self.bindingProperties {
            try encodeContainer.encode(bindingProperties, forKey: .bindingProperties)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValueProperties.self, forKey: .bindingProperties)
        bindingProperties = bindingPropertiesDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the data binding configuration for a form's input fields at runtime.You can use FormInputBindingPropertiesValue to add exposed properties to a form to allow different values to be entered when a form is reused in different places in an app.
    public struct FormInputBindingPropertiesValue: Swift.Equatable {
        /// Describes the properties to customize with data at runtime.
        public var bindingProperties: AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValueProperties?
        /// The property type.
        public var type: Swift.String?

        public init(
            bindingProperties: AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValueProperties? = nil,
            type: Swift.String? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.type = type
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValueProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case model
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the data binding configuration for a specific property using data stored in Amazon Web Services. For Amazon Web Services connected properties, you can bind a property to data stored in an Amplify DataStore model.
    public struct FormInputBindingPropertiesValueProperties: Swift.Equatable {
        /// An Amplify DataStore model.
        public var model: Swift.String?

        public init(
            model: Swift.String? = nil
        )
        {
            self.model = model
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormInputValueProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case concat
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = self.bindingProperties {
            try encodeContainer.encode(bindingProperties, forKey: .bindingProperties)
        }
        if let concat = concat {
            var concatContainer = encodeContainer.nestedUnkeyedContainer(forKey: .concat)
            for forminputvalueproperty0 in concat {
                try concatContainer.encode(forminputvalueproperty0)
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let bindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormInputValuePropertyBindingProperties.self, forKey: .bindingProperties)
        bindingProperties = bindingPropertiesDecoded
        let concatContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.FormInputValueProperty?].self, forKey: .concat)
        var concatDecoded0:[AmplifyUIBuilderClientTypes.FormInputValueProperty]? = nil
        if let concatContainer = concatContainer {
            concatDecoded0 = [AmplifyUIBuilderClientTypes.FormInputValueProperty]()
            for structure0 in concatContainer {
                if let structure0 = structure0 {
                    concatDecoded0?.append(structure0)
                }
            }
        }
        concat = concatDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for an input field on a form. Use FormInputValueProperty to specify the values to render or bind by default.
    public struct FormInputValueProperty: Swift.Equatable {
        /// The information to bind fields to data at runtime.
        public var bindingProperties: AmplifyUIBuilderClientTypes.FormInputValuePropertyBindingProperties?
        /// A list of form properties to concatenate to create the value to assign to this field property.
        public var concat: [AmplifyUIBuilderClientTypes.FormInputValueProperty]?
        /// The value to assign to the input field.
        public var value: Swift.String?

        public init(
            bindingProperties: AmplifyUIBuilderClientTypes.FormInputValuePropertyBindingProperties? = nil,
            concat: [AmplifyUIBuilderClientTypes.FormInputValueProperty]? = nil,
            value: Swift.String? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.concat = concat
            self.value = value
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormInputValuePropertyBindingProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case property
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Associates a form property to a binding property. This enables exposed properties on the top level form to propagate data to the form's property values.
    public struct FormInputValuePropertyBindingProperties: Swift.Equatable {
        /// The data field to bind the property to.
        public var field: Swift.String?
        /// The form property to bind to the data field.
        /// This member is required.
        public var property: Swift.String?

        public init(
            field: Swift.String? = nil,
            property: Swift.String? = nil
        )
        {
            self.field = field
            self.property = property
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormStyle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case horizontalGap
        case outerPadding
        case verticalGap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let horizontalGap = self.horizontalGap {
            try encodeContainer.encode(horizontalGap, forKey: .horizontalGap)
        }
        if let outerPadding = self.outerPadding {
            try encodeContainer.encode(outerPadding, forKey: .outerPadding)
        }
        if let verticalGap = self.verticalGap {
            try encodeContainer.encode(verticalGap, forKey: .verticalGap)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let horizontalGapDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyleConfig.self, forKey: .horizontalGap)
        horizontalGap = horizontalGapDecoded
        let verticalGapDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyleConfig.self, forKey: .verticalGap)
        verticalGap = verticalGapDecoded
        let outerPaddingDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyleConfig.self, forKey: .outerPadding)
        outerPadding = outerPaddingDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for the form's style.
    public struct FormStyle: Swift.Equatable {
        /// The spacing for the horizontal gap.
        public var horizontalGap: AmplifyUIBuilderClientTypes.FormStyleConfig?
        /// The size of the outer padding for the form.
        public var outerPadding: AmplifyUIBuilderClientTypes.FormStyleConfig?
        /// The spacing for the vertical gap.
        public var verticalGap: AmplifyUIBuilderClientTypes.FormStyleConfig?

        public init(
            horizontalGap: AmplifyUIBuilderClientTypes.FormStyleConfig? = nil,
            outerPadding: AmplifyUIBuilderClientTypes.FormStyleConfig? = nil,
            verticalGap: AmplifyUIBuilderClientTypes.FormStyleConfig? = nil
        )
        {
            self.horizontalGap = horizontalGap
            self.outerPadding = outerPadding
            self.verticalGap = verticalGap
        }
    }

}

extension AmplifyUIBuilderClientTypes.FormStyleConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case tokenreference = "tokenReference"
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .tokenreference(tokenreference):
                try container.encode(tokenreference, forKey: .tokenreference)
            case let .value(value):
                try container.encode(value, forKey: .value)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tokenreferenceDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .tokenreference)
        if let tokenreference = tokenreferenceDecoded {
            self = .tokenreference(tokenreference)
            return
        }
        let valueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .value)
        if let value = valueDecoded {
            self = .value(value)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration settings for the form's style properties.
    public enum FormStyleConfig: Swift.Equatable {
        /// A reference to a design token to use to bind the form's style properties to an existing theme.
        case tokenreference(Swift.String)
        /// The value of the style setting.
        case value(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AmplifyUIBuilderClientTypes.FormSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case dataType
        case environmentName
        case formActionType
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let formActionType = self.formActionType {
            try encodeContainer.encode(formActionType.rawValue, forKey: .formActionType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataTypeConfig.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let formActionTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormActionType.self, forKey: .formActionType)
        formActionType = formActionTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the basic information about a form.
    public struct FormSummary: Swift.Equatable {
        /// The unique ID for the app associated with the form summary.
        /// This member is required.
        public var appId: Swift.String?
        /// The form's data source type.
        /// This member is required.
        public var dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig?
        /// The name of the backend environment that is part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The type of operation to perform on the form.
        /// This member is required.
        public var formActionType: AmplifyUIBuilderClientTypes.FormActionType?
        /// The ID of the form.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the form.
        /// This member is required.
        public var name: Swift.String?

        public init(
            appId: Swift.String? = nil,
            dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig? = nil,
            environmentName: Swift.String? = nil,
            formActionType: AmplifyUIBuilderClientTypes.FormActionType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appId = appId
            self.dataType = dataType
            self.environmentName = environmentName
            self.formActionType = formActionType
            self.id = id
            self.name = name
        }
    }

}

extension AmplifyUIBuilderClientTypes {
    public enum GenericDataRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case belongsTo
        case hasMany
        case hasOne
        case sdkUnknown(Swift.String)

        public static var allCases: [GenericDataRelationshipType] {
            return [
                .belongsTo,
                .hasMany,
                .hasOne,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .belongsTo: return "BELONGS_TO"
            case .hasMany: return "HAS_MANY"
            case .hasOne: return "HAS_ONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GenericDataRelationshipType(rawValue: rawValue) ?? GenericDataRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension GetCodegenJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/codegen-jobs/\(id.urlPercentEncoding())"
    }
}

public struct GetCodegenJobInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the code generation job.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app associated with the code generation job.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the code generation job.
    /// This member is required.
    public var id: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct GetCodegenJobInputBody: Swift.Equatable {
}

extension GetCodegenJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCodegenJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.CodegenJob = try responseDecoder.decode(responseBody: data)
            self.job = output
        } else {
            self.job = nil
        }
    }
}

public struct GetCodegenJobOutput: Swift.Equatable {
    /// The configuration settings for the code generation job.
    public var job: AmplifyUIBuilderClientTypes.CodegenJob?

    public init(
        job: AmplifyUIBuilderClientTypes.CodegenJob? = nil
    )
    {
        self.job = job
    }
}

struct GetCodegenJobOutputBody: Swift.Equatable {
    let job: AmplifyUIBuilderClientTypes.CodegenJob?
}

extension GetCodegenJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenJob.self, forKey: .job)
        job = jobDecoded
    }
}

enum GetCodegenJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components/\(id.urlPercentEncoding())"
    }
}

public struct GetComponentInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the component.
    /// This member is required.
    public var id: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct GetComponentInputBody: Swift.Equatable {
}

extension GetComponentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.Component = try responseDecoder.decode(responseBody: data)
            self.component = output
        } else {
            self.component = nil
        }
    }
}

public struct GetComponentOutput: Swift.Equatable {
    /// Represents the configuration settings for the component.
    public var component: AmplifyUIBuilderClientTypes.Component?

    public init(
        component: AmplifyUIBuilderClientTypes.Component? = nil
    )
    {
        self.component = component
    }
}

struct GetComponentOutputBody: Swift.Equatable {
    let component: AmplifyUIBuilderClientTypes.Component?
}

extension GetComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

enum GetComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms/\(id.urlPercentEncoding())"
    }
}

public struct GetFormInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the form.
    /// This member is required.
    public var id: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct GetFormInputBody: Swift.Equatable {
}

extension GetFormInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.Form = try responseDecoder.decode(responseBody: data)
            self.form = output
        } else {
            self.form = nil
        }
    }
}

public struct GetFormOutput: Swift.Equatable {
    /// Represents the configuration settings for the form.
    public var form: AmplifyUIBuilderClientTypes.Form?

    public init(
        form: AmplifyUIBuilderClientTypes.Form? = nil
    )
    {
        self.form = form
    }
}

struct GetFormOutputBody: Swift.Equatable {
    let form: AmplifyUIBuilderClientTypes.Form?
}

extension GetFormOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case form
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Form.self, forKey: .form)
        form = formDecoded
    }
}

enum GetFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/metadata"
    }
}

public struct GetMetadataInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

struct GetMetadataInputBody: Swift.Equatable {
}

extension GetMetadataInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.features = output.features
        } else {
            self.features = nil
        }
    }
}

public struct GetMetadataOutput: Swift.Equatable {
    /// Represents the configuration settings for the features metadata.
    /// This member is required.
    public var features: [Swift.String:Swift.String]?

    public init(
        features: [Swift.String:Swift.String]? = nil
    )
    {
        self.features = features
    }
}

struct GetMetadataOutputBody: Swift.Equatable {
    let features: [Swift.String:Swift.String]?
}

extension GetMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case features
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featuresContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .features)
        var featuresDecoded0: [Swift.String:Swift.String]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?[key0] = string0
                }
            }
        }
        features = featuresDecoded0
    }
}

enum GetMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes/\(id.urlPercentEncoding())"
    }
}

public struct GetThemeInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the theme.
    /// This member is required.
    public var id: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct GetThemeInputBody: Swift.Equatable {
}

extension GetThemeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetThemeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.Theme = try responseDecoder.decode(responseBody: data)
            self.theme = output
        } else {
            self.theme = nil
        }
    }
}

public struct GetThemeOutput: Swift.Equatable {
    /// Represents the configuration settings for the theme.
    public var theme: AmplifyUIBuilderClientTypes.Theme?

    public init(
        theme: AmplifyUIBuilderClientTypes.Theme? = nil
    )
    {
        self.theme = theme
    }
}

struct GetThemeOutputBody: Swift.Equatable {
    let theme: AmplifyUIBuilderClientTypes.Theme?
}

extension GetThemeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case theme
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Theme.self, forKey: .theme)
        theme = themeDecoded
    }
}

enum GetThemeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.GraphQLRenderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fragmentsFilePath
        case mutationsFilePath
        case queriesFilePath
        case subscriptionsFilePath
        case typesFilePath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fragmentsFilePath = self.fragmentsFilePath {
            try encodeContainer.encode(fragmentsFilePath, forKey: .fragmentsFilePath)
        }
        if let mutationsFilePath = self.mutationsFilePath {
            try encodeContainer.encode(mutationsFilePath, forKey: .mutationsFilePath)
        }
        if let queriesFilePath = self.queriesFilePath {
            try encodeContainer.encode(queriesFilePath, forKey: .queriesFilePath)
        }
        if let subscriptionsFilePath = self.subscriptionsFilePath {
            try encodeContainer.encode(subscriptionsFilePath, forKey: .subscriptionsFilePath)
        }
        if let typesFilePath = self.typesFilePath {
            try encodeContainer.encode(typesFilePath, forKey: .typesFilePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typesFilePath)
        typesFilePath = typesFilePathDecoded
        let queriesFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queriesFilePath)
        queriesFilePath = queriesFilePathDecoded
        let mutationsFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mutationsFilePath)
        mutationsFilePath = mutationsFilePathDecoded
        let subscriptionsFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionsFilePath)
        subscriptionsFilePath = subscriptionsFilePathDecoded
        let fragmentsFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fragmentsFilePath)
        fragmentsFilePath = fragmentsFilePathDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the GraphQL configuration for an API for a code generation job.
    public struct GraphQLRenderConfig: Swift.Equatable {
        /// The path to the GraphQL fragments file, relative to the component output directory.
        /// This member is required.
        public var fragmentsFilePath: Swift.String?
        /// The path to the GraphQL mutations file, relative to the component output directory.
        /// This member is required.
        public var mutationsFilePath: Swift.String?
        /// The path to the GraphQL queries file, relative to the component output directory.
        /// This member is required.
        public var queriesFilePath: Swift.String?
        /// The path to the GraphQL subscriptions file, relative to the component output directory.
        /// This member is required.
        public var subscriptionsFilePath: Swift.String?
        /// The path to the GraphQL types file, relative to the component output directory.
        /// This member is required.
        public var typesFilePath: Swift.String?

        public init(
            fragmentsFilePath: Swift.String? = nil,
            mutationsFilePath: Swift.String? = nil,
            queriesFilePath: Swift.String? = nil,
            subscriptionsFilePath: Swift.String? = nil,
            typesFilePath: Swift.String? = nil
        )
        {
            self.fragmentsFilePath = fragmentsFilePath
            self.mutationsFilePath = mutationsFilePath
            self.queriesFilePath = queriesFilePath
            self.subscriptionsFilePath = subscriptionsFilePath
            self.typesFilePath = typesFilePath
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error has occurred. Please retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An invalid or out-of-range value was supplied for the input parameter.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    public enum JSModule: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case es2020
        case esnext
        case sdkUnknown(Swift.String)

        public static var allCases: [JSModule] {
            return [
                .es2020,
                .esnext,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .es2020: return "es2020"
            case .esnext: return "esnext"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JSModule(rawValue: rawValue) ?? JSModule.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes {
    public enum JSScript: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case js
        case jsx
        case tsx
        case sdkUnknown(Swift.String)

        public static var allCases: [JSScript] {
            return [
                .js,
                .jsx,
                .tsx,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .js: return "js"
            case .jsx: return "jsx"
            case .tsx: return "tsx"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JSScript(rawValue: rawValue) ?? JSScript.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes {
    public enum JSTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case es2015
        case es2020
        case sdkUnknown(Swift.String)

        public static var allCases: [JSTarget] {
            return [
                .es2015,
                .es2020,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .es2015: return "es2015"
            case .es2020: return "es2020"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JSTarget(rawValue: rawValue) ?? JSTarget.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes {
    public enum LabelDecorator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case `optional`
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [LabelDecorator] {
            return [
                .none,
                .optional,
                .required,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "none"
            case .optional: return "optional"
            case .required: return "required"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LabelDecorator(rawValue: rawValue) ?? LabelDecorator.sdkUnknown(rawValue)
        }
    }
}

extension ListCodegenJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCodegenJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/codegen-jobs"
    }
}

public struct ListCodegenJobsInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The maximum number of jobs to retrieve.
    public var maxResults: Swift.Int?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCodegenJobsInputBody: Swift.Equatable {
}

extension ListCodegenJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCodegenJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCodegenJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ListCodegenJobsOutput: Swift.Equatable {
    /// The list of code generation jobs for the Amplify app.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.CodegenJobSummary]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        entities: [AmplifyUIBuilderClientTypes.CodegenJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ListCodegenJobsOutputBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.CodegenJobSummary]?
    let nextToken: Swift.String?
}

extension ListCodegenJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.CodegenJobSummary?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.CodegenJobSummary]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.CodegenJobSummary]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCodegenJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListComponentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The maximum number of components to retrieve.
    public var maxResults: Swift.Int
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentsInputBody: Swift.Equatable {
}

extension ListComponentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutput: Swift.Equatable {
    /// The list of components for the Amplify app.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.ComponentSummary]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        entities: [AmplifyUIBuilderClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.ComponentSummary]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentSummary?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.ComponentSummary]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.ComponentSummary]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFormsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFormsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms"
    }
}

public struct ListFormsInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The maximum number of forms to retrieve.
    public var maxResults: Swift.Int
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFormsInputBody: Swift.Equatable {
}

extension ListFormsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFormsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFormsOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ListFormsOutput: Swift.Equatable {
    /// The list of forms for the Amplify app.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.FormSummary]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        entities: [AmplifyUIBuilderClientTypes.FormSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ListFormsOutputBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.FormSummary]?
    let nextToken: Swift.String?
}

extension ListFormsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.FormSummary?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.FormSummary]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.FormSummary]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFormsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThemesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThemesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes"
    }
}

public struct ListThemesInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The maximum number of theme results to return in the response.
    public var maxResults: Swift.Int
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThemesInputBody: Swift.Equatable {
}

extension ListThemesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThemesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThemesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ListThemesOutput: Swift.Equatable {
    /// The list of themes for the Amplify app.
    /// This member is required.
    public var entities: [AmplifyUIBuilderClientTypes.ThemeSummary]?
    /// The pagination token that's returned if more results are available.
    public var nextToken: Swift.String?

    public init(
        entities: [AmplifyUIBuilderClientTypes.ThemeSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ListThemesOutputBody: Swift.Equatable {
    let entities: [AmplifyUIBuilderClientTypes.ThemeSummary]?
    let nextToken: Swift.String?
}

extension ListThemesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeSummary?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUIBuilderClientTypes.ThemeSummary]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeSummary]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThemesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.MutationActionSetStateParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentName
        case property
        case `set` = "set"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let property = self.property {
            try encodeContainer.encode(property, forKey: .property)
        }
        if let `set` = self.`set` {
            try encodeContainer.encode(`set`, forKey: .`set`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
        let setDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ComponentProperty.self, forKey: .set)
        `set` = setDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the state configuration when an action modifies a property of another element within the same component.
    public struct MutationActionSetStateParameter: Swift.Equatable {
        /// The name of the component that is being modified.
        /// This member is required.
        public var componentName: Swift.String?
        /// The name of the component property to apply the state configuration to.
        /// This member is required.
        public var property: Swift.String?
        /// The state configuration to assign to the property.
        /// This member is required.
        public var `set`: AmplifyUIBuilderClientTypes.ComponentProperty?

        public init(
            componentName: Swift.String? = nil,
            property: Swift.String? = nil,
            `set`: AmplifyUIBuilderClientTypes.ComponentProperty? = nil
        )
        {
            self.componentName = componentName
            self.property = property
            self.`set` = `set`
        }
    }

}

extension AmplifyUIBuilderClientTypes.NoApiRenderConfig: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration for an application with no API being used.
    public struct NoApiRenderConfig: Swift.Equatable {

        public init() { }
    }

}

extension AmplifyUIBuilderClientTypes.Predicate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and
        case field
        case operand
        case operandType
        case `operator` = "operator"
        case or
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for predicate0 in and {
                try andContainer.encode(predicate0)
            }
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let operand = self.operand {
            try encodeContainer.encode(operand, forKey: .operand)
        }
        if let operandType = self.operandType {
            try encodeContainer.encode(operandType, forKey: .operandType)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
        if let or = or {
            var orContainer = encodeContainer.nestedUnkeyedContainer(forKey: .or)
            for predicate0 in or {
                try orContainer.encode(predicate0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Predicate?].self, forKey: .or)
        var orDecoded0:[AmplifyUIBuilderClientTypes.Predicate]? = nil
        if let orContainer = orContainer {
            orDecoded0 = [AmplifyUIBuilderClientTypes.Predicate]()
            for structure0 in orContainer {
                if let structure0 = structure0 {
                    orDecoded0?.append(structure0)
                }
            }
        }
        or = orDecoded0
        let andContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.Predicate?].self, forKey: .and)
        var andDecoded0:[AmplifyUIBuilderClientTypes.Predicate]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [AmplifyUIBuilderClientTypes.Predicate]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operator)
        `operator` = operatorDecoded
        let operandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operand)
        operand = operandDecoded
        let operandTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operandType)
        operandType = operandTypeDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Stores information for generating Amplify DataStore queries. Use a Predicate to retrieve a subset of the data in a collection.
    public struct Predicate: Swift.Equatable {
        /// A list of predicates to combine logically.
        public var and: [AmplifyUIBuilderClientTypes.Predicate]?
        /// The field to query.
        public var field: Swift.String?
        /// The value to use when performing the evaluation.
        public var operand: Swift.String?
        /// The type of value to use when performing the evaluation.
        public var operandType: Swift.String?
        /// The operator to use to perform the evaluation.
        public var `operator`: Swift.String?
        /// A list of predicates to combine logically.
        public var or: [AmplifyUIBuilderClientTypes.Predicate]?

        public init(
            and: [AmplifyUIBuilderClientTypes.Predicate]? = nil,
            field: Swift.String? = nil,
            operand: Swift.String? = nil,
            operandType: Swift.String? = nil,
            `operator`: Swift.String? = nil,
            or: [AmplifyUIBuilderClientTypes.Predicate]? = nil
        )
        {
            self.and = and
            self.field = field
            self.operand = operand
            self.operandType = operandType
            self.`operator` = `operator`
            self.or = or
        }
    }

}

extension AmplifyUIBuilderClientTypes.PutMetadataFlagBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let newValue = self.newValue {
            try encodeContainer.encode(newValue, forKey: .newValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let newValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newValue)
        newValue = newValueDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Stores the metadata information about a feature on a form.
    public struct PutMetadataFlagBody: Swift.Equatable {
        /// The new information to store.
        /// This member is required.
        public var newValue: Swift.String?

        public init(
            newValue: Swift.String? = nil
        )
        {
            self.newValue = newValue
        }
    }

}

public struct PutMetadataFlagInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMetadataFlagInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMetadataFlagInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutMetadataFlagOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let body = input.operationInput.body {
                let bodyData = try encoder.encode(body)
                let bodyBody = ClientRuntime.HttpBody.data(bodyData)
                input.builder.withBody(bodyBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let bodyData = "{}".data(using: .utf8)!
                    let bodyBody = ClientRuntime.HttpBody.data(bodyData)
                    input.builder.withBody(bodyBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMetadataFlagInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMetadataFlagOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutMetadataFlagInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = self.body {
            try encodeContainer.encode(body, forKey: .body)
        }
    }
}

extension PutMetadataFlagInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let featureName = featureName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/metadata/features/\(featureName.urlPercentEncoding())"
    }
}

public struct PutMetadataFlagInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The metadata information to store.
    /// This member is required.
    public var body: AmplifyUIBuilderClientTypes.PutMetadataFlagBody?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The name of the feature associated with the metadata.
    /// This member is required.
    public var featureName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        body: AmplifyUIBuilderClientTypes.PutMetadataFlagBody? = nil,
        environmentName: Swift.String? = nil,
        featureName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.body = body
        self.environmentName = environmentName
        self.featureName = featureName
    }
}

struct PutMetadataFlagInputBody: Swift.Equatable {
    let body: AmplifyUIBuilderClientTypes.PutMetadataFlagBody?
}

extension PutMetadataFlagInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.PutMetadataFlagBody.self, forKey: .body)
        body = bodyDecoded
    }
}

extension PutMetadataFlagOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutMetadataFlagOutput: Swift.Equatable {

    public init() { }
}

enum PutMetadataFlagOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.ReactStartCodegenJobData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiConfiguration
        case dependencies
        case inlineSourceMap
        case module
        case renderTypeDeclarations
        case script
        case target
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiConfiguration = self.apiConfiguration {
            try encodeContainer.encode(apiConfiguration, forKey: .apiConfiguration)
        }
        if let dependencies = dependencies {
            var dependenciesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dependencies)
            for (dictKey0, reactCodegenDependencies0) in dependencies {
                try dependenciesContainer.encode(reactCodegenDependencies0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if inlineSourceMap != false {
            try encodeContainer.encode(inlineSourceMap, forKey: .inlineSourceMap)
        }
        if let module = self.module {
            try encodeContainer.encode(module.rawValue, forKey: .module)
        }
        if renderTypeDeclarations != false {
            try encodeContainer.encode(renderTypeDeclarations, forKey: .renderTypeDeclarations)
        }
        if let script = self.script {
            try encodeContainer.encode(script.rawValue, forKey: .script)
        }
        if let target = self.target {
            try encodeContainer.encode(target.rawValue, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let moduleDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.JSModule.self, forKey: .module)
        module = moduleDecoded
        let targetDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.JSTarget.self, forKey: .target)
        target = targetDecoded
        let scriptDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.JSScript.self, forKey: .script)
        script = scriptDecoded
        let renderTypeDeclarationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .renderTypeDeclarations) ?? false
        renderTypeDeclarations = renderTypeDeclarationsDecoded
        let inlineSourceMapDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inlineSourceMap) ?? false
        inlineSourceMap = inlineSourceMapDecoded
        let apiConfigurationDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ApiConfiguration.self, forKey: .apiConfiguration)
        apiConfiguration = apiConfigurationDecoded
        let dependenciesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dependencies)
        var dependenciesDecoded0: [Swift.String:Swift.String]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in dependenciesContainer {
                if let string0 = string0 {
                    dependenciesDecoded0?[key0] = string0
                }
            }
        }
        dependencies = dependenciesDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the code generation job configuration for a React project.
    public struct ReactStartCodegenJobData: Swift.Equatable {
        /// The API configuration for the code generation job.
        public var apiConfiguration: AmplifyUIBuilderClientTypes.ApiConfiguration?
        /// Lists the dependency packages that may be required for the project code to run.
        public var dependencies: [Swift.String:Swift.String]?
        /// Specifies whether the code generation job should render inline source maps.
        public var inlineSourceMap: Swift.Bool
        /// The JavaScript module type.
        public var module: AmplifyUIBuilderClientTypes.JSModule?
        /// Specifies whether the code generation job should render type declaration files.
        public var renderTypeDeclarations: Swift.Bool
        /// The file type to use for a JavaScript project.
        public var script: AmplifyUIBuilderClientTypes.JSScript?
        /// The ECMAScript specification to use.
        public var target: AmplifyUIBuilderClientTypes.JSTarget?

        public init(
            apiConfiguration: AmplifyUIBuilderClientTypes.ApiConfiguration? = nil,
            dependencies: [Swift.String:Swift.String]? = nil,
            inlineSourceMap: Swift.Bool = false,
            module: AmplifyUIBuilderClientTypes.JSModule? = nil,
            renderTypeDeclarations: Swift.Bool = false,
            script: AmplifyUIBuilderClientTypes.JSScript? = nil,
            target: AmplifyUIBuilderClientTypes.JSTarget? = nil
        )
        {
            self.apiConfiguration = apiConfiguration
            self.dependencies = dependencies
            self.inlineSourceMap = inlineSourceMap
            self.module = module
            self.renderTypeDeclarations = renderTypeDeclarations
            self.script = script
            self.target = target
        }
    }

}

public struct RefreshTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshTokenInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<RefreshTokenOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let refreshTokenBody = input.operationInput.refreshTokenBody {
                let refreshTokenBodyData = try encoder.encode(refreshTokenBody)
                let refreshTokenBodyBody = ClientRuntime.HttpBody.data(refreshTokenBodyData)
                input.builder.withBody(refreshTokenBodyBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let refreshTokenBodyData = "{}".data(using: .utf8)!
                    let refreshTokenBodyBody = ClientRuntime.HttpBody.data(refreshTokenBodyData)
                    input.builder.withBody(refreshTokenBodyBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTokenOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension RefreshTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshTokenBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let refreshTokenBody = self.refreshTokenBody {
            try encodeContainer.encode(refreshTokenBody, forKey: .refreshTokenBody)
        }
    }
}

extension RefreshTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let provider = provider else {
            return nil
        }
        return "/tokens/\(provider.rawValue.urlPercentEncoding())/refresh"
    }
}

public struct RefreshTokenInput: Swift.Equatable {
    /// The third-party provider for the token. The only valid value is figma.
    /// This member is required.
    public var provider: AmplifyUIBuilderClientTypes.TokenProviders?
    /// Information about the refresh token request.
    /// This member is required.
    public var refreshTokenBody: AmplifyUIBuilderClientTypes.RefreshTokenRequestBody?

    public init(
        provider: AmplifyUIBuilderClientTypes.TokenProviders? = nil,
        refreshTokenBody: AmplifyUIBuilderClientTypes.RefreshTokenRequestBody? = nil
    )
    {
        self.provider = provider
        self.refreshTokenBody = refreshTokenBody
    }
}

struct RefreshTokenInputBody: Swift.Equatable {
    let refreshTokenBody: AmplifyUIBuilderClientTypes.RefreshTokenRequestBody?
}

extension RefreshTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshTokenBody
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshTokenBodyDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.RefreshTokenRequestBody.self, forKey: .refreshTokenBody)
        refreshTokenBody = refreshTokenBodyDecoded
    }
}

extension RefreshTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTokenOutput(expiresIn: \(Swift.String(describing: expiresIn)), accessToken: \"CONTENT_REDACTED\")"}
}

extension RefreshTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RefreshTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
        } else {
            self.accessToken = nil
            self.expiresIn = nil
        }
    }
}

public struct RefreshTokenOutput: Swift.Equatable {
    /// The access token.
    /// This member is required.
    public var accessToken: Swift.String?
    /// The date and time when the new access token expires.
    /// This member is required.
    public var expiresIn: Swift.Int?

    public init(
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
    }
}

struct RefreshTokenOutputBody: Swift.Equatable {
    let accessToken: Swift.String?
    let expiresIn: Swift.Int?
}

extension RefreshTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
    }
}

enum RefreshTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.RefreshTokenRequestBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case token
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let token = self.token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
    }
}

extension AmplifyUIBuilderClientTypes.RefreshTokenRequestBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTokenRequestBody(clientId: \"CONTENT_REDACTED\", token: \"CONTENT_REDACTED\")"}
}

extension AmplifyUIBuilderClientTypes {
    /// Describes a refresh token.
    public struct RefreshTokenRequestBody: Swift.Equatable {
        /// The ID of the client to request the token from.
        public var clientId: Swift.String?
        /// The token to use to refresh a previously issued access token that might have expired.
        /// This member is required.
        public var token: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            token: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.token = token
        }
    }

}

extension ResourceConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in the request conflicts with an existing resource.
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource does not exist, or access was denied.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyUIBuilderClientTypes.SectionalElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case excluded
        case level
        case orientation
        case position
        case text
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let excluded = self.excluded {
            try encodeContainer.encode(excluded, forKey: .excluded)
        }
        if let level = self.level {
            try encodeContainer.encode(level, forKey: .level)
        }
        if let orientation = self.orientation {
            try encodeContainer.encode(orientation, forKey: .orientation)
        }
        if let position = self.position {
            try encodeContainer.encode(position, forKey: .position)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let positionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FieldPosition.self, forKey: .position)
        position = positionDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let levelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .level)
        level = levelDecoded
        let orientationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .orientation)
        orientation = orientationDecoded
        let excludedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .excluded)
        excluded = excludedDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Stores the configuration information for a visual helper element for a form. A sectional element can be a header, a text block, or a divider. These elements are static and not associated with any data.
    public struct SectionalElement: Swift.Equatable {
        /// Excludes a sectional element that was generated by default for a specified data model.
        public var excluded: Swift.Bool?
        /// Specifies the size of the font for a Heading sectional element. Valid values are 1 | 2 | 3 | 4 | 5 | 6.
        public var level: Swift.Int?
        /// Specifies the orientation for a Divider sectional element. Valid values are horizontal or vertical.
        public var orientation: Swift.String?
        /// Specifies the position of the text in a field for a Text sectional element.
        public var position: AmplifyUIBuilderClientTypes.FieldPosition?
        /// The text for a Text sectional element.
        public var text: Swift.String?
        /// The type of sectional element. Valid values are Heading, Text, and Divider.
        /// This member is required.
        public var type: Swift.String?

        public init(
            excluded: Swift.Bool? = nil,
            level: Swift.Int? = nil,
            orientation: Swift.String? = nil,
            position: AmplifyUIBuilderClientTypes.FieldPosition? = nil,
            text: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.excluded = excluded
            self.level = level
            self.orientation = orientation
            self.position = position
            self.text = text
            self.type = type
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your Amazon Web Services account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    public enum SortDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortDirection] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortDirection(rawValue: rawValue) ?? SortDirection.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.SortProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case direction
        case field
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let direction = self.direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let directionDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.SortDirection.self, forKey: .direction)
        direction = directionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes how to sort the data that you bind to a component.
    public struct SortProperty: Swift.Equatable {
        /// The direction of the sort, either ascending or descending.
        /// This member is required.
        public var direction: AmplifyUIBuilderClientTypes.SortDirection?
        /// The field to perform the sort on.
        /// This member is required.
        public var field: Swift.String?

        public init(
            direction: AmplifyUIBuilderClientTypes.SortDirection? = nil,
            field: Swift.String? = nil
        )
        {
            self.direction = direction
            self.field = field
        }
    }

}

extension AmplifyUIBuilderClientTypes.StartCodegenJobData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoGenerateForms
        case features
        case genericDataSchema
        case renderConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoGenerateForms = self.autoGenerateForms {
            try encodeContainer.encode(autoGenerateForms, forKey: .autoGenerateForms)
        }
        if let features = self.features {
            try encodeContainer.encode(features, forKey: .features)
        }
        if let genericDataSchema = self.genericDataSchema {
            try encodeContainer.encode(genericDataSchema, forKey: .genericDataSchema)
        }
        if let renderConfig = self.renderConfig {
            try encodeContainer.encode(renderConfig, forKey: .renderConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let renderConfigDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenJobRenderConfig.self, forKey: .renderConfig)
        renderConfig = renderConfigDecoded
        let genericDataSchemaDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenJobGenericDataSchema.self, forKey: .genericDataSchema)
        genericDataSchema = genericDataSchemaDecoded
        let autoGenerateFormsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoGenerateForms)
        autoGenerateForms = autoGenerateFormsDecoded
        let featuresDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenFeatureFlags.self, forKey: .features)
        features = featuresDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// The code generation job resource configuration.
    public struct StartCodegenJobData: Swift.Equatable {
        /// Specifies whether to autogenerate forms in the code generation job.
        public var autoGenerateForms: Swift.Bool?
        /// The feature flags for a code generation job.
        public var features: AmplifyUIBuilderClientTypes.CodegenFeatureFlags?
        /// The data schema to use for a code generation job.
        public var genericDataSchema: AmplifyUIBuilderClientTypes.CodegenJobGenericDataSchema?
        /// The code generation configuration for the codegen job.
        /// This member is required.
        public var renderConfig: AmplifyUIBuilderClientTypes.CodegenJobRenderConfig?
        /// One or more key-value pairs to use when tagging the code generation job data.
        public var tags: [Swift.String:Swift.String]?

        public init(
            autoGenerateForms: Swift.Bool? = nil,
            features: AmplifyUIBuilderClientTypes.CodegenFeatureFlags? = nil,
            genericDataSchema: AmplifyUIBuilderClientTypes.CodegenJobGenericDataSchema? = nil,
            renderConfig: AmplifyUIBuilderClientTypes.CodegenJobRenderConfig? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.autoGenerateForms = autoGenerateForms
            self.features = features
            self.genericDataSchema = genericDataSchema
            self.renderConfig = renderConfig
            self.tags = tags
        }
    }

}

public struct StartCodegenJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartCodegenJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartCodegenJobInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<StartCodegenJobOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let codegenJobToCreate = input.operationInput.codegenJobToCreate {
                let codegenJobToCreateData = try encoder.encode(codegenJobToCreate)
                let codegenJobToCreateBody = ClientRuntime.HttpBody.data(codegenJobToCreateData)
                input.builder.withBody(codegenJobToCreateBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let codegenJobToCreateData = "{}".data(using: .utf8)!
                    let codegenJobToCreateBody = ClientRuntime.HttpBody.data(codegenJobToCreateData)
                    input.builder.withBody(codegenJobToCreateBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartCodegenJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartCodegenJobOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension StartCodegenJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codegenJobToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codegenJobToCreate = self.codegenJobToCreate {
            try encodeContainer.encode(codegenJobToCreate, forKey: .codegenJobToCreate)
        }
    }
}

extension StartCodegenJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension StartCodegenJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/codegen-jobs"
    }
}

public struct StartCodegenJobInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The idempotency token used to ensure that the code generation job request completes only once.
    public var clientToken: Swift.String?
    /// The code generation job resource configuration.
    /// This member is required.
    public var codegenJobToCreate: AmplifyUIBuilderClientTypes.StartCodegenJobData?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init(
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        codegenJobToCreate: AmplifyUIBuilderClientTypes.StartCodegenJobData? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.codegenJobToCreate = codegenJobToCreate
        self.environmentName = environmentName
    }
}

struct StartCodegenJobInputBody: Swift.Equatable {
    let codegenJobToCreate: AmplifyUIBuilderClientTypes.StartCodegenJobData?
}

extension StartCodegenJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codegenJobToCreate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codegenJobToCreateDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.StartCodegenJobData.self, forKey: .codegenJobToCreate)
        codegenJobToCreate = codegenJobToCreateDecoded
    }
}

extension StartCodegenJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.CodegenJob = try responseDecoder.decode(responseBody: data)
            self.entity = output
        } else {
            self.entity = nil
        }
    }
}

public struct StartCodegenJobOutput: Swift.Equatable {
    /// The code generation job for a UI component that is associated with an Amplify app.
    public var entity: AmplifyUIBuilderClientTypes.CodegenJob?

    public init(
        entity: AmplifyUIBuilderClientTypes.CodegenJob? = nil
    )
    {
        self.entity = entity
    }
}

struct StartCodegenJobOutputBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.CodegenJob?
}

extension StartCodegenJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.CodegenJob.self, forKey: .entity)
        entity = entityDecoded
    }
}

enum StartCodegenJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes {
    public enum StorageAccessLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case protected
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageAccessLevel] {
            return [
                .private,
                .protected,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "private"
            case .protected: return "protected"
            case .public: return "public"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageAccessLevel(rawValue: rawValue) ?? StorageAccessLevel.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUIBuilderClientTypes.Theme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case createdAt
        case environmentName
        case id
        case modifiedAt
        case name
        case overrides
        case tags
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for themevalues0 in overrides {
                try overridesContainer.encode(themevalues0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for themevalues0 in values {
                try valuesContainer.encode(themevalues0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .overrides)
        var overridesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// A theme is a collection of style settings that apply globally to the components associated with an Amplify application.
    public struct Theme: Swift.Equatable {
        /// The unique ID for the Amplify app associated with the theme.
        /// This member is required.
        public var appId: Swift.String?
        /// The time that the theme was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID for the theme.
        /// This member is required.
        public var id: Swift.String?
        /// The time that the theme was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The name of the theme.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize a theme.
        public var overrides: [AmplifyUIBuilderClientTypes.ThemeValues]?
        /// One or more key-value pairs to use when tagging the theme.
        public var tags: [Swift.String:Swift.String]?
        /// A list of key-value pairs that defines the properties of the theme.
        /// This member is required.
        public var values: [AmplifyUIBuilderClientTypes.ThemeValues]?

        public init(
            appId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            overrides: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            values: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        )
        {
            self.appId = appId
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.overrides = overrides
            self.tags = tags
            self.values = values
        }
    }

}

extension AmplifyUIBuilderClientTypes.ThemeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case environmentName
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the basic information about a theme.
    public struct ThemeSummary: Swift.Equatable {
        /// The unique ID for the app associated with the theme summary.
        /// This member is required.
        public var appId: Swift.String?
        /// The name of the backend environment that is part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the theme.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the theme.
        /// This member is required.
        public var name: Swift.String?

        public init(
            appId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
            self.name = name
        }
    }

}

extension AmplifyUIBuilderClientTypes.ThemeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for themevalues0 in children {
                try childrenContainer.encode(themevalues0)
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Describes the configuration of a theme's properties.
    public struct ThemeValue: Swift.Equatable {
        /// A list of key-value pairs that define the theme's properties.
        public var children: [AmplifyUIBuilderClientTypes.ThemeValues]?
        /// The value of a theme property.
        public var value: Swift.String?

        public init(
            children: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil,
            value: Swift.String? = nil
        )
        {
            self.children = children
            self.value = value
        }
    }

}

extension AmplifyUIBuilderClientTypes.ThemeValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.ThemeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// A key-value pair that defines a property of a theme.
    public struct ThemeValues: Swift.Equatable {
        /// The name of the property.
        public var key: Swift.String?
        /// The value of the property.
        public var value: AmplifyUIBuilderClientTypes.ThemeValue?

        public init(
            key: Swift.String? = nil,
            value: AmplifyUIBuilderClientTypes.ThemeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    public enum TokenProviders: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The figma token provider.
        case figma
        case sdkUnknown(Swift.String)

        public static var allCases: [TokenProviders] {
            return [
                .figma,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .figma: return "figma"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TokenProviders(rawValue: rawValue) ?? TokenProviders.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have permission to perform this operation.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyUIBuilderClientTypes.UpdateComponentData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case children
        case collectionProperties
        case componentType
        case events
        case id
        case name
        case overrides
        case properties
        case schemaVersion
        case sourceId
        case variants
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, componentBindingProperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(componentBindingProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchild0 in children {
                try childrenContainer.encode(componentchild0)
            }
        }
        if let collectionProperties = collectionProperties {
            var collectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .collectionProperties)
            for (dictKey0, componentCollectionProperties0) in collectionProperties {
                try collectionPropertiesContainer.encode(componentCollectionProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .events)
            for (dictKey0, componentEvents0) in events {
                try eventsContainer.encode(componentEvents0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentOverrides0) in overrides {
                var componentOverrides0Container = overridesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, componentOverridesValue1) in componentOverrides0 {
                    try componentOverrides0Container.encode(componentOverridesValue1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentProperties0) in properties {
                try propertiesContainer.encode(componentProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sourceId = self.sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let variants = variants {
            var variantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variants)
            for componentvariant0 in variants {
                try variantsContainer.encode(componentvariant0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUIBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUIBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let variantsContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ComponentVariant?].self, forKey: .variants)
        var variantsDecoded0:[AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        if let variantsContainer = variantsContainer {
            variantsDecoded0 = [AmplifyUIBuilderClientTypes.ComponentVariant]()
            for structure0 in variantsContainer {
                if let structure0 = structure0 {
                    variantsDecoded0?.append(structure0)
                }
            }
        }
        variants = variantsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]()
            for (key0, componentbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let componentbindingpropertiesvalue0 = componentbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = componentbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
        let collectionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentDataConfiguration?].self, forKey: .collectionProperties)
        var collectionPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil
        if let collectionPropertiesContainer = collectionPropertiesContainer {
            collectionPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]()
            for (key0, componentdataconfiguration0) in collectionPropertiesContainer {
                if let componentdataconfiguration0 = componentdataconfiguration0 {
                    collectionPropertiesDecoded0?[key0] = componentdataconfiguration0
                }
            }
        }
        collectionProperties = collectionPropertiesDecoded0
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.ComponentEvent?].self, forKey: .events)
        var eventsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]()
            for (key0, componentevent0) in eventsContainer {
                if let componentevent0 = componentevent0 {
                    eventsDecoded0?[key0] = componentevent0
                }
            }
        }
        events = eventsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Updates and saves all of the information about a component, based on component ID.
    public struct UpdateComponentData: Swift.Equatable {
        /// The data binding information for the component's properties.
        public var bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]?
        /// The components that are instances of the main component.
        public var children: [AmplifyUIBuilderClientTypes.ComponentChild]?
        /// The configuration for binding a component's properties to a data model. Use this for a collection component.
        public var collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]?
        /// The type of the component. This can be an Amplify custom UI component or another custom component.
        public var componentType: Swift.String?
        /// The event configuration for the component. Use for the workflow feature in Amplify Studio that allows you to bind events and actions to components.
        public var events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]?
        /// The unique ID of the component to update.
        public var id: Swift.String?
        /// The name of the component to update.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize the component.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// Describes the component's properties.
        public var properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]?
        /// The schema version of the component when it was imported.
        public var schemaVersion: Swift.String?
        /// The unique ID of the component in its original source system, such as Figma.
        public var sourceId: Swift.String?
        /// A list of the unique variants of the main component being updated.
        public var variants: [AmplifyUIBuilderClientTypes.ComponentVariant]?

        public init(
            bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentBindingPropertiesValue]? = nil,
            children: [AmplifyUIBuilderClientTypes.ComponentChild]? = nil,
            collectionProperties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentDataConfiguration]? = nil,
            componentType: Swift.String? = nil,
            events: [Swift.String:AmplifyUIBuilderClientTypes.ComponentEvent]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            properties: [Swift.String:AmplifyUIBuilderClientTypes.ComponentProperty]? = nil,
            schemaVersion: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            variants: [AmplifyUIBuilderClientTypes.ComponentVariant]? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.events = events
            self.id = id
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.schemaVersion = schemaVersion
            self.sourceId = sourceId
            self.variants = variants
        }
    }

}

public struct UpdateComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateComponentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateComponentOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let updatedComponent = input.operationInput.updatedComponent {
                let updatedComponentData = try encoder.encode(updatedComponent)
                let updatedComponentBody = ClientRuntime.HttpBody.data(updatedComponentData)
                input.builder.withBody(updatedComponentBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let updatedComponentData = "{}".data(using: .utf8)!
                    let updatedComponentBody = ClientRuntime.HttpBody.data(updatedComponentData)
                    input.builder.withBody(updatedComponentBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateComponentOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedComponent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatedComponent = self.updatedComponent {
            try encodeContainer.encode(updatedComponent, forKey: .updatedComponent)
        }
    }
}

extension UpdateComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components/\(id.urlPercentEncoding())"
    }
}

public struct UpdateComponentInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the component.
    /// This member is required.
    public var id: Swift.String?
    /// The configuration of the updated component.
    /// This member is required.
    public var updatedComponent: AmplifyUIBuilderClientTypes.UpdateComponentData?

    public init(
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil,
        updatedComponent: AmplifyUIBuilderClientTypes.UpdateComponentData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.id = id
        self.updatedComponent = updatedComponent
    }
}

struct UpdateComponentInputBody: Swift.Equatable {
    let updatedComponent: AmplifyUIBuilderClientTypes.UpdateComponentData?
}

extension UpdateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedComponent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatedComponentDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.UpdateComponentData.self, forKey: .updatedComponent)
        updatedComponent = updatedComponentDecoded
    }
}

extension UpdateComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.Component = try responseDecoder.decode(responseBody: data)
            self.entity = output
        } else {
            self.entity = nil
        }
    }
}

public struct UpdateComponentOutput: Swift.Equatable {
    /// Describes the configuration of the updated component.
    public var entity: AmplifyUIBuilderClientTypes.Component?

    public init(
        entity: AmplifyUIBuilderClientTypes.Component? = nil
    )
    {
        self.entity = entity
    }
}

struct UpdateComponentOutputBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Component?
}

extension UpdateComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Component.self, forKey: .entity)
        entity = entityDecoded
    }
}

enum UpdateComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.UpdateFormData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cta
        case dataType
        case fields
        case formActionType
        case labelDecorator
        case name
        case schemaVersion
        case sectionalElements
        case style
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cta = self.cta {
            try encodeContainer.encode(cta, forKey: .cta)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let fields = fields {
            var fieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .fields)
            for (dictKey0, fieldsMap0) in fields {
                try fieldsContainer.encode(fieldsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let formActionType = self.formActionType {
            try encodeContainer.encode(formActionType.rawValue, forKey: .formActionType)
        }
        if let labelDecorator = self.labelDecorator {
            try encodeContainer.encode(labelDecorator.rawValue, forKey: .labelDecorator)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let sectionalElements = sectionalElements {
            var sectionalElementsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sectionalElements)
            for (dictKey0, sectionalElementMap0) in sectionalElements {
                try sectionalElementsContainer.encode(sectionalElementMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let style = self.style {
            try encodeContainer.encode(style, forKey: .style)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormDataTypeConfig.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let formActionTypeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormActionType.self, forKey: .formActionType)
        formActionType = formActionTypeDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.FieldConfig?].self, forKey: .fields)
        var fieldsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]()
            for (key0, fieldconfig0) in fieldsContainer {
                if let fieldconfig0 = fieldconfig0 {
                    fieldsDecoded0?[key0] = fieldconfig0
                }
            }
        }
        fields = fieldsDecoded0
        let styleDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormStyle.self, forKey: .style)
        style = styleDecoded
        let sectionalElementsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.SectionalElement?].self, forKey: .sectionalElements)
        var sectionalElementsDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil
        if let sectionalElementsContainer = sectionalElementsContainer {
            sectionalElementsDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]()
            for (key0, sectionalelement0) in sectionalElementsContainer {
                if let sectionalelement0 = sectionalelement0 {
                    sectionalElementsDecoded0?[key0] = sectionalelement0
                }
            }
        }
        sectionalElements = sectionalElementsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let ctaDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormCTA.self, forKey: .cta)
        cta = ctaDecoded
        let labelDecoratorDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.LabelDecorator.self, forKey: .labelDecorator)
        labelDecorator = labelDecoratorDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Updates and saves all of the information about a form, based on form ID.
    public struct UpdateFormData: Swift.Equatable {
        /// The FormCTA object that stores the call to action configuration for the form.
        public var cta: AmplifyUIBuilderClientTypes.FormCTA?
        /// The type of data source to use to create the form.
        public var dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig?
        /// The configuration information for the form's fields.
        public var fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]?
        /// Specifies whether to perform a create or update action on the form.
        public var formActionType: AmplifyUIBuilderClientTypes.FormActionType?
        /// Specifies an icon or decoration to display on the form.
        public var labelDecorator: AmplifyUIBuilderClientTypes.LabelDecorator?
        /// The name of the form.
        public var name: Swift.String?
        /// The schema version of the form.
        public var schemaVersion: Swift.String?
        /// The configuration information for the visual helper elements for the form. These elements are not associated with any data.
        public var sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]?
        /// The configuration for the form's style.
        public var style: AmplifyUIBuilderClientTypes.FormStyle?

        public init(
            cta: AmplifyUIBuilderClientTypes.FormCTA? = nil,
            dataType: AmplifyUIBuilderClientTypes.FormDataTypeConfig? = nil,
            fields: [Swift.String:AmplifyUIBuilderClientTypes.FieldConfig]? = nil,
            formActionType: AmplifyUIBuilderClientTypes.FormActionType? = nil,
            labelDecorator: AmplifyUIBuilderClientTypes.LabelDecorator? = nil,
            name: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            sectionalElements: [Swift.String:AmplifyUIBuilderClientTypes.SectionalElement]? = nil,
            style: AmplifyUIBuilderClientTypes.FormStyle? = nil
        )
        {
            self.cta = cta
            self.dataType = dataType
            self.fields = fields
            self.formActionType = formActionType
            self.labelDecorator = labelDecorator
            self.name = name
            self.schemaVersion = schemaVersion
            self.sectionalElements = sectionalElements
            self.style = style
        }
    }

}

public struct UpdateFormInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateFormInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateFormInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateFormOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let updatedForm = input.operationInput.updatedForm {
                let updatedFormData = try encoder.encode(updatedForm)
                let updatedFormBody = ClientRuntime.HttpBody.data(updatedFormData)
                input.builder.withBody(updatedFormBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let updatedFormData = "{}".data(using: .utf8)!
                    let updatedFormBody = ClientRuntime.HttpBody.data(updatedFormData)
                    input.builder.withBody(updatedFormBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateFormInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateFormOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateFormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedForm
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatedForm = self.updatedForm {
            try encodeContainer.encode(updatedForm, forKey: .updatedForm)
        }
    }
}

extension UpdateFormInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdateFormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/forms/\(id.urlPercentEncoding())"
    }
}

public struct UpdateFormInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the form.
    /// This member is required.
    public var id: Swift.String?
    /// The request accepts the following data in JSON format.
    /// This member is required.
    public var updatedForm: AmplifyUIBuilderClientTypes.UpdateFormData?

    public init(
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil,
        updatedForm: AmplifyUIBuilderClientTypes.UpdateFormData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.id = id
        self.updatedForm = updatedForm
    }
}

struct UpdateFormInputBody: Swift.Equatable {
    let updatedForm: AmplifyUIBuilderClientTypes.UpdateFormData?
}

extension UpdateFormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedForm
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatedFormDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.UpdateFormData.self, forKey: .updatedForm)
        updatedForm = updatedFormDecoded
    }
}

extension UpdateFormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.Form = try responseDecoder.decode(responseBody: data)
            self.entity = output
        } else {
            self.entity = nil
        }
    }
}

public struct UpdateFormOutput: Swift.Equatable {
    /// Describes the configuration of the updated form.
    public var entity: AmplifyUIBuilderClientTypes.Form?

    public init(
        entity: AmplifyUIBuilderClientTypes.Form? = nil
    )
    {
        self.entity = entity
    }
}

struct UpdateFormOutputBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Form?
}

extension UpdateFormOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Form.self, forKey: .entity)
        entity = entityDecoded
    }
}

enum UpdateFormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.UpdateThemeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case overrides
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for themevalues0 in overrides {
                try overridesContainer.encode(themevalues0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for themevalues0 in values {
                try valuesContainer.encode(themevalues0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ThemeValues?].self, forKey: .overrides)
        var overridesDecoded0:[AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [AmplifyUIBuilderClientTypes.ThemeValues]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Saves the data binding information for a theme.
    public struct UpdateThemeData: Swift.Equatable {
        /// The unique ID of the theme to update.
        public var id: Swift.String?
        /// The name of the theme to update.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize the theme.
        public var overrides: [AmplifyUIBuilderClientTypes.ThemeValues]?
        /// A list of key-value pairs that define the theme's properties.
        /// This member is required.
        public var values: [AmplifyUIBuilderClientTypes.ThemeValues]?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            overrides: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil,
            values: [AmplifyUIBuilderClientTypes.ThemeValues]? = nil
        )
        {
            self.id = id
            self.name = name
            self.overrides = overrides
            self.values = values
        }
    }

}

public struct UpdateThemeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateThemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateThemeInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateThemeOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let updatedTheme = input.operationInput.updatedTheme {
                let updatedThemeData = try encoder.encode(updatedTheme)
                let updatedThemeBody = ClientRuntime.HttpBody.data(updatedThemeData)
                input.builder.withBody(updatedThemeBody)
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let updatedThemeData = "{}".data(using: .utf8)!
                    let updatedThemeBody = ClientRuntime.HttpBody.data(updatedThemeData)
                    input.builder.withBody(updatedThemeBody)
                }
            }
        } catch let err {
            throw ClientRuntime.ClientError.unknownError(err.localizedDescription)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateThemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateThemeOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedTheme
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatedTheme = self.updatedTheme {
            try encodeContainer.encode(updatedTheme, forKey: .updatedTheme)
        }
    }
}

extension UpdateThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension UpdateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes/\(id.urlPercentEncoding())"
    }
}

public struct UpdateThemeInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the theme.
    /// This member is required.
    public var id: Swift.String?
    /// The configuration of the updated theme.
    /// This member is required.
    public var updatedTheme: AmplifyUIBuilderClientTypes.UpdateThemeData?

    public init(
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil,
        updatedTheme: AmplifyUIBuilderClientTypes.UpdateThemeData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.id = id
        self.updatedTheme = updatedTheme
    }
}

struct UpdateThemeInputBody: Swift.Equatable {
    let updatedTheme: AmplifyUIBuilderClientTypes.UpdateThemeData?
}

extension UpdateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedTheme
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatedThemeDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.UpdateThemeData.self, forKey: .updatedTheme)
        updatedTheme = updatedThemeDecoded
    }
}

extension UpdateThemeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: AmplifyUIBuilderClientTypes.Theme = try responseDecoder.decode(responseBody: data)
            self.entity = output
        } else {
            self.entity = nil
        }
    }
}

public struct UpdateThemeOutput: Swift.Equatable {
    /// Describes the configuration of the updated theme.
    public var entity: AmplifyUIBuilderClientTypes.Theme?

    public init(
        entity: AmplifyUIBuilderClientTypes.Theme? = nil
    )
    {
        self.entity = entity
    }
}

struct UpdateThemeOutputBody: Swift.Equatable {
    let entity: AmplifyUIBuilderClientTypes.Theme?
}

extension UpdateThemeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.Theme.self, forKey: .entity)
        entity = entityDecoded
    }
}

enum UpdateThemeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceConflictException": return try await ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AmplifyUIBuilderClientTypes.ValueMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayValue
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayValue = self.displayValue {
            try encodeContainer.encode(displayValue, forKey: .displayValue)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayValueDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormInputValueProperty.self, forKey: .displayValue)
        displayValue = displayValueDecoded
        let valueDecoded = try containerValues.decodeIfPresent(AmplifyUIBuilderClientTypes.FormInputValueProperty.self, forKey: .value)
        value = valueDecoded
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Associates a complex object with a display value. Use ValueMapping to store how to represent complex objects when they are displayed.
    public struct ValueMapping: Swift.Equatable {
        /// The value to display for the complex object.
        public var displayValue: AmplifyUIBuilderClientTypes.FormInputValueProperty?
        /// The complex object.
        /// This member is required.
        public var value: AmplifyUIBuilderClientTypes.FormInputValueProperty?

        public init(
            displayValue: AmplifyUIBuilderClientTypes.FormInputValueProperty? = nil,
            value: AmplifyUIBuilderClientTypes.FormInputValueProperty? = nil
        )
        {
            self.displayValue = displayValue
            self.value = value
        }
    }

}

extension AmplifyUIBuilderClientTypes.ValueMappings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, formInputBindingProperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(formInputBindingProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for valuemapping0 in values {
                try valuesContainer.encode(valuemapping0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUIBuilderClientTypes.ValueMapping?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUIBuilderClientTypes.ValueMapping]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUIBuilderClientTypes.ValueMapping]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValue]()
            for (key0, forminputbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let forminputbindingpropertiesvalue0 = forminputbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = forminputbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
    }
}

extension AmplifyUIBuilderClientTypes {
    /// Represents the data binding configuration for a value map.
    public struct ValueMappings: Swift.Equatable {
        /// The information to bind fields to data at runtime.
        public var bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValue]?
        /// The value and display value pairs.
        /// This member is required.
        public var values: [AmplifyUIBuilderClientTypes.ValueMapping]?

        public init(
            bindingProperties: [Swift.String:AmplifyUIBuilderClientTypes.FormInputBindingPropertiesValue]? = nil,
            values: [AmplifyUIBuilderClientTypes.ValueMapping]? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.values = values
        }
    }

}
