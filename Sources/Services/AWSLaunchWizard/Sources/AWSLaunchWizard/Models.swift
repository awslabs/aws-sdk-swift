//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

/// An internal error has occurred. Retry your request, but if the problem persists, contact us with details by posting a question on [re:Post](https://repost.aws/).
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded an Launch Wizard resource limit. For example, you might have too many deployments in progress.
public struct ResourceLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified workload or deployment resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateDeploymentInput: Swift.Sendable {
    /// The name of the deployment pattern supported by a given workload. You can use the [ListWorkloadDeploymentPatterns](https://docs.aws.amazon.com/launchwizard/latest/APIReference/API_ListWorkloadDeploymentPatterns.html) operation to discover supported values for this parameter.
    /// This member is required.
    public var deploymentPatternName: Swift.String?
    /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
    public var dryRun: Swift.Bool?
    /// The name of the deployment.
    /// This member is required.
    public var name: Swift.String?
    /// The settings specified for the deployment. These settings define how to deploy and configure your resources created by the deployment. For more information about the specifications required for creating a deployment for a SAP workload, see [SAP deployment specifications](https://docs.aws.amazon.com/launchwizard/latest/APIReference/launch-wizard-specifications-sap.html). To retrieve the specifications required to create a deployment for other workloads, use the [GetWorkloadDeploymentPattern](https://docs.aws.amazon.com/launchwizard/latest/APIReference/API_GetWorkloadDeploymentPattern.html) operation.
    /// This member is required.
    public var specifications: [Swift.String: Swift.String]?
    /// The tags to add to the deployment.
    public var tags: [Swift.String: Swift.String]?
    /// The name of the workload. You can use the [ListWorkloads](https://docs.aws.amazon.com/launchwizard/latest/APIReference/API_ListWorkloads.html) operation to discover supported values for this parameter.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        deploymentPatternName: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        name: Swift.String? = nil,
        specifications: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.deploymentPatternName = deploymentPatternName
        self.dryRun = dryRun
        self.name = name
        self.specifications = specifications
        self.tags = tags
        self.workloadName = workloadName
    }
}

extension CreateDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentInput(deploymentPatternName: \(Swift.String(describing: deploymentPatternName)), dryRun: \(Swift.String(describing: dryRun)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), workloadName: \(Swift.String(describing: workloadName)), specifications: \"CONTENT_REDACTED\")"}
}

public struct CreateDeploymentOutput: Swift.Sendable {
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

public struct DeleteDeploymentInput: Swift.Sendable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

extension LaunchWizardClientTypes {

    public enum DeploymentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case creating
        case deleted
        case deleteFailed
        case deleteInitiating
        case deleteInProgress
        case failed
        case inProgress
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .completed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleteInitiating,
                .deleteInProgress,
                .failed,
                .inProgress,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInitiating: return "DELETE_INITIATING"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteDeploymentOutput: Swift.Sendable {
    /// The status of the deployment.
    public var status: LaunchWizardClientTypes.DeploymentStatus?
    /// The reason for the deployment status.
    public var statusReason: Swift.String?

    public init(
        status: LaunchWizardClientTypes.DeploymentStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.status = status
        self.statusReason = statusReason
    }
}

public struct ListDeploymentEventsInput: Swift.Sendable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LaunchWizardClientTypes {

    public enum EventStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case created
        case failed
        case inProgress
        case pending
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .created,
                .failed,
                .inProgress,
                .pending,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LaunchWizardClientTypes {

    /// A summary of the deployment event data.
    public struct DeploymentEventDataSummary: Swift.Sendable {
        /// The description of the deployment event.
        public var description: Swift.String?
        /// The name of the deployment event.
        public var name: Swift.String?
        /// The status of the deployment event.
        public var status: LaunchWizardClientTypes.EventStatus?
        /// The reason of the deployment event status.
        public var statusReason: Swift.String?
        /// The timestamp of the deployment event.
        public var timestamp: Foundation.Date?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            status: LaunchWizardClientTypes.EventStatus? = nil,
            statusReason: Swift.String? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.description = description
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.timestamp = timestamp
        }
    }
}

public struct ListDeploymentEventsOutput: Swift.Sendable {
    /// Lists the deployment events.
    public var deploymentEvents: [LaunchWizardClientTypes.DeploymentEventDataSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        deploymentEvents: [LaunchWizardClientTypes.DeploymentEventDataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentEvents = deploymentEvents
        self.nextToken = nextToken
    }
}

public struct GetDeploymentInput: Swift.Sendable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

extension LaunchWizardClientTypes {

    /// The data associated with a deployment.
    public struct DeploymentData: Swift.Sendable {
        /// The time the deployment was created.
        public var createdAt: Foundation.Date?
        /// The time the deployment was deleted.
        public var deletedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the deployment.
        public var deploymentArn: Swift.String?
        /// The ID of the deployment.
        public var id: Swift.String?
        /// The name of the deployment.
        public var name: Swift.String?
        /// The pattern name of the deployment.
        public var patternName: Swift.String?
        /// The resource group of the deployment.
        public var resourceGroup: Swift.String?
        /// The settings specified for the deployment. These settings define how to deploy and configure your resources created by the deployment. For more information about the specifications required for creating a deployment for a SAP workload, see [SAP deployment specifications](https://docs.aws.amazon.com/launchwizard/latest/APIReference/launch-wizard-specifications-sap.html). To retrieve the specifications required to create a deployment for other workloads, use the [GetWorkloadDeploymentPattern](https://docs.aws.amazon.com/launchwizard/latest/APIReference/API_GetWorkloadDeploymentPattern.html) operation.
        public var specifications: [Swift.String: Swift.String]?
        /// The status of the deployment.
        public var status: LaunchWizardClientTypes.DeploymentStatus?
        /// Information about the tags attached to a deployment.
        public var tags: [Swift.String: Swift.String]?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            deletedAt: Foundation.Date? = nil,
            deploymentArn: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            patternName: Swift.String? = nil,
            resourceGroup: Swift.String? = nil,
            specifications: [Swift.String: Swift.String]? = nil,
            status: LaunchWizardClientTypes.DeploymentStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.deploymentArn = deploymentArn
            self.id = id
            self.name = name
            self.patternName = patternName
            self.resourceGroup = resourceGroup
            self.specifications = specifications
            self.status = status
            self.tags = tags
            self.workloadName = workloadName
        }
    }
}

extension LaunchWizardClientTypes.DeploymentData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentData(createdAt: \(Swift.String(describing: createdAt)), deletedAt: \(Swift.String(describing: deletedAt)), deploymentArn: \(Swift.String(describing: deploymentArn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), patternName: \(Swift.String(describing: patternName)), resourceGroup: \(Swift.String(describing: resourceGroup)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), workloadName: \(Swift.String(describing: workloadName)), specifications: \"CONTENT_REDACTED\")"}
}

public struct GetDeploymentOutput: Swift.Sendable {
    /// An object that details the deployment.
    public var deployment: LaunchWizardClientTypes.DeploymentData?

    public init(
        deployment: LaunchWizardClientTypes.DeploymentData? = nil
    )
    {
        self.deployment = deployment
    }
}

extension LaunchWizardClientTypes {

    public enum DeploymentFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deploymentStatus
        case workloadName
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentFilterKey] {
            return [
                .deploymentStatus,
                .workloadName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deploymentStatus: return "DEPLOYMENT_STATUS"
            case .workloadName: return "WORKLOAD_NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LaunchWizardClientTypes {

    /// A filter name and value pair that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria.
    public struct DeploymentFilter: Swift.Sendable {
        /// The name of the filter. Filter names are case-sensitive.
        public var name: LaunchWizardClientTypes.DeploymentFilterKey?
        /// The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
        public var values: [Swift.String]?

        public init(
            name: LaunchWizardClientTypes.DeploymentFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct ListDeploymentsInput: Swift.Sendable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * WORKLOAD_NAME - The name used in deployments.
    ///
    /// * DEPLOYMENT_STATUS - COMPLETED | CREATING | DELETE_IN_PROGRESS | DELETE_INITIATING | DELETE_FAILED | DELETED | FAILED | IN_PROGRESS | VALIDATING
    public var filters: [LaunchWizardClientTypes.DeploymentFilter]?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        filters: [LaunchWizardClientTypes.DeploymentFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LaunchWizardClientTypes {

    /// A summary of the deployment data.
    public struct DeploymentDataSummary: Swift.Sendable {
        /// The time the deployment was created.
        public var createdAt: Foundation.Date?
        /// The ID of the deployment.
        public var id: Swift.String?
        /// The name of the deployment
        public var name: Swift.String?
        /// The name of the workload deployment pattern.
        public var patternName: Swift.String?
        /// The status of the deployment.
        public var status: LaunchWizardClientTypes.DeploymentStatus?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            patternName: Swift.String? = nil,
            status: LaunchWizardClientTypes.DeploymentStatus? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.patternName = patternName
            self.status = status
            self.workloadName = workloadName
        }
    }
}

public struct ListDeploymentsOutput: Swift.Sendable {
    /// Lists the deployments.
    public var deployments: [LaunchWizardClientTypes.DeploymentDataSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        deployments: [LaunchWizardClientTypes.DeploymentDataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

extension LaunchWizardClientTypes {

    /// A field that details a condition of the specifications for a deployment.
    public struct DeploymentConditionalField: Swift.Sendable {
        /// The comparator of the condition. Valid values: Equal | NotEqual
        public var comparator: Swift.String?
        /// The name of the deployment condition.
        public var name: Swift.String?
        /// The value of the condition.
        public var value: Swift.String?

        public init(
            comparator: Swift.String? = nil,
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparator = comparator
            self.name = name
            self.value = value
        }
    }
}

extension LaunchWizardClientTypes {

    /// A field that details a specification of a deployment pattern.
    public struct DeploymentSpecificationsField: Swift.Sendable {
        /// The allowed values of the deployment specification.
        public var allowedValues: [Swift.String]?
        /// The conditionals used for the deployment specification.
        public var conditionals: [LaunchWizardClientTypes.DeploymentConditionalField]?
        /// The description of the deployment specification.
        public var description: Swift.String?
        /// The name of the deployment specification.
        public var name: Swift.String?
        /// Indicates if the deployment specification is required.
        public var `required`: Swift.String?

        public init(
            allowedValues: [Swift.String]? = nil,
            conditionals: [LaunchWizardClientTypes.DeploymentConditionalField]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            `required`: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.conditionals = conditionals
            self.description = description
            self.name = name
            self.`required` = `required`
        }
    }
}

public struct GetWorkloadInput: Swift.Sendable {
    /// The name of the workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        workloadName: Swift.String? = nil
    )
    {
        self.workloadName = workloadName
    }
}

extension LaunchWizardClientTypes {

    public enum WorkloadStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LaunchWizardClientTypes {

    /// Describes a workload.
    public struct WorkloadData: Swift.Sendable {
        /// The description of a workload.
        public var description: Swift.String?
        /// The display name of a workload.
        public var displayName: Swift.String?
        /// The URL of a workload document.
        public var documentationUrl: Swift.String?
        /// The URL of a workload icon.
        public var iconUrl: Swift.String?
        /// The status of a workload.
        public var status: LaunchWizardClientTypes.WorkloadStatus?
        /// The message about a workload's status.
        public var statusMessage: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            documentationUrl: Swift.String? = nil,
            iconUrl: Swift.String? = nil,
            status: LaunchWizardClientTypes.WorkloadStatus? = nil,
            statusMessage: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.documentationUrl = documentationUrl
            self.iconUrl = iconUrl
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
        }
    }
}

public struct GetWorkloadOutput: Swift.Sendable {
    /// Information about the workload.
    public var workload: LaunchWizardClientTypes.WorkloadData?

    public init(
        workload: LaunchWizardClientTypes.WorkloadData? = nil
    )
    {
        self.workload = workload
    }
}

public struct GetWorkloadDeploymentPatternInput: Swift.Sendable {
    /// The name of the deployment pattern.
    /// This member is required.
    public var deploymentPatternName: Swift.String?
    /// The name of the workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        deploymentPatternName: Swift.String? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.deploymentPatternName = deploymentPatternName
        self.workloadName = workloadName
    }
}

extension LaunchWizardClientTypes {

    public enum WorkloadDeploymentPatternStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadDeploymentPatternStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LaunchWizardClientTypes {

    /// The data that details a workload deployment pattern.
    public struct WorkloadDeploymentPatternData: Swift.Sendable {
        /// The name of the deployment pattern.
        public var deploymentPatternName: Swift.String?
        /// The description of the deployment pattern.
        public var description: Swift.String?
        /// The display name of the deployment pattern.
        public var displayName: Swift.String?
        /// The settings specified for the deployment. These settings define how to deploy and configure your resources created by the deployment. For more information about the specifications required for creating a deployment for a SAP workload, see [SAP deployment specifications](https://docs.aws.amazon.com/launchwizard/latest/APIReference/launch-wizard-specifications-sap.html). To retrieve the specifications required to create a deployment for other workloads, use the [GetWorkloadDeploymentPattern](https://docs.aws.amazon.com/launchwizard/latest/APIReference/API_GetWorkloadDeploymentPattern.html) operation.
        public var specifications: [LaunchWizardClientTypes.DeploymentSpecificationsField]?
        /// The status of the deployment pattern.
        public var status: LaunchWizardClientTypes.WorkloadDeploymentPatternStatus?
        /// The status message of the deployment pattern.
        public var statusMessage: Swift.String?
        /// The workload name of the deployment pattern.
        public var workloadName: Swift.String?
        /// The workload version name of the deployment pattern.
        public var workloadVersionName: Swift.String?

        public init(
            deploymentPatternName: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            specifications: [LaunchWizardClientTypes.DeploymentSpecificationsField]? = nil,
            status: LaunchWizardClientTypes.WorkloadDeploymentPatternStatus? = nil,
            statusMessage: Swift.String? = nil,
            workloadName: Swift.String? = nil,
            workloadVersionName: Swift.String? = nil
        )
        {
            self.deploymentPatternName = deploymentPatternName
            self.description = description
            self.displayName = displayName
            self.specifications = specifications
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
            self.workloadVersionName = workloadVersionName
        }
    }
}

public struct GetWorkloadDeploymentPatternOutput: Swift.Sendable {
    /// Details about the workload deployment pattern.
    public var workloadDeploymentPattern: LaunchWizardClientTypes.WorkloadDeploymentPatternData?

    public init(
        workloadDeploymentPattern: LaunchWizardClientTypes.WorkloadDeploymentPatternData? = nil
    )
    {
        self.workloadDeploymentPattern = workloadDeploymentPattern
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Information about the tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to attach to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys identifying the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct ListWorkloadsInput: Swift.Sendable {
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension LaunchWizardClientTypes {

    /// Describes workload data.
    public struct WorkloadDataSummary: Swift.Sendable {
        /// The display name of the workload data.
        public var displayName: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.workloadName = workloadName
        }
    }
}

public struct ListWorkloadsOutput: Swift.Sendable {
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?
    /// Information about the workloads.
    public var workloads: [LaunchWizardClientTypes.WorkloadDataSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloads: [LaunchWizardClientTypes.WorkloadDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloads = workloads
    }
}

public struct ListWorkloadDeploymentPatternsInput: Swift.Sendable {
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?
    /// The name of the workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadName = workloadName
    }
}

extension LaunchWizardClientTypes {

    /// Describes a workload deployment pattern.
    public struct WorkloadDeploymentPatternDataSummary: Swift.Sendable {
        /// The name of a workload deployment pattern.
        public var deploymentPatternName: Swift.String?
        /// The description of a workload deployment pattern.
        public var description: Swift.String?
        /// The display name of a workload deployment pattern.
        public var displayName: Swift.String?
        /// The status of a workload deployment pattern.
        public var status: LaunchWizardClientTypes.WorkloadDeploymentPatternStatus?
        /// A message about a workload deployment pattern's status.
        public var statusMessage: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?
        /// The name of the workload deployment pattern version.
        public var workloadVersionName: Swift.String?

        public init(
            deploymentPatternName: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            status: LaunchWizardClientTypes.WorkloadDeploymentPatternStatus? = nil,
            statusMessage: Swift.String? = nil,
            workloadName: Swift.String? = nil,
            workloadVersionName: Swift.String? = nil
        )
        {
            self.deploymentPatternName = deploymentPatternName
            self.description = description
            self.displayName = displayName
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
            self.workloadVersionName = workloadVersionName
        }
    }
}

public struct ListWorkloadDeploymentPatternsOutput: Swift.Sendable {
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?
    /// Describes the workload deployment patterns.
    public var workloadDeploymentPatterns: [LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloadDeploymentPatterns: [LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadDeploymentPatterns = workloadDeploymentPatterns
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        return "/createDeployment"
    }
}

extension DeleteDeploymentInput {

    static func urlPathProvider(_ value: DeleteDeploymentInput) -> Swift.String? {
        return "/deleteDeployment"
    }
}

extension GetDeploymentInput {

    static func urlPathProvider(_ value: GetDeploymentInput) -> Swift.String? {
        return "/getDeployment"
    }
}

extension GetWorkloadInput {

    static func urlPathProvider(_ value: GetWorkloadInput) -> Swift.String? {
        return "/getWorkload"
    }
}

extension GetWorkloadDeploymentPatternInput {

    static func urlPathProvider(_ value: GetWorkloadDeploymentPatternInput) -> Swift.String? {
        return "/getWorkloadDeploymentPattern"
    }
}

extension ListDeploymentEventsInput {

    static func urlPathProvider(_ value: ListDeploymentEventsInput) -> Swift.String? {
        return "/listDeploymentEvents"
    }
}

extension ListDeploymentsInput {

    static func urlPathProvider(_ value: ListDeploymentsInput) -> Swift.String? {
        return "/listDeployments"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListWorkloadDeploymentPatternsInput {

    static func urlPathProvider(_ value: ListWorkloadDeploymentPatternsInput) -> Swift.String? {
        return "/listWorkloadDeploymentPatterns"
    }
}

extension ListWorkloadsInput {

    static func urlPathProvider(_ value: ListWorkloadsInput) -> Swift.String? {
        return "/listWorkloads"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentPatternName"].write(value.deploymentPatternName)
        try writer["dryRun"].write(value.dryRun)
        try writer["name"].write(value.name)
        try writer["specifications"].writeMap(value.specifications, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["workloadName"].write(value.workloadName)
    }
}

extension DeleteDeploymentInput {

    static func write(value: DeleteDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentId"].write(value.deploymentId)
    }
}

extension GetDeploymentInput {

    static func write(value: GetDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentId"].write(value.deploymentId)
    }
}

extension GetWorkloadInput {

    static func write(value: GetWorkloadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workloadName"].write(value.workloadName)
    }
}

extension GetWorkloadDeploymentPatternInput {

    static func write(value: GetWorkloadDeploymentPatternInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentPatternName"].write(value.deploymentPatternName)
        try writer["workloadName"].write(value.workloadName)
    }
}

extension ListDeploymentEventsInput {

    static func write(value: ListDeploymentEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentId"].write(value.deploymentId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDeploymentsInput {

    static func write(value: ListDeploymentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: LaunchWizardClientTypes.DeploymentFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWorkloadDeploymentPatternsInput {

    static func write(value: ListWorkloadDeploymentPatternsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["workloadName"].write(value.workloadName)
    }
}

extension ListWorkloadsInput {

    static func write(value: ListWorkloadsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        return value
    }
}

extension DeleteDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDeploymentOutput()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension GetDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentOutput()
        value.deployment = try reader["deployment"].readIfPresent(with: LaunchWizardClientTypes.DeploymentData.read(from:))
        return value
    }
}

extension GetWorkloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadOutput()
        value.workload = try reader["workload"].readIfPresent(with: LaunchWizardClientTypes.WorkloadData.read(from:))
        return value
    }
}

extension GetWorkloadDeploymentPatternOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadDeploymentPatternOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadDeploymentPatternOutput()
        value.workloadDeploymentPattern = try reader["workloadDeploymentPattern"].readIfPresent(with: LaunchWizardClientTypes.WorkloadDeploymentPatternData.read(from:))
        return value
    }
}

extension ListDeploymentEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeploymentEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeploymentEventsOutput()
        value.deploymentEvents = try reader["deploymentEvents"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.DeploymentEventDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeploymentsOutput()
        value.deployments = try reader["deployments"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.DeploymentDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWorkloadDeploymentPatternsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkloadDeploymentPatternsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadDeploymentPatternsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workloadDeploymentPatterns = try reader["workloadDeploymentPatterns"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkloadsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkloadsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workloads = try reader["workloads"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.WorkloadDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceLimitException": return try ResourceLimitException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceLimitException": return try ResourceLimitException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadDeploymentPatternOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeploymentEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkloadDeploymentPatternsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkloadsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceLimitException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LaunchWizardClientTypes.DeploymentData {

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.DeploymentData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.DeploymentData()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.patternName = try reader["patternName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.specifications = try reader["specifications"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceGroup = try reader["resourceGroup"].readIfPresent()
        value.deletedAt = try reader["deletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.deploymentArn = try reader["deploymentArn"].readIfPresent()
        return value
    }
}

extension LaunchWizardClientTypes.WorkloadData {

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.WorkloadData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.WorkloadData()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.documentationUrl = try reader["documentationUrl"].readIfPresent()
        value.iconUrl = try reader["iconUrl"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension LaunchWizardClientTypes.WorkloadDeploymentPatternData {

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.WorkloadDeploymentPatternData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.WorkloadDeploymentPatternData()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.deploymentPatternName = try reader["deploymentPatternName"].readIfPresent()
        value.workloadVersionName = try reader["workloadVersionName"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.specifications = try reader["specifications"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.DeploymentSpecificationsField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LaunchWizardClientTypes.DeploymentSpecificationsField {

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.DeploymentSpecificationsField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.DeploymentSpecificationsField()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.allowedValues = try reader["allowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.`required` = try reader["required"].readIfPresent()
        value.conditionals = try reader["conditionals"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.DeploymentConditionalField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LaunchWizardClientTypes.DeploymentConditionalField {

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.DeploymentConditionalField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.DeploymentConditionalField()
        value.name = try reader["name"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.comparator = try reader["comparator"].readIfPresent()
        return value
    }
}

extension LaunchWizardClientTypes.DeploymentEventDataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.DeploymentEventDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.DeploymentEventDataSummary()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LaunchWizardClientTypes.DeploymentDataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.DeploymentDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.DeploymentDataSummary()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.patternName = try reader["patternName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.deploymentPatternName = try reader["deploymentPatternName"].readIfPresent()
        value.workloadVersionName = try reader["workloadVersionName"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension LaunchWizardClientTypes.WorkloadDataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.WorkloadDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.WorkloadDataSummary()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        return value
    }
}

extension LaunchWizardClientTypes.DeploymentFilter {

    static func write(value: LaunchWizardClientTypes.DeploymentFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum LaunchWizardClientTypes {}
