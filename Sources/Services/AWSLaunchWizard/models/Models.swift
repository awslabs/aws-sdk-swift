// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CreateDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentInput(deploymentPatternName: \(Swift.String(describing: deploymentPatternName)), dryRun: \(Swift.String(describing: dryRun)), name: \(Swift.String(describing: name)), workloadName: \(Swift.String(describing: workloadName)), specifications: \"CONTENT_REDACTED\")"}
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentPatternName
        case dryRun
        case name
        case specifications
        case workloadName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentPatternName = self.deploymentPatternName {
            try encodeContainer.encode(deploymentPatternName, forKey: .deploymentPatternName)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let specifications = specifications {
            var specificationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .specifications)
            for (dictKey0, deploymentSpecifications0) in specifications {
                try specificationsContainer.encode(deploymentSpecifications0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createDeployment"
    }
}

public struct CreateDeploymentInput: Swift.Equatable {
    /// The name of the deployment pattern supported by a given workload. You can use the [ListWorkloadDeploymentPatterns](https://docs.aws.amazon.com/launchwizard/latest/APIReference/API_ListWorkloadDeploymentPatterns.html) operation to discover supported values for this parameter.
    /// This member is required.
    public var deploymentPatternName: Swift.String?
    /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
    public var dryRun: Swift.Bool?
    /// The name of the deployment.
    /// This member is required.
    public var name: Swift.String?
    /// The settings specified for the deployment. For more information on the specifications required for creating a deployment, see [Workload specifications](https://docs.aws.amazon.com/launchwizard/latest/APIReference/launch-wizard-specifications.html).
    /// This member is required.
    public var specifications: [Swift.String:Swift.String]?
    /// The name of the workload. You can use the [ListWorkloadDeploymentPatterns](https://docs.aws.amazon.com/launchwizard/latest/APIReference/API_ListWorkloadDeploymentPatterns.html) operation to discover supported values for this parameter.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        deploymentPatternName: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        name: Swift.String? = nil,
        specifications: [Swift.String:Swift.String]? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.deploymentPatternName = deploymentPatternName
        self.dryRun = dryRun
        self.name = name
        self.specifications = specifications
        self.workloadName = workloadName
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let workloadName: Swift.String?
    let deploymentPatternName: Swift.String?
    let name: Swift.String?
    let specifications: [Swift.String:Swift.String]?
    let dryRun: Swift.Bool?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentPatternName
        case dryRun
        case name
        case specifications
        case workloadName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let deploymentPatternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentPatternName)
        deploymentPatternName = deploymentPatternNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let specificationsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .specifications)
        var specificationsDecoded0: [Swift.String:Swift.String]? = nil
        if let specificationsContainer = specificationsContainer {
            specificationsDecoded0 = [Swift.String:Swift.String]()
            for (key0, valuestring0) in specificationsContainer {
                if let valuestring0 = valuestring0 {
                    specificationsDecoded0?[key0] = valuestring0
                }
            }
        }
        specifications = specificationsDecoded0
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentId = nil
        }
    }
}

public struct CreateDeploymentOutput: Swift.Equatable {
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct CreateDeploymentOutputBody: Swift.Equatable {
    let deploymentId: Swift.String?
}

extension CreateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

enum CreateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitException": return try await ResourceLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
    }
}

extension DeleteDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteDeployment"
    }
}

public struct DeleteDeploymentInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct DeleteDeploymentInputBody: Swift.Equatable {
    let deploymentId: Swift.String?
}

extension DeleteDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

extension DeleteDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct DeleteDeploymentOutput: Swift.Equatable {
    /// The status of the deployment.
    public var status: LaunchWizardClientTypes.DeploymentStatus?
    /// The reason for the deployment status.
    public var statusReason: Swift.String?

    public init(
        status: LaunchWizardClientTypes.DeploymentStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.status = status
        self.statusReason = statusReason
    }
}

struct DeleteDeploymentOutputBody: Swift.Equatable {
    let status: LaunchWizardClientTypes.DeploymentStatus?
    let statusReason: Swift.String?
}

extension DeleteDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case statusReason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(LaunchWizardClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

enum DeleteDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LaunchWizardClientTypes.DeploymentData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case deletedAt
        case id
        case name
        case patternName
        case resourceGroup
        case specifications
        case status
        case workloadName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deletedAt = self.deletedAt {
            try encodeContainer.encodeTimestamp(deletedAt, format: .epochSeconds, forKey: .deletedAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let resourceGroup = self.resourceGroup {
            try encodeContainer.encode(resourceGroup, forKey: .resourceGroup)
        }
        if let specifications = specifications {
            var specificationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .specifications)
            for (dictKey0, deploymentSpecifications0) in specifications {
                try specificationsContainer.encode(deploymentSpecifications0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LaunchWizardClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let specificationsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .specifications)
        var specificationsDecoded0: [Swift.String:Swift.String]? = nil
        if let specificationsContainer = specificationsContainer {
            specificationsDecoded0 = [Swift.String:Swift.String]()
            for (key0, valuestring0) in specificationsContainer {
                if let valuestring0 = valuestring0 {
                    specificationsDecoded0?[key0] = valuestring0
                }
            }
        }
        specifications = specificationsDecoded0
        let resourceGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroup)
        resourceGroup = resourceGroupDecoded
        let deletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
    }
}

extension LaunchWizardClientTypes.DeploymentData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentData(createdAt: \(Swift.String(describing: createdAt)), deletedAt: \(Swift.String(describing: deletedAt)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), patternName: \(Swift.String(describing: patternName)), resourceGroup: \(Swift.String(describing: resourceGroup)), status: \(Swift.String(describing: status)), workloadName: \(Swift.String(describing: workloadName)), specifications: \"CONTENT_REDACTED\")"}
}

extension LaunchWizardClientTypes {
    /// The data associated with a deployment.
    public struct DeploymentData: Swift.Equatable {
        /// The time the deployment was created.
        public var createdAt: ClientRuntime.Date?
        /// The time the deployment was deleted.
        public var deletedAt: ClientRuntime.Date?
        /// The ID of the deployment.
        public var id: Swift.String?
        /// The name of the deployment.
        public var name: Swift.String?
        /// The pattern name of the deployment.
        public var patternName: Swift.String?
        /// The resource group of the deployment.
        public var resourceGroup: Swift.String?
        /// The specifications of the deployment. For more information on specifications for each deployment, see [Workload specifications](https://docs.aws.amazon.com/launchwizard/latest/APIReference/launch-wizard-specifications.html).
        public var specifications: [Swift.String:Swift.String]?
        /// The status of the deployment.
        public var status: LaunchWizardClientTypes.DeploymentStatus?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            patternName: Swift.String? = nil,
            resourceGroup: Swift.String? = nil,
            specifications: [Swift.String:Swift.String]? = nil,
            status: LaunchWizardClientTypes.DeploymentStatus? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.id = id
            self.name = name
            self.patternName = patternName
            self.resourceGroup = resourceGroup
            self.specifications = specifications
            self.status = status
            self.workloadName = workloadName
        }
    }

}

extension LaunchWizardClientTypes.DeploymentDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case id
        case name
        case patternName
        case status
        case workloadName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let patternName = self.patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LaunchWizardClientTypes.DeploymentStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension LaunchWizardClientTypes {
    /// A summary of the deployment data.
    public struct DeploymentDataSummary: Swift.Equatable {
        /// The time the deployment was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the deployment.
        public var id: Swift.String?
        /// The name of the deployment
        public var name: Swift.String?
        /// The name of the workload deployment pattern.
        public var patternName: Swift.String?
        /// The status of the deployment.
        public var status: LaunchWizardClientTypes.DeploymentStatus?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            patternName: Swift.String? = nil,
            status: LaunchWizardClientTypes.DeploymentStatus? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.patternName = patternName
            self.status = status
            self.workloadName = workloadName
        }
    }

}

extension LaunchWizardClientTypes.DeploymentEventDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case status
        case statusReason
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LaunchWizardClientTypes.EventStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension LaunchWizardClientTypes {
    /// A summary of the deployment event data.
    public struct DeploymentEventDataSummary: Swift.Equatable {
        /// The description of the deployment event.
        public var description: Swift.String?
        /// The name of the deployment event.
        public var name: Swift.String?
        /// The status of the deployment event.
        public var status: LaunchWizardClientTypes.EventStatus?
        /// The reason of the deployment event status.
        public var statusReason: Swift.String?
        /// The timestamp of the deployment event.
        public var timestamp: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            status: LaunchWizardClientTypes.EventStatus? = nil,
            statusReason: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.timestamp = timestamp
        }
    }

}

extension LaunchWizardClientTypes.DeploymentFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(LaunchWizardClientTypes.DeploymentFilterKey.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension LaunchWizardClientTypes {
    /// A filter name and value pair that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria.
    public struct DeploymentFilter: Swift.Equatable {
        /// The name of the filter. Filter names are case-sensitive.
        public var name: LaunchWizardClientTypes.DeploymentFilterKey?
        /// The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
        public var values: [Swift.String]?

        public init(
            name: LaunchWizardClientTypes.DeploymentFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension LaunchWizardClientTypes {
    public enum DeploymentFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploymentStatus
        case workloadName
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentFilterKey] {
            return [
                .deploymentStatus,
                .workloadName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploymentStatus: return "DEPLOYMENT_STATUS"
            case .workloadName: return "WORKLOAD_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentFilterKey(rawValue: rawValue) ?? DeploymentFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension LaunchWizardClientTypes {
    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case creating
        case deleted
        case deleteFailed
        case deleteInitiating
        case deleteInProgress
        case failed
        case inProgress
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .completed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleteInitiating,
                .deleteInProgress,
                .failed,
                .inProgress,
                .validating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInitiating: return "DELETE_INITIATING"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentStatus(rawValue: rawValue) ?? DeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension LaunchWizardClientTypes {
    public enum EventStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case created
        case failed
        case inProgress
        case pending
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .created,
                .failed,
                .inProgress,
                .pending,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventStatus(rawValue: rawValue) ?? EventStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
    }
}

extension GetDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getDeployment"
    }
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
    let deploymentId: Swift.String?
}

extension GetDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

extension GetDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployment = output.deployment
        } else {
            self.deployment = nil
        }
    }
}

public struct GetDeploymentOutput: Swift.Equatable {
    /// An object that details the deployment.
    public var deployment: LaunchWizardClientTypes.DeploymentData?

    public init(
        deployment: LaunchWizardClientTypes.DeploymentData? = nil
    )
    {
        self.deployment = deployment
    }
}

struct GetDeploymentOutputBody: Swift.Equatable {
    let deployment: LaunchWizardClientTypes.DeploymentData?
}

extension GetDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentDecoded = try containerValues.decodeIfPresent(LaunchWizardClientTypes.DeploymentData.self, forKey: .deployment)
        deployment = deploymentDecoded
    }
}

enum GetDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkloadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

extension GetWorkloadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getWorkload"
    }
}

public struct GetWorkloadInput: Swift.Equatable {
    /// The name of the workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        workloadName: Swift.String? = nil
    )
    {
        self.workloadName = workloadName
    }
}

struct GetWorkloadInputBody: Swift.Equatable {
    let workloadName: Swift.String?
}

extension GetWorkloadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workloadName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
    }
}

extension GetWorkloadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkloadOutputBody = try responseDecoder.decode(responseBody: data)
            self.workload = output.workload
        } else {
            self.workload = nil
        }
    }
}

public struct GetWorkloadOutput: Swift.Equatable {
    /// Information about the workload.
    public var workload: LaunchWizardClientTypes.WorkloadData?

    public init(
        workload: LaunchWizardClientTypes.WorkloadData? = nil
    )
    {
        self.workload = workload
    }
}

struct GetWorkloadOutputBody: Swift.Equatable {
    let workload: LaunchWizardClientTypes.WorkloadData?
}

extension GetWorkloadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workload
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDecoded = try containerValues.decodeIfPresent(LaunchWizardClientTypes.WorkloadData.self, forKey: .workload)
        workload = workloadDecoded
    }
}

enum GetWorkloadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error has occurred. Retry your request, but if the problem persists, contact us with details by posting a question on [re:Post](https://repost.aws/).
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDeploymentEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDeploymentEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDeploymentEvents"
    }
}

public struct ListDeploymentEventsInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentEventsInputBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDeploymentEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeploymentEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentEvents = output.deploymentEvents
            self.nextToken = output.nextToken
        } else {
            self.deploymentEvents = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentEventsOutput: Swift.Equatable {
    /// Lists the deployment events.
    public var deploymentEvents: [LaunchWizardClientTypes.DeploymentEventDataSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        deploymentEvents: [LaunchWizardClientTypes.DeploymentEventDataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentEvents = deploymentEvents
        self.nextToken = nextToken
    }
}

struct ListDeploymentEventsOutputBody: Swift.Equatable {
    let deploymentEvents: [LaunchWizardClientTypes.DeploymentEventDataSummary]?
    let nextToken: Swift.String?
}

extension ListDeploymentEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentEvents
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentEventsContainer = try containerValues.decodeIfPresent([LaunchWizardClientTypes.DeploymentEventDataSummary?].self, forKey: .deploymentEvents)
        var deploymentEventsDecoded0:[LaunchWizardClientTypes.DeploymentEventDataSummary]? = nil
        if let deploymentEventsContainer = deploymentEventsContainer {
            deploymentEventsDecoded0 = [LaunchWizardClientTypes.DeploymentEventDataSummary]()
            for structure0 in deploymentEventsContainer {
                if let structure0 = structure0 {
                    deploymentEventsDecoded0?.append(structure0)
                }
            }
        }
        deploymentEvents = deploymentEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeploymentEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeploymentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for deploymentfilter0 in filters {
                try filtersContainer.encode(deploymentfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listDeployments"
    }
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * WORKLOAD_NAME
    ///
    /// * DEPLOYMENT_STATUS
    public var filters: [LaunchWizardClientTypes.DeploymentFilter]?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        filters: [LaunchWizardClientTypes.DeploymentFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
    let filters: [LaunchWizardClientTypes.DeploymentFilter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDeploymentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([LaunchWizardClientTypes.DeploymentFilter?].self, forKey: .filters)
        var filtersDecoded0:[LaunchWizardClientTypes.DeploymentFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [LaunchWizardClientTypes.DeploymentFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutput: Swift.Equatable {
    /// Lists the deployments.
    public var deployments: [LaunchWizardClientTypes.DeploymentDataSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        deployments: [LaunchWizardClientTypes.DeploymentDataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputBody: Swift.Equatable {
    let deployments: [LaunchWizardClientTypes.DeploymentDataSummary]?
    let nextToken: Swift.String?
}

extension ListDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([LaunchWizardClientTypes.DeploymentDataSummary?].self, forKey: .deployments)
        var deploymentsDecoded0:[LaunchWizardClientTypes.DeploymentDataSummary]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [LaunchWizardClientTypes.DeploymentDataSummary]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkloadDeploymentPatternsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case workloadName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }
}

extension ListWorkloadDeploymentPatternsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorkloadDeploymentPatterns"
    }
}

public struct ListWorkloadDeploymentPatternsInput: Swift.Equatable {
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?
    /// The name of the workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadName = workloadName
    }
}

struct ListWorkloadDeploymentPatternsInputBody: Swift.Equatable {
    let workloadName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWorkloadDeploymentPatternsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case workloadName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkloadDeploymentPatternsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkloadDeploymentPatternsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workloadDeploymentPatterns = output.workloadDeploymentPatterns
        } else {
            self.nextToken = nil
            self.workloadDeploymentPatterns = nil
        }
    }
}

public struct ListWorkloadDeploymentPatternsOutput: Swift.Equatable {
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?
    /// Describes the workload deployment patterns.
    public var workloadDeploymentPatterns: [LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloadDeploymentPatterns: [LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadDeploymentPatterns = workloadDeploymentPatterns
    }
}

struct ListWorkloadDeploymentPatternsOutputBody: Swift.Equatable {
    let workloadDeploymentPatterns: [LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary]?
    let nextToken: Swift.String?
}

extension ListWorkloadDeploymentPatternsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workloadDeploymentPatterns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadDeploymentPatternsContainer = try containerValues.decodeIfPresent([LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary?].self, forKey: .workloadDeploymentPatterns)
        var workloadDeploymentPatternsDecoded0:[LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary]? = nil
        if let workloadDeploymentPatternsContainer = workloadDeploymentPatternsContainer {
            workloadDeploymentPatternsDecoded0 = [LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary]()
            for structure0 in workloadDeploymentPatternsContainer {
                if let structure0 = structure0 {
                    workloadDeploymentPatternsDecoded0?.append(structure0)
                }
            }
        }
        workloadDeploymentPatterns = workloadDeploymentPatternsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkloadDeploymentPatternsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWorkloadsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWorkloadsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listWorkloads"
    }
}

public struct ListWorkloadsInput: Swift.Equatable {
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkloadsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWorkloadsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkloadsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWorkloadsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.workloads = output.workloads
        } else {
            self.nextToken = nil
            self.workloads = nil
        }
    }
}

public struct ListWorkloadsOutput: Swift.Equatable {
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?
    /// Information about the workloads.
    public var workloads: [LaunchWizardClientTypes.WorkloadDataSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloads: [LaunchWizardClientTypes.WorkloadDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloads = workloads
    }
}

struct ListWorkloadsOutputBody: Swift.Equatable {
    let workloads: [LaunchWizardClientTypes.WorkloadDataSummary]?
    let nextToken: Swift.String?
}

extension ListWorkloadsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case workloads
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadsContainer = try containerValues.decodeIfPresent([LaunchWizardClientTypes.WorkloadDataSummary?].self, forKey: .workloads)
        var workloadsDecoded0:[LaunchWizardClientTypes.WorkloadDataSummary]? = nil
        if let workloadsContainer = workloadsContainer {
            workloadsDecoded0 = [LaunchWizardClientTypes.WorkloadDataSummary]()
            for structure0 in workloadsContainer {
                if let structure0 = structure0 {
                    workloadsDecoded0?.append(structure0)
                }
            }
        }
        workloads = workloadsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWorkloadsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceLimitException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLimitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded an Launch Wizard resource limit. For example, you might have too many deployments in progress.
public struct ResourceLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceLimitExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified workload or deployment resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LaunchWizardClientTypes.WorkloadData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case displayName
        case documentationUrl
        case iconUrl
        case status
        case statusMessage
        case workloadName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let documentationUrl = self.documentationUrl {
            try encodeContainer.encode(documentationUrl, forKey: .documentationUrl)
        }
        if let iconUrl = self.iconUrl {
            try encodeContainer.encode(iconUrl, forKey: .iconUrl)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let documentationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationUrl)
        documentationUrl = documentationUrlDecoded
        let iconUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconUrl)
        iconUrl = iconUrlDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LaunchWizardClientTypes.WorkloadStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension LaunchWizardClientTypes {
    /// Describes a workload.
    public struct WorkloadData: Swift.Equatable {
        /// The description of a workload.
        public var description: Swift.String?
        /// The display name of a workload.
        public var displayName: Swift.String?
        /// The URL of a workload document.
        public var documentationUrl: Swift.String?
        /// The URL of a workload icon.
        public var iconUrl: Swift.String?
        /// The status of a workload.
        public var status: LaunchWizardClientTypes.WorkloadStatus?
        /// The message about a workload's status.
        public var statusMessage: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            documentationUrl: Swift.String? = nil,
            iconUrl: Swift.String? = nil,
            status: LaunchWizardClientTypes.WorkloadStatus? = nil,
            statusMessage: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.documentationUrl = documentationUrl
            self.iconUrl = iconUrl
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
        }
    }

}

extension LaunchWizardClientTypes.WorkloadDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case workloadName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension LaunchWizardClientTypes {
    /// Describes workload data.
    public struct WorkloadDataSummary: Swift.Equatable {
        /// The display name of the workload data.
        public var displayName: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.workloadName = workloadName
        }
    }

}

extension LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentPatternName
        case description
        case displayName
        case status
        case statusMessage
        case workloadName
        case workloadVersionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentPatternName = self.deploymentPatternName {
            try encodeContainer.encode(deploymentPatternName, forKey: .deploymentPatternName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let workloadName = self.workloadName {
            try encodeContainer.encode(workloadName, forKey: .workloadName)
        }
        if let workloadVersionName = self.workloadVersionName {
            try encodeContainer.encode(workloadVersionName, forKey: .workloadVersionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workloadNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadName)
        workloadName = workloadNameDecoded
        let deploymentPatternNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentPatternName)
        deploymentPatternName = deploymentPatternNameDecoded
        let workloadVersionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workloadVersionName)
        workloadVersionName = workloadVersionNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(LaunchWizardClientTypes.WorkloadDeploymentPatternStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension LaunchWizardClientTypes {
    /// Describes a workload deployment pattern.
    public struct WorkloadDeploymentPatternDataSummary: Swift.Equatable {
        /// The name of a workload deployment pattern.
        public var deploymentPatternName: Swift.String?
        /// The description of a workload deployment pattern.
        public var description: Swift.String?
        /// The display name of a workload deployment pattern.
        public var displayName: Swift.String?
        /// The status of a workload deployment pattern.
        public var status: LaunchWizardClientTypes.WorkloadDeploymentPatternStatus?
        /// A message about a workload deployment pattern's status.
        public var statusMessage: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?
        /// The name of the workload deployment pattern version.
        public var workloadVersionName: Swift.String?

        public init(
            deploymentPatternName: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            status: LaunchWizardClientTypes.WorkloadDeploymentPatternStatus? = nil,
            statusMessage: Swift.String? = nil,
            workloadName: Swift.String? = nil,
            workloadVersionName: Swift.String? = nil
        )
        {
            self.deploymentPatternName = deploymentPatternName
            self.description = description
            self.displayName = displayName
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
            self.workloadVersionName = workloadVersionName
        }
    }

}

extension LaunchWizardClientTypes {
    public enum WorkloadDeploymentPatternStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadDeploymentPatternStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkloadDeploymentPatternStatus(rawValue: rawValue) ?? WorkloadDeploymentPatternStatus.sdkUnknown(rawValue)
        }
    }
}

extension LaunchWizardClientTypes {
    public enum WorkloadStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkloadStatus(rawValue: rawValue) ?? WorkloadStatus.sdkUnknown(rawValue)
        }
    }
}
