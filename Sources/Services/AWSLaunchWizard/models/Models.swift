// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension CreateDeploymentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDeploymentInput(deploymentPatternName: \(Swift.String(describing: deploymentPatternName)), dryRun: \(Swift.String(describing: dryRun)), name: \(Swift.String(describing: name)), workloadName: \(Swift.String(describing: workloadName)), specifications: \"CONTENT_REDACTED\")"}
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        return "/createDeployment"
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentPatternName"].write(value.deploymentPatternName)
        try writer["dryRun"].write(value.dryRun)
        try writer["name"].write(value.name)
        try writer["specifications"].writeMap(value.specifications, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["workloadName"].write(value.workloadName)
    }
}

public struct CreateDeploymentInput {
    /// The name of the deployment pattern supported by a given workload. You can use the [ListWorkloadDeploymentPatterns](https://docs.aws.amazon.com/launchwizard/latest/APIReference/API_ListWorkloadDeploymentPatterns.html) operation to discover supported values for this parameter.
    /// This member is required.
    public var deploymentPatternName: Swift.String?
    /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
    public var dryRun: Swift.Bool?
    /// The name of the deployment.
    /// This member is required.
    public var name: Swift.String?
    /// The settings specified for the deployment. For more information on the specifications required for creating a deployment, see [Workload specifications](https://docs.aws.amazon.com/launchwizard/latest/APIReference/launch-wizard-specifications.html).
    /// This member is required.
    public var specifications: [Swift.String:Swift.String]?
    /// The name of the workload. You can use the [ListWorkloadDeploymentPatterns](https://docs.aws.amazon.com/launchwizard/latest/APIReference/API_ListWorkloadDeploymentPatterns.html) operation to discover supported values for this parameter.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        deploymentPatternName: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        name: Swift.String? = nil,
        specifications: [Swift.String:Swift.String]? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.deploymentPatternName = deploymentPatternName
        self.dryRun = dryRun
        self.name = name
        self.specifications = specifications
        self.workloadName = workloadName
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.deploymentId = try reader["deploymentId"].readIfPresent()
        return value
    }
}

public struct CreateDeploymentOutput {
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceLimitException": return try ResourceLimitException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDeploymentInput {

    static func urlPathProvider(_ value: DeleteDeploymentInput) -> Swift.String? {
        return "/deleteDeployment"
    }
}

extension DeleteDeploymentInput {

    static func write(value: DeleteDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentId"].write(value.deploymentId)
    }
}

public struct DeleteDeploymentInput {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

extension DeleteDeploymentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDeploymentOutput()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

public struct DeleteDeploymentOutput {
    /// The status of the deployment.
    public var status: LaunchWizardClientTypes.DeploymentStatus?
    /// The reason for the deployment status.
    public var statusReason: Swift.String?

    public init(
        status: LaunchWizardClientTypes.DeploymentStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.status = status
        self.statusReason = statusReason
    }
}

enum DeleteDeploymentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LaunchWizardClientTypes.DeploymentData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeploymentData(createdAt: \(Swift.String(describing: createdAt)), deletedAt: \(Swift.String(describing: deletedAt)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), patternName: \(Swift.String(describing: patternName)), resourceGroup: \(Swift.String(describing: resourceGroup)), status: \(Swift.String(describing: status)), workloadName: \(Swift.String(describing: workloadName)), specifications: \"CONTENT_REDACTED\")"}
}

extension LaunchWizardClientTypes.DeploymentData {

    static func write(value: LaunchWizardClientTypes.DeploymentData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .epochSeconds)
        try writer["deletedAt"].writeTimestamp(value.deletedAt, format: .epochSeconds)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["patternName"].write(value.patternName)
        try writer["resourceGroup"].write(value.resourceGroup)
        try writer["specifications"].writeMap(value.specifications, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["status"].write(value.status)
        try writer["workloadName"].write(value.workloadName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.DeploymentData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.DeploymentData()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.patternName = try reader["patternName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        value.specifications = try reader["specifications"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceGroup = try reader["resourceGroup"].readIfPresent()
        value.deletedAt = try reader["deletedAt"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension LaunchWizardClientTypes {
    /// The data associated with a deployment.
    public struct DeploymentData {
        /// The time the deployment was created.
        public var createdAt: ClientRuntime.Date?
        /// The time the deployment was deleted.
        public var deletedAt: ClientRuntime.Date?
        /// The ID of the deployment.
        public var id: Swift.String?
        /// The name of the deployment.
        public var name: Swift.String?
        /// The pattern name of the deployment.
        public var patternName: Swift.String?
        /// The resource group of the deployment.
        public var resourceGroup: Swift.String?
        /// The specifications of the deployment. For more information on specifications for each deployment, see [Workload specifications](https://docs.aws.amazon.com/launchwizard/latest/APIReference/launch-wizard-specifications.html).
        public var specifications: [Swift.String:Swift.String]?
        /// The status of the deployment.
        public var status: LaunchWizardClientTypes.DeploymentStatus?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            patternName: Swift.String? = nil,
            resourceGroup: Swift.String? = nil,
            specifications: [Swift.String:Swift.String]? = nil,
            status: LaunchWizardClientTypes.DeploymentStatus? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.id = id
            self.name = name
            self.patternName = patternName
            self.resourceGroup = resourceGroup
            self.specifications = specifications
            self.status = status
            self.workloadName = workloadName
        }
    }

}

extension LaunchWizardClientTypes.DeploymentDataSummary {

    static func write(value: LaunchWizardClientTypes.DeploymentDataSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .epochSeconds)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["patternName"].write(value.patternName)
        try writer["status"].write(value.status)
        try writer["workloadName"].write(value.workloadName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.DeploymentDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.DeploymentDataSummary()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.patternName = try reader["patternName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension LaunchWizardClientTypes {
    /// A summary of the deployment data.
    public struct DeploymentDataSummary {
        /// The time the deployment was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the deployment.
        public var id: Swift.String?
        /// The name of the deployment
        public var name: Swift.String?
        /// The name of the workload deployment pattern.
        public var patternName: Swift.String?
        /// The status of the deployment.
        public var status: LaunchWizardClientTypes.DeploymentStatus?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            patternName: Swift.String? = nil,
            status: LaunchWizardClientTypes.DeploymentStatus? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.patternName = patternName
            self.status = status
            self.workloadName = workloadName
        }
    }

}

extension LaunchWizardClientTypes.DeploymentEventDataSummary {

    static func write(value: LaunchWizardClientTypes.DeploymentEventDataSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["status"].write(value.status)
        try writer["statusReason"].write(value.statusReason)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: .epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.DeploymentEventDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.DeploymentEventDataSummary()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: .epochSeconds)
        return value
    }
}

extension LaunchWizardClientTypes {
    /// A summary of the deployment event data.
    public struct DeploymentEventDataSummary {
        /// The description of the deployment event.
        public var description: Swift.String?
        /// The name of the deployment event.
        public var name: Swift.String?
        /// The status of the deployment event.
        public var status: LaunchWizardClientTypes.EventStatus?
        /// The reason of the deployment event status.
        public var statusReason: Swift.String?
        /// The timestamp of the deployment event.
        public var timestamp: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            status: LaunchWizardClientTypes.EventStatus? = nil,
            statusReason: Swift.String? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.timestamp = timestamp
        }
    }

}

extension LaunchWizardClientTypes.DeploymentFilter {

    static func write(value: LaunchWizardClientTypes.DeploymentFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.DeploymentFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.DeploymentFilter()
        value.name = try reader["name"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LaunchWizardClientTypes {
    /// A filter name and value pair that is used to return more specific results from a describe operation. Filters can be used to match a set of resources by specific criteria.
    public struct DeploymentFilter {
        /// The name of the filter. Filter names are case-sensitive.
        public var name: LaunchWizardClientTypes.DeploymentFilterKey?
        /// The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
        public var values: [Swift.String]?

        public init(
            name: LaunchWizardClientTypes.DeploymentFilterKey? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension LaunchWizardClientTypes {

    public enum DeploymentFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deploymentStatus
        case workloadName
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentFilterKey] {
            return [
                .deploymentStatus,
                .workloadName,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deploymentStatus: return "DEPLOYMENT_STATUS"
            case .workloadName: return "WORKLOAD_NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LaunchWizardClientTypes {

    public enum DeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case creating
        case deleted
        case deleteFailed
        case deleteInitiating
        case deleteInProgress
        case failed
        case inProgress
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentStatus] {
            return [
                .completed,
                .creating,
                .deleted,
                .deleteFailed,
                .deleteInitiating,
                .deleteInProgress,
                .failed,
                .inProgress,
                .validating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInitiating: return "DELETE_INITIATING"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LaunchWizardClientTypes {

    public enum EventStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case canceling
        case completed
        case created
        case failed
        case inProgress
        case pending
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStatus] {
            return [
                .canceled,
                .canceling,
                .completed,
                .created,
                .failed,
                .inProgress,
                .pending,
                .timedOut,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .completed: return "COMPLETED"
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GetDeploymentInput {

    static func urlPathProvider(_ value: GetDeploymentInput) -> Swift.String? {
        return "/getDeployment"
    }
}

extension GetDeploymentInput {

    static func write(value: GetDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentId"].write(value.deploymentId)
    }
}

public struct GetDeploymentInput {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
    }
}

extension GetDeploymentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentOutput()
        value.deployment = try reader["deployment"].readIfPresent(with: LaunchWizardClientTypes.DeploymentData.read(from:))
        return value
    }
}

public struct GetDeploymentOutput {
    /// An object that details the deployment.
    public var deployment: LaunchWizardClientTypes.DeploymentData?

    public init(
        deployment: LaunchWizardClientTypes.DeploymentData? = nil
    )
    {
        self.deployment = deployment
    }
}

enum GetDeploymentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetWorkloadInput {

    static func urlPathProvider(_ value: GetWorkloadInput) -> Swift.String? {
        return "/getWorkload"
    }
}

extension GetWorkloadInput {

    static func write(value: GetWorkloadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workloadName"].write(value.workloadName)
    }
}

public struct GetWorkloadInput {
    /// The name of the workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        workloadName: Swift.String? = nil
    )
    {
        self.workloadName = workloadName
    }
}

extension GetWorkloadOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetWorkloadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadOutput()
        value.workload = try reader["workload"].readIfPresent(with: LaunchWizardClientTypes.WorkloadData.read(from:))
        return value
    }
}

public struct GetWorkloadOutput {
    /// Information about the workload.
    public var workload: LaunchWizardClientTypes.WorkloadData?

    public init(
        workload: LaunchWizardClientTypes.WorkloadData? = nil
    )
    {
        self.workload = workload
    }
}

enum GetWorkloadOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An internal error has occurred. Retry your request, but if the problem persists, contact us with details by posting a question on [re:Post](https://repost.aws/).
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum LaunchWizardClientTypes {}

extension ListDeploymentEventsInput {

    static func urlPathProvider(_ value: ListDeploymentEventsInput) -> Swift.String? {
        return "/listDeploymentEvents"
    }
}

extension ListDeploymentEventsInput {

    static func write(value: ListDeploymentEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentId"].write(value.deploymentId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListDeploymentEventsInput {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDeploymentEventsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDeploymentEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeploymentEventsOutput()
        value.deploymentEvents = try reader["deploymentEvents"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.DeploymentEventDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListDeploymentEventsOutput {
    /// Lists the deployment events.
    public var deploymentEvents: [LaunchWizardClientTypes.DeploymentEventDataSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        deploymentEvents: [LaunchWizardClientTypes.DeploymentEventDataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deploymentEvents = deploymentEvents
        self.nextToken = nextToken
    }
}

enum ListDeploymentEventsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDeploymentsInput {

    static func urlPathProvider(_ value: ListDeploymentsInput) -> Swift.String? {
        return "/listDeployments"
    }
}

extension ListDeploymentsInput {

    static func write(value: ListDeploymentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: LaunchWizardClientTypes.DeploymentFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListDeploymentsInput {
    /// Filters to scope the results. The following filters are supported:
    ///
    /// * WORKLOAD_NAME
    ///
    /// * DEPLOYMENT_STATUS
    public var filters: [LaunchWizardClientTypes.DeploymentFilter]?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        filters: [LaunchWizardClientTypes.DeploymentFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDeploymentsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeploymentsOutput()
        value.deployments = try reader["deployments"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.DeploymentDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListDeploymentsOutput {
    /// Lists the deployments.
    public var deployments: [LaunchWizardClientTypes.DeploymentDataSummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        deployments: [LaunchWizardClientTypes.DeploymentDataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

enum ListDeploymentsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListWorkloadDeploymentPatternsInput {

    static func urlPathProvider(_ value: ListWorkloadDeploymentPatternsInput) -> Swift.String? {
        return "/listWorkloadDeploymentPatterns"
    }
}

extension ListWorkloadDeploymentPatternsInput {

    static func write(value: ListWorkloadDeploymentPatternsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["workloadName"].write(value.workloadName)
    }
}

public struct ListWorkloadDeploymentPatternsInput {
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?
    /// The name of the workload.
    /// This member is required.
    public var workloadName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadName = workloadName
    }
}

extension ListWorkloadDeploymentPatternsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListWorkloadDeploymentPatternsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadDeploymentPatternsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workloadDeploymentPatterns = try reader["workloadDeploymentPatterns"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListWorkloadDeploymentPatternsOutput {
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?
    /// Describes the workload deployment patterns.
    public var workloadDeploymentPatterns: [LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloadDeploymentPatterns: [LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloadDeploymentPatterns = workloadDeploymentPatterns
    }
}

enum ListWorkloadDeploymentPatternsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListWorkloadsInput {

    static func urlPathProvider(_ value: ListWorkloadsInput) -> Swift.String? {
        return "/listWorkloads"
    }
}

extension ListWorkloadsInput {

    static func write(value: ListWorkloadsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListWorkloadsInput {
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListWorkloadsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListWorkloadsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workloads = try reader["workloads"].readListIfPresent(memberReadingClosure: LaunchWizardClientTypes.WorkloadDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListWorkloadsOutput {
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?
    /// Information about the workloads.
    public var workloads: [LaunchWizardClientTypes.WorkloadDataSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workloads: [LaunchWizardClientTypes.WorkloadDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workloads = workloads
    }
}

enum ListWorkloadsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceLimitException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceLimitException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You have exceeded an Launch Wizard resource limit. For example, you might have too many deployments in progress.
public struct ResourceLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified workload or deployment resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LaunchWizardClientTypes.WorkloadData {

    static func write(value: LaunchWizardClientTypes.WorkloadData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["documentationUrl"].write(value.documentationUrl)
        try writer["iconUrl"].write(value.iconUrl)
        try writer["status"].write(value.status)
        try writer["statusMessage"].write(value.statusMessage)
        try writer["workloadName"].write(value.workloadName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.WorkloadData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.WorkloadData()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.documentationUrl = try reader["documentationUrl"].readIfPresent()
        value.iconUrl = try reader["iconUrl"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension LaunchWizardClientTypes {
    /// Describes a workload.
    public struct WorkloadData {
        /// The description of a workload.
        public var description: Swift.String?
        /// The display name of a workload.
        public var displayName: Swift.String?
        /// The URL of a workload document.
        public var documentationUrl: Swift.String?
        /// The URL of a workload icon.
        public var iconUrl: Swift.String?
        /// The status of a workload.
        public var status: LaunchWizardClientTypes.WorkloadStatus?
        /// The message about a workload's status.
        public var statusMessage: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            documentationUrl: Swift.String? = nil,
            iconUrl: Swift.String? = nil,
            status: LaunchWizardClientTypes.WorkloadStatus? = nil,
            statusMessage: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.documentationUrl = documentationUrl
            self.iconUrl = iconUrl
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
        }
    }

}

extension LaunchWizardClientTypes.WorkloadDataSummary {

    static func write(value: LaunchWizardClientTypes.WorkloadDataSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["workloadName"].write(value.workloadName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.WorkloadDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.WorkloadDataSummary()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        return value
    }
}

extension LaunchWizardClientTypes {
    /// Describes workload data.
    public struct WorkloadDataSummary {
        /// The display name of the workload data.
        public var displayName: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            workloadName: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.workloadName = workloadName
        }
    }

}

extension LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary {

    static func write(value: LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deploymentPatternName"].write(value.deploymentPatternName)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["status"].write(value.status)
        try writer["statusMessage"].write(value.statusMessage)
        try writer["workloadName"].write(value.workloadName)
        try writer["workloadVersionName"].write(value.workloadVersionName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LaunchWizardClientTypes.WorkloadDeploymentPatternDataSummary()
        value.workloadName = try reader["workloadName"].readIfPresent()
        value.deploymentPatternName = try reader["deploymentPatternName"].readIfPresent()
        value.workloadVersionName = try reader["workloadVersionName"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension LaunchWizardClientTypes {
    /// Describes a workload deployment pattern.
    public struct WorkloadDeploymentPatternDataSummary {
        /// The name of a workload deployment pattern.
        public var deploymentPatternName: Swift.String?
        /// The description of a workload deployment pattern.
        public var description: Swift.String?
        /// The display name of a workload deployment pattern.
        public var displayName: Swift.String?
        /// The status of a workload deployment pattern.
        public var status: LaunchWizardClientTypes.WorkloadDeploymentPatternStatus?
        /// A message about a workload deployment pattern's status.
        public var statusMessage: Swift.String?
        /// The name of the workload.
        public var workloadName: Swift.String?
        /// The name of the workload deployment pattern version.
        public var workloadVersionName: Swift.String?

        public init(
            deploymentPatternName: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            status: LaunchWizardClientTypes.WorkloadDeploymentPatternStatus? = nil,
            statusMessage: Swift.String? = nil,
            workloadName: Swift.String? = nil,
            workloadVersionName: Swift.String? = nil
        )
        {
            self.deploymentPatternName = deploymentPatternName
            self.description = description
            self.displayName = displayName
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
            self.workloadVersionName = workloadVersionName
        }
    }

}

extension LaunchWizardClientTypes {

    public enum WorkloadDeploymentPatternStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadDeploymentPatternStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .inactive,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LaunchWizardClientTypes {

    public enum WorkloadStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleted
        case disabled
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadStatus] {
            return [
                .active,
                .deleted,
                .disabled,
                .inactive,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}
