// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ARCZonalShiftClientTypes {
    public enum AppliedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applied
        case notApplied
        case sdkUnknown(Swift.String)

        public static var allCases: [AppliedStatus] {
            return [
                .applied,
                .notApplied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .notApplied: return "NOT_APPLIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppliedStatus(rawValue: rawValue) ?? AppliedStatus.sdkUnknown(rawValue)
        }
    }
}

extension ARCZonalShiftClientTypes {
    public enum AutoshiftAppliedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applied
        case notApplied
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoshiftAppliedStatus] {
            return [
                .applied,
                .notApplied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .notApplied: return "NOT_APPLIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoshiftAppliedStatus(rawValue: rawValue) ?? AutoshiftAppliedStatus.sdkUnknown(rawValue)
        }
    }
}

extension ARCZonalShiftClientTypes {
    public enum AutoshiftExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoshiftExecutionStatus] {
            return [
                .active,
                .completed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoshiftExecutionStatus(rawValue: rawValue) ?? AutoshiftExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ARCZonalShiftClientTypes.AutoshiftInResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedStatus
        case awayFrom
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appliedStatus = self.appliedStatus {
            try encodeContainer.encode(appliedStatus.rawValue, forKey: .appliedStatus)
        }
        if let awayFrom = self.awayFrom {
            try encodeContainer.encode(awayFrom, forKey: .awayFrom)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appliedStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.AutoshiftAppliedStatus.self, forKey: .appliedStatus)
        appliedStatus = appliedStatusDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension ARCZonalShiftClientTypes {
    /// A complex structure that lists an autoshift that is currently active for a managed resource and information about the autoshift. For more information, see [How zonal autoshift and practice runs work](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
    public struct AutoshiftInResource: Swift.Equatable {
        /// The appliedStatus field specifies which application traffic shift is in effect for a resource when there is more than one traffic shift active. There can be more than one application traffic shift in progress at the same time - that is, practice run zonal shifts, customer-started zonal shifts, or an autoshift. The appliedStatus field for an autoshift for a resource can have one of two values: APPLIED or NOT_APPLIED. The zonal shift or autoshift that is currently in effect for the resource has an applied status set to APPLIED. The overall principle for precedence is that zonal shifts that you start as a customer take precedence autoshifts, which take precedence over practice runs. That is, customer-started zonal shifts > autoshifts > practice run zonal shifts. For more information, see [How zonal autoshift and practice runs work](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
        /// This member is required.
        public var appliedStatus: ARCZonalShiftClientTypes.AutoshiftAppliedStatus?
        /// The Availability Zone that traffic is shifted away from for a resource, when Amazon Web Services starts an autoshift. Until the autoshift ends, traffic for the resource is instead directed to other Availability Zones in the Amazon Web Services Region. An autoshift can end for a resource, for example, when Amazon Web Services ends the autoshift for the Availability Zone or when you disable zonal autoshift for the resource.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// The time (UTC) when the autoshift started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            appliedStatus: ARCZonalShiftClientTypes.AutoshiftAppliedStatus? = nil,
            awayFrom: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.appliedStatus = appliedStatus
            self.awayFrom = awayFrom
            self.startTime = startTime
        }
    }

}

extension ARCZonalShiftClientTypes.AutoshiftSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case endTime
        case startTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awayFrom = self.awayFrom {
            try encodeContainer.encode(awayFrom, forKey: .awayFrom)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.AutoshiftExecutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ARCZonalShiftClientTypes {
    /// Information about an autoshift. Amazon Web Services starts an autoshift to temporarily move traffic for a resource away from an Availability Zone in an Amazon Web Services Region when Amazon Web Services determines that there's an issue in the Availability Zone that could potentially affect customers. You can configure zonal autoshift in Route 53 ARC for managed resources in your Amazon Web Services account in a Region. Supported Amazon Web Services resources are automatically registered with Route 53 ARC. Autoshifts are temporary. When the Availability Zone recovers, Amazon Web Services ends the autoshift, and traffic for the resource is no longer directed to the other Availability Zones in the Region. You can stop an autoshift for a resource by disabling zonal autoshift.
    public struct AutoshiftSummary: Swift.Equatable {
        /// The Availability Zone that traffic is shifted away from for a resource when Amazon Web Services starts an autoshift. Until the autoshift ends, traffic for the resource is instead directed to other Availability Zones in the Amazon Web Services Region. An autoshift can end for a resource, for example, when Amazon Web Services ends the autoshift for the Availability Zone or when you disable zonal autoshift for the resource.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// The time (in UTC) when the autoshift ended.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The time (in UTC) when the autoshift started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The status for an autoshift.
        /// This member is required.
        public var status: ARCZonalShiftClientTypes.AutoshiftExecutionStatus?

        public init(
            awayFrom: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ARCZonalShiftClientTypes.AutoshiftExecutionStatus? = nil
        )
        {
            self.awayFrom = awayFrom
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
        }
    }

}

extension CancelZonalShiftInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let zonalShiftId = zonalShiftId else {
            return nil
        }
        return "/zonalshifts/\(zonalShiftId.urlPercentEncoding())"
    }
}

public struct CancelZonalShiftInput: Swift.Equatable {
    /// The internally-generated identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        zonalShiftId: Swift.String? = nil
    )
    {
        self.zonalShiftId = zonalShiftId
    }
}

struct CancelZonalShiftInputBody: Swift.Equatable {
}

extension CancelZonalShiftInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelZonalShiftOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelZonalShiftOutputBody = try responseDecoder.decode(responseBody: data)
            self.awayFrom = output.awayFrom
            self.comment = output.comment
            self.expiryTime = output.expiryTime
            self.resourceIdentifier = output.resourceIdentifier
            self.startTime = output.startTime
            self.status = output.status
            self.zonalShiftId = output.zonalShiftId
        } else {
            self.awayFrom = nil
            self.comment = nil
            self.expiryTime = nil
            self.resourceIdentifier = nil
            self.startTime = nil
            self.status = nil
            self.zonalShiftId = nil
        }
    }
}

public struct CancelZonalShiftOutput: Swift.Equatable {
    /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
    /// This member is required.
    public var expiryTime: ClientRuntime.Date?
    /// The identifier for the resource to shift away traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The time (UTC) when the zonal shift starts.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift has been started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        resourceIdentifier: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiryTime = expiryTime
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.status = status
        self.zonalShiftId = zonalShiftId
    }
}

struct CancelZonalShiftOutputBody: Swift.Equatable {
    let zonalShiftId: Swift.String?
    let resourceIdentifier: Swift.String?
    let awayFrom: Swift.String?
    let expiryTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    let comment: Swift.String?
}

extension CancelZonalShiftOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiryTime
        case resourceIdentifier
        case startTime
        case status
        case zonalShiftId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalShiftStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum CancelZonalShiftOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
            self.properties.zonalShiftId = output.zonalShiftId
        } else {
            self.properties.message = nil
            self.properties.reason = nil
            self.properties.zonalShiftId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the conflict exception.
        /// This member is required.
        public internal(set) var reason: ARCZonalShiftClientTypes.ConflictExceptionReason? = nil
        /// The zonal shift ID associated with the conflict exception.
        public internal(set) var zonalShiftId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: ARCZonalShiftClientTypes.ConflictExceptionReason? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.zonalShiftId = zonalShiftId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: ARCZonalShiftClientTypes.ConflictExceptionReason?
    let zonalShiftId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
        case zonalShiftId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
    }
}

extension ARCZonalShiftClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autoshiftEnabled
        case practiceConfigurationAlreadyExists
        case practiceConfigurationDoesNotExist
        case simultaneousZonalShiftsConflict
        case zonalShiftAlreadyExists
        case zonalShiftStatusNotActive
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .autoshiftEnabled,
                .practiceConfigurationAlreadyExists,
                .practiceConfigurationDoesNotExist,
                .simultaneousZonalShiftsConflict,
                .zonalShiftAlreadyExists,
                .zonalShiftStatusNotActive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autoshiftEnabled: return "AutoShiftEnabled"
            case .practiceConfigurationAlreadyExists: return "PracticeConfigurationAlreadyExists"
            case .practiceConfigurationDoesNotExist: return "PracticeConfigurationDoesNotExist"
            case .simultaneousZonalShiftsConflict: return "SimultaneousZonalShiftsConflict"
            case .zonalShiftAlreadyExists: return "ZonalShiftAlreadyExists"
            case .zonalShiftStatusNotActive: return "ZonalShiftStatusNotActive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension ARCZonalShiftClientTypes.ControlCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmIdentifier
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmIdentifier = self.alarmIdentifier {
            try encodeContainer.encode(alarmIdentifier, forKey: .alarmIdentifier)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ControlConditionType.self, forKey: .type)
        type = typeDecoded
        let alarmIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmIdentifier)
        alarmIdentifier = alarmIdentifierDecoded
    }
}

extension ARCZonalShiftClientTypes {
    /// A control condition is an alarm that you specify for a practice run. When you configure practice runs with zonal autoshift for a resource, you specify Amazon CloudWatch alarms, which you create in CloudWatch to use with the practice run. The alarms that you specify are an outcome alarm, to monitor application health during practice runs and, optionally, a blocking alarm, to block practice runs from starting. Control condition alarms do not apply for autoshifts. For more information, see [ Considerations when you configure zonal autoshift](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.considerations.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
    public struct ControlCondition: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the Amazon CloudWatch alarm that you specify as a control condition for a practice run.
        /// This member is required.
        public var alarmIdentifier: Swift.String?
        /// The type of alarm specified for a practice run. The only valid value is CLOUDWATCH.
        /// This member is required.
        public var type: ARCZonalShiftClientTypes.ControlConditionType?

        public init(
            alarmIdentifier: Swift.String? = nil,
            type: ARCZonalShiftClientTypes.ControlConditionType? = nil
        )
        {
            self.alarmIdentifier = alarmIdentifier
            self.type = type
        }
    }

}

extension ARCZonalShiftClientTypes {
    public enum ControlConditionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudwatch
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlConditionType] {
            return [
                .cloudwatch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudwatch: return "CLOUDWATCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlConditionType(rawValue: rawValue) ?? ControlConditionType.sdkUnknown(rawValue)
        }
    }
}

extension CreatePracticeRunConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedDates
        case blockedWindows
        case blockingAlarms
        case outcomeAlarms
        case resourceIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockedDates = blockedDates {
            var blockedDatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedDates)
            for blockeddate0 in blockedDates {
                try blockedDatesContainer.encode(blockeddate0)
            }
        }
        if let blockedWindows = blockedWindows {
            var blockedWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedWindows)
            for blockedwindow0 in blockedWindows {
                try blockedWindowsContainer.encode(blockedwindow0)
            }
        }
        if let blockingAlarms = blockingAlarms {
            var blockingAlarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockingAlarms)
            for controlcondition0 in blockingAlarms {
                try blockingAlarmsContainer.encode(controlcondition0)
            }
        }
        if let outcomeAlarms = outcomeAlarms {
            var outcomeAlarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomeAlarms)
            for controlcondition0 in outcomeAlarms {
                try outcomeAlarmsContainer.encode(controlcondition0)
            }
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

extension CreatePracticeRunConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration"
    }
}

public struct CreatePracticeRunConfigurationInput: Swift.Equatable {
    /// Optionally, you can block Route 53 ARC from starting practice runs for a resource on specific calendar dates. The format for blocked dates is: YYYY-MM-DD. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Separate multiple blocked dates with spaces. For example, if you have an application update scheduled to launch on May 1, 2024, and you don't want practice runs to shift traffic away at that time, you could set a blocked date for 2024-05-01.
    public var blockedDates: [Swift.String]?
    /// Optionally, you can block Route 53 ARC from starting practice runs for specific windows of days and times. The format for blocked windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple blocked windows with spaces. For example, say you run business report summaries three days a week. For this scenario, you might set the following recurring days and times as blocked windows, for example: MON-20:30-21:30 WED-20:30-21:30 FRI-20:30-21:30.
    public var blockedWindows: [Swift.String]?
    /// An Amazon CloudWatch alarm that you can specify for zonal autoshift practice runs. This alarm blocks Route 53 ARC from starting practice run zonal shifts, and ends a practice run that's in progress, when the alarm is in an ALARM state.
    public var blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    /// The outcome alarm for practice runs is a required Amazon CloudWatch alarm that you specify that ends a practice run when the alarm is in an ALARM state. Configure the alarm to monitor the health of your application when traffic is shifted away from an Availability Zone during each weekly practice run. You should configure the alarm to go into an ALARM state if your application is impacted by the zonal shift, and you want to stop the zonal shift, to let traffic for the resource return to the Availability Zone.
    /// This member is required.
    public var outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    /// The identifier of the resource to shift away traffic for when a practice run starts a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        blockedDates: [Swift.String]? = nil,
        blockedWindows: [Swift.String]? = nil,
        blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
        outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.blockedDates = blockedDates
        self.blockedWindows = blockedWindows
        self.blockingAlarms = blockingAlarms
        self.outcomeAlarms = outcomeAlarms
        self.resourceIdentifier = resourceIdentifier
    }
}

struct CreatePracticeRunConfigurationInputBody: Swift.Equatable {
    let resourceIdentifier: Swift.String?
    let blockedWindows: [Swift.String]?
    let blockedDates: [Swift.String]?
    let blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    let outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
}

extension CreatePracticeRunConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedDates
        case blockedWindows
        case blockingAlarms
        case outcomeAlarms
        case resourceIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let blockedWindowsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .blockedWindows)
        var blockedWindowsDecoded0:[Swift.String]? = nil
        if let blockedWindowsContainer = blockedWindowsContainer {
            blockedWindowsDecoded0 = [Swift.String]()
            for string0 in blockedWindowsContainer {
                if let string0 = string0 {
                    blockedWindowsDecoded0?.append(string0)
                }
            }
        }
        blockedWindows = blockedWindowsDecoded0
        let blockedDatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .blockedDates)
        var blockedDatesDecoded0:[Swift.String]? = nil
        if let blockedDatesContainer = blockedDatesContainer {
            blockedDatesDecoded0 = [Swift.String]()
            for string0 in blockedDatesContainer {
                if let string0 = string0 {
                    blockedDatesDecoded0?.append(string0)
                }
            }
        }
        blockedDates = blockedDatesDecoded0
        let blockingAlarmsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ControlCondition?].self, forKey: .blockingAlarms)
        var blockingAlarmsDecoded0:[ARCZonalShiftClientTypes.ControlCondition]? = nil
        if let blockingAlarmsContainer = blockingAlarmsContainer {
            blockingAlarmsDecoded0 = [ARCZonalShiftClientTypes.ControlCondition]()
            for structure0 in blockingAlarmsContainer {
                if let structure0 = structure0 {
                    blockingAlarmsDecoded0?.append(structure0)
                }
            }
        }
        blockingAlarms = blockingAlarmsDecoded0
        let outcomeAlarmsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ControlCondition?].self, forKey: .outcomeAlarms)
        var outcomeAlarmsDecoded0:[ARCZonalShiftClientTypes.ControlCondition]? = nil
        if let outcomeAlarmsContainer = outcomeAlarmsContainer {
            outcomeAlarmsDecoded0 = [ARCZonalShiftClientTypes.ControlCondition]()
            for structure0 in outcomeAlarmsContainer {
                if let structure0 = structure0 {
                    outcomeAlarmsDecoded0?.append(structure0)
                }
            }
        }
        outcomeAlarms = outcomeAlarmsDecoded0
    }
}

extension CreatePracticeRunConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePracticeRunConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.practiceRunConfiguration = output.practiceRunConfiguration
            self.zonalAutoshiftStatus = output.zonalAutoshiftStatus
        } else {
            self.arn = nil
            self.name = nil
            self.practiceRunConfiguration = nil
            self.zonalAutoshiftStatus = nil
        }
    }
}

public struct CreatePracticeRunConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you configured the practice run for.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the resource that you configured the practice run for.
    /// This member is required.
    public var name: Swift.String?
    /// A practice run configuration for a resource. Configurations include the outcome alarm that you specify for practice runs, and, optionally, a blocking alarm and blocking dates and windows.
    /// This member is required.
    public var practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration?
    /// The status for zonal autoshift for a resource. When you specify the autoshift status as ENABLED, Amazon Web Services shifts traffic away from shifts away application resource traffic from an Availability Zone, on your behalf, when Amazon Web Services determines that there's an issue in the Availability Zone that could potentially affect customers. When you enable zonal autoshift, you must also configure practice runs for the resource.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.practiceRunConfiguration = practiceRunConfiguration
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

struct CreatePracticeRunConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
    let practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration?
}

extension CreatePracticeRunConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case practiceRunConfiguration
        case zonalAutoshiftStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let zonalAutoshiftStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalAutoshiftStatus.self, forKey: .zonalAutoshiftStatus)
        zonalAutoshiftStatus = zonalAutoshiftStatusDecoded
        let practiceRunConfigurationDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.PracticeRunConfiguration.self, forKey: .practiceRunConfiguration)
        practiceRunConfiguration = practiceRunConfigurationDecoded
    }
}

enum CreatePracticeRunConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePracticeRunConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/configuration/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct DeletePracticeRunConfigurationInput: Swift.Equatable {
    /// The identifier for the resource that you want to delete the practice run configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

struct DeletePracticeRunConfigurationInputBody: Swift.Equatable {
}

extension DeletePracticeRunConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePracticeRunConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePracticeRunConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.zonalAutoshiftStatus = output.zonalAutoshiftStatus
        } else {
            self.arn = nil
            self.name = nil
            self.zonalAutoshiftStatus = nil
        }
    }
}

public struct DeletePracticeRunConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you deleted the practice run for.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the resource that you deleted the practice run for.
    /// This member is required.
    public var name: Swift.String?
    /// The status of zonal autoshift for the resource.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

struct DeletePracticeRunConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
}

extension DeletePracticeRunConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case zonalAutoshiftStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let zonalAutoshiftStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalAutoshiftStatus.self, forKey: .zonalAutoshiftStatus)
        zonalAutoshiftStatus = zonalAutoshiftStatusDecoded
    }
}

enum DeletePracticeRunConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetManagedResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/managedresources/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetManagedResourceInput: Swift.Equatable {
    /// The identifier for the resource to shift away traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

struct GetManagedResourceInputBody: Swift.Equatable {
}

extension GetManagedResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetManagedResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetManagedResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appliedWeights = output.appliedWeights
            self.arn = output.arn
            self.autoshifts = output.autoshifts
            self.name = output.name
            self.practiceRunConfiguration = output.practiceRunConfiguration
            self.zonalAutoshiftStatus = output.zonalAutoshiftStatus
            self.zonalShifts = output.zonalShifts
        } else {
            self.appliedWeights = nil
            self.arn = nil
            self.autoshifts = nil
            self.name = nil
            self.practiceRunConfiguration = nil
            self.zonalAutoshiftStatus = nil
            self.zonalShifts = nil
        }
    }
}

public struct GetManagedResourceOutput: Swift.Equatable {
    /// A collection of key-value pairs that indicate whether resources are active in Availability Zones or not. The key name is the Availability Zone where the resource is deployed. The value is 1 or 0.
    /// This member is required.
    public var appliedWeights: [Swift.String:Swift.Float]?
    /// The Amazon Resource Name (ARN) for the resource.
    public var arn: Swift.String?
    /// An array of the autoshifts that are active for the resource.
    public var autoshifts: [ARCZonalShiftClientTypes.AutoshiftInResource]?
    /// The name of the resource.
    public var name: Swift.String?
    /// The practice run configuration for zonal autoshift that's associated with the resource.
    public var practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration?
    /// The status for zonal autoshift for a resource. When the autoshift status is ENABLED, Amazon Web Services shifts traffic for a resource away from an Availability Zone, on your behalf, when Amazon Web Services determines that there's an issue in the Availability Zone that could potentially affect customers.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
    /// The zonal shifts that are currently active for a resource.
    /// This member is required.
    public var zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]?

    public init(
        appliedWeights: [Swift.String:Swift.Float]? = nil,
        arn: Swift.String? = nil,
        autoshifts: [ARCZonalShiftClientTypes.AutoshiftInResource]? = nil,
        name: Swift.String? = nil,
        practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil,
        zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]? = nil
    )
    {
        self.appliedWeights = appliedWeights
        self.arn = arn
        self.autoshifts = autoshifts
        self.name = name
        self.practiceRunConfiguration = practiceRunConfiguration
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
        self.zonalShifts = zonalShifts
    }
}

struct GetManagedResourceOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let appliedWeights: [Swift.String:Swift.Float]?
    let zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]?
    let autoshifts: [ARCZonalShiftClientTypes.AutoshiftInResource]?
    let practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration?
    let zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
}

extension GetManagedResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedWeights
        case arn
        case autoshifts
        case name
        case practiceRunConfiguration
        case zonalAutoshiftStatus
        case zonalShifts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let appliedWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Float?].self, forKey: .appliedWeights)
        var appliedWeightsDecoded0: [Swift.String:Swift.Float]? = nil
        if let appliedWeightsContainer = appliedWeightsContainer {
            appliedWeightsDecoded0 = [Swift.String:Swift.Float]()
            for (key0, weight0) in appliedWeightsContainer {
                if let weight0 = weight0 {
                    appliedWeightsDecoded0?[key0] = weight0
                }
            }
        }
        appliedWeights = appliedWeightsDecoded0
        let zonalShiftsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ZonalShiftInResource?].self, forKey: .zonalShifts)
        var zonalShiftsDecoded0:[ARCZonalShiftClientTypes.ZonalShiftInResource]? = nil
        if let zonalShiftsContainer = zonalShiftsContainer {
            zonalShiftsDecoded0 = [ARCZonalShiftClientTypes.ZonalShiftInResource]()
            for structure0 in zonalShiftsContainer {
                if let structure0 = structure0 {
                    zonalShiftsDecoded0?.append(structure0)
                }
            }
        }
        zonalShifts = zonalShiftsDecoded0
        let autoshiftsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.AutoshiftInResource?].self, forKey: .autoshifts)
        var autoshiftsDecoded0:[ARCZonalShiftClientTypes.AutoshiftInResource]? = nil
        if let autoshiftsContainer = autoshiftsContainer {
            autoshiftsDecoded0 = [ARCZonalShiftClientTypes.AutoshiftInResource]()
            for structure0 in autoshiftsContainer {
                if let structure0 = structure0 {
                    autoshiftsDecoded0?.append(structure0)
                }
            }
        }
        autoshifts = autoshiftsDecoded0
        let practiceRunConfigurationDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.PracticeRunConfiguration.self, forKey: .practiceRunConfiguration)
        practiceRunConfiguration = practiceRunConfigurationDecoded
        let zonalAutoshiftStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalAutoshiftStatus.self, forKey: .zonalAutoshiftStatus)
        zonalAutoshiftStatus = zonalAutoshiftStatusDecoded
    }
}

enum GetManagedResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAutoshiftsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListAutoshiftsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/autoshifts"
    }
}

public struct ListAutoshiftsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The status of the autoshift.
    public var status: ARCZonalShiftClientTypes.AutoshiftExecutionStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: ARCZonalShiftClientTypes.AutoshiftExecutionStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListAutoshiftsInputBody: Swift.Equatable {
}

extension ListAutoshiftsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAutoshiftsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAutoshiftsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAutoshiftsOutput: Swift.Equatable {
    /// The items in the response list.
    public var items: [ARCZonalShiftClientTypes.AutoshiftSummary]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [ARCZonalShiftClientTypes.AutoshiftSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAutoshiftsOutputBody: Swift.Equatable {
    let items: [ARCZonalShiftClientTypes.AutoshiftSummary]?
    let nextToken: Swift.String?
}

extension ListAutoshiftsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.AutoshiftSummary?].self, forKey: .items)
        var itemsDecoded0:[ARCZonalShiftClientTypes.AutoshiftSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ARCZonalShiftClientTypes.AutoshiftSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAutoshiftsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListManagedResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListManagedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/managedresources"
    }
}

public struct ListManagedResourcesInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListManagedResourcesInputBody: Swift.Equatable {
}

extension ListManagedResourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListManagedResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListManagedResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedResourcesOutput: Swift.Equatable {
    /// The items in the response list.
    /// This member is required.
    public var items: [ARCZonalShiftClientTypes.ManagedResourceSummary]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [ARCZonalShiftClientTypes.ManagedResourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListManagedResourcesOutputBody: Swift.Equatable {
    let items: [ARCZonalShiftClientTypes.ManagedResourceSummary]?
    let nextToken: Swift.String?
}

extension ListManagedResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ManagedResourceSummary?].self, forKey: .items)
        var itemsDecoded0:[ARCZonalShiftClientTypes.ManagedResourceSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ARCZonalShiftClientTypes.ManagedResourceSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListManagedResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListZonalShiftsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let resourceIdentifier = resourceIdentifier {
                let resourceIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "resourceIdentifier".urlPercentEncoding(), value: Swift.String(resourceIdentifier).urlPercentEncoding())
                items.append(resourceIdentifierQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListZonalShiftsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/zonalshifts"
    }
}

public struct ListZonalShiftsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The identifier for the resource that you want to list zonal shifts for. The identifier is the Amazon Resource Name (ARN) for the resource.
    public var resourceIdentifier: Swift.String?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift has been started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
        self.status = status
    }
}

struct ListZonalShiftsInputBody: Swift.Equatable {
}

extension ListZonalShiftsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListZonalShiftsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListZonalShiftsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListZonalShiftsOutput: Swift.Equatable {
    /// The items in the response list.
    public var items: [ARCZonalShiftClientTypes.ZonalShiftSummary]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [ARCZonalShiftClientTypes.ZonalShiftSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListZonalShiftsOutputBody: Swift.Equatable {
    let items: [ARCZonalShiftClientTypes.ZonalShiftSummary]?
    let nextToken: Swift.String?
}

extension ListZonalShiftsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ZonalShiftSummary?].self, forKey: .items)
        var itemsDecoded0:[ARCZonalShiftClientTypes.ZonalShiftSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ARCZonalShiftClientTypes.ZonalShiftSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListZonalShiftsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ARCZonalShiftClientTypes.ManagedResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedWeights
        case arn
        case autoshifts
        case availabilityZones
        case name
        case practiceRunStatus
        case zonalAutoshiftStatus
        case zonalShifts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appliedWeights = appliedWeights {
            var appliedWeightsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .appliedWeights)
            for (dictKey0, appliedWeights0) in appliedWeights {
                try appliedWeightsContainer.encode(appliedWeights0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoshifts = autoshifts {
            var autoshiftsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoshifts)
            for autoshiftinresource0 in autoshifts {
                try autoshiftsContainer.encode(autoshiftinresource0)
            }
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzone0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let practiceRunStatus = self.practiceRunStatus {
            try encodeContainer.encode(practiceRunStatus.rawValue, forKey: .practiceRunStatus)
        }
        if let zonalAutoshiftStatus = self.zonalAutoshiftStatus {
            try encodeContainer.encode(zonalAutoshiftStatus.rawValue, forKey: .zonalAutoshiftStatus)
        }
        if let zonalShifts = zonalShifts {
            var zonalShiftsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .zonalShifts)
            for zonalshiftinresource0 in zonalShifts {
                try zonalShiftsContainer.encode(zonalshiftinresource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let appliedWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Float?].self, forKey: .appliedWeights)
        var appliedWeightsDecoded0: [Swift.String:Swift.Float]? = nil
        if let appliedWeightsContainer = appliedWeightsContainer {
            appliedWeightsDecoded0 = [Swift.String:Swift.Float]()
            for (key0, weight0) in appliedWeightsContainer {
                if let weight0 = weight0 {
                    appliedWeightsDecoded0?[key0] = weight0
                }
            }
        }
        appliedWeights = appliedWeightsDecoded0
        let zonalShiftsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ZonalShiftInResource?].self, forKey: .zonalShifts)
        var zonalShiftsDecoded0:[ARCZonalShiftClientTypes.ZonalShiftInResource]? = nil
        if let zonalShiftsContainer = zonalShiftsContainer {
            zonalShiftsDecoded0 = [ARCZonalShiftClientTypes.ZonalShiftInResource]()
            for structure0 in zonalShiftsContainer {
                if let structure0 = structure0 {
                    zonalShiftsDecoded0?.append(structure0)
                }
            }
        }
        zonalShifts = zonalShiftsDecoded0
        let autoshiftsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.AutoshiftInResource?].self, forKey: .autoshifts)
        var autoshiftsDecoded0:[ARCZonalShiftClientTypes.AutoshiftInResource]? = nil
        if let autoshiftsContainer = autoshiftsContainer {
            autoshiftsDecoded0 = [ARCZonalShiftClientTypes.AutoshiftInResource]()
            for structure0 in autoshiftsContainer {
                if let structure0 = structure0 {
                    autoshiftsDecoded0?.append(structure0)
                }
            }
        }
        autoshifts = autoshiftsDecoded0
        let zonalAutoshiftStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalAutoshiftStatus.self, forKey: .zonalAutoshiftStatus)
        zonalAutoshiftStatus = zonalAutoshiftStatusDecoded
        let practiceRunStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalAutoshiftStatus.self, forKey: .practiceRunStatus)
        practiceRunStatus = practiceRunStatusDecoded
    }
}

extension ARCZonalShiftClientTypes {
    /// A complex structure for a managed resource in an Amazon Web Services account with information about zonal shifts and autoshifts. A managed resource is a load balancer that has been registered with Route 53 ARC by Elastic Load Balancing. You can start a zonal shift in Route 53 ARC for a managed resource to temporarily move traffic for the resource away from an Availability Zone in an Amazon Web Services Region. You can also configure zonal autoshift for a managed resource. At this time, managed resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    public struct ManagedResourceSummary: Swift.Equatable {
        /// A collection of key-value pairs that indicate whether resources are active in Availability Zones or not. The key name is the Availability Zone where the resource is deployed. The value is 1 or 0.
        public var appliedWeights: [Swift.String:Swift.Float]?
        /// The Amazon Resource Name (ARN) for the managed resource.
        public var arn: Swift.String?
        /// An array of the autoshifts that have been completed for a resource.
        public var autoshifts: [ARCZonalShiftClientTypes.AutoshiftInResource]?
        /// The Availability Zones that a resource is deployed in.
        /// This member is required.
        public var availabilityZones: [Swift.String]?
        /// The name of the managed resource.
        public var name: Swift.String?
        /// This status tracks whether a practice run configuration exists for a resource. When you configure a practice run for a resource so that a practice run configuration exists, Route 53 ARC sets this value to ENABLED. If a you have not configured a practice run for the resource, or delete a practice run configuration, Route 53 ARC sets the value to DISABLED. Route 53 ARC updates this status; you can't set a practice run status to ENABLED or DISABLED.
        public var practiceRunStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
        /// The status of autoshift for a resource. When you configure zonal autoshift for a resource, you can set the value of the status to ENABLED or DISABLED.
        public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
        /// An array of the zonal shifts for a resource.
        public var zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]?

        public init(
            appliedWeights: [Swift.String:Swift.Float]? = nil,
            arn: Swift.String? = nil,
            autoshifts: [ARCZonalShiftClientTypes.AutoshiftInResource]? = nil,
            availabilityZones: [Swift.String]? = nil,
            name: Swift.String? = nil,
            practiceRunStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil,
            zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil,
            zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]? = nil
        )
        {
            self.appliedWeights = appliedWeights
            self.arn = arn
            self.autoshifts = autoshifts
            self.availabilityZones = availabilityZones
            self.name = name
            self.practiceRunStatus = practiceRunStatus
            self.zonalAutoshiftStatus = zonalAutoshiftStatus
            self.zonalShifts = zonalShifts
        }
    }

}

extension ARCZonalShiftClientTypes.PracticeRunConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedDates
        case blockedWindows
        case blockingAlarms
        case outcomeAlarms
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockedDates = blockedDates {
            var blockedDatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedDates)
            for blockeddate0 in blockedDates {
                try blockedDatesContainer.encode(blockeddate0)
            }
        }
        if let blockedWindows = blockedWindows {
            var blockedWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedWindows)
            for blockedwindow0 in blockedWindows {
                try blockedWindowsContainer.encode(blockedwindow0)
            }
        }
        if let blockingAlarms = blockingAlarms {
            var blockingAlarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockingAlarms)
            for controlcondition0 in blockingAlarms {
                try blockingAlarmsContainer.encode(controlcondition0)
            }
        }
        if let outcomeAlarms = outcomeAlarms {
            var outcomeAlarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomeAlarms)
            for controlcondition0 in outcomeAlarms {
                try outcomeAlarmsContainer.encode(controlcondition0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockingAlarmsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ControlCondition?].self, forKey: .blockingAlarms)
        var blockingAlarmsDecoded0:[ARCZonalShiftClientTypes.ControlCondition]? = nil
        if let blockingAlarmsContainer = blockingAlarmsContainer {
            blockingAlarmsDecoded0 = [ARCZonalShiftClientTypes.ControlCondition]()
            for structure0 in blockingAlarmsContainer {
                if let structure0 = structure0 {
                    blockingAlarmsDecoded0?.append(structure0)
                }
            }
        }
        blockingAlarms = blockingAlarmsDecoded0
        let outcomeAlarmsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ControlCondition?].self, forKey: .outcomeAlarms)
        var outcomeAlarmsDecoded0:[ARCZonalShiftClientTypes.ControlCondition]? = nil
        if let outcomeAlarmsContainer = outcomeAlarmsContainer {
            outcomeAlarmsDecoded0 = [ARCZonalShiftClientTypes.ControlCondition]()
            for structure0 in outcomeAlarmsContainer {
                if let structure0 = structure0 {
                    outcomeAlarmsDecoded0?.append(structure0)
                }
            }
        }
        outcomeAlarms = outcomeAlarmsDecoded0
        let blockedWindowsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .blockedWindows)
        var blockedWindowsDecoded0:[Swift.String]? = nil
        if let blockedWindowsContainer = blockedWindowsContainer {
            blockedWindowsDecoded0 = [Swift.String]()
            for string0 in blockedWindowsContainer {
                if let string0 = string0 {
                    blockedWindowsDecoded0?.append(string0)
                }
            }
        }
        blockedWindows = blockedWindowsDecoded0
        let blockedDatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .blockedDates)
        var blockedDatesDecoded0:[Swift.String]? = nil
        if let blockedDatesContainer = blockedDatesContainer {
            blockedDatesDecoded0 = [Swift.String]()
            for string0 in blockedDatesContainer {
                if let string0 = string0 {
                    blockedDatesDecoded0?.append(string0)
                }
            }
        }
        blockedDates = blockedDatesDecoded0
    }
}

extension ARCZonalShiftClientTypes {
    /// A practice run configuration for a resource includes the Amazon CloudWatch alarms that you've specified for a practice run, as well as any blocked dates or blocked windows for the practice run. You can update or delete a practice run configuration. Before you delete a practice run configuration, you must disable zonal autoshift for the resource. A practice run configuration is required when zonal autoshift is enabled.
    public struct PracticeRunConfiguration: Swift.Equatable {
        /// An array of one or more dates that you can specify when Amazon Web Services does not start practice runs for a resource. Specify blocked dates, in UTC, in the format YYYY-MM-DD, separated by spaces.
        public var blockedDates: [Swift.String]?
        /// An array of one or more windows of days and times that you can block Route 53 ARC from starting practice runs for a resource. Specify the blocked windows in UTC, using the format DAY:HH:MM-DAY:HH:MM, separated by spaces. For example, MON:18:30-MON:19:30 TUE:18:30-TUE:19:30.
        public var blockedWindows: [Swift.String]?
        /// The blocking alarm for practice runs is an optional alarm that you can specify that blocks practice runs when the alarm is in an ALARM state.
        public var blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
        /// The outcome alarm for practice runs is an alarm that you specify that ends a practice run when the alarm is in an ALARM state.
        /// This member is required.
        public var outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]?

        public init(
            blockedDates: [Swift.String]? = nil,
            blockedWindows: [Swift.String]? = nil,
            blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
            outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil
        )
        {
            self.blockedDates = blockedDates
            self.blockedWindows = blockedWindows
            self.blockingAlarms = blockingAlarms
            self.outcomeAlarms = outcomeAlarms
        }
    }

}

extension ARCZonalShiftClientTypes {
    public enum PracticeRunOutcome: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case interrupted
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [PracticeRunOutcome] {
            return [
                .failed,
                .interrupted,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .interrupted: return "INTERRUPTED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PracticeRunOutcome(rawValue: rawValue) ?? PracticeRunOutcome.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input requested a resource that was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartZonalShiftInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiresIn
        case resourceIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awayFrom = self.awayFrom {
            try encodeContainer.encode(awayFrom, forKey: .awayFrom)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let expiresIn = self.expiresIn {
            try encodeContainer.encode(expiresIn, forKey: .expiresIn)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

extension StartZonalShiftInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/zonalshifts"
    }
}

public struct StartZonalShiftInput: Swift.Equatable {
    /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The length of time that you want a zonal shift to be active, which Route 53 ARC converts to an expiry time (expiration time). Zonal shifts are temporary. You can set a zonal shift to be active initially for up to three days (72 hours). If you want to still keep traffic away from an Availability Zone, you can update the zonal shift and set a new expiration. You can also cancel a zonal shift, before it expires, for example, if you're ready to restore traffic to the Availability Zone. To set a length of time for a zonal shift to be active, specify a whole number, and then one of the following, with no space:
    ///
    /// * A lowercase letter m: To specify that the value is in minutes.
    ///
    /// * A lowercase letter h: To specify that the value is in hours.
    ///
    ///
    /// For example: 20h means the zonal shift expires in 20 hours. 120m means the zonal shift expires in 120 minutes (2 hours).
    /// This member is required.
    public var expiresIn: Swift.String?
    /// The identifier for the resource to shift away traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiresIn: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiresIn = expiresIn
        self.resourceIdentifier = resourceIdentifier
    }
}

struct StartZonalShiftInputBody: Swift.Equatable {
    let resourceIdentifier: Swift.String?
    let awayFrom: Swift.String?
    let expiresIn: Swift.String?
    let comment: Swift.String?
}

extension StartZonalShiftInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiresIn
        case resourceIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension StartZonalShiftOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartZonalShiftOutputBody = try responseDecoder.decode(responseBody: data)
            self.awayFrom = output.awayFrom
            self.comment = output.comment
            self.expiryTime = output.expiryTime
            self.resourceIdentifier = output.resourceIdentifier
            self.startTime = output.startTime
            self.status = output.status
            self.zonalShiftId = output.zonalShiftId
        } else {
            self.awayFrom = nil
            self.comment = nil
            self.expiryTime = nil
            self.resourceIdentifier = nil
            self.startTime = nil
            self.status = nil
            self.zonalShiftId = nil
        }
    }
}

public struct StartZonalShiftOutput: Swift.Equatable {
    /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
    /// This member is required.
    public var expiryTime: ClientRuntime.Date?
    /// The identifier for the resource to shift away traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The time (UTC) when the zonal shift starts.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift has been started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        resourceIdentifier: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiryTime = expiryTime
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.status = status
        self.zonalShiftId = zonalShiftId
    }
}

struct StartZonalShiftOutputBody: Swift.Equatable {
    let zonalShiftId: Swift.String?
    let resourceIdentifier: Swift.String?
    let awayFrom: Swift.String?
    let expiryTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    let comment: Swift.String?
}

extension StartZonalShiftOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiryTime
        case resourceIdentifier
        case startTime
        case status
        case zonalShiftId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalShiftStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum StartZonalShiftOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdatePracticeRunConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedDates
        case blockedWindows
        case blockingAlarms
        case outcomeAlarms
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockedDates = blockedDates {
            var blockedDatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedDates)
            for blockeddate0 in blockedDates {
                try blockedDatesContainer.encode(blockeddate0)
            }
        }
        if let blockedWindows = blockedWindows {
            var blockedWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockedWindows)
            for blockedwindow0 in blockedWindows {
                try blockedWindowsContainer.encode(blockedwindow0)
            }
        }
        if let blockingAlarms = blockingAlarms {
            var blockingAlarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockingAlarms)
            for controlcondition0 in blockingAlarms {
                try blockingAlarmsContainer.encode(controlcondition0)
            }
        }
        if let outcomeAlarms = outcomeAlarms {
            var outcomeAlarmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomeAlarms)
            for controlcondition0 in outcomeAlarms {
                try outcomeAlarmsContainer.encode(controlcondition0)
            }
        }
    }
}

extension UpdatePracticeRunConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/configuration/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct UpdatePracticeRunConfigurationInput: Swift.Equatable {
    /// Add, change, or remove blocked dates for a practice run in zonal autoshift. Optionally, you can block practice runs for specific calendar dates. The format for blocked dates is: YYYY-MM-DD. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Separate multiple blocked dates with spaces. For example, if you have an application update scheduled to launch on May 1, 2024, and you don't want practice runs to shift traffic away at that time, you could set a blocked date for 2024-05-01.
    public var blockedDates: [Swift.String]?
    /// Add, change, or remove windows of days and times for when you can, optionally, block Route 53 ARC from starting a practice run for a resource. The format for blocked windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple blocked windows with spaces. For example, say you run business report summaries three days a week. For this scenario, you might set the following recurring days and times as blocked windows, for example: MON-20:30-21:30 WED-20:30-21:30 FRI-20:30-21:30.
    public var blockedWindows: [Swift.String]?
    /// Add, change, or remove the Amazon CloudWatch alarm that you optionally specify as the blocking alarm for practice runs.
    public var blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    /// Specify a new the Amazon CloudWatch alarm as the outcome alarm for practice runs.
    public var outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    /// The identifier for the resource that you want to update the practice run configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        blockedDates: [Swift.String]? = nil,
        blockedWindows: [Swift.String]? = nil,
        blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
        outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.blockedDates = blockedDates
        self.blockedWindows = blockedWindows
        self.blockingAlarms = blockingAlarms
        self.outcomeAlarms = outcomeAlarms
        self.resourceIdentifier = resourceIdentifier
    }
}

struct UpdatePracticeRunConfigurationInputBody: Swift.Equatable {
    let blockedWindows: [Swift.String]?
    let blockedDates: [Swift.String]?
    let blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    let outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
}

extension UpdatePracticeRunConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockedDates
        case blockedWindows
        case blockingAlarms
        case outcomeAlarms
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedWindowsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .blockedWindows)
        var blockedWindowsDecoded0:[Swift.String]? = nil
        if let blockedWindowsContainer = blockedWindowsContainer {
            blockedWindowsDecoded0 = [Swift.String]()
            for string0 in blockedWindowsContainer {
                if let string0 = string0 {
                    blockedWindowsDecoded0?.append(string0)
                }
            }
        }
        blockedWindows = blockedWindowsDecoded0
        let blockedDatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .blockedDates)
        var blockedDatesDecoded0:[Swift.String]? = nil
        if let blockedDatesContainer = blockedDatesContainer {
            blockedDatesDecoded0 = [Swift.String]()
            for string0 in blockedDatesContainer {
                if let string0 = string0 {
                    blockedDatesDecoded0?.append(string0)
                }
            }
        }
        blockedDates = blockedDatesDecoded0
        let blockingAlarmsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ControlCondition?].self, forKey: .blockingAlarms)
        var blockingAlarmsDecoded0:[ARCZonalShiftClientTypes.ControlCondition]? = nil
        if let blockingAlarmsContainer = blockingAlarmsContainer {
            blockingAlarmsDecoded0 = [ARCZonalShiftClientTypes.ControlCondition]()
            for structure0 in blockingAlarmsContainer {
                if let structure0 = structure0 {
                    blockingAlarmsDecoded0?.append(structure0)
                }
            }
        }
        blockingAlarms = blockingAlarmsDecoded0
        let outcomeAlarmsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ControlCondition?].self, forKey: .outcomeAlarms)
        var outcomeAlarmsDecoded0:[ARCZonalShiftClientTypes.ControlCondition]? = nil
        if let outcomeAlarmsContainer = outcomeAlarmsContainer {
            outcomeAlarmsDecoded0 = [ARCZonalShiftClientTypes.ControlCondition]()
            for structure0 in outcomeAlarmsContainer {
                if let structure0 = structure0 {
                    outcomeAlarmsDecoded0?.append(structure0)
                }
            }
        }
        outcomeAlarms = outcomeAlarmsDecoded0
    }
}

extension UpdatePracticeRunConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePracticeRunConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.practiceRunConfiguration = output.practiceRunConfiguration
            self.zonalAutoshiftStatus = output.zonalAutoshiftStatus
        } else {
            self.arn = nil
            self.name = nil
            self.practiceRunConfiguration = nil
            self.zonalAutoshiftStatus = nil
        }
    }
}

public struct UpdatePracticeRunConfigurationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you updated the practice run for.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the resource that you updated the practice run for.
    /// This member is required.
    public var name: Swift.String?
    /// The practice run configuration that was updated.
    /// This member is required.
    public var practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration?
    /// The zonal autoshift status for the resource that you updated the practice run for.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.practiceRunConfiguration = practiceRunConfiguration
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

struct UpdatePracticeRunConfigurationOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
    let practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration?
}

extension UpdatePracticeRunConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case practiceRunConfiguration
        case zonalAutoshiftStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let zonalAutoshiftStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalAutoshiftStatus.self, forKey: .zonalAutoshiftStatus)
        zonalAutoshiftStatus = zonalAutoshiftStatusDecoded
        let practiceRunConfigurationDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.PracticeRunConfiguration.self, forKey: .practiceRunConfiguration)
        practiceRunConfiguration = practiceRunConfigurationDecoded
    }
}

enum UpdatePracticeRunConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateZonalAutoshiftConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case zonalAutoshiftStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let zonalAutoshiftStatus = self.zonalAutoshiftStatus {
            try encodeContainer.encode(zonalAutoshiftStatus.rawValue, forKey: .zonalAutoshiftStatus)
        }
    }
}

extension UpdateZonalAutoshiftConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/managedresources/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateZonalAutoshiftConfigurationInput: Swift.Equatable {
    /// The identifier for the resource that you want to update the zonal autoshift configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The zonal autoshift status for the resource that you want to update the zonal autoshift configuration for.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        resourceIdentifier: Swift.String? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

struct UpdateZonalAutoshiftConfigurationInputBody: Swift.Equatable {
    let zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
}

extension UpdateZonalAutoshiftConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case zonalAutoshiftStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zonalAutoshiftStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalAutoshiftStatus.self, forKey: .zonalAutoshiftStatus)
        zonalAutoshiftStatus = zonalAutoshiftStatusDecoded
    }
}

extension UpdateZonalAutoshiftConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateZonalAutoshiftConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceIdentifier = output.resourceIdentifier
            self.zonalAutoshiftStatus = output.zonalAutoshiftStatus
        } else {
            self.resourceIdentifier = nil
            self.zonalAutoshiftStatus = nil
        }
    }
}

public struct UpdateZonalAutoshiftConfigurationOutput: Swift.Equatable {
    /// The identifier for the resource that you updated the zonal autoshift configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The zonal autoshift status for the resource that you updated the zonal autoshift configuration for.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        resourceIdentifier: Swift.String? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

struct UpdateZonalAutoshiftConfigurationOutputBody: Swift.Equatable {
    let resourceIdentifier: Swift.String?
    let zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
}

extension UpdateZonalAutoshiftConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIdentifier
        case zonalAutoshiftStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let zonalAutoshiftStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalAutoshiftStatus.self, forKey: .zonalAutoshiftStatus)
        zonalAutoshiftStatus = zonalAutoshiftStatusDecoded
    }
}

enum UpdateZonalAutoshiftConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateZonalShiftInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case expiresIn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let expiresIn = self.expiresIn {
            try encodeContainer.encode(expiresIn, forKey: .expiresIn)
        }
    }
}

extension UpdateZonalShiftInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let zonalShiftId = zonalShiftId else {
            return nil
        }
        return "/zonalshifts/\(zonalShiftId.urlPercentEncoding())"
    }
}

public struct UpdateZonalShiftInput: Swift.Equatable {
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    public var comment: Swift.String?
    /// The length of time that you want a zonal shift to be active, which Route 53 ARC converts to an expiry time (expiration time). Zonal shifts are temporary. You can set a zonal shift to be active initially for up to three days (72 hours). If you want to still keep traffic away from an Availability Zone, you can update the zonal shift and set a new expiration. You can also cancel a zonal shift, before it expires, for example, if you're ready to restore traffic to the Availability Zone. To set a length of time for a zonal shift to be active, specify a whole number, and then one of the following, with no space:
    ///
    /// * A lowercase letter m: To specify that the value is in minutes.
    ///
    /// * A lowercase letter h: To specify that the value is in hours.
    ///
    ///
    /// For example: 20h means the zonal shift expires in 20 hours. 120m means the zonal shift expires in 120 minutes (2 hours).
    public var expiresIn: Swift.String?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        comment: Swift.String? = nil,
        expiresIn: Swift.String? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.comment = comment
        self.expiresIn = expiresIn
        self.zonalShiftId = zonalShiftId
    }
}

struct UpdateZonalShiftInputBody: Swift.Equatable {
    let comment: Swift.String?
    let expiresIn: Swift.String?
}

extension UpdateZonalShiftInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case expiresIn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
    }
}

extension UpdateZonalShiftOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateZonalShiftOutputBody = try responseDecoder.decode(responseBody: data)
            self.awayFrom = output.awayFrom
            self.comment = output.comment
            self.expiryTime = output.expiryTime
            self.resourceIdentifier = output.resourceIdentifier
            self.startTime = output.startTime
            self.status = output.status
            self.zonalShiftId = output.zonalShiftId
        } else {
            self.awayFrom = nil
            self.comment = nil
            self.expiryTime = nil
            self.resourceIdentifier = nil
            self.startTime = nil
            self.status = nil
            self.zonalShiftId = nil
        }
    }
}

public struct UpdateZonalShiftOutput: Swift.Equatable {
    /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
    /// This member is required.
    public var expiryTime: ClientRuntime.Date?
    /// The identifier for the resource to shift away traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The time (UTC) when the zonal shift starts.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift has been started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        resourceIdentifier: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiryTime = expiryTime
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.status = status
        self.zonalShiftId = zonalShiftId
    }
}

struct UpdateZonalShiftOutputBody: Swift.Equatable {
    let zonalShiftId: Swift.String?
    let resourceIdentifier: Swift.String?
    let awayFrom: Swift.String?
    let expiryTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    let comment: Swift.String?
}

extension UpdateZonalShiftOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiryTime
        case resourceIdentifier
        case startTime
        case status
        case zonalShiftId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalShiftStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

enum UpdateZonalShiftOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        /// This member is required.
        public internal(set) var reason: ARCZonalShiftClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: ARCZonalShiftClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: ARCZonalShiftClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ARCZonalShiftClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidAlarmCondition
        case invalidAz
        case invalidConditionType
        case invalidExpiresIn
        case invalidPracticeBlocker
        case invalidResourceIdentifier
        case invalidStatus
        case invalidToken
        case missingValue
        case unsupportedAz
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .invalidAlarmCondition,
                .invalidAz,
                .invalidConditionType,
                .invalidExpiresIn,
                .invalidPracticeBlocker,
                .invalidResourceIdentifier,
                .invalidStatus,
                .invalidToken,
                .missingValue,
                .unsupportedAz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidAlarmCondition: return "InvalidAlarmCondition"
            case .invalidAz: return "InvalidAz"
            case .invalidConditionType: return "InvalidConditionType"
            case .invalidExpiresIn: return "InvalidExpiresIn"
            case .invalidPracticeBlocker: return "InvalidPracticeBlocker"
            case .invalidResourceIdentifier: return "InvalidResourceIdentifier"
            case .invalidStatus: return "InvalidStatus"
            case .invalidToken: return "InvalidToken"
            case .missingValue: return "MissingValue"
            case .unsupportedAz: return "UnsupportedAz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension ARCZonalShiftClientTypes {
    public enum ZonalAutoshiftStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ZonalAutoshiftStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ZonalAutoshiftStatus(rawValue: rawValue) ?? ZonalAutoshiftStatus.sdkUnknown(rawValue)
        }
    }
}

extension ARCZonalShiftClientTypes.ZonalShiftInResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedStatus
        case awayFrom
        case comment
        case expiryTime
        case practiceRunOutcome
        case resourceIdentifier
        case startTime
        case zonalShiftId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appliedStatus = self.appliedStatus {
            try encodeContainer.encode(appliedStatus.rawValue, forKey: .appliedStatus)
        }
        if let awayFrom = self.awayFrom {
            try encodeContainer.encode(awayFrom, forKey: .awayFrom)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let expiryTime = self.expiryTime {
            try encodeContainer.encodeTimestamp(expiryTime, format: .epochSeconds, forKey: .expiryTime)
        }
        if let practiceRunOutcome = self.practiceRunOutcome {
            try encodeContainer.encode(practiceRunOutcome.rawValue, forKey: .practiceRunOutcome)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let zonalShiftId = self.zonalShiftId {
            try encodeContainer.encode(zonalShiftId, forKey: .zonalShiftId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appliedStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.AppliedStatus.self, forKey: .appliedStatus)
        appliedStatus = appliedStatusDecoded
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let practiceRunOutcomeDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.PracticeRunOutcome.self, forKey: .practiceRunOutcome)
        practiceRunOutcome = practiceRunOutcomeDecoded
    }
}

extension ARCZonalShiftClientTypes {
    /// A complex structure that lists the zonal shifts for a managed resource and their statuses for the resource.
    public struct ZonalShiftInResource: Swift.Equatable {
        /// The appliedStatus field specifies which application traffic shift is in effect for a resource when there is more than one traffic shift active. There can be more than one application traffic shift in progress at the same time - that is, practice run zonal shifts, customer-started zonal shifts, or an autoshift. The appliedStatus field for an autoshift for a resource can have one of two values: APPLIED or NOT_APPLIED. The zonal shift or autoshift that is currently in effect for the resource has an applied status set to APPLIED. The overall principle for precedence is that zonal shifts that you start as a customer take precedence autoshifts, which take precedence over practice runs. That is, customer-started zonal shifts > autoshifts > practice run zonal shifts. For more information, see [How zonal autoshift and practice runs work](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
        /// This member is required.
        public var appliedStatus: ARCZonalShiftClientTypes.AppliedStatus?
        /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.
        /// This member is required.
        public var comment: Swift.String?
        /// The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
        /// This member is required.
        public var expiryTime: ClientRuntime.Date?
        /// The outcome, or end state, returned for a practice run. The following values can be returned:
        ///
        /// * PENDING: Outcome value when a practice run is in progress.
        ///
        /// * SUCCEEDED: Outcome value when the outcome alarm specified for the practice run configuration does not go into an ALARM state during the practice run, and the practice run was not interrupted before it completed the expected 30 minute zonal shift.
        ///
        /// * INTERRUPTED: Outcome value when the practice run was stopped before the expected 30 minute zonal shift duration, or there was another problem with the practice run that created an inconclusive outcome.
        ///
        /// * FAILED: Outcome value when the outcome alarm specified for the practice run configuration goes into an ALARM state during the practice run, and the practice run was not interrupted before it completed.
        ///
        ///
        /// For more information about practice run outcomes, see [ Considerations when you configure zonal autoshift](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.configure.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
        public var practiceRunOutcome: ARCZonalShiftClientTypes.PracticeRunOutcome?
        /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
        /// This member is required.
        public var resourceIdentifier: Swift.String?
        /// The time (UTC) when the zonal shift starts.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The identifier of a zonal shift.
        /// This member is required.
        public var zonalShiftId: Swift.String?

        public init(
            appliedStatus: ARCZonalShiftClientTypes.AppliedStatus? = nil,
            awayFrom: Swift.String? = nil,
            comment: Swift.String? = nil,
            expiryTime: ClientRuntime.Date? = nil,
            practiceRunOutcome: ARCZonalShiftClientTypes.PracticeRunOutcome? = nil,
            resourceIdentifier: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            zonalShiftId: Swift.String? = nil
        )
        {
            self.appliedStatus = appliedStatus
            self.awayFrom = awayFrom
            self.comment = comment
            self.expiryTime = expiryTime
            self.practiceRunOutcome = practiceRunOutcome
            self.resourceIdentifier = resourceIdentifier
            self.startTime = startTime
            self.zonalShiftId = zonalShiftId
        }
    }

}

extension ARCZonalShiftClientTypes {
    public enum ZonalShiftStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case expired
        case sdkUnknown(Swift.String)

        public static var allCases: [ZonalShiftStatus] {
            return [
                .active,
                .canceled,
                .expired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .expired: return "EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ZonalShiftStatus(rawValue: rawValue) ?? ZonalShiftStatus.sdkUnknown(rawValue)
        }
    }
}

extension ARCZonalShiftClientTypes.ZonalShiftSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiryTime
        case practiceRunOutcome
        case resourceIdentifier
        case startTime
        case status
        case zonalShiftId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awayFrom = self.awayFrom {
            try encodeContainer.encode(awayFrom, forKey: .awayFrom)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let expiryTime = self.expiryTime {
            try encodeContainer.encodeTimestamp(expiryTime, format: .epochSeconds, forKey: .expiryTime)
        }
        if let practiceRunOutcome = self.practiceRunOutcome {
            try encodeContainer.encode(practiceRunOutcome.rawValue, forKey: .practiceRunOutcome)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let zonalShiftId = self.zonalShiftId {
            try encodeContainer.encode(zonalShiftId, forKey: .zonalShiftId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalShiftStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let practiceRunOutcomeDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.PracticeRunOutcome.self, forKey: .practiceRunOutcome)
        practiceRunOutcome = practiceRunOutcomeDecoded
    }
}

extension ARCZonalShiftClientTypes {
    /// Lists information about zonal shifts in Amazon Route 53 Application Recovery Controller, including zonal shifts that you start yourself and zonal shifts that Route 53 ARC starts on your behalf for practice runs with zonal autoshift. Zonal shifts are temporary, including customer-started zonal shifts and the zonal autoshift practice run zonal shifts that Route 53 ARC starts weekly, on your behalf. A zonal shift that a customer starts can be active for up to three days (72 hours). A practice run zonal shift has a 30 minute duration.
    public struct ZonalShiftSummary: Swift.Equatable {
        /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.
        /// This member is required.
        public var comment: Swift.String?
        /// The expiry time (expiration time) for a customer-started zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
        /// This member is required.
        public var expiryTime: ClientRuntime.Date?
        /// The outcome, or end state, of a practice run. The following values can be returned:
        ///
        /// * PENDING: Outcome value when the practice run is in progress.
        ///
        /// * SUCCEEDED: Outcome value when the outcome alarm specified for the practice run configuration does not go into an ALARM state during the practice run, and the practice run was not interrupted before it completed.
        ///
        /// * INTERRUPTED: Outcome value when the practice run did not run for the expected 30 minutes or there was another problem with the practice run that created an inconclusive outcome.
        ///
        /// * FAILED: Outcome value when the outcome alarm specified for the practice run configuration goes into an ALARM state during the practice run, and the practice run was not interrupted before it completed.
        ///
        ///
        /// For more information about practice run outcomes, see [ Considerations when you configure zonal autoshift](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.configure.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
        public var practiceRunOutcome: ARCZonalShiftClientTypes.PracticeRunOutcome?
        /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
        /// This member is required.
        public var resourceIdentifier: Swift.String?
        /// The time (UTC) when the zonal shift starts.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
        ///
        /// * ACTIVE: The zonal shift has been started and active.
        ///
        /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
        ///
        /// * CANCELED: The zonal shift was canceled.
        /// This member is required.
        public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
        /// The identifier of a zonal shift.
        /// This member is required.
        public var zonalShiftId: Swift.String?

        public init(
            awayFrom: Swift.String? = nil,
            comment: Swift.String? = nil,
            expiryTime: ClientRuntime.Date? = nil,
            practiceRunOutcome: ARCZonalShiftClientTypes.PracticeRunOutcome? = nil,
            resourceIdentifier: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
            zonalShiftId: Swift.String? = nil
        )
        {
            self.awayFrom = awayFrom
            self.comment = comment
            self.expiryTime = expiryTime
            self.practiceRunOutcome = practiceRunOutcome
            self.resourceIdentifier = resourceIdentifier
            self.startTime = startTime
            self.status = status
            self.zonalShiftId = zonalShiftId
        }
    }

}
