// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ARCZonalShiftClientTypes {
    public enum AppliedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applied
        case notApplied
        case sdkUnknown(Swift.String)

        public static var allCases: [AppliedStatus] {
            return [
                .applied,
                .notApplied,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .notApplied: return "NOT_APPLIED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppliedStatus(rawValue: rawValue) ?? AppliedStatus.sdkUnknown(rawValue)
        }
    }
}

extension CancelZonalShiftInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let zonalShiftId = zonalShiftId else {
            return nil
        }
        return "/zonalshifts/\(zonalShiftId.urlPercentEncoding())"
    }
}

public struct CancelZonalShiftInput: Swift.Equatable {
    /// The internally-generated identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init (
        zonalShiftId: Swift.String? = nil
    )
    {
        self.zonalShiftId = zonalShiftId
    }
}

struct CancelZonalShiftInputBody: Swift.Equatable {
}

extension CancelZonalShiftInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelZonalShiftOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelZonalShiftOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelZonalShiftOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelZonalShiftOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelZonalShiftOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awayFrom = output.awayFrom
            self.comment = output.comment
            self.expiryTime = output.expiryTime
            self.resourceIdentifier = output.resourceIdentifier
            self.startTime = output.startTime
            self.status = output.status
            self.zonalShiftId = output.zonalShiftId
        } else {
            self.awayFrom = nil
            self.comment = nil
            self.expiryTime = nil
            self.resourceIdentifier = nil
            self.startTime = nil
            self.status = nil
            self.zonalShiftId = nil
        }
    }
}

public struct CancelZonalShiftOutputResponse: Swift.Equatable {
    /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.
    /// This member is required.
    public var expiryTime: ClientRuntime.Date?
    /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The time (UTC) when the zonal shift is started.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift is started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init (
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        resourceIdentifier: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiryTime = expiryTime
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.status = status
        self.zonalShiftId = zonalShiftId
    }
}

struct CancelZonalShiftOutputResponseBody: Swift.Equatable {
    let zonalShiftId: Swift.String?
    let resourceIdentifier: Swift.String?
    let awayFrom: Swift.String?
    let expiryTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    let comment: Swift.String?
}

extension CancelZonalShiftOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiryTime
        case resourceIdentifier
        case startTime
        case status
        case zonalShiftId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalShiftStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
            self.zonalShiftId = output.zonalShiftId
        } else {
            self.message = nil
            self.reason = nil
            self.zonalShiftId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the conflict exception.
    /// This member is required.
    public var reason: ARCZonalShiftClientTypes.ConflictExceptionReason?
    /// The zonal shift ID associated with the conflict exception.
    public var zonalShiftId: Swift.String?

    public init (
        message: Swift.String? = nil,
        reason: ARCZonalShiftClientTypes.ConflictExceptionReason? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.message = message
        self.reason = reason
        self.zonalShiftId = zonalShiftId
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: ARCZonalShiftClientTypes.ConflictExceptionReason?
    let zonalShiftId: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
        case zonalShiftId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
    }
}

extension ARCZonalShiftClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case simultaneousZonalShiftsConflict
        case zonalShiftAlreadyExists
        case zonalShiftStatusNotActive
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .simultaneousZonalShiftsConflict,
                .zonalShiftAlreadyExists,
                .zonalShiftStatusNotActive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .simultaneousZonalShiftsConflict: return "SimultaneousZonalShiftsConflict"
            case .zonalShiftAlreadyExists: return "ZonalShiftAlreadyExists"
            case .zonalShiftStatusNotActive: return "ZonalShiftStatusNotActive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension GetManagedResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/managedresources/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetManagedResourceInput: Swift.Equatable {
    /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init (
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

struct GetManagedResourceInputBody: Swift.Equatable {
}

extension GetManagedResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetManagedResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetManagedResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetManagedResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetManagedResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetManagedResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appliedWeights = output.appliedWeights
            self.arn = output.arn
            self.name = output.name
            self.zonalShifts = output.zonalShifts
        } else {
            self.appliedWeights = nil
            self.arn = nil
            self.name = nil
            self.zonalShifts = nil
        }
    }
}

public struct GetManagedResourceOutputResponse: Swift.Equatable {
    /// A collection of key-value pairs that indicate whether resources are active in Availability Zones or not. The key name is the Availability Zone where the resource is deployed. The value is 1 or 0.
    /// This member is required.
    public var appliedWeights: [Swift.String:Swift.Float]?
    /// The Amazon Resource Name (ARN) for the resource.
    public var arn: Swift.String?
    /// The name of the resource.
    public var name: Swift.String?
    /// The zonal shifts that are currently active for a resource.
    /// This member is required.
    public var zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]?

    public init (
        appliedWeights: [Swift.String:Swift.Float]? = nil,
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]? = nil
    )
    {
        self.appliedWeights = appliedWeights
        self.arn = arn
        self.name = name
        self.zonalShifts = zonalShifts
    }
}

struct GetManagedResourceOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let appliedWeights: [Swift.String:Swift.Float]?
    let zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]?
}

extension GetManagedResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedWeights
        case arn
        case name
        case zonalShifts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let appliedWeightsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Float?].self, forKey: .appliedWeights)
        var appliedWeightsDecoded0: [Swift.String:Swift.Float]? = nil
        if let appliedWeightsContainer = appliedWeightsContainer {
            appliedWeightsDecoded0 = [Swift.String:Swift.Float]()
            for (key0, weight0) in appliedWeightsContainer {
                if let weight0 = weight0 {
                    appliedWeightsDecoded0?[key0] = weight0
                }
            }
        }
        appliedWeights = appliedWeightsDecoded0
        let zonalShiftsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ZonalShiftInResource?].self, forKey: .zonalShifts)
        var zonalShiftsDecoded0:[ARCZonalShiftClientTypes.ZonalShiftInResource]? = nil
        if let zonalShiftsContainer = zonalShiftsContainer {
            zonalShiftsDecoded0 = [ARCZonalShiftClientTypes.ZonalShiftInResource]()
            for structure0 in zonalShiftsContainer {
                if let structure0 = structure0 {
                    zonalShiftsDecoded0?.append(structure0)
                }
            }
        }
        zonalShifts = zonalShiftsDecoded0
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an internal server error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListManagedResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListManagedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/managedresources"
    }
}

public struct ListManagedResourcesInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListManagedResourcesInputBody: Swift.Equatable {
}

extension ListManagedResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListManagedResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListManagedResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListManagedResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListManagedResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListManagedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedResourcesOutputResponse: Swift.Equatable {
    /// The items in the response list.
    /// This member is required.
    public var items: [ARCZonalShiftClientTypes.ManagedResourceSummary]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [ARCZonalShiftClientTypes.ManagedResourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListManagedResourcesOutputResponseBody: Swift.Equatable {
    let items: [ARCZonalShiftClientTypes.ManagedResourceSummary]?
    let nextToken: Swift.String?
}

extension ListManagedResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ManagedResourceSummary?].self, forKey: .items)
        var itemsDecoded0:[ARCZonalShiftClientTypes.ManagedResourceSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ARCZonalShiftClientTypes.ManagedResourceSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListZonalShiftsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListZonalShiftsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/zonalshifts"
    }
}

public struct ListZonalShiftsInput: Swift.Equatable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift is started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListZonalShiftsInputBody: Swift.Equatable {
}

extension ListZonalShiftsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListZonalShiftsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListZonalShiftsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListZonalShiftsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListZonalShiftsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListZonalShiftsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListZonalShiftsOutputResponse: Swift.Equatable {
    /// The items in the response list.
    public var items: [ARCZonalShiftClientTypes.ZonalShiftSummary]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [ARCZonalShiftClientTypes.ZonalShiftSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListZonalShiftsOutputResponseBody: Swift.Equatable {
    let items: [ARCZonalShiftClientTypes.ZonalShiftSummary]?
    let nextToken: Swift.String?
}

extension ListZonalShiftsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ARCZonalShiftClientTypes.ZonalShiftSummary?].self, forKey: .items)
        var itemsDecoded0:[ARCZonalShiftClientTypes.ZonalShiftSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ARCZonalShiftClientTypes.ZonalShiftSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ARCZonalShiftClientTypes.ManagedResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case availabilityZones
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzone0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension ARCZonalShiftClientTypes {
    /// A complex structure for a managed resource in an account. A managed resource is a Network Load Balancer or Application Load Balancer that has been registered with Route 53 ARC by Elastic Load Balancing. You can start a zonal shift in Route 53 ARC for a managed resource to temporarily move traffic for the resource away from an Availability Zone in an AWS Region. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    public struct ManagedResourceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the managed resource.
        public var arn: Swift.String?
        /// The Availability Zones that a resource is deployed in.
        /// This member is required.
        public var availabilityZones: [Swift.String]?
        /// The name of the managed resource.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            availabilityZones: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.availabilityZones = availabilityZones
            self.name = name
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input requested a resource that was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartZonalShiftInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiresIn
        case resourceIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awayFrom = self.awayFrom {
            try encodeContainer.encode(awayFrom, forKey: .awayFrom)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let expiresIn = self.expiresIn {
            try encodeContainer.encode(expiresIn, forKey: .expiresIn)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }
}

extension StartZonalShiftInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/zonalshifts"
    }
}

public struct StartZonalShiftInput: Swift.Equatable {
    /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The length of time that you want a zonal shift to be active, which Route 53 ARC converts to an expiry time (expiration time). Zonal shifts are temporary. You can set a zonal shift to be active initially for up to three days (72 hours). If you want to still keep traffic away from an Availability Zone, you can update the zonal shift and set a new expiration. You can also cancel a zonal shift, before it expires, for example, if you're ready to restore traffic to the Availability Zone. To set a length of time for a zonal shift to be active, specify a whole number, and then one of the following, with no space:
    ///
    /// * A lowercase letter m: To specify that the value is in minutes.
    ///
    /// * A lowercase letter h: To specify that the value is in hours.
    ///
    ///
    /// For example: 20h means the zonal shift expires in 20 hours. 120m means the zonal shift expires in 120 minutes (2 hours).
    /// This member is required.
    public var expiresIn: Swift.String?
    /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init (
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiresIn: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiresIn = expiresIn
        self.resourceIdentifier = resourceIdentifier
    }
}

struct StartZonalShiftInputBody: Swift.Equatable {
    let resourceIdentifier: Swift.String?
    let awayFrom: Swift.String?
    let expiresIn: Swift.String?
    let comment: Swift.String?
}

extension StartZonalShiftInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiresIn
        case resourceIdentifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension StartZonalShiftOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartZonalShiftOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartZonalShiftOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartZonalShiftOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartZonalShiftOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awayFrom = output.awayFrom
            self.comment = output.comment
            self.expiryTime = output.expiryTime
            self.resourceIdentifier = output.resourceIdentifier
            self.startTime = output.startTime
            self.status = output.status
            self.zonalShiftId = output.zonalShiftId
        } else {
            self.awayFrom = nil
            self.comment = nil
            self.expiryTime = nil
            self.resourceIdentifier = nil
            self.startTime = nil
            self.status = nil
            self.zonalShiftId = nil
        }
    }
}

public struct StartZonalShiftOutputResponse: Swift.Equatable {
    /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.
    /// This member is required.
    public var expiryTime: ClientRuntime.Date?
    /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The time (UTC) when the zonal shift is started.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift is started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init (
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        resourceIdentifier: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiryTime = expiryTime
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.status = status
        self.zonalShiftId = zonalShiftId
    }
}

struct StartZonalShiftOutputResponseBody: Swift.Equatable {
    let zonalShiftId: Swift.String?
    let resourceIdentifier: Swift.String?
    let awayFrom: Swift.String?
    let expiryTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    let comment: Swift.String?
}

extension StartZonalShiftOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiryTime
        case resourceIdentifier
        case startTime
        case status
        case zonalShiftId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalShiftStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateZonalShiftInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case expiresIn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let expiresIn = self.expiresIn {
            try encodeContainer.encode(expiresIn, forKey: .expiresIn)
        }
    }
}

extension UpdateZonalShiftInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let zonalShiftId = zonalShiftId else {
            return nil
        }
        return "/zonalshifts/\(zonalShiftId.urlPercentEncoding())"
    }
}

public struct UpdateZonalShiftInput: Swift.Equatable {
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    public var comment: Swift.String?
    /// The length of time that you want a zonal shift to be active, which Route 53 ARC converts to an expiry time (expiration time). Zonal shifts are temporary. You can set a zonal shift to be active initially for up to three days (72 hours). If you want to still keep traffic away from an Availability Zone, you can update the zonal shift and set a new expiration. You can also cancel a zonal shift, before it expires, for example, if you're ready to restore traffic to the Availability Zone. To set a length of time for a zonal shift to be active, specify a whole number, and then one of the following, with no space:
    ///
    /// * A lowercase letter m: To specify that the value is in minutes.
    ///
    /// * A lowercase letter h: To specify that the value is in hours.
    ///
    ///
    /// For example: 20h means the zonal shift expires in 20 hours. 120m means the zonal shift expires in 120 minutes (2 hours).
    public var expiresIn: Swift.String?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init (
        comment: Swift.String? = nil,
        expiresIn: Swift.String? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.comment = comment
        self.expiresIn = expiresIn
        self.zonalShiftId = zonalShiftId
    }
}

struct UpdateZonalShiftInputBody: Swift.Equatable {
    let comment: Swift.String?
    let expiresIn: Swift.String?
}

extension UpdateZonalShiftInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case expiresIn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
    }
}

extension UpdateZonalShiftOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateZonalShiftOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateZonalShiftOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateZonalShiftOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateZonalShiftOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.awayFrom = output.awayFrom
            self.comment = output.comment
            self.expiryTime = output.expiryTime
            self.resourceIdentifier = output.resourceIdentifier
            self.startTime = output.startTime
            self.status = output.status
            self.zonalShiftId = output.zonalShiftId
        } else {
            self.awayFrom = nil
            self.comment = nil
            self.expiryTime = nil
            self.resourceIdentifier = nil
            self.startTime = nil
            self.status = nil
            self.zonalShiftId = nil
        }
    }
}

public struct UpdateZonalShiftOutputResponse: Swift.Equatable {
    /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.
    /// This member is required.
    public var expiryTime: ClientRuntime.Date?
    /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The time (UTC) when the zonal shift is started.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift is started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init (
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        resourceIdentifier: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiryTime = expiryTime
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.status = status
        self.zonalShiftId = zonalShiftId
    }
}

struct UpdateZonalShiftOutputResponseBody: Swift.Equatable {
    let zonalShiftId: Swift.String?
    let resourceIdentifier: Swift.String?
    let awayFrom: Swift.String?
    let expiryTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    let comment: Swift.String?
}

extension UpdateZonalShiftOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiryTime
        case resourceIdentifier
        case startTime
        case status
        case zonalShiftId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalShiftStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the validation exception.
    /// This member is required.
    public var reason: ARCZonalShiftClientTypes.ValidationExceptionReason?

    public init (
        message: Swift.String? = nil,
        reason: ARCZonalShiftClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: ARCZonalShiftClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ARCZonalShiftClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidAz
        case invalidExpiresIn
        case invalidResourceIdentifier
        case invalidStatus
        case invalidToken
        case missingValue
        case unsupportedAz
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .invalidAz,
                .invalidExpiresIn,
                .invalidResourceIdentifier,
                .invalidStatus,
                .invalidToken,
                .missingValue,
                .unsupportedAz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidAz: return "InvalidAz"
            case .invalidExpiresIn: return "InvalidExpiresIn"
            case .invalidResourceIdentifier: return "InvalidResourceIdentifier"
            case .invalidStatus: return "InvalidStatus"
            case .invalidToken: return "InvalidToken"
            case .missingValue: return "MissingValue"
            case .unsupportedAz: return "UnsupportedAz"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension ARCZonalShiftClientTypes.ZonalShiftInResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedStatus
        case awayFrom
        case comment
        case expiryTime
        case resourceIdentifier
        case startTime
        case zonalShiftId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appliedStatus = self.appliedStatus {
            try encodeContainer.encode(appliedStatus.rawValue, forKey: .appliedStatus)
        }
        if let awayFrom = self.awayFrom {
            try encodeContainer.encode(awayFrom, forKey: .awayFrom)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let expiryTime = self.expiryTime {
            try encodeContainer.encodeTimestamp(expiryTime, format: .epochSeconds, forKey: .expiryTime)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let zonalShiftId = self.zonalShiftId {
            try encodeContainer.encode(zonalShiftId, forKey: .zonalShiftId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appliedStatusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.AppliedStatus.self, forKey: .appliedStatus)
        appliedStatus = appliedStatusDecoded
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension ARCZonalShiftClientTypes {
    /// A complex structure that lists the zonal shifts for a managed resource and their statuses for the resource.
    public struct ZonalShiftInResource: Swift.Equatable {
        /// An appliedStatus for a zonal shift for a resource can have one of two values: APPLIED or NOT_APPLIED.
        /// This member is required.
        public var appliedStatus: ARCZonalShiftClientTypes.AppliedStatus?
        /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.
        /// This member is required.
        public var comment: Swift.String?
        /// The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.
        /// This member is required.
        public var expiryTime: ClientRuntime.Date?
        /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
        /// This member is required.
        public var resourceIdentifier: Swift.String?
        /// The time (UTC) when the zonal shift is started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The identifier of a zonal shift.
        /// This member is required.
        public var zonalShiftId: Swift.String?

        public init (
            appliedStatus: ARCZonalShiftClientTypes.AppliedStatus? = nil,
            awayFrom: Swift.String? = nil,
            comment: Swift.String? = nil,
            expiryTime: ClientRuntime.Date? = nil,
            resourceIdentifier: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            zonalShiftId: Swift.String? = nil
        )
        {
            self.appliedStatus = appliedStatus
            self.awayFrom = awayFrom
            self.comment = comment
            self.expiryTime = expiryTime
            self.resourceIdentifier = resourceIdentifier
            self.startTime = startTime
            self.zonalShiftId = zonalShiftId
        }
    }

}

extension ARCZonalShiftClientTypes {
    public enum ZonalShiftStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case expired
        case sdkUnknown(Swift.String)

        public static var allCases: [ZonalShiftStatus] {
            return [
                .active,
                .canceled,
                .expired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .expired: return "EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ZonalShiftStatus(rawValue: rawValue) ?? ZonalShiftStatus.sdkUnknown(rawValue)
        }
    }
}

extension ARCZonalShiftClientTypes.ZonalShiftSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awayFrom
        case comment
        case expiryTime
        case resourceIdentifier
        case startTime
        case status
        case zonalShiftId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awayFrom = self.awayFrom {
            try encodeContainer.encode(awayFrom, forKey: .awayFrom)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let expiryTime = self.expiryTime {
            try encodeContainer.encodeTimestamp(expiryTime, format: .epochSeconds, forKey: .expiryTime)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let zonalShiftId = self.zonalShiftId {
            try encodeContainer.encode(zonalShiftId, forKey: .zonalShiftId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zonalShiftIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zonalShiftId)
        zonalShiftId = zonalShiftIdDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let awayFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awayFrom)
        awayFrom = awayFromDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ARCZonalShiftClientTypes.ZonalShiftStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension ARCZonalShiftClientTypes {
    /// You start a zonal shift to temporarily move load balancer traffic away from an Availability Zone in a AWS Region. A zonal shift helps your application recover immediately, for example, from a developer's bad code deployment or from an AWS infrastructure failure in a single Availability Zone. You can start a zonal shift in Route 53 ARC only for managed resources in your account in an AWS Region. Supported AWS resources are automatically registered with Route 53 ARC. Zonal shifts are temporary. A zonal shift can be active for up to three days (72 hours). When you start a zonal shift, you specify how long you want it to be active, which Amazon Route 53 Application Recovery Controller converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can extend the zonal shift by updating the expiration so the zonal shift is active longer.
    public struct ZonalShiftSummary: Swift.Equatable {
        /// The Availability Zone that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the AWS Region.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.
        /// This member is required.
        public var comment: Swift.String?
        /// The expiry time (expiration time) for the zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift, for example, if you're ready to restore traffic to the Availability Zone. Or you can update the zonal shift to specify another length of time to expire in.
        /// This member is required.
        public var expiryTime: ClientRuntime.Date?
        /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
        /// This member is required.
        public var resourceIdentifier: Swift.String?
        /// The time (UTC) when the zonal shift is started.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
        ///
        /// * ACTIVE: The zonal shift is started and active.
        ///
        /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
        ///
        /// * CANCELED: The zonal shift was canceled.
        /// This member is required.
        public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
        /// The identifier of a zonal shift.
        /// This member is required.
        public var zonalShiftId: Swift.String?

        public init (
            awayFrom: Swift.String? = nil,
            comment: Swift.String? = nil,
            expiryTime: ClientRuntime.Date? = nil,
            resourceIdentifier: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
            zonalShiftId: Swift.String? = nil
        )
        {
            self.awayFrom = awayFrom
            self.comment = comment
            self.expiryTime = expiryTime
            self.resourceIdentifier = resourceIdentifier
            self.startTime = startTime
            self.status = status
            self.zonalShiftId = zonalShiftId
        }
    }

}
