//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ARCZonalShiftClientTypes {

    public enum AppliedStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applied
        case notApplied
        case sdkUnknown(Swift.String)

        public static var allCases: [AppliedStatus] {
            return [
                .applied,
                .notApplied
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .notApplied: return "NOT_APPLIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// There was an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ARCZonalShiftClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalidAlarmCondition
        case invalidAz
        case invalidConditionType
        case invalidExpiresIn
        case invalidPracticeBlocker
        case invalidResourceIdentifier
        case invalidStatus
        case invalidToken
        case missingValue
        case unsupportedAz
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .invalidAlarmCondition,
                .invalidAz,
                .invalidConditionType,
                .invalidExpiresIn,
                .invalidPracticeBlocker,
                .invalidResourceIdentifier,
                .invalidStatus,
                .invalidToken,
                .missingValue,
                .unsupportedAz
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalidAlarmCondition: return "InvalidAlarmCondition"
            case .invalidAz: return "InvalidAz"
            case .invalidConditionType: return "InvalidConditionType"
            case .invalidExpiresIn: return "InvalidExpiresIn"
            case .invalidPracticeBlocker: return "InvalidPracticeBlocker"
            case .invalidResourceIdentifier: return "InvalidResourceIdentifier"
            case .invalidStatus: return "InvalidStatus"
            case .invalidToken: return "InvalidToken"
            case .missingValue: return "MissingValue"
            case .unsupportedAz: return "UnsupportedAz"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        /// This member is required.
        public internal(set) var reason: ARCZonalShiftClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: ARCZonalShiftClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension ARCZonalShiftClientTypes {

    public enum AutoshiftExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case completed
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoshiftExecutionStatus] {
            return [
                .active,
                .completed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .completed: return "COMPLETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAutoshiftsInput: Swift.Sendable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The status of the autoshift.
    public var status: ARCZonalShiftClientTypes.AutoshiftExecutionStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: ARCZonalShiftClientTypes.AutoshiftExecutionStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension ARCZonalShiftClientTypes {

    /// Information about an autoshift. Amazon Web Services starts an autoshift to temporarily move traffic for a resource away from an Availability Zone in an Amazon Web Services Region when Amazon Web Services determines that there's an issue in the Availability Zone that could potentially affect customers. You can configure zonal autoshift in Route 53 ARC for managed resources in your Amazon Web Services account in a Region. Supported Amazon Web Services resources are automatically registered with Route 53 ARC. Autoshifts are temporary. When the Availability Zone recovers, Amazon Web Services ends the autoshift, and traffic for the resource is no longer directed to the other Availability Zones in the Region. You can stop an autoshift for a resource by disabling zonal autoshift.
    public struct AutoshiftSummary: Swift.Sendable {
        /// The Availability Zone (for example, use1-az1) that traffic is shifted away from for a resource when Amazon Web Services starts an autoshift. Until the autoshift ends, traffic for the resource is instead directed to other Availability Zones in the Amazon Web Services Region. An autoshift can end for a resource, for example, when Amazon Web Services ends the autoshift for the Availability Zone or when you disable zonal autoshift for the resource.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// The time (in UTC) when the autoshift ended.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The time (in UTC) when the autoshift started.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The status for an autoshift.
        /// This member is required.
        public var status: ARCZonalShiftClientTypes.AutoshiftExecutionStatus?

        public init(
            awayFrom: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil,
            status: ARCZonalShiftClientTypes.AutoshiftExecutionStatus? = nil
        )
        {
            self.awayFrom = awayFrom
            self.endTime = endTime
            self.startTime = startTime
            self.status = status
        }
    }
}

public struct ListAutoshiftsOutput: Swift.Sendable {
    /// The items in the response list.
    public var items: [ARCZonalShiftClientTypes.AutoshiftSummary]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [ARCZonalShiftClientTypes.AutoshiftSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension ARCZonalShiftClientTypes {

    public enum AutoshiftAppliedStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applied
        case notApplied
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoshiftAppliedStatus] {
            return [
                .applied,
                .notApplied
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .notApplied: return "NOT_APPLIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCZonalShiftClientTypes {

    /// A complex structure that lists an autoshift that is currently active for a managed resource and information about the autoshift. For more information, see [How zonal autoshift and practice runs work](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
    public struct AutoshiftInResource: Swift.Sendable {
        /// The appliedStatus field specifies which application traffic shift is in effect for a resource when there is more than one active traffic shift. There can be more than one application traffic shift in progress at the same time - that is, practice run zonal shifts, customer-initiated zonal shifts, or an autoshift. The appliedStatus field for a shift that is in progress for a resource can have one of two values: APPLIED or NOT_APPLIED. The zonal shift or autoshift that is currently in effect for the resource has an appliedStatus set to APPLIED. The overall principle for precedence is that zonal shifts that you start as a customer take precedence autoshifts, which take precedence over practice runs. That is, customer-initiated zonal shifts > autoshifts > practice run zonal shifts. For more information, see [How zonal autoshift and practice runs work](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
        /// This member is required.
        public var appliedStatus: ARCZonalShiftClientTypes.AutoshiftAppliedStatus?
        /// The Availability Zone (for example, use1-az1) that traffic is shifted away from for a resource, when Amazon Web Services starts an autoshift. Until the autoshift ends, traffic for the resource is instead directed to other Availability Zones in the Amazon Web Services Region. An autoshift can end for a resource, for example, when Amazon Web Services ends the autoshift for the Availability Zone or when you disable zonal autoshift for the resource.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// The time (UTC) when the autoshift started.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            appliedStatus: ARCZonalShiftClientTypes.AutoshiftAppliedStatus? = nil,
            awayFrom: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.appliedStatus = appliedStatus
            self.awayFrom = awayFrom
            self.startTime = startTime
        }
    }
}

public struct GetAutoshiftObserverNotificationStatusInput: Swift.Sendable {

    public init() { }
}

extension ARCZonalShiftClientTypes {

    public enum AutoshiftObserverNotificationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoshiftObserverNotificationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAutoshiftObserverNotificationStatusOutput: Swift.Sendable {
    /// The status of autoshift observer notification. If the status is ENABLED, Route 53 ARC includes all autoshift events when you use the Amazon EventBridge pattern Autoshift In Progress. When the status is DISABLED, Route 53 ARC includes only autoshift events for autoshifts when one or more of your resources is included in the autoshift.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.AutoshiftObserverNotificationStatus?

    public init(
        status: ARCZonalShiftClientTypes.AutoshiftObserverNotificationStatus? = nil
    )
    {
        self.status = status
    }
}

public struct UpdateAutoshiftObserverNotificationStatusInput: Swift.Sendable {
    /// The status to set for autoshift observer notification. If the status is ENABLED, Route 53 ARC includes all autoshift events when you use the Amazon EventBridge pattern Autoshift In Progress. When the status is DISABLED, Route 53 ARC includes only autoshift events for autoshifts when one or more of your resources is included in the autoshift.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.AutoshiftObserverNotificationStatus?

    public init(
        status: ARCZonalShiftClientTypes.AutoshiftObserverNotificationStatus? = nil
    )
    {
        self.status = status
    }
}

public struct UpdateAutoshiftObserverNotificationStatusOutput: Swift.Sendable {
    /// The status for autoshift observer notification.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.AutoshiftObserverNotificationStatus?

    public init(
        status: ARCZonalShiftClientTypes.AutoshiftObserverNotificationStatus? = nil
    )
    {
        self.status = status
    }
}

extension ARCZonalShiftClientTypes {

    public enum ConflictExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autoshiftEnabled
        case practiceConfigurationAlreadyExists
        case practiceConfigurationDoesNotExist
        case simultaneousZonalShiftsConflict
        case zonalShiftAlreadyExists
        case zonalShiftStatusNotActive
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .autoshiftEnabled,
                .practiceConfigurationAlreadyExists,
                .practiceConfigurationDoesNotExist,
                .simultaneousZonalShiftsConflict,
                .zonalShiftAlreadyExists,
                .zonalShiftStatusNotActive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autoshiftEnabled: return "AutoShiftEnabled"
            case .practiceConfigurationAlreadyExists: return "PracticeConfigurationAlreadyExists"
            case .practiceConfigurationDoesNotExist: return "PracticeConfigurationDoesNotExist"
            case .simultaneousZonalShiftsConflict: return "SimultaneousZonalShiftsConflict"
            case .zonalShiftAlreadyExists: return "ZonalShiftAlreadyExists"
            case .zonalShiftStatusNotActive: return "ZonalShiftStatusNotActive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the conflict exception.
        /// This member is required.
        public internal(set) var reason: ARCZonalShiftClientTypes.ConflictExceptionReason? = nil
        /// The zonal shift ID associated with the conflict exception.
        public internal(set) var zonalShiftId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: ARCZonalShiftClientTypes.ConflictExceptionReason? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.zonalShiftId = zonalShiftId
    }
}

/// The input requested a resource that was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelZonalShiftInput: Swift.Sendable {
    /// The internally-generated identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        zonalShiftId: Swift.String? = nil
    )
    {
        self.zonalShiftId = zonalShiftId
    }
}

extension ARCZonalShiftClientTypes {

    public enum ZonalShiftStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case canceled
        case expired
        case sdkUnknown(Swift.String)

        public static var allCases: [ZonalShiftStatus] {
            return [
                .active,
                .canceled,
                .expired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .expired: return "EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelZonalShiftOutput: Swift.Sendable {
    /// The Availability Zone (for example, use1-az1) that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The expiry time (expiration time) for a customer-initiated zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
    /// This member is required.
    public var expiryTime: Foundation.Date?
    /// The identifier for the resource that Amazon Web Services shifts traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The time (UTC) when the zonal shift starts.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift has been started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiryTime: Foundation.Date? = nil,
        resourceIdentifier: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiryTime = expiryTime
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.status = status
        self.zonalShiftId = zonalShiftId
    }
}

extension ARCZonalShiftClientTypes {

    public enum ControlConditionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudwatch
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlConditionType] {
            return [
                .cloudwatch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudwatch: return "CLOUDWATCH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCZonalShiftClientTypes {

    /// A control condition is an alarm that you specify for a practice run. When you configure practice runs with zonal autoshift for a resource, you specify Amazon CloudWatch alarms, which you create in CloudWatch to use with the practice run. The alarms that you specify are an outcome alarm, to monitor application health during practice runs and, optionally, a blocking alarm, to block practice runs from starting or to interrupt a practice run in progress. Control condition alarms do not apply for autoshifts. For more information, see [ Considerations when you configure zonal autoshift](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.considerations.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
    public struct ControlCondition: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for an Amazon CloudWatch alarm that you specify as a control condition for a practice run.
        /// This member is required.
        public var alarmIdentifier: Swift.String?
        /// The type of alarm specified for a practice run. You can only specify Amazon CloudWatch alarms for practice runs, so the only valid value is CLOUDWATCH.
        /// This member is required.
        public var type: ARCZonalShiftClientTypes.ControlConditionType?

        public init(
            alarmIdentifier: Swift.String? = nil,
            type: ARCZonalShiftClientTypes.ControlConditionType? = nil
        )
        {
            self.alarmIdentifier = alarmIdentifier
            self.type = type
        }
    }
}

public struct CreatePracticeRunConfigurationInput: Swift.Sendable {
    /// Optionally, you can block Route 53 ARC from starting practice runs for a resource on specific calendar dates. The format for blocked dates is: YYYY-MM-DD. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Separate multiple blocked dates with spaces. For example, if you have an application update scheduled to launch on May 1, 2024, and you don't want practice runs to shift traffic away at that time, you could set a blocked date for 2024-05-01.
    public var blockedDates: [Swift.String]?
    /// Optionally, you can block Route 53 ARC from starting practice runs for specific windows of days and times. The format for blocked windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple blocked windows with spaces. For example, say you run business report summaries three days a week. For this scenario, you might set the following recurring days and times as blocked windows, for example: MON-20:30-21:30 WED-20:30-21:30 FRI-20:30-21:30.
    public var blockedWindows: [Swift.String]?
    /// An Amazon CloudWatch alarm that you can specify for zonal autoshift practice runs. This alarm blocks Route 53 ARC from starting practice run zonal shifts, and ends a practice run that's in progress, when the alarm is in an ALARM state.
    public var blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    /// The outcome alarm for practice runs is a required Amazon CloudWatch alarm that you specify that ends a practice run when the alarm is in an ALARM state. Configure the alarm to monitor the health of your application when traffic is shifted away from an Availability Zone during each weekly practice run. You should configure the alarm to go into an ALARM state if your application is impacted by the zonal shift, and you want to stop the zonal shift, to let traffic for the resource return to the Availability Zone.
    /// This member is required.
    public var outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    /// The identifier of the resource that Amazon Web Services shifts traffic for with a practice run zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        blockedDates: [Swift.String]? = nil,
        blockedWindows: [Swift.String]? = nil,
        blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
        outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.blockedDates = blockedDates
        self.blockedWindows = blockedWindows
        self.blockingAlarms = blockingAlarms
        self.outcomeAlarms = outcomeAlarms
        self.resourceIdentifier = resourceIdentifier
    }
}

extension ARCZonalShiftClientTypes {

    /// A practice run configuration for a resource includes the Amazon CloudWatch alarms that you've specified for a practice run, as well as any blocked dates or blocked windows for the practice run. When a resource has a practice run configuration, Route 53 ARC shifts traffic for the resource weekly for practice runs. Practice runs are required for zonal autoshift. The zonal shifts that Route 53 ARC starts for practice runs help you to ensure that shifting away traffic from an Availability Zone during an autoshift is safe for your application. You can update or delete a practice run configuration. Before you delete a practice run configuration, you must disable zonal autoshift for the resource. A practice run configuration is required when zonal autoshift is enabled.
    public struct PracticeRunConfiguration: Swift.Sendable {
        /// An array of one or more dates that you can specify when Amazon Web Services does not start practice runs for a resource. Specify blocked dates, in UTC, in the format YYYY-MM-DD, separated by spaces.
        public var blockedDates: [Swift.String]?
        /// An array of one or more windows of days and times that you can block Route 53 ARC from starting practice runs for a resource. Specify the blocked windows in UTC, using the format DAY:HH:MM-DAY:HH:MM, separated by spaces. For example, MON:18:30-MON:19:30 TUE:18:30-TUE:19:30.
        public var blockedWindows: [Swift.String]?
        /// The blocking alarm for practice runs is an optional alarm that you can specify that blocks practice runs when the alarm is in an ALARM state.
        public var blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
        /// The outcome alarm for practice runs is an alarm that you specify that ends a practice run when the alarm is in an ALARM state.
        /// This member is required.
        public var outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]?

        public init(
            blockedDates: [Swift.String]? = [],
            blockedWindows: [Swift.String]? = nil,
            blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
            outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil
        )
        {
            self.blockedDates = blockedDates
            self.blockedWindows = blockedWindows
            self.blockingAlarms = blockingAlarms
            self.outcomeAlarms = outcomeAlarms
        }
    }
}

extension ARCZonalShiftClientTypes {

    public enum ZonalAutoshiftStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ZonalAutoshiftStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePracticeRunConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you configured the practice run for.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the resource that you configured the practice run for.
    /// This member is required.
    public var name: Swift.String?
    /// A practice run configuration for a resource. Configurations include the outcome alarm that you specify for practice runs, and, optionally, a blocking alarm and blocking dates and windows.
    /// This member is required.
    public var practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration?
    /// The status for zonal autoshift for a resource. When you specify ENABLED for the autoshift status, Amazon Web Services shifts traffic away from shifts away application resource traffic from an Availability Zone, on your behalf, when internal telemetry indicates that there is an Availability Zone impairment that could potentially impact customers. When you enable zonal autoshift, you must also configure practice runs for the resource.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.practiceRunConfiguration = practiceRunConfiguration
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

public struct DeletePracticeRunConfigurationInput: Swift.Sendable {
    /// The identifier for the resource that you want to delete the practice run configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct DeletePracticeRunConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you deleted the practice run for.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the resource that you deleted the practice run for.
    /// This member is required.
    public var name: Swift.String?
    /// The status of zonal autoshift for the resource.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

public struct GetManagedResourceInput: Swift.Sendable {
    /// The identifier for the resource that Amazon Web Services shifts traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

extension ARCZonalShiftClientTypes {

    public enum PracticeRunOutcome: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case interrupted
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [PracticeRunOutcome] {
            return [
                .failed,
                .interrupted,
                .pending,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .interrupted: return "INTERRUPTED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCZonalShiftClientTypes {

    /// A complex structure that lists the zonal shifts for a managed resource and their statuses for the resource.
    public struct ZonalShiftInResource: Swift.Sendable {
        /// The appliedStatus field specifies which application traffic shift is in effect for a resource when there is more than one active traffic shift. There can be more than one application traffic shift in progress at the same time - that is, practice run zonal shifts, customer-initiated zonal shifts, or an autoshift. The appliedStatus field for a shift that is in progress for a resource can have one of two values: APPLIED or NOT_APPLIED. The zonal shift or autoshift that is currently in effect for the resource has an appliedStatus set to APPLIED. The overall principle for precedence is that zonal shifts that you start as a customer take precedence autoshifts, which take precedence over practice runs. That is, customer-initiated zonal shifts > autoshifts > practice run zonal shifts. For more information, see [How zonal autoshift and practice runs work](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.how-it-works.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
        /// This member is required.
        public var appliedStatus: ARCZonalShiftClientTypes.AppliedStatus?
        /// The Availability Zone (for example, use1-az1) that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// A comment that you enter for a customer-initiated zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.
        /// This member is required.
        public var comment: Swift.String?
        /// The expiry time (expiration time) for a customer-initiated zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
        /// This member is required.
        public var expiryTime: Foundation.Date?
        /// The outcome, or end state, returned for a practice run. The following values can be returned:
        ///
        /// * PENDING: Outcome value when a practice run is in progress.
        ///
        /// * SUCCEEDED: Outcome value when the outcome alarm specified for the practice run configuration does not go into an ALARM state during the practice run, and the practice run was not interrupted before it completed the expected 30 minute zonal shift.
        ///
        /// * INTERRUPTED: Outcome value when the practice run was stopped before the expected 30 minute zonal shift duration, or there was another problem with the practice run that created an inconclusive outcome.
        ///
        /// * FAILED: Outcome value when the outcome alarm specified for the practice run configuration goes into an ALARM state during the practice run, and the practice run was not interrupted before it completed.
        ///
        ///
        /// For more information about practice run outcomes, see [ Considerations when you configure zonal autoshift](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.configure.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
        public var practiceRunOutcome: ARCZonalShiftClientTypes.PracticeRunOutcome?
        /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
        /// This member is required.
        public var resourceIdentifier: Swift.String?
        /// The time (UTC) when the zonal shift starts.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The identifier of a zonal shift.
        /// This member is required.
        public var zonalShiftId: Swift.String?

        public init(
            appliedStatus: ARCZonalShiftClientTypes.AppliedStatus? = nil,
            awayFrom: Swift.String? = nil,
            comment: Swift.String? = nil,
            expiryTime: Foundation.Date? = nil,
            practiceRunOutcome: ARCZonalShiftClientTypes.PracticeRunOutcome? = nil,
            resourceIdentifier: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            zonalShiftId: Swift.String? = nil
        )
        {
            self.appliedStatus = appliedStatus
            self.awayFrom = awayFrom
            self.comment = comment
            self.expiryTime = expiryTime
            self.practiceRunOutcome = practiceRunOutcome
            self.resourceIdentifier = resourceIdentifier
            self.startTime = startTime
            self.zonalShiftId = zonalShiftId
        }
    }
}

public struct GetManagedResourceOutput: Swift.Sendable {
    /// A collection of key-value pairs that indicate whether resources are active in Availability Zones or not. The key name is the Availability Zone where the resource is deployed. The value is 1 or 0.
    /// This member is required.
    public var appliedWeights: [Swift.String: Swift.Float]?
    /// The Amazon Resource Name (ARN) for the resource.
    public var arn: Swift.String?
    /// An array of the autoshifts that are active for the resource.
    public var autoshifts: [ARCZonalShiftClientTypes.AutoshiftInResource]?
    /// The name of the resource.
    public var name: Swift.String?
    /// The practice run configuration for zonal autoshift that's associated with the resource.
    public var practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration?
    /// The status for zonal autoshift for a resource. When the autoshift status is ENABLED, Amazon Web Services shifts traffic for a resource away from an Availability Zone, on your behalf, when Amazon Web Services determines that there's an issue in the Availability Zone that could potentially affect customers.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
    /// The zonal shifts that are currently active for a resource.
    /// This member is required.
    public var zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]?

    public init(
        appliedWeights: [Swift.String: Swift.Float]? = nil,
        arn: Swift.String? = nil,
        autoshifts: [ARCZonalShiftClientTypes.AutoshiftInResource]? = nil,
        name: Swift.String? = nil,
        practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil,
        zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]? = nil
    )
    {
        self.appliedWeights = appliedWeights
        self.arn = arn
        self.autoshifts = autoshifts
        self.name = name
        self.practiceRunConfiguration = practiceRunConfiguration
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
        self.zonalShifts = zonalShifts
    }
}

public struct ListManagedResourcesInput: Swift.Sendable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ARCZonalShiftClientTypes {

    /// A complex structure for a managed resource in an Amazon Web Services account with information about zonal shifts and autoshifts. A managed resource is a load balancer that has been registered with Route 53 ARC by Elastic Load Balancing. You can start a zonal shift in Route 53 ARC for a managed resource to temporarily move traffic for the resource away from an Availability Zone in an Amazon Web Services Region. You can also configure zonal autoshift for a managed resource. At this time, managed resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    public struct ManagedResourceSummary: Swift.Sendable {
        /// A collection of key-value pairs that indicate whether resources are active in Availability Zones or not. The key name is the Availability Zone where the resource is deployed. The value is 1 or 0.
        public var appliedWeights: [Swift.String: Swift.Float]?
        /// The Amazon Resource Name (ARN) for the managed resource.
        public var arn: Swift.String?
        /// An array of the autoshifts that have been completed for a resource.
        public var autoshifts: [ARCZonalShiftClientTypes.AutoshiftInResource]?
        /// The Availability Zones that a resource is deployed in.
        /// This member is required.
        public var availabilityZones: [Swift.String]?
        /// The name of the managed resource.
        public var name: Swift.String?
        /// This status tracks whether a practice run configuration exists for a resource. When you configure a practice run for a resource so that a practice run configuration exists, Route 53 ARC sets this value to ENABLED. If a you have not configured a practice run for the resource, or delete a practice run configuration, Route 53 ARC sets the value to DISABLED. Route 53 ARC updates this status; you can't set a practice run status to ENABLED or DISABLED.
        public var practiceRunStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
        /// The status of autoshift for a resource. When you configure zonal autoshift for a resource, you can set the value of the status to ENABLED or DISABLED.
        public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?
        /// An array of the zonal shifts for a resource.
        public var zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]?

        public init(
            appliedWeights: [Swift.String: Swift.Float]? = nil,
            arn: Swift.String? = nil,
            autoshifts: [ARCZonalShiftClientTypes.AutoshiftInResource]? = nil,
            availabilityZones: [Swift.String]? = nil,
            name: Swift.String? = nil,
            practiceRunStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil,
            zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil,
            zonalShifts: [ARCZonalShiftClientTypes.ZonalShiftInResource]? = nil
        )
        {
            self.appliedWeights = appliedWeights
            self.arn = arn
            self.autoshifts = autoshifts
            self.availabilityZones = availabilityZones
            self.name = name
            self.practiceRunStatus = practiceRunStatus
            self.zonalAutoshiftStatus = zonalAutoshiftStatus
            self.zonalShifts = zonalShifts
        }
    }
}

public struct ListManagedResourcesOutput: Swift.Sendable {
    /// The items in the response list.
    /// This member is required.
    public var items: [ARCZonalShiftClientTypes.ManagedResourceSummary]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [ARCZonalShiftClientTypes.ManagedResourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListZonalShiftsInput: Swift.Sendable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The identifier for the resource that you want to list zonal shifts for. The identifier is the Amazon Resource Name (ARN) for the resource.
    public var resourceIdentifier: Swift.String?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift has been started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
        self.status = status
    }
}

extension ARCZonalShiftClientTypes {

    /// Lists information about zonal shifts in Amazon Route 53 Application Recovery Controller, including zonal shifts that you start yourself and zonal shifts that Route 53 ARC starts on your behalf for practice runs with zonal autoshift. Zonal shifts are temporary, including customer-initiated zonal shifts and the zonal autoshift practice run zonal shifts that Route 53 ARC starts weekly, on your behalf. A zonal shift that a customer starts can be active for up to three days (72 hours). A practice run zonal shift has a 30 minute duration.
    public struct ZonalShiftSummary: Swift.Sendable {
        /// The Availability Zone (for example, use1-az1) that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
        /// This member is required.
        public var awayFrom: Swift.String?
        /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. That is, a new comment overwrites any existing comment string.
        /// This member is required.
        public var comment: Swift.String?
        /// The expiry time (expiration time) for a customer-initiated zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
        /// This member is required.
        public var expiryTime: Foundation.Date?
        /// The outcome, or end state, of a practice run. The following values can be returned:
        ///
        /// * PENDING: Outcome value when the practice run is in progress.
        ///
        /// * SUCCEEDED: Outcome value when the outcome alarm specified for the practice run configuration does not go into an ALARM state during the practice run, and the practice run was not interrupted before it completed.
        ///
        /// * INTERRUPTED: Outcome value when the practice run did not run for the expected 30 minutes or there was another problem with the practice run that created an inconclusive outcome.
        ///
        /// * FAILED: Outcome value when the outcome alarm specified for the practice run configuration goes into an ALARM state during the practice run, and the practice run was not interrupted before it completed.
        ///
        ///
        /// For more information about practice run outcomes, see [ Considerations when you configure zonal autoshift](https://docs.aws.amazon.com/r53recovery/latest/dg/arc-zonal-autoshift.configure.html) in the Amazon Route 53 Application Recovery Controller Developer Guide.
        public var practiceRunOutcome: ARCZonalShiftClientTypes.PracticeRunOutcome?
        /// The identifier for the resource to include in a zonal shift. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, you can only start a zonal shift for Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
        /// This member is required.
        public var resourceIdentifier: Swift.String?
        /// The time (UTC) when the zonal shift starts.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
        ///
        /// * ACTIVE: The zonal shift has been started and active.
        ///
        /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
        ///
        /// * CANCELED: The zonal shift was canceled.
        /// This member is required.
        public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
        /// The identifier of a zonal shift.
        /// This member is required.
        public var zonalShiftId: Swift.String?

        public init(
            awayFrom: Swift.String? = nil,
            comment: Swift.String? = nil,
            expiryTime: Foundation.Date? = nil,
            practiceRunOutcome: ARCZonalShiftClientTypes.PracticeRunOutcome? = nil,
            resourceIdentifier: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
            zonalShiftId: Swift.String? = nil
        )
        {
            self.awayFrom = awayFrom
            self.comment = comment
            self.expiryTime = expiryTime
            self.practiceRunOutcome = practiceRunOutcome
            self.resourceIdentifier = resourceIdentifier
            self.startTime = startTime
            self.status = status
            self.zonalShiftId = zonalShiftId
        }
    }
}

public struct ListZonalShiftsOutput: Swift.Sendable {
    /// The items in the response list.
    public var items: [ARCZonalShiftClientTypes.ZonalShiftSummary]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [ARCZonalShiftClientTypes.ZonalShiftSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateZonalAutoshiftConfigurationInput: Swift.Sendable {
    /// The identifier for the resource that you want to update the zonal autoshift configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The zonal autoshift status for the resource that you want to update the zonal autoshift configuration for. Choose ENABLED to authorize Amazon Web Services to shift away resource traffic for an application from an Availability Zone during events, on your behalf, to help reduce time to recovery.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        resourceIdentifier: Swift.String? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

public struct UpdateZonalAutoshiftConfigurationOutput: Swift.Sendable {
    /// The identifier for the resource that you updated the zonal autoshift configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The updated zonal autoshift status for the resource.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        resourceIdentifier: Swift.String? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

public struct UpdatePracticeRunConfigurationInput: Swift.Sendable {
    /// Add, change, or remove blocked dates for a practice run in zonal autoshift. Optionally, you can block practice runs for specific calendar dates. The format for blocked dates is: YYYY-MM-DD. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Separate multiple blocked dates with spaces. For example, if you have an application update scheduled to launch on May 1, 2024, and you don't want practice runs to shift traffic away at that time, you could set a blocked date for 2024-05-01.
    public var blockedDates: [Swift.String]?
    /// Add, change, or remove windows of days and times for when you can, optionally, block Route 53 ARC from starting a practice run for a resource. The format for blocked windows is: DAY:HH:SS-DAY:HH:SS. Keep in mind, when you specify dates, that dates and times for practice runs are in UTC. Also, be aware of potential time adjustments that might be required for daylight saving time differences. Separate multiple blocked windows with spaces. For example, say you run business report summaries three days a week. For this scenario, you might set the following recurring days and times as blocked windows, for example: MON-20:30-21:30 WED-20:30-21:30 FRI-20:30-21:30.
    public var blockedWindows: [Swift.String]?
    /// Add, change, or remove the Amazon CloudWatch alarm that you optionally specify as the blocking alarm for practice runs.
    public var blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    /// Specify a new the Amazon CloudWatch alarm as the outcome alarm for practice runs.
    public var outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]?
    /// The identifier for the resource that you want to update the practice run configuration for. The identifier is the Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        blockedDates: [Swift.String]? = nil,
        blockedWindows: [Swift.String]? = nil,
        blockingAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
        outcomeAlarms: [ARCZonalShiftClientTypes.ControlCondition]? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.blockedDates = blockedDates
        self.blockedWindows = blockedWindows
        self.blockingAlarms = blockingAlarms
        self.outcomeAlarms = outcomeAlarms
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct UpdatePracticeRunConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you updated the practice run for.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the resource that you updated the practice run for.
    /// This member is required.
    public var name: Swift.String?
    /// The practice run configuration that was updated.
    /// This member is required.
    public var practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration?
    /// The zonal autoshift status for the resource that you updated the practice run for.
    /// This member is required.
    public var zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        practiceRunConfiguration: ARCZonalShiftClientTypes.PracticeRunConfiguration? = nil,
        zonalAutoshiftStatus: ARCZonalShiftClientTypes.ZonalAutoshiftStatus? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.practiceRunConfiguration = practiceRunConfiguration
        self.zonalAutoshiftStatus = zonalAutoshiftStatus
    }
}

public struct UpdateZonalShiftInput: Swift.Sendable {
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    public var comment: Swift.String?
    /// The length of time that you want a zonal shift to be active, which Route 53 ARC converts to an expiry time (expiration time). Zonal shifts are temporary. You can set a zonal shift to be active initially for up to three days (72 hours). If you want to still keep traffic away from an Availability Zone, you can update the zonal shift and set a new expiration. You can also cancel a zonal shift, before it expires, for example, if you're ready to restore traffic to the Availability Zone. To set a length of time for a zonal shift to be active, specify a whole number, and then one of the following, with no space:
    ///
    /// * A lowercase letter m: To specify that the value is in minutes.
    ///
    /// * A lowercase letter h: To specify that the value is in hours.
    ///
    ///
    /// For example: 20h means the zonal shift expires in 20 hours. 120m means the zonal shift expires in 120 minutes (2 hours).
    public var expiresIn: Swift.String?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        comment: Swift.String? = nil,
        expiresIn: Swift.String? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.comment = comment
        self.expiresIn = expiresIn
        self.zonalShiftId = zonalShiftId
    }
}

public struct UpdateZonalShiftOutput: Swift.Sendable {
    /// The Availability Zone (for example, use1-az1) that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The expiry time (expiration time) for a customer-initiated zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
    /// This member is required.
    public var expiryTime: Foundation.Date?
    /// The identifier for the resource that Amazon Web Services shifts traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The time (UTC) when the zonal shift starts.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift has been started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiryTime: Foundation.Date? = nil,
        resourceIdentifier: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiryTime = expiryTime
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.status = status
        self.zonalShiftId = zonalShiftId
    }
}

public struct StartZonalShiftInput: Swift.Sendable {
    /// The Availability Zone (for example, use1-az1) that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The length of time that you want a zonal shift to be active, which Route 53 ARC converts to an expiry time (expiration time). Zonal shifts are temporary. You can set a zonal shift to be active initially for up to three days (72 hours). If you want to still keep traffic away from an Availability Zone, you can update the zonal shift and set a new expiration. You can also cancel a zonal shift, before it expires, for example, if you're ready to restore traffic to the Availability Zone. To set a length of time for a zonal shift to be active, specify a whole number, and then one of the following, with no space:
    ///
    /// * A lowercase letter m: To specify that the value is in minutes.
    ///
    /// * A lowercase letter h: To specify that the value is in hours.
    ///
    ///
    /// For example: 20h means the zonal shift expires in 20 hours. 120m means the zonal shift expires in 120 minutes (2 hours).
    /// This member is required.
    public var expiresIn: Swift.String?
    /// The identifier for the resource that Amazon Web Services shifts traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiresIn: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiresIn = expiresIn
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct StartZonalShiftOutput: Swift.Sendable {
    /// The Availability Zone (for example, use1-az1) that traffic is moved away from for a resource when you start a zonal shift. Until the zonal shift expires or you cancel it, traffic for the resource is instead moved to other Availability Zones in the Amazon Web Services Region.
    /// This member is required.
    public var awayFrom: Swift.String?
    /// A comment that you enter about the zonal shift. Only the latest comment is retained; no comment history is maintained. A new comment overwrites any existing comment string.
    /// This member is required.
    public var comment: Swift.String?
    /// The expiry time (expiration time) for a customer-initiated zonal shift. A zonal shift is temporary and must be set to expire when you start the zonal shift. You can initially set a zonal shift to expire in a maximum of three days (72 hours). However, you can update a zonal shift to set a new expiration at any time. When you start a zonal shift, you specify how long you want it to be active, which Route 53 ARC converts to an expiry time (expiration time). You can cancel a zonal shift when you're ready to restore traffic to the Availability Zone, or just wait for it to expire. Or you can update the zonal shift to specify another length of time to expire in.
    /// This member is required.
    public var expiryTime: Foundation.Date?
    /// The identifier for the resource that Amazon Web Services shifts traffic for. The identifier is the Amazon Resource Name (ARN) for the resource. At this time, supported resources are Network Load Balancers and Application Load Balancers with cross-zone load balancing turned off.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The time (UTC) when the zonal shift starts.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// A status for a zonal shift. The Status for a zonal shift can have one of the following values:
    ///
    /// * ACTIVE: The zonal shift has been started and active.
    ///
    /// * EXPIRED: The zonal shift has expired (the expiry time was exceeded).
    ///
    /// * CANCELED: The zonal shift was canceled.
    /// This member is required.
    public var status: ARCZonalShiftClientTypes.ZonalShiftStatus?
    /// The identifier of a zonal shift.
    /// This member is required.
    public var zonalShiftId: Swift.String?

    public init(
        awayFrom: Swift.String? = nil,
        comment: Swift.String? = nil,
        expiryTime: Foundation.Date? = nil,
        resourceIdentifier: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        status: ARCZonalShiftClientTypes.ZonalShiftStatus? = nil,
        zonalShiftId: Swift.String? = nil
    )
    {
        self.awayFrom = awayFrom
        self.comment = comment
        self.expiryTime = expiryTime
        self.resourceIdentifier = resourceIdentifier
        self.startTime = startTime
        self.status = status
        self.zonalShiftId = zonalShiftId
    }
}

extension CancelZonalShiftInput {

    static func urlPathProvider(_ value: CancelZonalShiftInput) -> Swift.String? {
        guard let zonalShiftId = value.zonalShiftId else {
            return nil
        }
        return "/zonalshifts/\(zonalShiftId.urlPercentEncoding())"
    }
}

extension CreatePracticeRunConfigurationInput {

    static func urlPathProvider(_ value: CreatePracticeRunConfigurationInput) -> Swift.String? {
        return "/configuration"
    }
}

extension DeletePracticeRunConfigurationInput {

    static func urlPathProvider(_ value: DeletePracticeRunConfigurationInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/configuration/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension GetAutoshiftObserverNotificationStatusInput {

    static func urlPathProvider(_ value: GetAutoshiftObserverNotificationStatusInput) -> Swift.String? {
        return "/autoshift-observer-notification"
    }
}

extension GetManagedResourceInput {

    static func urlPathProvider(_ value: GetManagedResourceInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/managedresources/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension ListAutoshiftsInput {

    static func urlPathProvider(_ value: ListAutoshiftsInput) -> Swift.String? {
        return "/autoshifts"
    }
}

extension ListAutoshiftsInput {

    static func queryItemProvider(_ value: ListAutoshiftsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListManagedResourcesInput {

    static func urlPathProvider(_ value: ListManagedResourcesInput) -> Swift.String? {
        return "/managedresources"
    }
}

extension ListManagedResourcesInput {

    static func queryItemProvider(_ value: ListManagedResourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListZonalShiftsInput {

    static func urlPathProvider(_ value: ListZonalShiftsInput) -> Swift.String? {
        return "/zonalshifts"
    }
}

extension ListZonalShiftsInput {

    static func queryItemProvider(_ value: ListZonalShiftsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resourceIdentifier = value.resourceIdentifier {
            let resourceIdentifierQueryItem = Smithy.URIQueryItem(name: "resourceIdentifier".urlPercentEncoding(), value: Swift.String(resourceIdentifier).urlPercentEncoding())
            items.append(resourceIdentifierQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension StartZonalShiftInput {

    static func urlPathProvider(_ value: StartZonalShiftInput) -> Swift.String? {
        return "/zonalshifts"
    }
}

extension UpdateAutoshiftObserverNotificationStatusInput {

    static func urlPathProvider(_ value: UpdateAutoshiftObserverNotificationStatusInput) -> Swift.String? {
        return "/autoshift-observer-notification"
    }
}

extension UpdatePracticeRunConfigurationInput {

    static func urlPathProvider(_ value: UpdatePracticeRunConfigurationInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/configuration/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension UpdateZonalAutoshiftConfigurationInput {

    static func urlPathProvider(_ value: UpdateZonalAutoshiftConfigurationInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/managedresources/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension UpdateZonalShiftInput {

    static func urlPathProvider(_ value: UpdateZonalShiftInput) -> Swift.String? {
        guard let zonalShiftId = value.zonalShiftId else {
            return nil
        }
        return "/zonalshifts/\(zonalShiftId.urlPercentEncoding())"
    }
}

extension CreatePracticeRunConfigurationInput {

    static func write(value: CreatePracticeRunConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedDates"].writeList(value.blockedDates, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["blockedWindows"].writeList(value.blockedWindows, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["blockingAlarms"].writeList(value.blockingAlarms, memberWritingClosure: ARCZonalShiftClientTypes.ControlCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outcomeAlarms"].writeList(value.outcomeAlarms, memberWritingClosure: ARCZonalShiftClientTypes.ControlCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceIdentifier"].write(value.resourceIdentifier)
    }
}

extension StartZonalShiftInput {

    static func write(value: StartZonalShiftInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["awayFrom"].write(value.awayFrom)
        try writer["comment"].write(value.comment)
        try writer["expiresIn"].write(value.expiresIn)
        try writer["resourceIdentifier"].write(value.resourceIdentifier)
    }
}

extension UpdateAutoshiftObserverNotificationStatusInput {

    static func write(value: UpdateAutoshiftObserverNotificationStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension UpdatePracticeRunConfigurationInput {

    static func write(value: UpdatePracticeRunConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blockedDates"].writeList(value.blockedDates, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["blockedWindows"].writeList(value.blockedWindows, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["blockingAlarms"].writeList(value.blockingAlarms, memberWritingClosure: ARCZonalShiftClientTypes.ControlCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outcomeAlarms"].writeList(value.outcomeAlarms, memberWritingClosure: ARCZonalShiftClientTypes.ControlCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateZonalAutoshiftConfigurationInput {

    static func write(value: UpdateZonalAutoshiftConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["zonalAutoshiftStatus"].write(value.zonalAutoshiftStatus)
    }
}

extension UpdateZonalShiftInput {

    static func write(value: UpdateZonalShiftInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["expiresIn"].write(value.expiresIn)
    }
}

extension CancelZonalShiftOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelZonalShiftOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelZonalShiftOutput()
        value.awayFrom = try reader["awayFrom"].readIfPresent() ?? ""
        value.comment = try reader["comment"].readIfPresent() ?? ""
        value.expiryTime = try reader["expiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent() ?? ""
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.zonalShiftId = try reader["zonalShiftId"].readIfPresent() ?? ""
        return value
    }
}

extension CreatePracticeRunConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePracticeRunConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePracticeRunConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.practiceRunConfiguration = try reader["practiceRunConfiguration"].readIfPresent(with: ARCZonalShiftClientTypes.PracticeRunConfiguration.read(from:))
        value.zonalAutoshiftStatus = try reader["zonalAutoshiftStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeletePracticeRunConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePracticeRunConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePracticeRunConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.zonalAutoshiftStatus = try reader["zonalAutoshiftStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetAutoshiftObserverNotificationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAutoshiftObserverNotificationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAutoshiftObserverNotificationStatusOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetManagedResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedResourceOutput()
        value.appliedWeights = try reader["appliedWeights"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readFloat(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.arn = try reader["arn"].readIfPresent()
        value.autoshifts = try reader["autoshifts"].readListIfPresent(memberReadingClosure: ARCZonalShiftClientTypes.AutoshiftInResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.practiceRunConfiguration = try reader["practiceRunConfiguration"].readIfPresent(with: ARCZonalShiftClientTypes.PracticeRunConfiguration.read(from:))
        value.zonalAutoshiftStatus = try reader["zonalAutoshiftStatus"].readIfPresent()
        value.zonalShifts = try reader["zonalShifts"].readListIfPresent(memberReadingClosure: ARCZonalShiftClientTypes.ZonalShiftInResource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListAutoshiftsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutoshiftsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutoshiftsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ARCZonalShiftClientTypes.AutoshiftSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListManagedResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedResourcesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ARCZonalShiftClientTypes.ManagedResourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListZonalShiftsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListZonalShiftsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListZonalShiftsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ARCZonalShiftClientTypes.ZonalShiftSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension StartZonalShiftOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartZonalShiftOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartZonalShiftOutput()
        value.awayFrom = try reader["awayFrom"].readIfPresent() ?? ""
        value.comment = try reader["comment"].readIfPresent() ?? ""
        value.expiryTime = try reader["expiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent() ?? ""
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.zonalShiftId = try reader["zonalShiftId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateAutoshiftObserverNotificationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAutoshiftObserverNotificationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAutoshiftObserverNotificationStatusOutput()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdatePracticeRunConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePracticeRunConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePracticeRunConfigurationOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.practiceRunConfiguration = try reader["practiceRunConfiguration"].readIfPresent(with: ARCZonalShiftClientTypes.PracticeRunConfiguration.read(from:))
        value.zonalAutoshiftStatus = try reader["zonalAutoshiftStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdateZonalAutoshiftConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateZonalAutoshiftConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateZonalAutoshiftConfigurationOutput()
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent() ?? ""
        value.zonalAutoshiftStatus = try reader["zonalAutoshiftStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdateZonalShiftOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateZonalShiftOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateZonalShiftOutput()
        value.awayFrom = try reader["awayFrom"].readIfPresent() ?? ""
        value.comment = try reader["comment"].readIfPresent() ?? ""
        value.expiryTime = try reader["expiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent() ?? ""
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.zonalShiftId = try reader["zonalShiftId"].readIfPresent() ?? ""
        return value
    }
}

enum CancelZonalShiftOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePracticeRunConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePracticeRunConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAutoshiftObserverNotificationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutoshiftsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListZonalShiftsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartZonalShiftOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAutoshiftObserverNotificationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePracticeRunConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateZonalAutoshiftConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateZonalShiftOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.properties.zonalShiftId = try reader["zonalShiftId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ARCZonalShiftClientTypes.PracticeRunConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ARCZonalShiftClientTypes.PracticeRunConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCZonalShiftClientTypes.PracticeRunConfiguration()
        value.blockingAlarms = try reader["blockingAlarms"].readListIfPresent(memberReadingClosure: ARCZonalShiftClientTypes.ControlCondition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outcomeAlarms = try reader["outcomeAlarms"].readListIfPresent(memberReadingClosure: ARCZonalShiftClientTypes.ControlCondition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.blockedWindows = try reader["blockedWindows"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.blockedDates = try reader["blockedDates"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ARCZonalShiftClientTypes.ControlCondition {

    static func write(value: ARCZonalShiftClientTypes.ControlCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmIdentifier"].write(value.alarmIdentifier)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ARCZonalShiftClientTypes.ControlCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCZonalShiftClientTypes.ControlCondition()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.alarmIdentifier = try reader["alarmIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension ARCZonalShiftClientTypes.ZonalShiftInResource {

    static func read(from reader: SmithyJSON.Reader) throws -> ARCZonalShiftClientTypes.ZonalShiftInResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCZonalShiftClientTypes.ZonalShiftInResource()
        value.appliedStatus = try reader["appliedStatus"].readIfPresent() ?? .sdkUnknown("")
        value.zonalShiftId = try reader["zonalShiftId"].readIfPresent() ?? ""
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent() ?? ""
        value.awayFrom = try reader["awayFrom"].readIfPresent() ?? ""
        value.expiryTime = try reader["expiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.comment = try reader["comment"].readIfPresent() ?? ""
        value.practiceRunOutcome = try reader["practiceRunOutcome"].readIfPresent()
        return value
    }
}

extension ARCZonalShiftClientTypes.AutoshiftInResource {

    static func read(from reader: SmithyJSON.Reader) throws -> ARCZonalShiftClientTypes.AutoshiftInResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCZonalShiftClientTypes.AutoshiftInResource()
        value.appliedStatus = try reader["appliedStatus"].readIfPresent() ?? .sdkUnknown("")
        value.awayFrom = try reader["awayFrom"].readIfPresent() ?? ""
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ARCZonalShiftClientTypes.AutoshiftSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ARCZonalShiftClientTypes.AutoshiftSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCZonalShiftClientTypes.AutoshiftSummary()
        value.awayFrom = try reader["awayFrom"].readIfPresent() ?? ""
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ARCZonalShiftClientTypes.ManagedResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ARCZonalShiftClientTypes.ManagedResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCZonalShiftClientTypes.ManagedResourceSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.availabilityZones = try reader["availabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.appliedWeights = try reader["appliedWeights"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readFloat(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.zonalShifts = try reader["zonalShifts"].readListIfPresent(memberReadingClosure: ARCZonalShiftClientTypes.ZonalShiftInResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.autoshifts = try reader["autoshifts"].readListIfPresent(memberReadingClosure: ARCZonalShiftClientTypes.AutoshiftInResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.zonalAutoshiftStatus = try reader["zonalAutoshiftStatus"].readIfPresent()
        value.practiceRunStatus = try reader["practiceRunStatus"].readIfPresent()
        return value
    }
}

extension ARCZonalShiftClientTypes.ZonalShiftSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ARCZonalShiftClientTypes.ZonalShiftSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCZonalShiftClientTypes.ZonalShiftSummary()
        value.zonalShiftId = try reader["zonalShiftId"].readIfPresent() ?? ""
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent() ?? ""
        value.awayFrom = try reader["awayFrom"].readIfPresent() ?? ""
        value.expiryTime = try reader["expiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.comment = try reader["comment"].readIfPresent() ?? ""
        value.practiceRunOutcome = try reader["practiceRunOutcome"].readIfPresent()
        return value
    }
}

public enum ARCZonalShiftClientTypes {}
