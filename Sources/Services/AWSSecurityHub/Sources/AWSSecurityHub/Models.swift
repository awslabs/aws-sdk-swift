//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox

/// Internal server error.
public struct InternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The account doesn't have permission to perform this action.
public struct InvalidAccessException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAccessException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The request was rejected because you supplied an invalid or out-of-range value for an input parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account or throttling limits. The error code describes the limit exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The request was rejected because we can't find the specified resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct AcceptAdministratorInvitationInput {
    /// The account ID of the Security Hub administrator account that sent the invitation.
    /// This member is required.
    public var administratorId: Swift.String?
    /// The identifier of the invitation sent from the Security Hub administrator account.
    /// This member is required.
    public var invitationId: Swift.String?

    public init(
        administratorId: Swift.String? = nil,
        invitationId: Swift.String? = nil
    )
    {
        self.administratorId = administratorId
        self.invitationId = invitationId
    }
}

public struct AcceptAdministratorInvitationOutput {

    public init() { }
}

public struct AcceptInvitationInput {
    /// The identifier of the invitation sent from the Security Hub administrator account.
    /// This member is required.
    public var invitationId: Swift.String?
    /// The account ID of the Security Hub administrator account that sent the invitation.
    /// This member is required.
    public var masterId: Swift.String?

    public init(
        invitationId: Swift.String? = nil,
        masterId: Swift.String? = nil
    )
    {
        self.invitationId = invitationId
        self.masterId = masterId
    }
}

public struct AcceptInvitationOutput {

    public init() { }
}

/// You don't have permission to perform the action specified in the request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

extension SecurityHubClientTypes {
    /// The details of an Amazon Web Services account.
    public struct AccountDetails {
        /// The ID of an Amazon Web Services account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The email of an Amazon Web Services account.
        public var email: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            email: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.email = email
        }
    }

}

extension SecurityHubClientTypes {
    /// Provided if CallerType is domain. It provides information about the DNS domain that issued the API call.
    public struct AwsApiCallActionDomainDetails {
        /// The name of the DNS domain that issued the API call. Length Constraints: 128.
        public var domain: Swift.String?

        public init(
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a city.
    public struct City {
        /// The name of the city.
        public var cityName: Swift.String?

        public init(
            cityName: Swift.String? = nil
        )
        {
            self.cityName = cityName
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a country.
    public struct Country {
        /// The 2-letter ISO 3166 country code for the country.
        public var countryCode: Swift.String?
        /// The name of the country.
        public var countryName: Swift.String?

        public init(
            countryCode: Swift.String? = nil,
            countryName: Swift.String? = nil
        )
        {
            self.countryCode = countryCode
            self.countryName = countryName
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides the latitude and longitude coordinates of a location.
    public struct GeoLocation {
        /// The latitude of the location.
        public var lat: Swift.Double?
        /// The longitude of the location.
        public var lon: Swift.Double?

        public init(
            lat: Swift.Double? = nil,
            lon: Swift.Double? = nil
        )
        {
            self.lat = lat
            self.lon = lon
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an internet provider.
    public struct IpOrganizationDetails {
        /// The Autonomous System Number (ASN) of the internet provider
        public var asn: Swift.Int?
        /// The name of the organization that registered the ASN.
        public var asnOrg: Swift.String?
        /// The ISP information for the internet provider.
        public var isp: Swift.String?
        /// The name of the internet provider.
        public var org: Swift.String?

        public init(
            asn: Swift.Int? = nil,
            asnOrg: Swift.String? = nil,
            isp: Swift.String? = nil,
            org: Swift.String? = nil
        )
        {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }
    }

}

extension SecurityHubClientTypes {
    /// For AwsApiAction, NetworkConnectionAction, and PortProbeAction, RemoteIpDetails provides information about the remote IP address that was involved in the action.
    public struct ActionRemoteIpDetails {
        /// The city where the remote IP address is located.
        public var city: SecurityHubClientTypes.City?
        /// The country where the remote IP address is located.
        public var country: SecurityHubClientTypes.Country?
        /// The coordinates of the location of the remote IP address.
        public var geoLocation: SecurityHubClientTypes.GeoLocation?
        /// The IP address.
        public var ipAddressV4: Swift.String?
        /// The internet service provider (ISP) organization associated with the remote IP address.
        public var organization: SecurityHubClientTypes.IpOrganizationDetails?

        public init(
            city: SecurityHubClientTypes.City? = nil,
            country: SecurityHubClientTypes.Country? = nil,
            geoLocation: SecurityHubClientTypes.GeoLocation? = nil,
            ipAddressV4: Swift.String? = nil,
            organization: SecurityHubClientTypes.IpOrganizationDetails? = nil
        )
        {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.organization = organization
        }
    }

}

extension SecurityHubClientTypes {
    /// Provided if ActionType is AWS_API_CALL. It provides details about the API call that was detected.
    public struct AwsApiCallAction {
        /// Identifies the resources that were affected by the API call.
        public var affectedResources: [Swift.String: Swift.String]?
        /// The name of the API method that was issued. Length Constraints: 128.
        public var api: Swift.String?
        /// Indicates whether the API call originated from a remote IP address (remoteip) or from a DNS domain (domain).
        public var callerType: Swift.String?
        /// Provided if CallerType is domain. Provides information about the DNS domain that the API call originated from.
        public var domainDetails: SecurityHubClientTypes.AwsApiCallActionDomainDetails?
        /// A timestamp that indicates when the API call was first observed. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var firstSeen: Swift.String?
        /// A timestamp that indicates when the API call was most recently observed. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastSeen: Swift.String?
        /// Provided if CallerType is remoteip. Provides information about the remote IP address that the API call originated from.
        public var remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails?
        /// The name of the Amazon Web Services service that the API method belongs to. Length Constraints: 128.
        public var serviceName: Swift.String?

        public init(
            affectedResources: [Swift.String: Swift.String]? = nil,
            api: Swift.String? = nil,
            callerType: Swift.String? = nil,
            domainDetails: SecurityHubClientTypes.AwsApiCallActionDomainDetails? = nil,
            firstSeen: Swift.String? = nil,
            lastSeen: Swift.String? = nil,
            remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.affectedResources = affectedResources
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
        }
    }

}

extension SecurityHubClientTypes {
    /// Provided if ActionType is DNS_REQUEST. It provides details about the DNS request that was detected.
    public struct DnsRequestAction {
        /// Indicates whether the DNS request was blocked.
        public var blocked: Swift.Bool?
        /// The DNS domain that is associated with the DNS request. Length Constraints: 128.
        public var domain: Swift.String?
        /// The protocol that was used for the DNS request. Length Constraints: Minimum length of 1. Maximum length of 64.
        public var `protocol`: Swift.String?

        public init(
            blocked: Swift.Bool? = nil,
            domain: Swift.String? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.blocked = blocked
            self.domain = domain
            self.`protocol` = `protocol`
        }
    }

}

extension SecurityHubClientTypes {
    /// For NetworkConnectionAction and PortProbeDetails, LocalPortDetails provides information about the local port that was involved in the action.
    public struct ActionLocalPortDetails {
        /// The number of the port.
        public var port: Swift.Int?
        /// The port name of the local connection. Length Constraints: 128.
        public var portName: Swift.String?

        public init(
            port: Swift.Int? = nil,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the remote port that was involved in an attempted network connection.
    public struct ActionRemotePortDetails {
        /// The number of the port.
        public var port: Swift.Int?
        /// The port name of the remote connection. Length Constraints: 128.
        public var portName: Swift.String?

        public init(
            port: Swift.Int? = nil,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension SecurityHubClientTypes {
    /// Provided if ActionType is NETWORK_CONNECTION. It provides details about the attempted network connection that was detected.
    public struct NetworkConnectionAction {
        /// Indicates whether the network connection attempt was blocked.
        public var blocked: Swift.Bool?
        /// The direction of the network connection request (IN or OUT).
        public var connectionDirection: Swift.String?
        /// Information about the port on the EC2 instance.
        public var localPortDetails: SecurityHubClientTypes.ActionLocalPortDetails?
        /// The protocol used to make the network connection request. Length Constraints: Minimum length of 1. Maximum length of 64.
        public var `protocol`: Swift.String?
        /// Information about the remote IP address that issued the network connection request.
        public var remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails?
        /// Information about the port on the remote IP address.
        public var remotePortDetails: SecurityHubClientTypes.ActionRemotePortDetails?

        public init(
            blocked: Swift.Bool? = nil,
            connectionDirection: Swift.String? = nil,
            localPortDetails: SecurityHubClientTypes.ActionLocalPortDetails? = nil,
            `protocol`: Swift.String? = nil,
            remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails? = nil,
            remotePortDetails: SecurityHubClientTypes.ActionRemotePortDetails? = nil
        )
        {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the IP address where the scanned port is located.
    public struct ActionLocalIpDetails {
        /// The IP address.
        public var ipAddressV4: Swift.String?

        public init(
            ipAddressV4: Swift.String? = nil
        )
        {
            self.ipAddressV4 = ipAddressV4
        }
    }

}

extension SecurityHubClientTypes {
    /// A port scan that was part of the port probe. For each scan, PortProbeDetails provides information about the local IP address and port that were scanned, and the remote IP address that the scan originated from.
    public struct PortProbeDetail {
        /// Provides information about the IP address where the scanned port is located.
        public var localIpDetails: SecurityHubClientTypes.ActionLocalIpDetails?
        /// Provides information about the port that was scanned.
        public var localPortDetails: SecurityHubClientTypes.ActionLocalPortDetails?
        /// Provides information about the remote IP address that performed the scan.
        public var remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails?

        public init(
            localIpDetails: SecurityHubClientTypes.ActionLocalIpDetails? = nil,
            localPortDetails: SecurityHubClientTypes.ActionLocalPortDetails? = nil,
            remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails? = nil
        )
        {
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }
    }

}

extension SecurityHubClientTypes {
    /// Provided if ActionType is PORT_PROBE. It provides details about the attempted port probe that was detected.
    public struct PortProbeAction {
        /// Indicates whether the port probe was blocked.
        public var blocked: Swift.Bool?
        /// Information about the ports affected by the port probe.
        public var portProbeDetails: [SecurityHubClientTypes.PortProbeDetail]?

        public init(
            blocked: Swift.Bool? = nil,
            portProbeDetails: [SecurityHubClientTypes.PortProbeDetail]? = nil
        )
        {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about one of the following actions that affects or that was taken on a resource:
    ///
    /// * A remote IP address issued an Amazon Web Services API call
    ///
    /// * A DNS request was received
    ///
    /// * A remote IP address attempted to connect to an EC2 instance
    ///
    /// * A remote IP address attempted a port probe on an EC2 instance
    public struct Action {
        /// The type of action that was detected. The possible action types are:
        ///
        /// * NETWORK_CONNECTION
        ///
        /// * AWS_API_CALL
        ///
        /// * DNS_REQUEST
        ///
        /// * PORT_PROBE
        public var actionType: Swift.String?
        /// Included if ActionType is AWS_API_CALL. Provides details about the API call that was detected.
        public var awsApiCallAction: SecurityHubClientTypes.AwsApiCallAction?
        /// Included if ActionType is DNS_REQUEST. Provides details about the DNS request that was detected.
        public var dnsRequestAction: SecurityHubClientTypes.DnsRequestAction?
        /// Included if ActionType is NETWORK_CONNECTION. Provides details about the network connection that was detected.
        public var networkConnectionAction: SecurityHubClientTypes.NetworkConnectionAction?
        /// Included if ActionType is PORT_PROBE. Provides details about the port probe that was detected.
        public var portProbeAction: SecurityHubClientTypes.PortProbeAction?

        public init(
            actionType: Swift.String? = nil,
            awsApiCallAction: SecurityHubClientTypes.AwsApiCallAction? = nil,
            dnsRequestAction: SecurityHubClientTypes.DnsRequestAction? = nil,
            networkConnectionAction: SecurityHubClientTypes.NetworkConnectionAction? = nil,
            portProbeAction: SecurityHubClientTypes.PortProbeAction? = nil
        )
        {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
        }
    }

}

extension SecurityHubClientTypes {
    /// The updated note.
    public struct NoteUpdate {
        /// The updated note text.
        /// This member is required.
        public var text: Swift.String?
        /// The principal that updated the note.
        /// This member is required.
        public var updatedBy: Swift.String?

        public init(
            text: Swift.String? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.text = text
            self.updatedBy = updatedBy
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about a related finding.
    public struct RelatedFinding {
        /// The product-generated identifier for a related finding.
        /// This member is required.
        public var id: Swift.String?
        /// The ARN of the product that generated a related finding.
        /// This member is required.
        public var productArn: Swift.String?

        public init(
            id: Swift.String? = nil,
            productArn: Swift.String? = nil
        )
        {
            self.id = id
            self.productArn = productArn
        }
    }

}

extension SecurityHubClientTypes {

    public enum SeverityLabel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [SeverityLabel] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Updates to the severity information for a finding.
    public struct SeverityUpdate {
        /// The severity value of the finding. The allowed values are the following.
        ///
        /// * INFORMATIONAL - No issue was found.
        ///
        /// * LOW - The issue does not require action on its own.
        ///
        /// * MEDIUM - The issue must be addressed but not urgently.
        ///
        /// * HIGH - The issue must be addressed as a priority.
        ///
        /// * CRITICAL - The issue must be remediated immediately to avoid it escalating.
        public var label: SecurityHubClientTypes.SeverityLabel?
        /// The normalized severity for the finding. This attribute is to be deprecated in favor of Label. If you provide Normalized and do not provide Label, Label is set automatically as follows.
        ///
        /// * 0 - INFORMATIONAL
        ///
        /// * 1–39 - LOW
        ///
        /// * 40–69 - MEDIUM
        ///
        /// * 70–89 - HIGH
        ///
        /// * 90–100 - CRITICAL
        public var normalized: Swift.Int?
        /// The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.
        public var product: Swift.Double?

        public init(
            label: SecurityHubClientTypes.SeverityLabel? = nil,
            normalized: Swift.Int? = nil,
            product: Swift.Double? = nil
        )
        {
            self.label = label
            self.normalized = normalized
            self.product = product
        }
    }

}

extension SecurityHubClientTypes {

    public enum VerificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case benignPositive
        case falsePositive
        case truePositive
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationState] {
            return [
                .benignPositive,
                .falsePositive,
                .truePositive,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .benignPositive: return "BENIGN_POSITIVE"
            case .falsePositive: return "FALSE_POSITIVE"
            case .truePositive: return "TRUE_POSITIVE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum WorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case new
        case notified
        case resolved
        case suppressed
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStatus] {
            return [
                .new,
                .notified,
                .resolved,
                .suppressed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .new: return "NEW"
            case .notified: return "NOTIFIED"
            case .resolved: return "RESOLVED"
            case .suppressed: return "SUPPRESSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Used to update information about the investigation into the finding.
    public struct WorkflowUpdate {
        /// The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to SUPPRESSED or RESOLVED does not prevent a new finding for the same issue. The allowed values are the following.
        ///
        /// * NEW - The initial state of a finding, before it is reviewed. Security Hub also resets WorkFlowStatus from NOTIFIED or RESOLVED to NEW in the following cases:
        ///
        /// * The record state changes from ARCHIVED to ACTIVE.
        ///
        /// * The compliance status changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.
        ///
        ///
        ///
        ///
        /// * NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.
        ///
        /// * RESOLVED - The finding was reviewed and remediated and is now considered resolved.
        ///
        /// * SUPPRESSED - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.
        public var status: SecurityHubClientTypes.WorkflowStatus?

        public init(
            status: SecurityHubClientTypes.WorkflowStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Identifies the finding fields that the automation rule action updates when a finding matches the defined criteria.
    public struct AutomationRulesFindingFieldsUpdate {
        /// The rule action updates the Confidence field of a finding.
        public var confidence: Swift.Int?
        /// The rule action updates the Criticality field of a finding.
        public var criticality: Swift.Int?
        /// The updated note.
        public var note: SecurityHubClientTypes.NoteUpdate?
        /// The rule action updates the RelatedFindings field of a finding.
        public var relatedFindings: [SecurityHubClientTypes.RelatedFinding]?
        /// Updates to the severity information for a finding.
        public var severity: SecurityHubClientTypes.SeverityUpdate?
        /// The rule action updates the Types field of a finding.
        public var types: [Swift.String]?
        /// The rule action updates the UserDefinedFields field of a finding.
        public var userDefinedFields: [Swift.String: Swift.String]?
        /// The rule action updates the VerificationState field of a finding.
        public var verificationState: SecurityHubClientTypes.VerificationState?
        /// Used to update information about the investigation into the finding.
        public var workflow: SecurityHubClientTypes.WorkflowUpdate?

        public init(
            confidence: Swift.Int? = nil,
            criticality: Swift.Int? = nil,
            note: SecurityHubClientTypes.NoteUpdate? = nil,
            relatedFindings: [SecurityHubClientTypes.RelatedFinding]? = nil,
            severity: SecurityHubClientTypes.SeverityUpdate? = nil,
            types: [Swift.String]? = nil,
            userDefinedFields: [Swift.String: Swift.String]? = nil,
            verificationState: SecurityHubClientTypes.VerificationState? = nil,
            workflow: SecurityHubClientTypes.WorkflowUpdate? = nil
        )
        {
            self.confidence = confidence
            self.criticality = criticality
            self.note = note
            self.relatedFindings = relatedFindings
            self.severity = severity
            self.types = types
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflow = workflow
        }
    }

}

extension SecurityHubClientTypes {

    public enum AutomationRulesActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case findingFieldsUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomationRulesActionType] {
            return [
                .findingFieldsUpdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .findingFieldsUpdate: return "FINDING_FIELDS_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// One or more actions to update finding fields if a finding matches the defined criteria of the rule.
    public struct AutomationRulesAction {
        /// Specifies that the automation rule action is an update to a finding field.
        public var findingFieldsUpdate: SecurityHubClientTypes.AutomationRulesFindingFieldsUpdate?
        /// Specifies that the rule action should update the Types finding field. The Types finding field classifies findings in the format of namespace/category/classifier. For more information, see [Types taxonomy for ASFF](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format-type-taxonomy.html) in the Security Hub User Guide.
        public var type: SecurityHubClientTypes.AutomationRulesActionType?

        public init(
            findingFieldsUpdate: SecurityHubClientTypes.AutomationRulesFindingFieldsUpdate? = nil,
            type: SecurityHubClientTypes.AutomationRulesActionType? = nil
        )
        {
            self.findingFieldsUpdate = findingFieldsUpdate
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// An ActionTarget object.
    public struct ActionTarget {
        /// The ARN for the target action.
        /// This member is required.
        public var actionTargetArn: Swift.String?
        /// The description of the target action.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the action target.
        /// This member is required.
        public var name: Swift.String?

        public init(
            actionTargetArn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }
    }

}

extension SecurityHubClientTypes {
    /// An adjustment to the CVSS metric.
    public struct Adjustment {
        /// The metric to adjust.
        public var metric: Swift.String?
        /// The reason for the adjustment.
        public var reason: Swift.String?

        public init(
            metric: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.metric = metric
            self.reason = reason
        }
    }

}

extension SecurityHubClientTypes {

    public enum AdminStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disableInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AdminStatus] {
            return [
                .disableInProgress,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Represents a Security Hub administrator account designated by an organization management account.
    public struct AdminAccount {
        /// The Amazon Web Services account identifier of the Security Hub administrator account.
        public var accountId: Swift.String?
        /// The current status of the Security Hub administrator account. Indicates whether the account is currently enabled as a Security Hub administrator.
        public var status: SecurityHubClientTypes.AdminStatus?

        public init(
            accountId: Swift.String? = nil,
            status: SecurityHubClientTypes.AdminStatus? = nil
        )
        {
            self.accountId = accountId
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an enabled security standard in which a security control is enabled.
    public struct AssociatedStandard {
        /// The unique identifier of a standard in which a control is enabled. This field consists of the resource portion of the Amazon Resource Name (ARN) returned for a standard in the [DescribeStandards](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_DescribeStandards.html) API response.
        public var standardsId: Swift.String?

        public init(
            standardsId: Swift.String? = nil
        )
        {
            self.standardsId = standardsId
        }
    }

}

extension SecurityHubClientTypes {

    public enum ConfigurationPolicyAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationPolicyAssociationStatus] {
            return [
                .failed,
                .pending,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum AssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applied
        case inherited
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationType] {
            return [
                .applied,
                .inherited
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .inherited: return "INHERITED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Options for filtering the ListConfigurationPolicyAssociations response. You can filter by the Amazon Resource Name (ARN) or universally unique identifier (UUID) of a configuration policy, AssociationType, or AssociationStatus.
    public struct AssociationFilters {
        /// The current status of the association between a target and a configuration policy.
        public var associationStatus: SecurityHubClientTypes.ConfigurationPolicyAssociationStatus?
        /// Indicates whether the association between a target and a configuration was directly applied by the Security Hub delegated administrator or inherited from a parent.
        public var associationType: SecurityHubClientTypes.AssociationType?
        /// The ARN or UUID of the configuration policy.
        public var configurationPolicyId: Swift.String?

        public init(
            associationStatus: SecurityHubClientTypes.ConfigurationPolicyAssociationStatus? = nil,
            associationType: SecurityHubClientTypes.AssociationType? = nil,
            configurationPolicyId: Swift.String? = nil
        )
        {
            self.associationStatus = associationStatus
            self.associationType = associationType
            self.configurationPolicyId = configurationPolicyId
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes the state of an association between a route table and a subnet or gateway.
    public struct AssociationStateDetails {
        /// The state of the association.
        public var state: Swift.String?
        /// The status message, if applicable.
        public var statusMessage: Swift.String?

        public init(
            state: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.state = state
            self.statusMessage = statusMessage
        }
    }

}

extension SecurityHubClientTypes {
    /// The associations between a route table and one or more subnets or a gateway.
    public struct AssociationSetDetails {
        /// The state of the association between a route table and a subnet or gateway.
        public var associationState: SecurityHubClientTypes.AssociationStateDetails?
        /// The ID of the internet gateway or virtual private gateway.
        public var gatewayId: Swift.String?
        /// Indicates whether this is the main route table.
        public var main: Swift.Bool?
        /// The ID of the association.
        public var routeTableAssociationId: Swift.String?
        /// The ID of the route table.
        public var routeTableId: Swift.String?
        /// The ID of the subnet. A subnet ID is not returned for an implicit association.
        public var subnetId: Swift.String?

        public init(
            associationState: SecurityHubClientTypes.AssociationStateDetails? = nil,
            gatewayId: Swift.String? = nil,
            main: Swift.Bool? = nil,
            routeTableAssociationId: Swift.String? = nil,
            routeTableId: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.associationState = associationState
            self.gatewayId = gatewayId
            self.main = main
            self.routeTableAssociationId = routeTableAssociationId
            self.routeTableId = routeTableId
            self.subnetId = subnetId
        }
    }

}

extension SecurityHubClientTypes {

    public enum AssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AssociationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum AutoEnableStandards: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoEnableStandards] {
            return [
                .default,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum StringFilterComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case equals
        case notContains
        case notEquals
        case `prefix`
        case prefixNotEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [StringFilterComparison] {
            return [
                .contains,
                .equals,
                .notContains,
                .notEquals,
                .prefix,
                .prefixNotEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .notContains: return "NOT_CONTAINS"
            case .notEquals: return "NOT_EQUALS"
            case .prefix: return "PREFIX"
            case .prefixNotEquals: return "PREFIX_NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A string filter for filtering Security Hub findings.
    public struct StringFilter {
        /// The condition to apply to a string value when filtering Security Hub findings. To search for values that have the filter value, use one of the following comparison operators:
        ///
        /// * To search for values that include the filter value, use CONTAINS. For example, the filter Title CONTAINS CloudFront matches findings that have a Title that includes the string CloudFront.
        ///
        /// * To search for values that exactly match the filter value, use EQUALS. For example, the filter AwsAccountId EQUALS 123456789012 only matches findings that have an account ID of 123456789012.
        ///
        /// * To search for values that start with the filter value, use PREFIX. For example, the filter ResourceRegion PREFIX us matches findings that have a ResourceRegion that starts with us. A ResourceRegion that starts with a different value, such as af, ap, or ca, doesn't match.
        ///
        ///
        /// CONTAINS, EQUALS, and PREFIX filters on the same field are joined by OR. A finding matches if it matches any one of those filters. For example, the filters Title CONTAINS CloudFront OR Title CONTAINS CloudWatch match a finding that includes either CloudFront, CloudWatch, or both strings in the title. To search for values that don’t have the filter value, use one of the following comparison operators:
        ///
        /// * To search for values that exclude the filter value, use NOT_CONTAINS. For example, the filter Title NOT_CONTAINS CloudFront matches findings that have a Title that excludes the string CloudFront.
        ///
        /// * To search for values other than the filter value, use NOT_EQUALS. For example, the filter AwsAccountId NOT_EQUALS 123456789012 only matches findings that have an account ID other than 123456789012.
        ///
        /// * To search for values that don't start with the filter value, use PREFIX_NOT_EQUALS. For example, the filter ResourceRegion PREFIX_NOT_EQUALS us matches findings with a ResourceRegion that starts with a value other than us.
        ///
        ///
        /// NOT_CONTAINS, NOT_EQUALS, and PREFIX_NOT_EQUALS filters on the same field are joined by AND. A finding matches only if it matches all of those filters. For example, the filters Title NOT_CONTAINS CloudFront AND Title NOT_CONTAINS CloudWatch match a finding that excludes both CloudFront and CloudWatch in the title. You can’t have both a CONTAINS filter and a NOT_CONTAINS filter on the same field. Similarly, you can't provide both an EQUALS filter and a NOT_EQUALS or PREFIX_NOT_EQUALS filter on the same field. Combining filters in this way returns an error. CONTAINS filters can only be used with other CONTAINS filters. NOT_CONTAINS filters can only be used with other NOT_CONTAINS filters. You can combine PREFIX filters with NOT_EQUALS or PREFIX_NOT_EQUALS filters for the same field. Security Hub first processes the PREFIX filters, and then the NOT_EQUALS or PREFIX_NOT_EQUALS filters. For example, for the following filters, Security Hub first identifies findings that have resource types that start with either AwsIam or AwsEc2. It then excludes findings that have a resource type of AwsIamPolicy and findings that have a resource type of AwsEc2NetworkInterface.
        ///
        /// * ResourceType PREFIX AwsIam
        ///
        /// * ResourceType PREFIX AwsEc2
        ///
        /// * ResourceType NOT_EQUALS AwsIamPolicy
        ///
        /// * ResourceType NOT_EQUALS AwsEc2NetworkInterface
        ///
        ///
        /// CONTAINS and NOT_CONTAINS operators can be used only with automation rules. For more information, see [Automation rules](https://docs.aws.amazon.com/securityhub/latest/userguide/automation-rules.html) in the Security Hub User Guide.
        public var comparison: SecurityHubClientTypes.StringFilterComparison?
        /// The string filter value. Filter values are case sensitive. For example, the product name for control-based findings is Security Hub. If you provide security hub as the filter value, there's no match.
        public var value: Swift.String?

        public init(
            comparison: SecurityHubClientTypes.StringFilterComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// A number filter for querying findings.
    public struct NumberFilter {
        /// The equal-to condition to be applied to a single field when querying for findings.
        public var eq: Swift.Double?
        /// The greater-than condition to be applied to a single field when querying for findings.
        public var gt: Swift.Double?
        /// The greater-than-equal condition to be applied to a single field when querying for findings.
        public var gte: Swift.Double?
        /// The less-than condition to be applied to a single field when querying for findings.
        public var lt: Swift.Double?
        /// The less-than-equal condition to be applied to a single field when querying for findings.
        public var lte: Swift.Double?

        public init(
            eq: Swift.Double? = nil,
            gt: Swift.Double? = nil,
            gte: Swift.Double? = nil,
            lt: Swift.Double? = nil,
            lte: Swift.Double? = nil
        )
        {
            self.eq = eq
            self.gt = gt
            self.gte = gte
            self.lt = lt
            self.lte = lte
        }
    }

}

extension SecurityHubClientTypes {

    public enum DateRangeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [DateRangeUnit] {
            return [
                .days
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A date range for the date filter.
    public struct DateRange {
        /// A date range unit for the date filter.
        public var unit: SecurityHubClientTypes.DateRangeUnit?
        /// A date range value for the date filter.
        public var value: Swift.Int?

        public init(
            unit: SecurityHubClientTypes.DateRangeUnit? = nil,
            value: Swift.Int? = nil
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// A date filter for querying findings.
    public struct DateFilter {
        /// A date range for the date filter.
        public var dateRange: SecurityHubClientTypes.DateRange?
        /// A timestamp that provides the end date for the date filter. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var end: Swift.String?
        /// A timestamp that provides the start date for the date filter. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var start: Swift.String?

        public init(
            dateRange: SecurityHubClientTypes.DateRange? = nil,
            end: Swift.String? = nil,
            start: Swift.String? = nil
        )
        {
            self.dateRange = dateRange
            self.end = end
            self.start = start
        }
    }

}

extension SecurityHubClientTypes {

    public enum MapFilterComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case equals
        case notContains
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [MapFilterComparison] {
            return [
                .contains,
                .equals,
                .notContains,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .notContains: return "NOT_CONTAINS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A map filter for filtering Security Hub findings. Each map filter provides the field to check for, the value to check for, and the comparison operator.
    public struct MapFilter {
        /// The condition to apply to the key value when filtering Security Hub findings with a map filter. To search for values that have the filter value, use one of the following comparison operators:
        ///
        /// * To search for values that include the filter value, use CONTAINS. For example, for the ResourceTags field, the filter Department CONTAINS Security matches findings that include the value Security for the Department tag. In the same example, a finding with a value of Security team for the Department tag is a match.
        ///
        /// * To search for values that exactly match the filter value, use EQUALS. For example, for the ResourceTags field, the filter Department EQUALS Security matches findings that have the value Security for the Department tag.
        ///
        ///
        /// CONTAINS and EQUALS filters on the same field are joined by OR. A finding matches if it matches any one of those filters. For example, the filters Department CONTAINS Security OR Department CONTAINS Finance match a finding that includes either Security, Finance, or both values. To search for values that don't have the filter value, use one of the following comparison operators:
        ///
        /// * To search for values that exclude the filter value, use NOT_CONTAINS. For example, for the ResourceTags field, the filter Department NOT_CONTAINS Finance matches findings that exclude the value Finance for the Department tag.
        ///
        /// * To search for values other than the filter value, use NOT_EQUALS. For example, for the ResourceTags field, the filter Department NOT_EQUALS Finance matches findings that don’t have the value Finance for the Department tag.
        ///
        ///
        /// NOT_CONTAINS and NOT_EQUALS filters on the same field are joined by AND. A finding matches only if it matches all of those filters. For example, the filters Department NOT_CONTAINS Security AND Department NOT_CONTAINS Finance match a finding that excludes both the Security and Finance values. CONTAINS filters can only be used with other CONTAINS filters. NOT_CONTAINS filters can only be used with other NOT_CONTAINS filters. You can’t have both a CONTAINS filter and a NOT_CONTAINS filter on the same field. Similarly, you can’t have both an EQUALS filter and a NOT_EQUALS filter on the same field. Combining filters in this way returns an error. CONTAINS and NOT_CONTAINS operators can be used only with automation rules. For more information, see [Automation rules](https://docs.aws.amazon.com/securityhub/latest/userguide/automation-rules.html) in the Security Hub User Guide.
        public var comparison: SecurityHubClientTypes.MapFilterComparison?
        /// The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
        public var key: Swift.String?
        /// The value for the key in the map filter. Filter values are case sensitive. For example, one of the values for a tag called Department might be Security. If you provide security as the filter value, then there's no match.
        public var value: Swift.String?

        public init(
            comparison: SecurityHubClientTypes.MapFilterComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// The criteria that determine which findings a rule applies to.
    public struct AutomationRulesFindingFilters {
        /// The Amazon Web Services account ID in which a finding was generated. Array Members: Minimum number of 1 item. Maximum number of 100 items.
        public var awsAccountId: [SecurityHubClientTypes.StringFilter]?
        /// The name of the Amazon Web Services account in which a finding was generated. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var awsAccountName: [SecurityHubClientTypes.StringFilter]?
        /// The name of the company for the product that generated the finding. For control-based findings, the company is Amazon Web Services. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var companyName: [SecurityHubClientTypes.StringFilter]?
        /// The unique identifier of a standard in which a control is enabled. This field consists of the resource portion of the Amazon Resource Name (ARN) returned for a standard in the [DescribeStandards](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_DescribeStandards.html) API response. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var complianceAssociatedStandardsId: [SecurityHubClientTypes.StringFilter]?
        /// The security control ID for which a finding was generated. Security control IDs are the same across standards. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var complianceSecurityControlId: [SecurityHubClientTypes.StringFilter]?
        /// The result of a security check. This field is only used for findings generated from controls. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var complianceStatus: [SecurityHubClientTypes.StringFilter]?
        /// The likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0–100 basis using a ratio scale. A value of 0 means 0 percent confidence, and a value of 100 means 100 percent confidence. For example, a data exfiltration detection based on a statistical deviation of network traffic has low confidence because an actual exfiltration hasn't been verified. For more information, see [Confidence](https://docs.aws.amazon.com/securityhub/latest/userguide/asff-top-level-attributes.html#asff-confidence) in the Security Hub User Guide. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var confidence: [SecurityHubClientTypes.NumberFilter]?
        /// A timestamp that indicates when this finding record was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        ///
        ///
        /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var createdAt: [SecurityHubClientTypes.DateFilter]?
        /// The level of importance that is assigned to the resources that are associated with a finding. Criticality is scored on a 0–100 basis, using a ratio scale that supports only full integers. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. For more information, see [Criticality](https://docs.aws.amazon.com/securityhub/latest/userguide/asff-top-level-attributes.html#asff-criticality) in the Security Hub User Guide. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var criticality: [SecurityHubClientTypes.NumberFilter]?
        /// A finding's description. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var description: [SecurityHubClientTypes.StringFilter]?
        /// A timestamp that indicates when the potential security issue captured by a finding was first observed by the security findings product. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        ///
        ///
        /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var firstObservedAt: [SecurityHubClientTypes.DateFilter]?
        /// The identifier for the solution-specific component that generated a finding. Array Members: Minimum number of 1 item. Maximum number of 100 items.
        public var generatorId: [SecurityHubClientTypes.StringFilter]?
        /// The product-specific identifier for a finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var id: [SecurityHubClientTypes.StringFilter]?
        /// A timestamp that indicates when the potential security issue captured by a finding was most recently observed by the security findings product. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        ///
        ///
        /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var lastObservedAt: [SecurityHubClientTypes.DateFilter]?
        /// The text of a user-defined note that's added to a finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var noteText: [SecurityHubClientTypes.StringFilter]?
        /// The timestamp of when the note was updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        ///
        ///
        /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var noteUpdatedAt: [SecurityHubClientTypes.DateFilter]?
        /// The principal that created a note. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var noteUpdatedBy: [SecurityHubClientTypes.StringFilter]?
        /// The Amazon Resource Name (ARN) for a third-party product that generated a finding in Security Hub. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var productArn: [SecurityHubClientTypes.StringFilter]?
        /// Provides the name of the product that generated the finding. For control-based findings, the product name is Security Hub. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var productName: [SecurityHubClientTypes.StringFilter]?
        /// Provides the current state of a finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var recordState: [SecurityHubClientTypes.StringFilter]?
        /// The product-generated identifier for a related finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var relatedFindingsId: [SecurityHubClientTypes.StringFilter]?
        /// The ARN for the product that generated a related finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var relatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]?
        /// The Amazon Resource Name (ARN) of the application that is related to a finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var resourceApplicationArn: [SecurityHubClientTypes.StringFilter]?
        /// The name of the application that is related to a finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var resourceApplicationName: [SecurityHubClientTypes.StringFilter]?
        /// Custom fields and values about the resource that a finding pertains to. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var resourceDetailsOther: [SecurityHubClientTypes.MapFilter]?
        /// The identifier for the given resource type. For Amazon Web Services resources that are identified by Amazon Resource Names (ARNs), this is the ARN. For Amazon Web Services resources that lack ARNs, this is the identifier as defined by the Amazon Web Servicesservice that created the resource. For non-Amazon Web Services resources, this is a unique identifier that is associated with the resource. Array Members: Minimum number of 1 item. Maximum number of 100 items.
        public var resourceId: [SecurityHubClientTypes.StringFilter]?
        /// The partition in which the resource that the finding pertains to is located. A partition is a group of Amazon Web Services Regions. Each Amazon Web Services account is scoped to one partition. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var resourcePartition: [SecurityHubClientTypes.StringFilter]?
        /// The Amazon Web Services Region where the resource that a finding pertains to is located. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var resourceRegion: [SecurityHubClientTypes.StringFilter]?
        /// A list of Amazon Web Services tags associated with a resource at the time the finding was processed. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var resourceTags: [SecurityHubClientTypes.MapFilter]?
        /// The type of resource that the finding pertains to. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var resourceType: [SecurityHubClientTypes.StringFilter]?
        /// The severity value of the finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var severityLabel: [SecurityHubClientTypes.StringFilter]?
        /// Provides a URL that links to a page about the current finding in the finding product. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var sourceUrl: [SecurityHubClientTypes.StringFilter]?
        /// A finding's title. Array Members: Minimum number of 1 item. Maximum number of 100 items.
        public var title: [SecurityHubClientTypes.StringFilter]?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. For a list of namespaces, classifiers, and categories, see [Types taxonomy for ASFF](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format-type-taxonomy.html) in the Security Hub User Guide. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var type: [SecurityHubClientTypes.StringFilter]?
        /// A timestamp that indicates when the finding record was most recently updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        ///
        ///
        /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var updatedAt: [SecurityHubClientTypes.DateFilter]?
        /// A list of user-defined name and value string pairs added to a finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var userDefinedFields: [SecurityHubClientTypes.MapFilter]?
        /// Provides the veracity of a finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var verificationState: [SecurityHubClientTypes.StringFilter]?
        /// Provides information about the status of the investigation into a finding. Array Members: Minimum number of 1 item. Maximum number of 20 items.
        public var workflowStatus: [SecurityHubClientTypes.StringFilter]?

        public init(
            awsAccountId: [SecurityHubClientTypes.StringFilter]? = nil,
            awsAccountName: [SecurityHubClientTypes.StringFilter]? = nil,
            companyName: [SecurityHubClientTypes.StringFilter]? = nil,
            complianceAssociatedStandardsId: [SecurityHubClientTypes.StringFilter]? = nil,
            complianceSecurityControlId: [SecurityHubClientTypes.StringFilter]? = nil,
            complianceStatus: [SecurityHubClientTypes.StringFilter]? = nil,
            confidence: [SecurityHubClientTypes.NumberFilter]? = nil,
            createdAt: [SecurityHubClientTypes.DateFilter]? = nil,
            criticality: [SecurityHubClientTypes.NumberFilter]? = nil,
            description: [SecurityHubClientTypes.StringFilter]? = nil,
            firstObservedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            generatorId: [SecurityHubClientTypes.StringFilter]? = nil,
            id: [SecurityHubClientTypes.StringFilter]? = nil,
            lastObservedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            noteText: [SecurityHubClientTypes.StringFilter]? = nil,
            noteUpdatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            noteUpdatedBy: [SecurityHubClientTypes.StringFilter]? = nil,
            productArn: [SecurityHubClientTypes.StringFilter]? = nil,
            productName: [SecurityHubClientTypes.StringFilter]? = nil,
            recordState: [SecurityHubClientTypes.StringFilter]? = nil,
            relatedFindingsId: [SecurityHubClientTypes.StringFilter]? = nil,
            relatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceApplicationArn: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceApplicationName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceDetailsOther: [SecurityHubClientTypes.MapFilter]? = nil,
            resourceId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourcePartition: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceRegion: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceTags: [SecurityHubClientTypes.MapFilter]? = nil,
            resourceType: [SecurityHubClientTypes.StringFilter]? = nil,
            severityLabel: [SecurityHubClientTypes.StringFilter]? = nil,
            sourceUrl: [SecurityHubClientTypes.StringFilter]? = nil,
            title: [SecurityHubClientTypes.StringFilter]? = nil,
            type: [SecurityHubClientTypes.StringFilter]? = nil,
            updatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            userDefinedFields: [SecurityHubClientTypes.MapFilter]? = nil,
            verificationState: [SecurityHubClientTypes.StringFilter]? = nil,
            workflowStatus: [SecurityHubClientTypes.StringFilter]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsAccountName = awsAccountName
            self.companyName = companyName
            self.complianceAssociatedStandardsId = complianceAssociatedStandardsId
            self.complianceSecurityControlId = complianceSecurityControlId
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.lastObservedAt = lastObservedAt
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.productArn = productArn
            self.productName = productName
            self.recordState = recordState
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceApplicationArn = resourceApplicationArn
            self.resourceApplicationName = resourceApplicationName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.severityLabel = severityLabel
            self.sourceUrl = sourceUrl
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflowStatus = workflowStatus
        }
    }

}

extension SecurityHubClientTypes {

    public enum RuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Defines the configuration of an automation rule.
    public struct AutomationRulesConfig {
        /// One or more actions to update finding fields if a finding matches the defined criteria of the rule.
        public var actions: [SecurityHubClientTypes.AutomationRulesAction]?
        /// A timestamp that indicates when the rule was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdAt: Foundation.Date?
        /// The principal that created a rule.
        public var createdBy: Swift.String?
        /// A set of [Amazon Web Services Security Finding Format](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format.html) finding field attributes and corresponding expected values that Security Hub uses to filter findings. If a rule is enabled and a finding matches the conditions specified in this parameter, Security Hub applies the rule action to the finding.
        public var criteria: SecurityHubClientTypes.AutomationRulesFindingFilters?
        /// A description of the rule.
        public var description: Swift.String?
        /// Specifies whether a rule is the last to be applied with respect to a finding that matches the rule criteria. This is useful when a finding matches the criteria for multiple rules, and each rule has different actions. If a rule is terminal, Security Hub applies the rule action to a finding that matches the rule criteria and doesn't evaluate other rules for the finding. By default, a rule isn't terminal.
        public var isTerminal: Swift.Bool?
        /// The Amazon Resource Name (ARN) of a rule.
        public var ruleArn: Swift.String?
        /// The name of the rule.
        public var ruleName: Swift.String?
        /// An integer ranging from 1 to 1000 that represents the order in which the rule action is applied to findings. Security Hub applies rules with lower values for this parameter first.
        public var ruleOrder: Swift.Int?
        /// Whether the rule is active after it is created. If this parameter is equal to ENABLED, Security Hub starts applying the rule to findings and finding updates after the rule is created.
        public var ruleStatus: SecurityHubClientTypes.RuleStatus?
        /// A timestamp that indicates when the rule was most recently updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var updatedAt: Foundation.Date?

        public init(
            actions: [SecurityHubClientTypes.AutomationRulesAction]? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            criteria: SecurityHubClientTypes.AutomationRulesFindingFilters? = nil,
            description: Swift.String? = nil,
            isTerminal: Swift.Bool? = nil,
            ruleArn: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            ruleOrder: Swift.Int? = nil,
            ruleStatus: SecurityHubClientTypes.RuleStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.actions = actions
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.criteria = criteria
            self.description = description
            self.isTerminal = isTerminal
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.ruleOrder = ruleOrder
            self.ruleStatus = ruleStatus
            self.updatedAt = updatedAt
        }
    }

}

extension SecurityHubClientTypes {
    /// Metadata for automation rules in the calling account. The response includes rules with a RuleStatus of ENABLED and DISABLED.
    public struct AutomationRulesMetadata {
        /// A timestamp that indicates when the rule was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdAt: Foundation.Date?
        /// The principal that created a rule.
        public var createdBy: Swift.String?
        /// A description of the rule.
        public var description: Swift.String?
        /// Specifies whether a rule is the last to be applied with respect to a finding that matches the rule criteria. This is useful when a finding matches the criteria for multiple rules, and each rule has different actions. If a rule is terminal, Security Hub applies the rule action to a finding that matches the rule criteria and doesn't evaluate other rules for the finding. By default, a rule isn't terminal.
        public var isTerminal: Swift.Bool?
        /// The Amazon Resource Name (ARN) for the rule.
        public var ruleArn: Swift.String?
        /// The name of the rule.
        public var ruleName: Swift.String?
        /// An integer ranging from 1 to 1000 that represents the order in which the rule action is applied to findings. Security Hub applies rules with lower values for this parameter first.
        public var ruleOrder: Swift.Int?
        /// Whether the rule is active after it is created. If this parameter is equal to ENABLED, Security Hub starts applying the rule to findings and finding updates after the rule is created. To change the value of this parameter after creating a rule, use [BatchUpdateAutomationRules](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateAutomationRules.html).
        public var ruleStatus: SecurityHubClientTypes.RuleStatus?
        /// A timestamp that indicates when the rule was most recently updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            isTerminal: Swift.Bool? = nil,
            ruleArn: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            ruleOrder: Swift.Int? = nil,
            ruleStatus: SecurityHubClientTypes.RuleStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.isTerminal = isTerminal
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.ruleOrder = ruleOrder
            self.ruleStatus = ruleStatus
            self.updatedAt = updatedAt
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an Availability Zone.
    public struct AvailabilityZone {
        /// The ID of the subnet. You can specify one subnet per Availability Zone.
        public var subnetId: Swift.String?
        /// The name of the Availability Zone.
        public var zoneName: Swift.String?

        public init(
            subnetId: Swift.String? = nil,
            zoneName: Swift.String? = nil
        )
        {
            self.subnetId = subnetId
            self.zoneName = zoneName
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about broker encryption options.
    public struct AwsAmazonMqBrokerEncryptionOptionsDetails {
        /// The KMS key that’s used to encrypt your data at rest. If not provided, Amazon MQ will use a default KMS key to encrypt your data.
        public var kmsKeyId: Swift.String?
        /// Specifies that an KMS key should be used for at-rest encryption. Set to true by default if no value is provided (for example, for RabbitMQ brokers).
        public var useAwsOwnedKey: Swift.Bool?

        public init(
            kmsKeyId: Swift.String? = nil,
            useAwsOwnedKey: Swift.Bool? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.useAwsOwnedKey = useAwsOwnedKey
        }
    }

}

extension SecurityHubClientTypes {
    /// The metadata of the Lightweight Directory Access Protocol (LDAP) server used to authenticate and authorize connections to the broker. This is an optional failover server.
    public struct AwsAmazonMqBrokerLdapServerMetadataDetails {
        /// Specifies the location of the LDAP server, such as Amazon Web Services Directory Service for Microsoft Active Directory.
        public var hosts: [Swift.String]?
        /// The distinguished name of the node in the directory information tree (DIT) to search for roles or groups.
        public var roleBase: Swift.String?
        /// The group name attribute in a role entry whose value is the name of that role.
        public var roleName: Swift.String?
        /// The LDAP search filter used to find roles within the roleBase.
        public var roleSearchMatching: Swift.String?
        /// The directory search scope for the role. If set to true, the scope is to search the entire subtree.
        public var roleSearchSubtree: Swift.Bool?
        /// A username for the service account, which is an account in your LDAP server that has access to initiate a connection.
        public var serviceAccountUsername: Swift.String?
        /// Selects a particular subtree of the directory information tree (DIT) to search for user entries.
        public var userBase: Swift.String?
        /// The name of the LDAP attribute in the user's directory entry for the user's group membership.
        public var userRoleName: Swift.String?
        /// The LDAP search filter used to find users within the userBase.
        public var userSearchMatching: Swift.String?
        /// The directory search scope for the user. If set to true, the scope is to search the entire subtree.
        public var userSearchSubtree: Swift.Bool?

        public init(
            hosts: [Swift.String]? = nil,
            roleBase: Swift.String? = nil,
            roleName: Swift.String? = nil,
            roleSearchMatching: Swift.String? = nil,
            roleSearchSubtree: Swift.Bool? = nil,
            serviceAccountUsername: Swift.String? = nil,
            userBase: Swift.String? = nil,
            userRoleName: Swift.String? = nil,
            userSearchMatching: Swift.String? = nil,
            userSearchSubtree: Swift.Bool? = nil
        )
        {
            self.hosts = hosts
            self.roleBase = roleBase
            self.roleName = roleName
            self.roleSearchMatching = roleSearchMatching
            self.roleSearchSubtree = roleSearchSubtree
            self.serviceAccountUsername = serviceAccountUsername
            self.userBase = userBase
            self.userRoleName = userRoleName
            self.userSearchMatching = userSearchMatching
            self.userSearchSubtree = userSearchSubtree
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about logs to be activated for the specified broker.
    public struct AwsAmazonMqBrokerLogsPendingDetails {
        /// Activates audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Doesn't apply to RabbitMQ brokers.
        public var audit: Swift.Bool?
        /// Activates general logging.
        public var general: Swift.Bool?

        public init(
            audit: Swift.Bool? = nil,
            general: Swift.Bool? = nil
        )
        {
            self.audit = audit
            self.general = general
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about logs to be activated for the specified broker.
    public struct AwsAmazonMqBrokerLogsDetails {
        /// Activates audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Doesn't apply to RabbitMQ brokers.
        public var audit: Swift.Bool?
        /// The location of the CloudWatch Logs log group where audit logs are sent.
        public var auditLogGroup: Swift.String?
        /// Activates general logging.
        public var general: Swift.Bool?
        /// The location of the CloudWatch Logs log group where general logs are sent.
        public var generalLogGroup: Swift.String?
        /// The list of information about logs that are to be turned on for the specified broker.
        public var pending: SecurityHubClientTypes.AwsAmazonMqBrokerLogsPendingDetails?

        public init(
            audit: Swift.Bool? = nil,
            auditLogGroup: Swift.String? = nil,
            general: Swift.Bool? = nil,
            generalLogGroup: Swift.String? = nil,
            pending: SecurityHubClientTypes.AwsAmazonMqBrokerLogsPendingDetails? = nil
        )
        {
            self.audit = audit
            self.auditLogGroup = auditLogGroup
            self.general = general
            self.generalLogGroup = generalLogGroup
            self.pending = pending
        }
    }

}

extension SecurityHubClientTypes {
    /// The scheduled time period (UTC) during which Amazon MQ begins to apply pending updates or patches to the broker.
    public struct AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails {
        /// The day of the week on which the maintenance window falls.
        public var dayOfWeek: Swift.String?
        /// The time, in 24-hour format, on which the maintenance window falls.
        public var timeOfDay: Swift.String?
        /// The time zone in either the Country/City format or the UTC offset format. UTC is the default format.
        public var timeZone: Swift.String?

        public init(
            dayOfWeek: Swift.String? = nil,
            timeOfDay: Swift.String? = nil,
            timeZone: Swift.String? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
            self.timeOfDay = timeOfDay
            self.timeZone = timeZone
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the broker usernames for the specified broker. Doesn't apply to RabbitMQ brokers.
    public struct AwsAmazonMqBrokerUsersDetails {
        /// The type of change pending for the broker user.
        public var pendingChange: Swift.String?
        /// The username of the broker user.
        public var username: Swift.String?

        public init(
            pendingChange: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.pendingChange = pendingChange
            self.username = username
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon MQ message broker. A message broker allows software applications and components to communicate using various programming languages, operating systems, and formal messaging protocols.
    public struct AwsAmazonMqBrokerDetails {
        /// The authentication strategy used to secure the broker. The default is SIMPLE.
        public var authenticationStrategy: Swift.String?
        /// Whether automatically upgrade new minor versions for brokers, as new versions are released and supported by Amazon MQ. Automatic upgrades occur during the scheduled maintenance window of the broker or after a manual broker reboot.
        public var autoMinorVersionUpgrade: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the broker.
        public var brokerArn: Swift.String?
        /// The unique ID that Amazon MQ generates for the broker.
        public var brokerId: Swift.String?
        /// The broker's name.
        public var brokerName: Swift.String?
        /// The broker's deployment mode.
        public var deploymentMode: Swift.String?
        /// Encryption options for the broker. Doesn’t apply to RabbitMQ brokers.
        public var encryptionOptions: SecurityHubClientTypes.AwsAmazonMqBrokerEncryptionOptionsDetails?
        /// The type of broker engine.
        public var engineType: Swift.String?
        /// The version of the broker engine.
        public var engineVersion: Swift.String?
        /// The broker's instance type.
        public var hostInstanceType: Swift.String?
        /// The metadata of the Lightweight Directory Access Protocol (LDAP) server used to authenticate and authorize connections to the broker. This is an optional failover server.
        public var ldapServerMetadata: SecurityHubClientTypes.AwsAmazonMqBrokerLdapServerMetadataDetails?
        /// Turns on Amazon CloudWatch logging for brokers.
        public var logs: SecurityHubClientTypes.AwsAmazonMqBrokerLogsDetails?
        /// The scheduled time period (UTC) during which Amazon MQ begins to apply pending updates or patches to the broker.
        public var maintenanceWindowStartTime: SecurityHubClientTypes.AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails?
        /// Permits connections from applications outside of the VPC that hosts the broker's subnets.
        public var publiclyAccessible: Swift.Bool?
        /// The list of rules (one minimum, 125 maximum) that authorize connections to brokers.
        public var securityGroups: [Swift.String]?
        /// The broker's storage type.
        public var storageType: Swift.String?
        /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones.
        public var subnetIds: [Swift.String]?
        /// The list of all broker usernames for the specified broker. Doesn't apply to RabbitMQ brokers.
        public var users: [SecurityHubClientTypes.AwsAmazonMqBrokerUsersDetails]?

        public init(
            authenticationStrategy: Swift.String? = nil,
            autoMinorVersionUpgrade: Swift.Bool? = nil,
            brokerArn: Swift.String? = nil,
            brokerId: Swift.String? = nil,
            brokerName: Swift.String? = nil,
            deploymentMode: Swift.String? = nil,
            encryptionOptions: SecurityHubClientTypes.AwsAmazonMqBrokerEncryptionOptionsDetails? = nil,
            engineType: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            hostInstanceType: Swift.String? = nil,
            ldapServerMetadata: SecurityHubClientTypes.AwsAmazonMqBrokerLdapServerMetadataDetails? = nil,
            logs: SecurityHubClientTypes.AwsAmazonMqBrokerLogsDetails? = nil,
            maintenanceWindowStartTime: SecurityHubClientTypes.AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            securityGroups: [Swift.String]? = nil,
            storageType: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            users: [SecurityHubClientTypes.AwsAmazonMqBrokerUsersDetails]? = nil
        )
        {
            self.authenticationStrategy = authenticationStrategy
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.brokerArn = brokerArn
            self.brokerId = brokerId
            self.brokerName = brokerName
            self.deploymentMode = deploymentMode
            self.encryptionOptions = encryptionOptions
            self.engineType = engineType
            self.engineVersion = engineVersion
            self.hostInstanceType = hostInstanceType
            self.ldapServerMetadata = ldapServerMetadata
            self.logs = logs
            self.maintenanceWindowStartTime = maintenanceWindowStartTime
            self.publiclyAccessible = publiclyAccessible
            self.securityGroups = securityGroups
            self.storageType = storageType
            self.subnetIds = subnetIds
            self.users = users
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about settings for logging access for the stage.
    public struct AwsApiGatewayAccessLogSettings {
        /// The ARN of the CloudWatch Logs log group that receives the access logs.
        public var destinationArn: Swift.String?
        /// A single-line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public var format: Swift.String?

        public init(
            destinationArn: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.format = format
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about settings for canary deployment in the stage.
    public struct AwsApiGatewayCanarySettings {
        /// The deployment identifier for the canary deployment.
        public var deploymentId: Swift.String?
        /// The percentage of traffic that is diverted to a canary deployment.
        public var percentTraffic: Swift.Double?
        /// Stage variables that are overridden in the canary release deployment. The variables include new stage variables that are introduced in the canary. Each variable is represented as a string-to-string map between the stage variable name and the variable value.
        public var stageVariableOverrides: [Swift.String: Swift.String]?
        /// Indicates whether the canary deployment uses the stage cache.
        public var useStageCache: Swift.Bool?

        public init(
            deploymentId: Swift.String? = nil,
            percentTraffic: Swift.Double? = nil,
            stageVariableOverrides: [Swift.String: Swift.String]? = nil,
            useStageCache: Swift.Bool? = nil
        )
        {
            self.deploymentId = deploymentId
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the endpoints for the API.
    public struct AwsApiGatewayEndpointConfiguration {
        /// A list of endpoint types for the REST API. For an edge-optimized API, the endpoint type is EDGE. For a Regional API, the endpoint type is REGIONAL. For a private API, the endpoint type is PRIVATE.
        public var types: [Swift.String]?

        public init(
            types: [Swift.String]? = nil
        )
        {
            self.types = types
        }
    }

}

extension SecurityHubClientTypes {
    /// Defines settings for a method for the stage.
    public struct AwsApiGatewayMethodSettings {
        /// Indicates whether the cached responses are encrypted.
        public var cacheDataEncrypted: Swift.Bool?
        /// Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.
        public var cacheTtlInSeconds: Swift.Int?
        /// Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.
        public var cachingEnabled: Swift.Bool?
        /// Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.
        public var dataTraceEnabled: Swift.Bool?
        /// The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
        public var httpMethod: Swift.String?
        /// The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs. If the logging level is ERROR, then the logs only include error-level entries. If the logging level is INFO, then the logs include both ERROR events and extra informational events. Valid values: OFF | ERROR | INFO
        public var loggingLevel: Swift.String?
        /// Indicates whether CloudWatch metrics are enabled for the method.
        public var metricsEnabled: Swift.Bool?
        /// Indicates whether authorization is required for a cache invalidation request.
        public var requireAuthorizationForCacheControl: Swift.Bool?
        /// The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash. For example, the path value /resource/subresource must be encoded as /~1resource~1subresource. To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
        public var resourcePath: Swift.String?
        /// The throttling burst limit for the method.
        public var throttlingBurstLimit: Swift.Int?
        /// The throttling rate limit for the method.
        public var throttlingRateLimit: Swift.Double?
        /// Indicates how to handle unauthorized requests for cache invalidation. Valid values: FAIL_WITH_403 | SUCCEED_WITH_RESPONSE_HEADER | SUCCEED_WITHOUT_RESPONSE_HEADER
        public var unauthorizedCacheControlHeaderStrategy: Swift.String?

        public init(
            cacheDataEncrypted: Swift.Bool? = nil,
            cacheTtlInSeconds: Swift.Int? = nil,
            cachingEnabled: Swift.Bool? = nil,
            dataTraceEnabled: Swift.Bool? = nil,
            httpMethod: Swift.String? = nil,
            loggingLevel: Swift.String? = nil,
            metricsEnabled: Swift.Bool? = nil,
            requireAuthorizationForCacheControl: Swift.Bool? = nil,
            resourcePath: Swift.String? = nil,
            throttlingBurstLimit: Swift.Int? = nil,
            throttlingRateLimit: Swift.Double? = nil,
            unauthorizedCacheControlHeaderStrategy: Swift.String? = nil
        )
        {
            self.cacheDataEncrypted = cacheDataEncrypted
            self.cacheTtlInSeconds = cacheTtlInSeconds
            self.cachingEnabled = cachingEnabled
            self.dataTraceEnabled = dataTraceEnabled
            self.httpMethod = httpMethod
            self.loggingLevel = loggingLevel
            self.metricsEnabled = metricsEnabled
            self.requireAuthorizationForCacheControl = requireAuthorizationForCacheControl
            self.resourcePath = resourcePath
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
            self.unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about a REST API in version 1 of Amazon API Gateway.
    public struct AwsApiGatewayRestApiDetails {
        /// The source of the API key for metering requests according to a usage plan. HEADER indicates whether to read the API key from the X-API-Key header of a request. AUTHORIZER indicates whether to read the API key from the UsageIdentifierKey from a custom authorizer.
        public var apiKeySource: Swift.String?
        /// The list of binary media types supported by the REST API.
        public var binaryMediaTypes: [Swift.String]?
        /// Indicates when the API was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdDate: Swift.String?
        /// A description of the REST API.
        public var description: Swift.String?
        /// The endpoint configuration of the REST API.
        public var endpointConfiguration: SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration?
        /// The identifier of the REST API.
        public var id: Swift.String?
        /// The minimum size in bytes of a payload before compression is enabled. If null, then compression is disabled. If 0, then all payloads are compressed.
        public var minimumCompressionSize: Swift.Int?
        /// The name of the REST API.
        public var name: Swift.String?
        /// The version identifier for the REST API.
        public var version: Swift.String?

        public init(
            apiKeySource: Swift.String? = nil,
            binaryMediaTypes: [Swift.String]? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            endpointConfiguration: SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration? = nil,
            id: Swift.String? = nil,
            minimumCompressionSize: Swift.Int? = nil,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.apiKeySource = apiKeySource
            self.binaryMediaTypes = binaryMediaTypes
            self.createdDate = createdDate
            self.description = description
            self.endpointConfiguration = endpointConfiguration
            self.id = id
            self.minimumCompressionSize = minimumCompressionSize
            self.name = name
            self.version = version
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about a version 1 Amazon API Gateway stage.
    public struct AwsApiGatewayStageDetails {
        /// Settings for logging access for the stage.
        public var accessLogSettings: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings?
        /// Indicates whether a cache cluster is enabled for the stage.
        public var cacheClusterEnabled: Swift.Bool?
        /// If a cache cluster is enabled, the size of the cache cluster.
        public var cacheClusterSize: Swift.String?
        /// If a cache cluster is enabled, the status of the cache cluster.
        public var cacheClusterStatus: Swift.String?
        /// Information about settings for canary deployment in the stage.
        public var canarySettings: SecurityHubClientTypes.AwsApiGatewayCanarySettings?
        /// The identifier of the client certificate for the stage.
        public var clientCertificateId: Swift.String?
        /// Indicates when the stage was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdDate: Swift.String?
        /// The identifier of the deployment that the stage points to.
        public var deploymentId: Swift.String?
        /// A description of the stage.
        public var description: Swift.String?
        /// The version of the API documentation that is associated with the stage.
        public var documentationVersion: Swift.String?
        /// Indicates when the stage was most recently updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastUpdatedDate: Swift.String?
        /// Defines the method settings for the stage.
        public var methodSettings: [SecurityHubClientTypes.AwsApiGatewayMethodSettings]?
        /// The name of the stage.
        public var stageName: Swift.String?
        /// Indicates whether active tracing with X-Ray is enabled for the stage.
        public var tracingEnabled: Swift.Bool?
        /// A map that defines the stage variables for the stage. Variable names can have alphanumeric and underscore characters. Variable values can contain the following characters:
        ///
        /// * Uppercase and lowercase letters
        ///
        /// * Numbers
        ///
        /// * Special characters -._~:/?#&=,
        public var variables: [Swift.String: Swift.String]?
        /// The ARN of the web ACL associated with the stage.
        public var webAclArn: Swift.String?

        public init(
            accessLogSettings: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings? = nil,
            cacheClusterEnabled: Swift.Bool? = nil,
            cacheClusterSize: Swift.String? = nil,
            cacheClusterStatus: Swift.String? = nil,
            canarySettings: SecurityHubClientTypes.AwsApiGatewayCanarySettings? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            documentationVersion: Swift.String? = nil,
            lastUpdatedDate: Swift.String? = nil,
            methodSettings: [SecurityHubClientTypes.AwsApiGatewayMethodSettings]? = nil,
            stageName: Swift.String? = nil,
            tracingEnabled: Swift.Bool? = nil,
            variables: [Swift.String: Swift.String]? = nil,
            webAclArn: Swift.String? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.cacheClusterEnabled = cacheClusterEnabled
            self.cacheClusterSize = cacheClusterSize
            self.cacheClusterStatus = cacheClusterStatus
            self.canarySettings = canarySettings
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.description = description
            self.documentationVersion = documentationVersion
            self.lastUpdatedDate = lastUpdatedDate
            self.methodSettings = methodSettings
            self.stageName = stageName
            self.tracingEnabled = tracingEnabled
            self.variables = variables
            self.webAclArn = webAclArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains the cross-origin resource sharing (CORS) configuration for the API. CORS is only supported for HTTP APIs.
    public struct AwsCorsConfiguration {
        /// Indicates whether the CORS request includes credentials.
        public var allowCredentials: Swift.Bool?
        /// The allowed headers for CORS requests.
        public var allowHeaders: [Swift.String]?
        /// The allowed methods for CORS requests.
        public var allowMethods: [Swift.String]?
        /// The allowed origins for CORS requests.
        public var allowOrigins: [Swift.String]?
        /// The exposed headers for CORS requests.
        public var exposeHeaders: [Swift.String]?
        /// The number of seconds for which the browser caches preflight request results.
        public var maxAge: Swift.Int?

        public init(
            allowCredentials: Swift.Bool? = nil,
            allowHeaders: [Swift.String]? = nil,
            allowMethods: [Swift.String]? = nil,
            allowOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAge: Swift.Int? = nil
        )
        {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about a version 2 API in Amazon API Gateway.
    public struct AwsApiGatewayV2ApiDetails {
        /// The URI of the API. Uses the format  .execute-api..amazonaws.com The stage name is typically appended to the URI to form a complete path to a deployed API stage.
        public var apiEndpoint: Swift.String?
        /// The identifier of the API.
        public var apiId: Swift.String?
        /// An API key selection expression. Supported only for WebSocket APIs.
        public var apiKeySelectionExpression: Swift.String?
        /// A cross-origin resource sharing (CORS) configuration. Supported only for HTTP APIs.
        public var corsConfiguration: SecurityHubClientTypes.AwsCorsConfiguration?
        /// Indicates when the API was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdDate: Swift.String?
        /// A description of the API.
        public var description: Swift.String?
        /// The name of the API.
        public var name: Swift.String?
        /// The API protocol for the API. Valid values: WEBSOCKET | HTTP
        public var protocolType: Swift.String?
        /// The route selection expression for the API. For HTTP APIs, must be ${request.method} ${request.path}. This is the default value for HTTP APIs. For WebSocket APIs, there is no default value.
        public var routeSelectionExpression: Swift.String?
        /// The version identifier for the API.
        public var version: Swift.String?

        public init(
            apiEndpoint: Swift.String? = nil,
            apiId: Swift.String? = nil,
            apiKeySelectionExpression: Swift.String? = nil,
            corsConfiguration: SecurityHubClientTypes.AwsCorsConfiguration? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            protocolType: Swift.String? = nil,
            routeSelectionExpression: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.apiEndpoint = apiEndpoint
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.version = version
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains route settings for a stage.
    public struct AwsApiGatewayV2RouteSettings {
        /// Indicates whether data trace logging is enabled. Data trace logging affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.
        public var dataTraceEnabled: Swift.Bool?
        /// Indicates whether detailed metrics are enabled.
        public var detailedMetricsEnabled: Swift.Bool?
        /// The logging level. The logging level affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs. If the logging level is ERROR, then the logs only include error-level entries. If the logging level is INFO, then the logs include both ERROR events and extra informational events. Valid values: OFF | ERROR | INFO
        public var loggingLevel: Swift.String?
        /// The throttling burst limit.
        public var throttlingBurstLimit: Swift.Int?
        /// The throttling rate limit.
        public var throttlingRateLimit: Swift.Double?

        public init(
            dataTraceEnabled: Swift.Bool? = nil,
            detailedMetricsEnabled: Swift.Bool? = nil,
            loggingLevel: Swift.String? = nil,
            throttlingBurstLimit: Swift.Int? = nil,
            throttlingRateLimit: Swift.Double? = nil
        )
        {
            self.dataTraceEnabled = dataTraceEnabled
            self.detailedMetricsEnabled = detailedMetricsEnabled
            self.loggingLevel = loggingLevel
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about a version 2 stage for Amazon API Gateway.
    public struct AwsApiGatewayV2StageDetails {
        /// Information about settings for logging access for the stage.
        public var accessLogSettings: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings?
        /// Indicates whether the stage is managed by API Gateway.
        public var apiGatewayManaged: Swift.Bool?
        /// Indicates whether updates to an API automatically trigger a new deployment.
        public var autoDeploy: Swift.Bool?
        /// The identifier of a client certificate for a stage. Supported only for WebSocket API calls.
        public var clientCertificateId: Swift.String?
        /// Indicates when the stage was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdDate: Swift.String?
        /// Default route settings for the stage.
        public var defaultRouteSettings: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings?
        /// The identifier of the deployment that the stage is associated with.
        public var deploymentId: Swift.String?
        /// The description of the stage.
        public var description: Swift.String?
        /// The status of the last deployment of a stage. Supported only if the stage has automatic deployment enabled.
        public var lastDeploymentStatusMessage: Swift.String?
        /// Indicates when the stage was most recently updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastUpdatedDate: Swift.String?
        /// The route settings for the stage.
        public var routeSettings: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings?
        /// The name of the stage.
        public var stageName: Swift.String?
        /// A map that defines the stage variables for the stage. Variable names can have alphanumeric and underscore characters. Variable values can contain the following characters:
        ///
        /// * Uppercase and lowercase letters
        ///
        /// * Numbers
        ///
        /// * Special characters -._~:/?#&=,
        public var stageVariables: [Swift.String: Swift.String]?

        public init(
            accessLogSettings: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings? = nil,
            apiGatewayManaged: Swift.Bool? = nil,
            autoDeploy: Swift.Bool? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: Swift.String? = nil,
            defaultRouteSettings: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            lastDeploymentStatusMessage: Swift.String? = nil,
            lastUpdatedDate: Swift.String? = nil,
            routeSettings: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings? = nil,
            stageName: Swift.String? = nil,
            stageVariables: [Swift.String: Swift.String]? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the authorization configuration for using an Lambda function with your AppSync GraphQL API endpoint.
    public struct AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails {
        /// The number of seconds a response should be cached for. The default is 5 minutes (300 seconds).
        public var authorizerResultTtlInSeconds: Swift.Int?
        /// The Amazon Resource Name (ARN) of the Lambda function to be called for authorization. This can be a standard Lambda ARN, a version ARN (.../v3), or an alias ARN.
        public var authorizerUri: Swift.String?
        /// A regular expression for validation of tokens before the Lambda function is called.
        public var identityValidationExpression: Swift.String?

        public init(
            authorizerResultTtlInSeconds: Swift.Int? = nil,
            authorizerUri: Swift.String? = nil,
            identityValidationExpression: Swift.String? = nil
        )
        {
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.identityValidationExpression = identityValidationExpression
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the authorization configuration for using an OpenID Connect compliant service with your AppSync GraphQL API endpoint.
    public struct AwsAppSyncGraphQlApiOpenIdConnectConfigDetails {
        /// The number of milliseconds that a token is valid after being authenticated.
        public var authTtL: Swift.Int?
        /// The client identifier of the relying party at the OpenID identity provider. This identifier is typically obtained when the relying party is registered with the OpenID identity provider. You can specify a regular expression so that AppSync can validate against multiple client identifiers at a time.
        public var clientId: Swift.String?
        /// The number of milliseconds that a token is valid after it's issued to a user.
        public var iatTtL: Swift.Int?
        /// The issuer for the OIDC configuration. The issuer returned by discovery must exactly match the value of iss in the ID token.
        public var issuer: Swift.String?

        public init(
            authTtL: Swift.Int? = nil,
            clientId: Swift.String? = nil,
            iatTtL: Swift.Int? = nil,
            issuer: Swift.String? = nil
        )
        {
            self.authTtL = authTtL
            self.clientId = clientId
            self.iatTtL = iatTtL
            self.issuer = issuer
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the authorization configuration for using Amazon Cognito user pools with your AppSync GraphQL API endpoint.
    public struct AwsAppSyncGraphQlApiUserPoolConfigDetails {
        /// A regular expression for validating the incoming Amazon Cognito user pools app client ID. If this value isn't set, no filtering is applied.
        public var appIdClientRegex: Swift.String?
        /// The Amazon Web Services Region in which the user pool was created.
        public var awsRegion: Swift.String?
        /// The action that you want your GraphQL API to take when a request that uses Amazon Cognito user pools authentication doesn't match the Amazon Cognito user pools configuration.
        public var defaultAction: Swift.String?
        /// The user pool ID.
        public var userPoolId: Swift.String?

        public init(
            appIdClientRegex: Swift.String? = nil,
            awsRegion: Swift.String? = nil,
            defaultAction: Swift.String? = nil,
            userPoolId: Swift.String? = nil
        )
        {
            self.appIdClientRegex = appIdClientRegex
            self.awsRegion = awsRegion
            self.defaultAction = defaultAction
            self.userPoolId = userPoolId
        }
    }

}

extension SecurityHubClientTypes {
    /// A list of additional authentication providers for the GraphqlApi API.
    public struct AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails {
        /// The type of security configuration for your GraphQL API: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
        public var authenticationType: Swift.String?
        /// The configuration for Lambda function authorization.
        public var lambdaAuthorizerConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails?
        /// The OpenID Connect configuration.
        public var openIdConnectConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails?
        /// The Amazon Cognito user pools configuration.
        public var userPoolConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails?

        public init(
            authenticationType: Swift.String? = nil,
            lambdaAuthorizerConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails? = nil,
            openIdConnectConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails? = nil,
            userPoolConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails? = nil
        )
        {
            self.authenticationType = authenticationType
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.openIdConnectConfig = openIdConnectConfig
            self.userPoolConfig = userPoolConfig
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the logging configuration when writing GraphQL operations and tracing to Amazon CloudWatch for an AppSync GraphQL API.
    public struct AwsAppSyncGraphQlApiLogConfigDetails {
        /// The Amazon Resource Name (ARN) of the service role that AppSync assumes to publish to CloudWatch Logs in your account.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging level.
        public var excludeVerboseContent: Swift.Bool?
        /// The field logging level.
        public var fieldLogLevel: Swift.String?

        public init(
            cloudWatchLogsRoleArn: Swift.String? = nil,
            excludeVerboseContent: Swift.Bool? = nil,
            fieldLogLevel: Swift.String? = nil
        )
        {
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.excludeVerboseContent = excludeVerboseContent
            self.fieldLogLevel = fieldLogLevel
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an AppSync Graph QL API, which lets you query multiple databases, microservices, and APIs from a single GraphQL endpoint.
    public struct AwsAppSyncGraphQlApiDetails {
        /// A list of additional authentication providers for the GraphQL API.
        public var additionalAuthenticationProviders: [SecurityHubClientTypes.AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails]?
        /// The unique identifier for the API.
        public var apiId: Swift.String?
        /// The Amazon Resource Name (ARN) of the API.
        public var arn: Swift.String?
        /// The type of security configuration for your GraphQL API: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
        public var authenticationType: Swift.String?
        /// The unique identifier for the API.
        public var id: Swift.String?
        /// Specifies the configuration for Lambda function authorization.
        public var lambdaAuthorizerConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails?
        /// The Amazon CloudWatch Logs configuration.
        public var logConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiLogConfigDetails?
        /// The API name.
        public var name: Swift.String?
        /// Specifies the authorization configuration for using an OpenID Connect compliant service with an AppSync GraphQL API endpoint.
        public var openIdConnectConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails?
        /// The Amazon Cognito user pools configuration.
        public var userPoolConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails?
        /// The Amazon Resource Name (ARN) of the WAF web access control list (web ACL) associated with this GraphQL API, if one exists.
        public var wafWebAclArn: Swift.String?
        /// Indicates whether to use X-Ray tracing for the GraphQL API.
        public var xrayEnabled: Swift.Bool?

        public init(
            additionalAuthenticationProviders: [SecurityHubClientTypes.AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails]? = nil,
            apiId: Swift.String? = nil,
            arn: Swift.String? = nil,
            authenticationType: Swift.String? = nil,
            id: Swift.String? = nil,
            lambdaAuthorizerConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails? = nil,
            logConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiLogConfigDetails? = nil,
            name: Swift.String? = nil,
            openIdConnectConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails? = nil,
            userPoolConfig: SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails? = nil,
            wafWebAclArn: Swift.String? = nil,
            xrayEnabled: Swift.Bool? = nil
        )
        {
            self.additionalAuthenticationProviders = additionalAuthenticationProviders
            self.apiId = apiId
            self.arn = arn
            self.authenticationType = authenticationType
            self.id = id
            self.lambdaAuthorizerConfig = lambdaAuthorizerConfig
            self.logConfig = logConfig
            self.name = name
            self.openIdConnectConfig = openIdConnectConfig
            self.userPoolConfig = userPoolConfig
            self.wafWebAclArn = wafWebAclArn
            self.xrayEnabled = xrayEnabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the method used to encrypt the user’s data stores in the Athena workgroup.
    public struct AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails {
        /// Indicates whether Amazon Simple Storage Service (Amazon S3) server-side encryption with Amazon S3 managed keys (SSE_S3), server-side encryption with KMS keys (SSE_KMS), or client-side encryption with KMS customer managed keys (CSE_KMS) is used.
        public var encryptionOption: Swift.String?
        /// For SSE_KMS and CSE_KMS, this is the KMS key Amazon Resource Name (ARN) or ID.
        public var kmsKey: Swift.String?

        public init(
            encryptionOption: Swift.String? = nil,
            kmsKey: Swift.String? = nil
        )
        {
            self.encryptionOption = encryptionOption
            self.kmsKey = kmsKey
        }
    }

}

extension SecurityHubClientTypes {
    /// The location in Amazon Simple Storage Service (Amazon S3) where query and calculation results are stored and the encryption option, if any, used for query and calculation results. These are known as client-side settings. If workgroup settings override client-side settings, then the query uses the workgroup settings.
    public struct AwsAthenaWorkGroupConfigurationResultConfigurationDetails {
        /// Specifies the method used to encrypt the user’s data stores in the Athena workgroup.
        public var encryptionConfiguration: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails?

        public init(
            encryptionConfiguration: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails? = nil
        )
        {
            self.encryptionConfiguration = encryptionConfiguration
        }
    }

}

extension SecurityHubClientTypes {
    /// The configuration of the workgroup, which includes the location in Amazon Simple Storage Service (Amazon S3) where query results are stored, the encryption option, if any, used for query results, whether Amazon CloudWatch metrics are enabled for the workgroup, and the limit for the amount of bytes scanned (cutoff) per query, if it is specified.
    public struct AwsAthenaWorkGroupConfigurationDetails {
        /// The location in Amazon S3 where query and calculation results are stored and the encryption option, if any, used for query and calculation results. These are known as client-side settings. If workgroup settings override client-side settings, then the query uses the workgroup settings.
        public var resultConfiguration: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationDetails?

        public init(
            resultConfiguration: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationDetails? = nil
        )
        {
            self.resultConfiguration = resultConfiguration
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon Athena workgroup.
    public struct AwsAthenaWorkGroupDetails {
        /// The configuration of the workgroup, which includes the location in Amazon Simple Storage Service (Amazon S3) where query results are stored, the encryption option, if any, used for query results, whether Amazon CloudWatch metrics are enabled for the workgroup, and the limit for the amount of bytes scanned (cutoff) per query, if it is specified.
        public var configuration: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationDetails?
        /// The workgroup description.
        public var description: Swift.String?
        /// The workgroup name.
        public var name: Swift.String?
        /// Whether the workgroup is enabled or disabled.
        public var state: Swift.String?

        public init(
            configuration: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationDetails? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.description = description
            self.name = name
            self.state = state
        }
    }

}

extension SecurityHubClientTypes {
    /// An Availability Zone for the automatic scaling group.
    public struct AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {
        /// The name of the Availability Zone.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the launch template to use.
    public struct AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification {
        /// The identifier of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public var launchTemplateId: Swift.String?
        /// The name of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public var launchTemplateName: Swift.String?
        /// Identifies the version of the launch template. You can specify a version identifier, or use the values $Latest or $Default.
        public var version: Swift.String?

        public init(
            launchTemplateId: Swift.String? = nil,
            launchTemplateName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.version = version
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the instances distribution.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails {
        /// How to allocate instance types to fulfill On-Demand capacity. The valid value is prioritized.
        public var onDemandAllocationStrategy: Swift.String?
        /// The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances.
        public var onDemandBaseCapacity: Swift.Int?
        /// The percentage of On-Demand Instances and Spot Instances for additional capacity beyond OnDemandBaseCapacity.
        public var onDemandPercentageAboveBaseCapacity: Swift.Int?
        /// How to allocate instances across Spot Instance pools. Valid values are as follows:
        ///
        /// * lowest-price
        ///
        /// * capacity-optimized
        ///
        /// * capacity-optimized-prioritized
        public var spotAllocationStrategy: Swift.String?
        /// The number of Spot Instance pools across which to allocate your Spot Instances.
        public var spotInstancePools: Swift.Int?
        /// The maximum price per unit hour that you are willing to pay for a Spot Instance.
        public var spotMaxPrice: Swift.String?

        public init(
            onDemandAllocationStrategy: Swift.String? = nil,
            onDemandBaseCapacity: Swift.Int? = nil,
            onDemandPercentageAboveBaseCapacity: Swift.Int? = nil,
            spotAllocationStrategy: Swift.String? = nil,
            spotInstancePools: Swift.Int? = nil,
            spotMaxPrice: Swift.String? = nil
        )
        {
            self.onDemandAllocationStrategy = onDemandAllocationStrategy
            self.onDemandBaseCapacity = onDemandBaseCapacity
            self.onDemandPercentageAboveBaseCapacity = onDemandPercentageAboveBaseCapacity
            self.spotAllocationStrategy = spotAllocationStrategy
            self.spotInstancePools = spotInstancePools
            self.spotMaxPrice = spotMaxPrice
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the launch template to use for a mixed instances policy.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
        /// The identifier of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public var launchTemplateId: Swift.String?
        /// The name of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public var launchTemplateName: Swift.String?
        /// Identifies the version of the launch template. You can specify a version identifier, or use the values $Latest or $Default.
        public var version: Swift.String?

        public init(
            launchTemplateId: Swift.String? = nil,
            launchTemplateName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.version = version
        }
    }

}

extension SecurityHubClientTypes {
    /// Property values to use to override the values in the launch template.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails {
        /// The instance type. For example, m3.xlarge.
        public var instanceType: Swift.String?
        /// The number of capacity units provided by the specified instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic.
        public var weightedCapacity: Swift.String?

        public init(
            instanceType: Swift.String? = nil,
            weightedCapacity: Swift.String? = nil
        )
        {
            self.instanceType = instanceType
            self.weightedCapacity = weightedCapacity
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes a launch template and overrides for a mixed instances policy.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails {
        /// The launch template to use for a mixed instances policy.
        public var launchTemplateSpecification: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification?
        /// Property values to use to override the values in the launch template.
        public var overrides: [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]?

        public init(
            launchTemplateSpecification: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification? = nil,
            overrides: [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]? = nil
        )
        {
            self.launchTemplateSpecification = launchTemplateSpecification
            self.overrides = overrides
        }
    }

}

extension SecurityHubClientTypes {
    /// The mixed instances policy for the automatic scaling group.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails {
        /// The instances distribution. The instances distribution specifies the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances, and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacity.
        public var instancesDistribution: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails?
        /// The launch template to use and the instance types (overrides) to use to provision EC2 instances to fulfill On-Demand and Spot capacities.
        public var launchTemplate: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails?

        public init(
            instancesDistribution: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails? = nil,
            launchTemplate: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails? = nil
        )
        {
            self.instancesDistribution = instancesDistribution
            self.launchTemplate = launchTemplate
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an auto scaling group.
    public struct AwsAutoScalingAutoScalingGroupDetails {
        /// The list of Availability Zones for the automatic scaling group.
        public var availabilityZones: [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]?
        /// Indicates whether capacity rebalancing is enabled.
        public var capacityRebalance: Swift.Bool?
        /// Indicates when the auto scaling group was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdTime: Swift.String?
        /// The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it checks the health status of an EC2 instance that has come into service.
        public var healthCheckGracePeriod: Swift.Int?
        /// The service to use for the health checks. Valid values are EC2 or ELB.
        public var healthCheckType: Swift.String?
        /// The name of the launch configuration.
        public var launchConfigurationName: Swift.String?
        /// The launch template to use.
        public var launchTemplate: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification?
        /// The list of load balancers associated with the group.
        public var loadBalancerNames: [Swift.String]?
        /// The mixed instances policy for the automatic scaling group.
        public var mixedInstancesPolicy: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails?

        public init(
            availabilityZones: [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]? = nil,
            capacityRebalance: Swift.Bool? = nil,
            createdTime: Swift.String? = nil,
            healthCheckGracePeriod: Swift.Int? = nil,
            healthCheckType: Swift.String? = nil,
            launchConfigurationName: Swift.String? = nil,
            launchTemplate: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification? = nil,
            loadBalancerNames: [Swift.String]? = nil,
            mixedInstancesPolicy: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.capacityRebalance = capacityRebalance
            self.createdTime = createdTime
            self.healthCheckGracePeriod = healthCheckGracePeriod
            self.healthCheckType = healthCheckType
            self.launchConfigurationName = launchConfigurationName
            self.launchTemplate = launchTemplate
            self.loadBalancerNames = loadBalancerNames
            self.mixedInstancesPolicy = mixedInstancesPolicy
        }
    }

}

extension SecurityHubClientTypes {
    /// Parameters that are used to automatically set up EBS volumes when an instance is launched.
    public struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {
        /// Whether to delete the volume when the instance is terminated.
        public var deleteOnTermination: Swift.Bool?
        /// Whether to encrypt the volume.
        public var encrypted: Swift.Bool?
        /// The number of input/output (I/O) operations per second (IOPS) to provision for the volume. Only supported for gp3 or io1 volumes. Required for io1 volumes. Not used with standard, gp2, st1, or sc1 volumes.
        public var iops: Swift.Int?
        /// The snapshot ID of the volume to use. You must specify either VolumeSize or SnapshotId.
        public var snapshotId: Swift.String?
        /// The volume size, in GiBs. The following are the supported volumes sizes for each volume type:
        ///
        /// * gp2 and gp3: 1-16,384
        ///
        /// * io1: 4-16,384
        ///
        /// * st1 and sc1: 125-16,384
        ///
        /// * standard: 1-1,024
        ///
        ///
        /// You must specify either SnapshotId or VolumeSize. If you specify both SnapshotId and VolumeSize, the volume size must be equal or greater than the size of the snapshot.
        public var volumeSize: Swift.Int?
        /// The volume type. Valid values are as follows:
        ///
        /// * gp2
        ///
        /// * gp3
        ///
        /// * io1
        ///
        /// * sc1
        ///
        /// * st1
        ///
        /// * standard
        public var volumeType: Swift.String?

        public init(
            deleteOnTermination: Swift.Bool? = nil,
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            snapshotId: Swift.String? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension SecurityHubClientTypes {
    /// A block device for the instance.
    public struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {
        /// The device name that is exposed to the EC2 instance. For example, /dev/sdh or xvdh.
        public var deviceName: Swift.String?
        /// Parameters that are used to automatically set up Amazon EBS volumes when an instance is launched.
        public var ebs: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails?
        /// Whether to suppress the device that is included in the block device mapping of the Amazon Machine Image (AMI). If NoDevice is true, then you cannot specify Ebs.>
        public var noDevice: Swift.Bool?
        /// The name of the virtual device (for example, ephemeral0). You can provide either VirtualName or Ebs, but not both.
        public var virtualName: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            ebs: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails? = nil,
            noDevice: Swift.Bool? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the type of monitoring for instances in the group.
    public struct AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {
        /// If set to true, then instances in the group launch with detailed monitoring. If set to false, then instances in the group launch with basic monitoring.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// The metadata options for the instances.
    public struct AwsAutoScalingLaunchConfigurationMetadataOptions {
        /// Enables or disables the HTTP metadata endpoint on your instances. By default, the metadata endpoint is enabled.
        public var httpEndpoint: Swift.String?
        /// The HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        public var httpPutResponseHopLimit: Swift.Int?
        /// Indicates whether token usage is required or optional for metadata requests. By default, token usage is optional.
        public var httpTokens: Swift.String?

        public init(
            httpEndpoint: Swift.String? = nil,
            httpPutResponseHopLimit: Swift.Int? = nil,
            httpTokens: Swift.String? = nil
        )
        {
            self.httpEndpoint = httpEndpoint
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about a launch configuration.
    public struct AwsAutoScalingLaunchConfigurationDetails {
        /// For Auto Scaling groups that run in a VPC, specifies whether to assign a public IP address to the group's instances.
        public var associatePublicIpAddress: Swift.Bool?
        /// Specifies the block devices for the instance.
        public var blockDeviceMappings: [SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]?
        /// The identifier of a ClassicLink-enabled VPC that EC2-Classic instances are linked to.
        public var classicLinkVpcId: Swift.String?
        /// The identifiers of one or more security groups for the VPC that is specified in ClassicLinkVPCId.
        public var classicLinkVpcSecurityGroups: [Swift.String]?
        /// The creation date and time for the launch configuration. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdTime: Swift.String?
        /// Whether the launch configuration is optimized for Amazon EBS I/O.
        public var ebsOptimized: Swift.Bool?
        /// The name or the ARN of the instance profile associated with the IAM role for the instance. The instance profile contains the IAM role.
        public var iamInstanceProfile: Swift.String?
        /// The identifier of the Amazon Machine Image (AMI) that is used to launch EC2 instances.
        public var imageId: Swift.String?
        /// Indicates the type of monitoring for instances in the group.
        public var instanceMonitoring: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails?
        /// The instance type for the instances.
        public var instanceType: Swift.String?
        /// The identifier of the kernel associated with the AMI.
        public var kernelId: Swift.String?
        /// The name of the key pair.
        public var keyName: Swift.String?
        /// The name of the launch configuration.
        public var launchConfigurationName: Swift.String?
        /// The metadata options for the instances.
        public var metadataOptions: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions?
        /// The tenancy of the instance. An instance with dedicated tenancy runs on isolated, single-tenant hardware and can only be launched into a VPC.
        public var placementTenancy: Swift.String?
        /// The identifier of the RAM disk associated with the AMI.
        public var ramdiskId: Swift.String?
        /// The security groups to assign to the instances in the Auto Scaling group.
        public var securityGroups: [Swift.String]?
        /// The maximum hourly price to be paid for any Spot Instance that is launched to fulfill the request.
        public var spotPrice: Swift.String?
        /// The user data to make available to the launched EC2 instances. Must be base64-encoded text.
        public var userData: Swift.String?

        public init(
            associatePublicIpAddress: Swift.Bool? = nil,
            blockDeviceMappings: [SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]? = nil,
            classicLinkVpcId: Swift.String? = nil,
            classicLinkVpcSecurityGroups: [Swift.String]? = nil,
            createdTime: Swift.String? = nil,
            ebsOptimized: Swift.Bool? = nil,
            iamInstanceProfile: Swift.String? = nil,
            imageId: Swift.String? = nil,
            instanceMonitoring: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails? = nil,
            instanceType: Swift.String? = nil,
            kernelId: Swift.String? = nil,
            keyName: Swift.String? = nil,
            launchConfigurationName: Swift.String? = nil,
            metadataOptions: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions? = nil,
            placementTenancy: Swift.String? = nil,
            ramdiskId: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            spotPrice: Swift.String? = nil,
            userData: Swift.String? = nil
        )
        {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.blockDeviceMappings = blockDeviceMappings
            self.classicLinkVpcId = classicLinkVpcId
            self.classicLinkVpcSecurityGroups = classicLinkVpcSecurityGroups
            self.createdTime = createdTime
            self.ebsOptimized = ebsOptimized
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceMonitoring = instanceMonitoring
            self.instanceType = instanceType
            self.kernelId = kernelId
            self.keyName = keyName
            self.launchConfigurationName = launchConfigurationName
            self.metadataOptions = metadataOptions
            self.placementTenancy = placementTenancy
            self.ramdiskId = ramdiskId
            self.securityGroups = securityGroups
            self.spotPrice = spotPrice
            self.userData = userData
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides a list of backup options for each resource type.
    public struct AwsBackupBackupPlanAdvancedBackupSettingsDetails {
        /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values are as follows:
        ///
        /// * Set to WindowsVSS: enabled to enable the WindowsVSS backup option and create a Windows VSS backup.
        ///
        /// * Set to WindowsVSS: disabled to create a regular backup. The WindowsVSS option is not enabled by default.
        public var backupOptions: [Swift.String: Swift.String]?
        /// The name of a resource type. The only supported resource type is Amazon EC2 instances with Windows VSS. The only valid value is EC2.
        public var resourceType: Swift.String?

        public init(
            backupOptions: [Swift.String: Swift.String]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides lifecycle details for the backup plan. A lifecycle defines when a backup is transitioned to cold storage and when it expires.
    public struct AwsBackupBackupPlanLifecycleDetails {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public var deleteAfterDays: Swift.Int?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAfterDays: Swift.Int?

        public init(
            deleteAfterDays: Swift.Int? = nil,
            moveToColdStorageAfterDays: Swift.Int? = nil
        )
        {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }
    }

}

extension SecurityHubClientTypes {
    /// An array of CopyAction objects, each of which contains details of the copy operation.
    public struct AwsBackupBackupPlanRuleCopyActionsDetails {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup.
        public var destinationBackupVaultArn: Swift.String?
        /// Defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. If you do not specify a lifecycle, Backup applies the lifecycle policy of the source backup to the destination backup. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days.
        public var lifecycle: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails?

        public init(
            destinationBackupVaultArn: Swift.String? = nil,
            lifecycle: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails? = nil
        )
        {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
    public struct AwsBackupBackupPlanRuleDetails {
        /// A value in minutes after a backup job is successfully started before it must be completed, or it is canceled by Backup.
        public var completionWindowMinutes: Swift.Int?
        /// An array of CopyAction objects, each of which contains details of the copy operation.
        public var copyActions: [SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails]?
        /// Specifies whether Backup creates continuous backups capable of point-in-time restore (PITR).
        public var enableContinuousBackup: Swift.Bool?
        /// Defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. If you do not specify a lifecycle, Backup applies the lifecycle policy of the source backup to the destination backup. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days.
        public var lifecycle: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public var ruleId: Swift.String?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        public var ruleName: Swift.String?
        /// A cron expression in UTC specifying when Backup initiates a backup job.
        public var scheduleExpression: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully.
        public var startWindowMinutes: Swift.Int?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region where they are created. They consist of letters, numbers, and hyphens.
        public var targetBackupVault: Swift.String?

        public init(
            completionWindowMinutes: Swift.Int? = nil,
            copyActions: [SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails]? = nil,
            enableContinuousBackup: Swift.Bool? = nil,
            lifecycle: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails? = nil,
            ruleId: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            startWindowMinutes: Swift.Int? = nil,
            targetBackupVault: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVault = targetBackupVault
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Backup backup plan and an array of BackupRule objects, each of which specifies a backup rule.
    public struct AwsBackupBackupPlanBackupPlanDetails {
        /// A list of backup options for each resource type.
        public var advancedBackupSettings: [SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails]?
        /// The display name of a backup plan.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        public var backupPlanRule: [SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails]?

        public init(
            advancedBackupSettings: [SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails]? = nil,
            backupPlanName: Swift.String? = nil,
            backupPlanRule: [SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.backupPlanRule = backupPlanRule
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Backup backup plan and an array of BackupRule objects, each of which specifies a backup rule.
    public struct AwsBackupBackupPlanDetails {
        /// Uniquely identifies the backup plan to be associated with the selection of resources.
        public var backupPlan: SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails?
        /// An Amazon Resource Name (ARN) that uniquely identifies the backup plan.
        public var backupPlanArn: Swift.String?
        /// A unique ID for the backup plan.
        public var backupPlanId: Swift.String?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings. Version IDs cannot be edited.
        public var versionId: Swift.String?

        public init(
            backupPlan: SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails? = nil,
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.backupPlan = backupPlan
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.versionId = versionId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the Amazon SNS event notifications for the specified backup vault.
    public struct AwsBackupBackupVaultNotificationsDetails {
        /// An array of events that indicate the status of jobs to back up resources to the backup vault. The following events are supported:
        ///
        /// * BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED
        ///
        /// * COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED
        ///
        /// * RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED | RECOVERY_POINT_MODIFIED
        ///
        /// * S3_BACKUP_OBJECT_FAILED | S3_RESTORE_OBJECT_FAILED
        public var backupVaultEvents: [Swift.String]?
        /// The Amazon Resource Name (ARN) that uniquely identifies the Amazon SNS topic for a backup vault's events.
        public var snsTopicArn: Swift.String?

        public init(
            backupVaultEvents: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil
        )
        {
            self.backupVaultEvents = backupVaultEvents
            self.snsTopicArn = snsTopicArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Backup backup vault. In Backup, a backup vault is a container that stores and organizes your backups.
    public struct AwsBackupBackupVaultDetails {
        /// A resource-based policy that is used to manage access permissions on the target backup vault.
        public var accessPolicy: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The unique ARN associated with the server-side encryption key. You can specify a key to encrypt your backups from services that support full Backup management. If you do not specify a key, Backup creates an KMS key for you by default.
        public var encryptionKeyArn: Swift.String?
        /// The Amazon SNS event notifications for the specified backup vault.
        public var notifications: SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails?

        public init(
            accessPolicy: Swift.String? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            notifications: SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails? = nil
        )
        {
            self.accessPolicy = accessPolicy
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.encryptionKeyArn = encryptionKeyArn
            self.notifications = notifications
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies how long in days before a recovery point transitions to cold storage or is deleted.
    public struct AwsBackupRecoveryPointCalculatedLifecycleDetails {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public var deleteAt: Swift.String?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAt: Swift.String?

        public init(
            deleteAt: Swift.String? = nil,
            moveToColdStorageAt: Swift.String? = nil
        )
        {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
    public struct AwsBackupRecoveryPointCreatedByDetails {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public var backupPlanVersion: Swift.String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public var backupRuleId: Swift.String?

        public init(
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanVersion: Swift.String? = nil,
            backupRuleId: Swift.String? = nil
        )
        {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted.
    public struct AwsBackupRecoveryPointLifecycleDetails {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public var deleteAfterDays: Swift.Int?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAfterDays: Swift.Int?

        public init(
            deleteAfterDays: Swift.Int? = nil,
            moveToColdStorageAfterDays: Swift.Int? = nil
        )
        {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains detailed information about the recovery points stored in an Backup backup vault. A backup, or recovery point, represents the content of a resource at a specified time.
    public struct AwsBackupRecoveryPointDetails {
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public var calculatedLifecycle: SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails?
        /// The date and time that a job to create a recovery point is completed, in Unix format and UTC. The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: Swift.String?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public var createdBy: SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails?
        /// The date and time a recovery point is created, in Unix format and UTC. The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Swift.String?
        /// The ARN for the server-side encryption key that is used to protect your backups.
        public var encryptionKeyArn: Swift.String?
        /// Specifies the IAM role ARN used to create the target recovery point
        public var iamRoleArn: Swift.String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public var isEncrypted: Swift.Bool?
        /// The date and time that a recovery point was last restored, in Unix format and UTC. The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastRestoreTime: Swift.String?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define
        public var lifecycle: SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails?
        /// An ARN that uniquely identifies a recovery point.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// The type of Amazon Web Services resource saved as a recovery point, such as an Amazon EBS volume or an Amazon RDS database.
        public var resourceType: Swift.String?
        /// The ARN for the backup vault where the recovery point was originally copied from. If the recovery point is restored to the same account, this value will be null.
        public var sourceBackupVaultArn: Swift.String?
        /// A status code specifying the state of the recovery point. Valid values are as follows:
        ///
        /// * COMPLETED
        ///
        /// * DELETING
        ///
        /// * EXPIRED
        ///
        /// * PARTIAL
        public var status: Swift.String?
        /// A message explaining the reason of the recovery point deletion failure.
        public var statusMessage: Swift.String?
        /// Specifies the storage class of the recovery point. Valid values are as follows:
        ///
        /// * COLD
        ///
        /// * DELETED
        ///
        /// * WARM
        public var storageClass: Swift.String?

        public init(
            backupSizeInBytes: Swift.Int? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            calculatedLifecycle: SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails? = nil,
            completionDate: Swift.String? = nil,
            createdBy: SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails? = nil,
            creationDate: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            isEncrypted: Swift.Bool? = nil,
            lastRestoreTime: Swift.String? = nil,
            lifecycle: SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            storageClass: Swift.String? = nil
        )
        {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
            self.storageClass = storageClass
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the CNAME record that is added to the DNS database for domain validation.
    public struct AwsCertificateManagerCertificateResourceRecord {
        /// The name of the resource.
        public var name: Swift.String?
        /// The type of resource.
        public var type: Swift.String?
        /// The value of the resource.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about one of the following:
    ///
    /// * The initial validation of each domain name that occurs as a result of the RequestCertificate request
    ///
    /// * The validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal
    public struct AwsCertificateManagerCertificateDomainValidationOption {
        /// A fully qualified domain name (FQDN) in the certificate.
        public var domainName: Swift.String?
        /// The CNAME record that is added to the DNS database for domain validation.
        public var resourceRecord: SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord?
        /// The domain name that Certificate Manager uses to send domain validation emails.
        public var validationDomain: Swift.String?
        /// A list of email addresses that Certificate Manager uses to send domain validation emails.
        public var validationEmails: [Swift.String]?
        /// The method used to validate the domain name.
        public var validationMethod: Swift.String?
        /// The validation status of the domain name.
        public var validationStatus: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            resourceRecord: SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord? = nil,
            validationDomain: Swift.String? = nil,
            validationEmails: [Swift.String]? = nil,
            validationMethod: Swift.String? = nil,
            validationStatus: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.resourceRecord = resourceRecord
            self.validationDomain = validationDomain
            self.validationEmails = validationEmails
            self.validationMethod = validationMethod
            self.validationStatus = validationStatus
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about an extended key usage X.509 v3 extension object.
    public struct AwsCertificateManagerCertificateExtendedKeyUsage {
        /// The name of an extension value. Indicates the purpose for which the certificate public key can be used.
        public var name: Swift.String?
        /// An object identifier (OID) for the extension value. The format is numbers separated by periods.
        public var oId: Swift.String?

        public init(
            name: Swift.String? = nil,
            oId: Swift.String? = nil
        )
        {
            self.name = name
            self.oId = oId
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about a key usage X.509 v3 extension object.
    public struct AwsCertificateManagerCertificateKeyUsage {
        /// The key usage extension name.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains other options for the certificate.
    public struct AwsCertificateManagerCertificateOptions {
        /// Whether to add the certificate to a transparency log. Valid values: DISABLED | ENABLED
        public var certificateTransparencyLoggingPreference: Swift.String?

        public init(
            certificateTransparencyLoggingPreference: Swift.String? = nil
        )
        {
            self.certificateTransparencyLoggingPreference = certificateTransparencyLoggingPreference
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the Certificate Manager managed renewal for an AMAZON_ISSUED certificate.
    public struct AwsCertificateManagerCertificateRenewalSummary {
        /// Information about the validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal. Provided only when the certificate type is AMAZON_ISSUED.
        public var domainValidationOptions: [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]?
        /// The status of the Certificate Manager managed renewal of the certificate. Valid values: PENDING_AUTO_RENEWAL | PENDING_VALIDATION | SUCCESS | FAILED
        public var renewalStatus: Swift.String?
        /// The reason that a renewal request was unsuccessful. This attribute is used only when RenewalStatus is FAILED. Valid values: NO_AVAILABLE_CONTACTS | ADDITIONAL_VERIFICATION_REQUIRED | DOMAIN_NOT_ALLOWED | INVALID_PUBLIC_DOMAIN | DOMAIN_VALIDATION_DENIED | CAA_ERROR | PCA_LIMIT_EXCEEDED | PCA_INVALID_ARN | PCA_INVALID_STATE | PCA_REQUEST_FAILED | PCA_NAME_CONSTRAINTS_VALIDATION | PCA_RESOURCE_NOT_FOUND | PCA_INVALID_ARGS | PCA_INVALID_DURATION | PCA_ACCESS_DENIED | SLR_NOT_FOUND | OTHER
        public var renewalStatusReason: Swift.String?
        /// Indicates when the renewal summary was last updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var updatedAt: Swift.String?

        public init(
            domainValidationOptions: [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]? = nil,
            renewalStatus: Swift.String? = nil,
            renewalStatusReason: Swift.String? = nil,
            updatedAt: Swift.String? = nil
        )
        {
            self.domainValidationOptions = domainValidationOptions
            self.renewalStatus = renewalStatus
            self.renewalStatusReason = renewalStatusReason
            self.updatedAt = updatedAt
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Certificate Manager certificate.
    public struct AwsCertificateManagerCertificateDetails {
        /// The ARN of the private certificate authority (CA) that will be used to issue the certificate.
        public var certificateAuthorityArn: Swift.String?
        /// Indicates when the certificate was requested. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdAt: Swift.String?
        /// The fully qualified domain name (FQDN), such as www.example.com, that is secured by the certificate.
        public var domainName: Swift.String?
        /// Contains information about the initial validation of each domain name that occurs as a result of the RequestCertificate request. Only provided if the certificate type is AMAZON_ISSUED.
        public var domainValidationOptions: [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]?
        /// Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID).
        public var extendedKeyUsages: [SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage]?
        /// For a failed certificate request, the reason for the failure. Valid values: NO_AVAILABLE_CONTACTS | ADDITIONAL_VERIFICATION_REQUIRED | DOMAIN_NOT_ALLOWED | INVALID_PUBLIC_DOMAIN | DOMAIN_VALIDATION_DENIED | CAA_ERROR | PCA_LIMIT_EXCEEDED | PCA_INVALID_ARN | PCA_INVALID_STATE | PCA_REQUEST_FAILED | PCA_NAME_CONSTRAINTS_VALIDATION | PCA_RESOURCE_NOT_FOUND | PCA_INVALID_ARGS | PCA_INVALID_DURATION | PCA_ACCESS_DENIED | SLR_NOT_FOUND | OTHER
        public var failureReason: Swift.String?
        /// Indicates when the certificate was imported. Provided if the certificate type is IMPORTED. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var importedAt: Swift.String?
        /// The list of ARNs for the Amazon Web Services resources that use the certificate.
        public var inUseBy: [Swift.String]?
        /// Indicates when the certificate was issued. Provided if the certificate type is AMAZON_ISSUED. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var issuedAt: Swift.String?
        /// The name of the certificate authority that issued and signed the certificate.
        public var issuer: Swift.String?
        /// The algorithm that was used to generate the public-private key pair. Valid values: RSA_2048 | RSA_1024 | RSA_4096 | EC_prime256v1 | EC_secp384r1 | EC_secp521r1
        public var keyAlgorithm: Swift.String?
        /// A list of key usage X.509 v3 extension objects.
        public var keyUsages: [SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage]?
        /// The time after which the certificate becomes invalid. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var notAfter: Swift.String?
        /// The time before which the certificate is not valid. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var notBefore: Swift.String?
        /// Provides a value that specifies whether to add the certificate to a transparency log.
        public var options: SecurityHubClientTypes.AwsCertificateManagerCertificateOptions?
        /// Whether the certificate is eligible for renewal. Valid values: ELIGIBLE | INELIGIBLE
        public var renewalEligibility: Swift.String?
        /// Information about the status of the Certificate Manager managed renewal for the certificate. Provided only when the certificate type is AMAZON_ISSUED.
        public var renewalSummary: SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary?
        /// The serial number of the certificate.
        public var serial: Swift.String?
        /// The algorithm that was used to sign the certificate.
        public var signatureAlgorithm: Swift.String?
        /// The status of the certificate. Valid values: PENDING_VALIDATION | ISSUED | INACTIVE | EXPIRED | VALIDATION_TIMED_OUT | REVOKED | FAILED
        public var status: Swift.String?
        /// The name of the entity that is associated with the public key contained in the certificate.
        public var subject: Swift.String?
        /// One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate. The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website.
        public var subjectAlternativeNames: [Swift.String]?
        /// The source of the certificate. For certificates that Certificate Manager provides, Type is AMAZON_ISSUED. For certificates that are imported with ImportCertificate, Type is IMPORTED. Valid values: IMPORTED | AMAZON_ISSUED | PRIVATE
        public var type: Swift.String?

        public init(
            certificateAuthorityArn: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainValidationOptions: [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]? = nil,
            extendedKeyUsages: [SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage]? = nil,
            failureReason: Swift.String? = nil,
            importedAt: Swift.String? = nil,
            inUseBy: [Swift.String]? = nil,
            issuedAt: Swift.String? = nil,
            issuer: Swift.String? = nil,
            keyAlgorithm: Swift.String? = nil,
            keyUsages: [SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage]? = nil,
            notAfter: Swift.String? = nil,
            notBefore: Swift.String? = nil,
            options: SecurityHubClientTypes.AwsCertificateManagerCertificateOptions? = nil,
            renewalEligibility: Swift.String? = nil,
            renewalSummary: SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary? = nil,
            serial: Swift.String? = nil,
            signatureAlgorithm: Swift.String? = nil,
            status: Swift.String? = nil,
            subject: Swift.String? = nil,
            subjectAlternativeNames: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.createdAt = createdAt
            self.domainName = domainName
            self.domainValidationOptions = domainValidationOptions
            self.extendedKeyUsages = extendedKeyUsages
            self.failureReason = failureReason
            self.importedAt = importedAt
            self.inUseBy = inUseBy
            self.issuedAt = issuedAt
            self.issuer = issuer
            self.keyAlgorithm = keyAlgorithm
            self.keyUsages = keyUsages
            self.notAfter = notAfter
            self.notBefore = notBefore
            self.options = options
            self.renewalEligibility = renewalEligibility
            self.renewalSummary = renewalSummary
            self.serial = serial
            self.signatureAlgorithm = signatureAlgorithm
            self.status = status
            self.subject = subject
            self.subjectAlternativeNames = subjectAlternativeNames
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the stack's conformity to its expected template configuration.
    public struct AwsCloudFormationStackDriftInformationDetails {
        /// Status of the stack's actual configuration compared to its expected template configuration.
        public var stackDriftStatus: Swift.String?

        public init(
            stackDriftStatus: Swift.String? = nil
        )
        {
            self.stackDriftStatus = stackDriftStatus
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the CloudFormation stack output.
    public struct AwsCloudFormationStackOutputsDetails {
        /// A user-defined description associated with the output.
        public var description: Swift.String?
        /// The key associated with the output.
        public var outputKey: Swift.String?
        /// The value associated with the output.
        public var outputValue: Swift.String?

        public init(
            description: Swift.String? = nil,
            outputKey: Swift.String? = nil,
            outputValue: Swift.String? = nil
        )
        {
            self.description = description
            self.outputKey = outputKey
            self.outputValue = outputValue
        }
    }

}

extension SecurityHubClientTypes {
    /// Nests a stack as a resource in a top-level template. Nested stacks are stacks created as resources for another stack.
    public struct AwsCloudFormationStackDetails {
        /// The capabilities allowed in the stack.
        public var capabilities: [Swift.String]?
        /// The time at which the stack was created.
        public var creationTime: Swift.String?
        /// A user-defined description associated with the stack.
        public var description: Swift.String?
        /// Boolean to enable or disable rollback on stack creation failures.
        public var disableRollback: Swift.Bool?
        /// Information about whether a stack's actual configuration differs, or has drifted, from its expected configuration, as defined in the stack template and any values specified as template parameters.
        public var driftInformation: SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails?
        /// Whether termination protection is enabled for the stack.
        public var enableTerminationProtection: Swift.Bool?
        /// The time the nested stack was last updated. This field will only be returned if the stack has been updated at least once.
        public var lastUpdatedTime: Swift.String?
        /// The Amazon Resource Names (ARNs) of the Amazon SNS topic to which stack-related events are published.
        public var notificationArns: [Swift.String]?
        /// A list of output structures.
        public var outputs: [SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails]?
        /// The ARN of an IAM role that's associated with the stack.
        public var roleArn: Swift.String?
        /// Unique identifier of the stack.
        public var stackId: Swift.String?
        /// The name associated with the stack.
        public var stackName: Swift.String?
        /// Current status of the stack.
        public var stackStatus: Swift.String?
        /// Success or failure message associated with the stack status.
        public var stackStatusReason: Swift.String?
        /// The length of time, in minutes, that CloudFormation waits for the nested stack to reach the CREATE_COMPLETE state.
        public var timeoutInMinutes: Swift.Int?

        public init(
            capabilities: [Swift.String]? = nil,
            creationTime: Swift.String? = nil,
            description: Swift.String? = nil,
            disableRollback: Swift.Bool? = nil,
            driftInformation: SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails? = nil,
            enableTerminationProtection: Swift.Bool? = nil,
            lastUpdatedTime: Swift.String? = nil,
            notificationArns: [Swift.String]? = nil,
            outputs: [SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails]? = nil,
            roleArn: Swift.String? = nil,
            stackId: Swift.String? = nil,
            stackName: Swift.String? = nil,
            stackStatus: Swift.String? = nil,
            stackStatusReason: Swift.String? = nil,
            timeoutInMinutes: Swift.Int? = nil
        )
        {
            self.capabilities = capabilities
            self.creationTime = creationTime
            self.description = description
            self.disableRollback = disableRollback
            self.driftInformation = driftInformation
            self.enableTerminationProtection = enableTerminationProtection
            self.lastUpdatedTime = lastUpdatedTime
            self.notificationArns = notificationArns
            self.outputs = outputs
            self.roleArn = roleArn
            self.stackId = stackId
            self.stackName = stackName
            self.stackStatus = stackStatus
            self.stackStatusReason = stackStatusReason
            self.timeoutInMinutes = timeoutInMinutes
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a cache behavior for the distribution.
    public struct AwsCloudFrontDistributionCacheBehavior {
        /// The protocol that viewers can use to access the files in an origin. You can specify the following options:
        ///
        /// * allow-all - Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.
        ///
        /// * https-only - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).
        public var viewerProtocolPolicy: Swift.String?

        public init(
            viewerProtocolPolicy: Swift.String? = nil
        )
        {
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about caching for the CloudFront distribution.
    public struct AwsCloudFrontDistributionCacheBehaviors {
        /// The cache behaviors for the distribution.
        public var items: [SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior]?

        public init(
            items: [SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior]? = nil
        )
        {
            self.items = items
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the default cache configuration for the CloudFront distribution.
    public struct AwsCloudFrontDistributionDefaultCacheBehavior {
        /// The protocol that viewers can use to access the files in an origin. You can specify the following options:
        ///
        /// * allow-all - Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.
        ///
        /// * https-only - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).
        public var viewerProtocolPolicy: Swift.String?

        public init(
            viewerProtocolPolicy: Swift.String? = nil
        )
        {
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension SecurityHubClientTypes {
    /// A complex type that controls whether access logs are written for the CloudFront distribution.
    public struct AwsCloudFrontDistributionLogging {
        /// The S3 bucket to store the access logs in.
        public var bucket: Swift.String?
        /// With this field, you can enable or disable the selected distribution.
        public var enabled: Swift.Bool?
        /// Specifies whether you want CloudFront to include cookies in access logs.
        public var includeCookies: Swift.Bool?
        /// An optional string that you want CloudFront to use as a prefix to the access log filenames for this distribution.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            includeCookies: Swift.Bool? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.`prefix` = `prefix`
        }
    }

}

extension SecurityHubClientTypes {
    /// The status codes that cause an origin group to fail over.
    public struct AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
        /// The list of status code values that can cause a failover to the next origin.
        public var items: [Swift.Int]?
        /// The number of status codes that can cause a failover.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.Int]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about when an origin group fails over.
    public struct AwsCloudFrontDistributionOriginGroupFailover {
        /// Information about the status codes that cause an origin group to fail over.
        public var statusCodes: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes?

        public init(
            statusCodes: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes? = nil
        )
        {
            self.statusCodes = statusCodes
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an origin group for the CloudFront distribution.
    public struct AwsCloudFrontDistributionOriginGroup {
        /// Provides the criteria for an origin group to fail over.
        public var failoverCriteria: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover?

        public init(
            failoverCriteria: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover? = nil
        )
        {
            self.failoverCriteria = failoverCriteria
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about origin groups that are associated with the CloudFront distribution.
    public struct AwsCloudFrontDistributionOriginGroups {
        /// The list of origin groups.
        public var items: [SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup]?

        public init(
            items: [SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup]? = nil
        )
        {
            self.items = items
        }
    }

}

extension SecurityHubClientTypes {
    /// A complex type that contains information about the SSL/TLS protocols that CloudFront can use when establishing an HTTPS connection with your origin.
    public struct AwsCloudFrontDistributionOriginSslProtocols {
        /// A list that contains allowed SSL/TLS protocols for this distribution.
        public var items: [Swift.String]?
        /// The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin.
        public var quantity: Swift.Int?

        public init(
            items: [Swift.String]? = nil,
            quantity: Swift.Int? = nil
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension SecurityHubClientTypes {
    /// A custom origin. A custom origin is any origin that is not an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is [configured with static website hosting](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) is a custom origin.
    public struct AwsCloudFrontDistributionOriginCustomOriginConfig {
        /// The HTTP port that CloudFront uses to connect to the origin.
        public var httpPort: Swift.Int?
        /// The HTTPS port that CloudFront uses to connect to the origin.
        public var httpsPort: Swift.Int?
        /// Specifies how long, in seconds, CloudFront persists its connection to the origin.
        public var originKeepaliveTimeout: Swift.Int?
        /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin.
        public var originProtocolPolicy: Swift.String?
        /// Specifies how long, in seconds, CloudFront waits for a response from the origin.
        public var originReadTimeout: Swift.Int?
        /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS.
        public var originSslProtocols: SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols?

        public init(
            httpPort: Swift.Int? = nil,
            httpsPort: Swift.Int? = nil,
            originKeepaliveTimeout: Swift.Int? = nil,
            originProtocolPolicy: Swift.String? = nil,
            originReadTimeout: Swift.Int? = nil,
            originSslProtocols: SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols? = nil
        )
        {
            self.httpPort = httpPort
            self.httpsPort = httpsPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an origin that is an Amazon S3 bucket that is not configured with static website hosting.
    public struct AwsCloudFrontDistributionOriginS3OriginConfig {
        /// The CloudFront origin access identity to associate with the origin.
        public var originAccessIdentity: Swift.String?

        public init(
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension SecurityHubClientTypes {
    /// A complex type that describes the Amazon S3 bucket, HTTP server (for example, a web server), Elemental MediaStore, or other server from which CloudFront gets your files.
    public struct AwsCloudFrontDistributionOriginItem {
        /// An origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this attribute. If the Amazon S3 bucket is not configured with static website hosting, use the S3OriginConfig type instead.
        public var customOriginConfig: SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig?
        /// Amazon S3 origins: The DNS name of the S3 bucket from which you want CloudFront to get objects for this origin.
        public var domainName: Swift.String?
        /// A unique identifier for the origin or origin group.
        public var id: Swift.String?
        /// An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
        public var originPath: Swift.String?
        /// An origin that is an S3 bucket that is not configured with static website hosting.
        public var s3OriginConfig: SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig?

        public init(
            customOriginConfig: SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            originPath: Swift.String? = nil,
            s3OriginConfig: SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig? = nil
        )
        {
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originPath = originPath
            self.s3OriginConfig = s3OriginConfig
        }
    }

}

extension SecurityHubClientTypes {
    /// A complex type that contains information about origins and origin groups for this CloudFront distribution.
    public struct AwsCloudFrontDistributionOrigins {
        /// A complex type that contains origins or origin groups for this distribution.
        public var items: [SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem]?

        public init(
            items: [SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem]? = nil
        )
        {
            self.items = items
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the TLS/SSL configuration that the CloudFront distribution uses to communicate with viewers.
    public struct AwsCloudFrontDistributionViewerCertificate {
        /// The ARN of the ACM certificate. Used if the certificate is stored in ACM. If you provide an ACM certificate ARN, you must also provide MinimumCertificateVersion and SslSupportMethod.
        public var acmCertificateArn: Swift.String?
        /// The identifier of the certificate. Note that in CloudFront, this attribute is deprecated.
        public var certificate: Swift.String?
        /// The source of the certificate identified by Certificate. Note that in CloudFront, this attribute is deprecated.
        public var certificateSource: Swift.String?
        /// Whether the distribution uses the CloudFront domain name. If set to false, then you provide either AcmCertificateArn or IamCertificateId.
        public var cloudFrontDefaultCertificate: Swift.Bool?
        /// The identifier of the IAM certificate. Used if the certificate is stored in IAM. If you provide IamCertificateId, then you also must provide MinimumProtocolVersion and SslSupportMethod.
        public var iamCertificateId: Swift.String?
        /// The security policy that CloudFront uses for HTTPS connections with viewers. If SslSupportMethod is sni-only, then MinimumProtocolVersion must be TLSv1 or higher.
        public var minimumProtocolVersion: Swift.String?
        /// The viewers that the distribution accepts HTTPS connections from.
        public var sslSupportMethod: Swift.String?

        public init(
            acmCertificateArn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateSource: Swift.String? = nil,
            cloudFrontDefaultCertificate: Swift.Bool? = nil,
            iamCertificateId: Swift.String? = nil,
            minimumProtocolVersion: Swift.String? = nil,
            sslSupportMethod: Swift.String? = nil
        )
        {
            self.acmCertificateArn = acmCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iamCertificateId = iamCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sslSupportMethod = sslSupportMethod
        }
    }

}

extension SecurityHubClientTypes {
    /// A CloudFront distribution configuration.
    public struct AwsCloudFrontDistributionDetails {
        /// Provides information about the cache configuration for the distribution.
        public var cacheBehaviors: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors?
        /// The default cache behavior for the configuration.
        public var defaultCacheBehavior: SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior?
        /// The object that CloudFront sends in response to requests from the origin (for example, index.html) when a viewer requests the root URL for the distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html).
        public var defaultRootObject: Swift.String?
        /// The domain name corresponding to the distribution.
        public var domainName: Swift.String?
        /// The entity tag is a hash of the object.
        public var eTag: Swift.String?
        /// Indicates when that the distribution was last modified. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastModifiedTime: Swift.String?
        /// A complex type that controls whether access logs are written for the distribution.
        public var logging: SecurityHubClientTypes.AwsCloudFrontDistributionLogging?
        /// Provides information about the origin groups in the distribution.
        public var originGroups: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups?
        /// A complex type that contains information about origins for this distribution.
        public var origins: SecurityHubClientTypes.AwsCloudFrontDistributionOrigins?
        /// Indicates the current status of the distribution.
        public var status: Swift.String?
        /// Provides information about the TLS/SSL configuration that the distribution uses to communicate with viewers.
        public var viewerCertificate: SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate?
        /// A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution.
        public var webAclId: Swift.String?

        public init(
            cacheBehaviors: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors? = nil,
            defaultCacheBehavior: SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior? = nil,
            defaultRootObject: Swift.String? = nil,
            domainName: Swift.String? = nil,
            eTag: Swift.String? = nil,
            lastModifiedTime: Swift.String? = nil,
            logging: SecurityHubClientTypes.AwsCloudFrontDistributionLogging? = nil,
            originGroups: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups? = nil,
            origins: SecurityHubClientTypes.AwsCloudFrontDistributionOrigins? = nil,
            status: Swift.String? = nil,
            viewerCertificate: SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate? = nil,
            webAclId: Swift.String? = nil
        )
        {
            self.cacheBehaviors = cacheBehaviors
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.domainName = domainName
            self.eTag = eTag
            self.lastModifiedTime = lastModifiedTime
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webAclId = webAclId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about a CloudTrail trail.
    public struct AwsCloudTrailTrailDetails {
        /// The ARN of the log group that CloudTrail logs are delivered to.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// The ARN of the role that the CloudWatch Events endpoint assumes when it writes to the log group.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Indicates whether the trail has custom event selectors.
        public var hasCustomEventSelectors: Swift.Bool?
        /// The Region where the trail was created.
        public var homeRegion: Swift.String?
        /// Indicates whether the trail publishes events from global services such as IAM to the log files.
        public var includeGlobalServiceEvents: Swift.Bool?
        /// Indicates whether the trail applies only to the current Region or to all Regions.
        public var isMultiRegionTrail: Swift.Bool?
        /// Whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account.
        public var isOrganizationTrail: Swift.Bool?
        /// The KMS key ID to use to encrypt the logs.
        public var kmsKeyId: Swift.String?
        /// Indicates whether CloudTrail log file validation is enabled.
        public var logFileValidationEnabled: Swift.Bool?
        /// The name of the trail.
        public var name: Swift.String?
        /// The name of the S3 bucket where the log files are published.
        public var s3BucketName: Swift.String?
        /// The S3 key prefix. The key prefix is added after the name of the S3 bucket where the log files are published.
        public var s3KeyPrefix: Swift.String?
        /// The ARN of the SNS topic that is used for notifications of log file delivery.
        public var snsTopicArn: Swift.String?
        /// The name of the SNS topic that is used for notifications of log file delivery.
        public var snsTopicName: Swift.String?
        /// The ARN of the trail.
        public var trailArn: Swift.String?

        public init(
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            cloudWatchLogsRoleArn: Swift.String? = nil,
            hasCustomEventSelectors: Swift.Bool? = nil,
            homeRegion: Swift.String? = nil,
            includeGlobalServiceEvents: Swift.Bool? = nil,
            isMultiRegionTrail: Swift.Bool? = nil,
            isOrganizationTrail: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            logFileValidationEnabled: Swift.Bool? = nil,
            name: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            snsTopicName: Swift.String? = nil,
            trailArn: Swift.String? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.hasCustomEventSelectors = hasCustomEventSelectors
            self.homeRegion = homeRegion
            self.includeGlobalServiceEvents = includeGlobalServiceEvents
            self.isMultiRegionTrail = isMultiRegionTrail
            self.isOrganizationTrail = isOrganizationTrail
            self.kmsKeyId = kmsKeyId
            self.logFileValidationEnabled = logFileValidationEnabled
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.snsTopicArn = snsTopicArn
            self.snsTopicName = snsTopicName
            self.trailArn = trailArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the dimensions for the metric associated with the alarm.
    public struct AwsCloudWatchAlarmDimensionsDetails {
        /// The name of a dimension.
        public var name: Swift.String?
        /// The value of a dimension.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies an alarm and associates it with the specified metric or metric math expression.
    public struct AwsCloudWatchAlarmDetails {
        /// Indicates whether actions should be executed during any changes to the alarm state.
        public var actionsEnabled: Swift.Bool?
        /// The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an ALARM state from any other state.
        public var alarmActions: [Swift.String]?
        /// The ARN of the alarm.
        public var alarmArn: Swift.String?
        /// The time stamp of the last update to the alarm configuration.
        public var alarmConfigurationUpdatedTimestamp: Swift.String?
        /// The description of the alarm.
        public var alarmDescription: Swift.String?
        /// The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name.
        public var alarmName: Swift.String?
        /// The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand.
        public var comparisonOperator: Swift.String?
        /// The number of datapoints that must be breaching to trigger the alarm.
        public var datapointsToAlarm: Swift.Int?
        /// The dimensions for the metric associated with the alarm.
        public var dimensions: [SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails]?
        /// Used only for alarms based on percentiles. If ignore, the alarm state does not change during periods with too few data points to be statistically significant. If evaluate or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available.
        public var evaluateLowSampleCountPercentile: Swift.String?
        /// The number of periods over which data is compared to the specified threshold.
        public var evaluationPeriods: Swift.Int?
        /// The percentile statistic for the metric associated with the alarm.
        public var extendedStatistic: Swift.String?
        /// The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an ARN.
        public var insufficientDataActions: [Swift.String]?
        /// The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use Metrics instead and you can't specify MetricName.
        public var metricName: Swift.String?
        /// The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify Namespace and you use Metrics instead.
        public var namespace: Swift.String?
        /// The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an ARN.
        public var okActions: [Swift.String]?
        /// The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric.
        public var period: Swift.Int?
        /// The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ExtendedStatistic. For an alarm based on a metric, you must specify either Statistic or ExtendedStatistic but not both. For an alarm based on a math expression, you can't specify Statistic. Instead, you use Metrics.
        public var statistic: Swift.String?
        /// The value to compare with the specified statistic.
        public var threshold: Swift.Double?
        /// n an alarm based on an anomaly detection model, this is the ID of the ANOMALY_DETECTION_BAND function used as the threshold for the alarm.
        public var thresholdMetricId: Swift.String?
        /// Sets how this alarm is to handle missing data points.
        public var treatMissingData: Swift.String?
        /// The unit of the metric associated with the alarm.
        public var unit: Swift.String?

        public init(
            actionsEnabled: Swift.Bool? = nil,
            alarmActions: [Swift.String]? = nil,
            alarmArn: Swift.String? = nil,
            alarmConfigurationUpdatedTimestamp: Swift.String? = nil,
            alarmDescription: Swift.String? = nil,
            alarmName: Swift.String? = nil,
            comparisonOperator: Swift.String? = nil,
            datapointsToAlarm: Swift.Int? = nil,
            dimensions: [SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails]? = nil,
            evaluateLowSampleCountPercentile: Swift.String? = nil,
            evaluationPeriods: Swift.Int? = nil,
            extendedStatistic: Swift.String? = nil,
            insufficientDataActions: [Swift.String]? = nil,
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil,
            okActions: [Swift.String]? = nil,
            period: Swift.Int? = nil,
            statistic: Swift.String? = nil,
            threshold: Swift.Double? = nil,
            thresholdMetricId: Swift.String? = nil,
            treatMissingData: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.actionsEnabled = actionsEnabled
            self.alarmActions = alarmActions
            self.alarmArn = alarmArn
            self.alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestamp
            self.alarmDescription = alarmDescription
            self.alarmName = alarmName
            self.comparisonOperator = comparisonOperator
            self.datapointsToAlarm = datapointsToAlarm
            self.dimensions = dimensions
            self.evaluateLowSampleCountPercentile = evaluateLowSampleCountPercentile
            self.evaluationPeriods = evaluationPeriods
            self.extendedStatistic = extendedStatistic
            self.insufficientDataActions = insufficientDataActions
            self.metricName = metricName
            self.namespace = namespace
            self.okActions = okActions
            self.period = period
            self.statistic = statistic
            self.threshold = threshold
            self.thresholdMetricId = thresholdMetricId
            self.treatMissingData = treatMissingData
            self.unit = unit
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the build artifacts for the CodeBuild project.
    public struct AwsCodeBuildProjectArtifactsDetails {
        /// An identifier for the artifact definition.
        public var artifactIdentifier: Swift.String?
        /// Indicates whether to disable encryption on the artifact. Only valid when Type is S3.
        public var encryptionDisabled: Swift.Bool?
        /// Only used when Type is S3. The name of the S3 bucket where the artifact is located.
        public var location: Swift.String?
        /// Only used when Type is S3. The name of the artifact. Used with NamepaceType and Path to determine the pattern for storing the artifact.
        public var name: Swift.String?
        /// Only used when Type is S3. The value to use for the namespace. Used with Name and Path to determine the pattern for storing the artifact.
        public var namespaceType: Swift.String?
        /// Whether the name specified in the buildspec file overrides the artifact name.
        public var overrideArtifactName: Swift.Bool?
        /// Only used when Type is S3. The type of output artifact to create.
        public var packaging: Swift.String?
        /// Only used when Type is S3. The path to the artifact. Used with Name and NamespaceType to determine the pattern for storing the artifact.
        public var path: Swift.String?
        /// The type of build artifact.
        public var type: Swift.String?

        public init(
            artifactIdentifier: Swift.String? = nil,
            encryptionDisabled: Swift.Bool? = nil,
            location: Swift.String? = nil,
            name: Swift.String? = nil,
            namespaceType: Swift.String? = nil,
            overrideArtifactName: Swift.Bool? = nil,
            packaging: Swift.String? = nil,
            path: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.artifactIdentifier = artifactIdentifier
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.name = name
            self.namespaceType = namespaceType
            self.overrideArtifactName = overrideArtifactName
            self.packaging = packaging
            self.path = path
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an environment variable that is available to builds for the build project.
    public struct AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {
        /// The name of the environment variable.
        public var name: Swift.String?
        /// The type of environment variable.
        public var type: Swift.String?
        /// The value of the environment variable.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// The credentials for access to a private registry.
    public struct AwsCodeBuildProjectEnvironmentRegistryCredential {
        /// The ARN or name of credentials created using Secrets Manager. The credential can use the name of the credentials only if they exist in your current Amazon Web Services Region.
        public var credential: Swift.String?
        /// The service that created the credentials to access a private Docker registry. The valid value, SECRETS_MANAGER, is for Secrets Manager.
        public var credentialProvider: Swift.String?

        public init(
            credential: Swift.String? = nil,
            credentialProvider: Swift.String? = nil
        )
        {
            self.credential = credential
            self.credentialProvider = credentialProvider
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the build environment for this build project.
    public struct AwsCodeBuildProjectEnvironment {
        /// The certificate to use with this build project.
        public var certificate: Swift.String?
        /// A set of environment variables to make available to builds for the build project.
        public var environmentVariables: [SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]?
        /// The type of credentials CodeBuild uses to pull images in your build. Valid values:
        ///
        /// * CODEBUILD specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust the CodeBuild service principal.
        ///
        /// * SERVICE_ROLE specifies that CodeBuild uses your build project's service role.
        ///
        ///
        /// When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an CodeBuild curated image, you must use CODEBUILD credentials.
        public var imagePullCredentialsType: Swift.String?
        /// Whether to allow the Docker daemon to run inside a Docker container. Set to true if the build project is used to build Docker images.
        public var privilegedMode: Swift.Bool?
        /// The credentials for access to a private registry.
        public var registryCredential: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential?
        /// The type of build environment to use for related builds. The environment type ARM_CONTAINER is available only in Regions US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt). The environment type LINUX_CONTAINER with compute type build.general1.2xlarge is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia). The environment type LINUX_GPU_CONTAINER is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia). Valid values: WINDOWS_CONTAINER | LINUX_CONTAINER | LINUX_GPU_CONTAINER | ARM_CONTAINER
        public var type: Swift.String?

        public init(
            certificate: Swift.String? = nil,
            environmentVariables: [SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]? = nil,
            imagePullCredentialsType: Swift.String? = nil,
            privilegedMode: Swift.Bool? = nil,
            registryCredential: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential? = nil,
            type: Swift.String? = nil
        )
        {
            self.certificate = certificate
            self.environmentVariables = environmentVariables
            self.imagePullCredentialsType = imagePullCredentialsType
            self.privilegedMode = privilegedMode
            self.registryCredential = registryCredential
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about CloudWatch Logs for the build project.
    public struct AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {
        /// The group name of the logs in CloudWatch Logs.
        public var groupName: Swift.String?
        /// The current status of the logs in CloudWatch Logs for a build project.
        public var status: Swift.String?
        /// The prefix of the stream name of the CloudWatch Logs.
        public var streamName: Swift.String?

        public init(
            groupName: Swift.String? = nil,
            status: Swift.String? = nil,
            streamName: Swift.String? = nil
        )
        {
            self.groupName = groupName
            self.status = status
            self.streamName = streamName
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about logs built to an S3 bucket for a build project.
    public struct AwsCodeBuildProjectLogsConfigS3LogsDetails {
        /// Whether to disable encryption of the S3 build log output.
        public var encryptionDisabled: Swift.Bool?
        /// The ARN of the S3 bucket and the path prefix for S3 logs.
        public var location: Swift.String?
        /// The current status of the S3 build logs.
        public var status: Swift.String?

        public init(
            encryptionDisabled: Swift.Bool? = nil,
            location: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about logs for the build project.
    public struct AwsCodeBuildProjectLogsConfigDetails {
        /// Information about CloudWatch Logs for the build project.
        public var cloudWatchLogs: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails?
        /// Information about logs built to an S3 bucket for a build project.
        public var s3Logs: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails?

        public init(
            cloudWatchLogs: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails? = nil,
            s3Logs: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Logs = s3Logs
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the build input source code for this build project.
    public struct AwsCodeBuildProjectSource {
        /// Information about the Git clone depth for the build project.
        public var gitCloneDepth: Swift.Int?
        /// Whether to ignore SSL warnings while connecting to the project source code.
        public var insecureSsl: Swift.Bool?
        /// Information about the location of the source code to be built. Valid values include:
        ///
        /// * For source code settings that are specified in the source action of a pipeline in CodePipeline, location should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.
        ///
        /// * For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the build spec file (for example, https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name ).
        ///
        /// * For source code in an S3 input bucket, one of the following.
        ///
        /// * The path to the ZIP file that contains the source code (for example, bucket-name/path/to/object-name.zip).
        ///
        /// * The path to the folder that contains the source code (for example, bucket-name/path/to/source-code/folder/).
        ///
        ///
        ///
        ///
        /// * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the build spec file.
        ///
        /// * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the build spec file.
        public var location: Swift.String?
        /// The type of repository that contains the source code to be built. Valid values are:
        ///
        /// * BITBUCKET - The source code is in a Bitbucket repository.
        ///
        /// * CODECOMMIT - The source code is in an CodeCommit repository.
        ///
        /// * CODEPIPELINE - The source code settings are specified in the source action of a pipeline in CodePipeline.
        ///
        /// * GITHUB - The source code is in a GitHub repository.
        ///
        /// * GITHUB_ENTERPRISE - The source code is in a GitHub Enterprise repository.
        ///
        /// * NO_SOURCE - The project does not have input source code.
        ///
        /// * S3 - The source code is in an S3 input bucket.
        public var type: Swift.String?

        public init(
            gitCloneDepth: Swift.Int? = nil,
            insecureSsl: Swift.Bool? = nil,
            location: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.gitCloneDepth = gitCloneDepth
            self.insecureSsl = insecureSsl
            self.location = location
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the VPC configuration that CodeBuild accesses.
    public struct AwsCodeBuildProjectVpcConfig {
        /// A list of one or more security group IDs in your VPC.
        public var securityGroupIds: [Swift.String]?
        /// A list of one or more subnet IDs in your VPC.
        public var subnets: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an CodeBuild project.
    public struct AwsCodeBuildProjectDetails {
        /// Information about the build artifacts for the CodeBuild project.
        public var artifacts: [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]?
        /// The KMS key used to encrypt the build output artifacts. You can specify either the ARN of the KMS key or, if available, the KMS key alias (using the format alias/alias-name).
        public var encryptionKey: Swift.String?
        /// Information about the build environment for this build project.
        public var environment: SecurityHubClientTypes.AwsCodeBuildProjectEnvironment?
        /// Information about logs for the build project.
        public var logsConfig: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails?
        /// The name of the build project.
        public var name: Swift.String?
        /// Information about the secondary artifacts for the CodeBuild project.
        public var secondaryArtifacts: [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]?
        /// The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.
        public var serviceRole: Swift.String?
        /// Information about the build input source code for this build project.
        public var source: SecurityHubClientTypes.AwsCodeBuildProjectSource?
        /// Information about the VPC configuration that CodeBuild accesses.
        public var vpcConfig: SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig?

        public init(
            artifacts: [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]? = nil,
            encryptionKey: Swift.String? = nil,
            environment: SecurityHubClientTypes.AwsCodeBuildProjectEnvironment? = nil,
            logsConfig: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails? = nil,
            name: Swift.String? = nil,
            secondaryArtifacts: [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]? = nil,
            serviceRole: Swift.String? = nil,
            source: SecurityHubClientTypes.AwsCodeBuildProjectSource? = nil,
            vpcConfig: SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig? = nil
        )
        {
            self.artifacts = artifacts
            self.encryptionKey = encryptionKey
            self.environment = environment
            self.logsConfig = logsConfig
            self.name = name
            self.secondaryArtifacts = secondaryArtifacts
            self.serviceRole = serviceRole
            self.source = source
            self.vpcConfig = vpcConfig
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Database Migration Service (DMS) endpoint. An endpoint provides connection, data store type, and location information about your data store.
    public struct AwsDmsEndpointDetails {
        /// The Amazon Resource Name (ARN) for the SSL certificate that encrypts connections between the DMS endpoint and the replication instance.
        public var certificateArn: Swift.String?
        /// The name of the endpoint database.
        public var databaseName: Swift.String?
        /// The Amazon Resource Name (ARN) of the endpoint.
        public var endpointArn: Swift.String?
        /// The database endpoint identifier.
        public var endpointIdentifier: Swift.String?
        /// The type of endpoint. Valid values are source and target.
        public var endpointType: Swift.String?
        /// The type of engine for the endpoint, depending on the EndpointType value.
        public var engineName: Swift.String?
        /// A value that can be used for cross-account validation.
        public var externalId: Swift.String?
        /// Additional attributes associated with the connection.
        public var extraConnectionAttributes: Swift.String?
        /// An DMS key identifier that is used to encrypt the connection parameters for the endpoint. If you don't specify a value for the KmsKeyId parameter, then DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// The port used to access the endpoint.
        public var port: Swift.Int?
        /// The name of the server where the endpoint database resides.
        public var serverName: Swift.String?
        /// The SSL mode used to connect to the endpoint. The default is none.
        public var sslMode: Swift.String?
        /// The user name to be used to log in to the endpoint database.
        public var username: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            endpointArn: Swift.String? = nil,
            endpointIdentifier: Swift.String? = nil,
            endpointType: Swift.String? = nil,
            engineName: Swift.String? = nil,
            externalId: Swift.String? = nil,
            extraConnectionAttributes: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            port: Swift.Int? = nil,
            serverName: Swift.String? = nil,
            sslMode: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.databaseName = databaseName
            self.endpointArn = endpointArn
            self.endpointIdentifier = endpointIdentifier
            self.endpointType = endpointType
            self.engineName = engineName
            self.externalId = externalId
            self.extraConnectionAttributes = extraConnectionAttributes
            self.kmsKeyId = kmsKeyId
            self.port = port
            self.serverName = serverName
            self.sslMode = sslMode
            self.username = username
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the replication subnet group.
    public struct AwsDmsReplicationInstanceReplicationSubnetGroupDetails {
        /// The identifier of the replication subnet group.
        public var replicationSubnetGroupIdentifier: Swift.String?

        public init(
            replicationSubnetGroupIdentifier: Swift.String? = nil
        )
        {
            self.replicationSubnetGroupIdentifier = replicationSubnetGroupIdentifier
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the virtual private cloud (VPC) security group that’s associated with the replication instance.
    public struct AwsDmsReplicationInstanceVpcSecurityGroupsDetails {
        /// The identifier of the VPC security group that’s associated with the replication instance.
        public var vpcSecurityGroupId: Swift.String?

        public init(
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Database Migration Service (DMS) replication instance. DMS uses a replication instance to connect to your source data store, read the source data, and format the data for consumption by the target data store.
    public struct AwsDmsReplicationInstanceDetails {
        /// The amount of storage (in gigabytes) that is allocated for the replication instance.
        public var allocatedStorage: Swift.Int?
        /// Indicates whether minor engine upgrades are applied automatically to the replication instance during the maintenance window.
        public var autoMinorVersionUpgrade: Swift.Bool?
        /// The Availability Zone that the replication instance is created in. The default value is a random, system-chosen Availability Zone in the endpoint's Amazon Web Services Region, such as us-east-1d.
        public var availabilityZone: Swift.String?
        /// The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.
        public var engineVersion: Swift.String?
        /// An KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the KmsKeyId parameter, DMS uses your default encryption key. KMS creates the default encryption key for your Amazon Web Services account. Your Amazon Web Services account has a different default encryption key for each Amazon Web Services Region.
        public var kmsKeyId: Swift.String?
        /// Specifies whether the replication instance is deployed across multiple Availability Zones (AZs). You can't set the AvailabilityZone parameter if the MultiAZ parameter is set to true.
        public var multiAZ: Swift.Bool?
        /// The maintenance window times for the replication instance. Upgrades to the replication instance are performed during this time.
        public var preferredMaintenanceWindow: Swift.String?
        /// Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address. The default value is true.
        public var publiclyAccessible: Swift.Bool?
        /// The compute and memory capacity of the replication instance as defined for the specified replication instance class.
        public var replicationInstanceClass: Swift.String?
        /// The replication instance identifier.
        public var replicationInstanceIdentifier: Swift.String?
        /// The subnet group for the replication instance.
        public var replicationSubnetGroup: SecurityHubClientTypes.AwsDmsReplicationInstanceReplicationSubnetGroupDetails?
        /// The virtual private cloud (VPC) security group for the replication instance.
        public var vpcSecurityGroups: [SecurityHubClientTypes.AwsDmsReplicationInstanceVpcSecurityGroupsDetails]?

        public init(
            allocatedStorage: Swift.Int? = nil,
            autoMinorVersionUpgrade: Swift.Bool? = nil,
            availabilityZone: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            replicationInstanceClass: Swift.String? = nil,
            replicationInstanceIdentifier: Swift.String? = nil,
            replicationSubnetGroup: SecurityHubClientTypes.AwsDmsReplicationInstanceReplicationSubnetGroupDetails? = nil,
            vpcSecurityGroups: [SecurityHubClientTypes.AwsDmsReplicationInstanceVpcSecurityGroupsDetails]? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.engineVersion = engineVersion
            self.kmsKeyId = kmsKeyId
            self.multiAZ = multiAZ
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.replicationInstanceClass = replicationInstanceClass
            self.replicationInstanceIdentifier = replicationInstanceIdentifier
            self.replicationSubnetGroup = replicationSubnetGroup
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Database Migration Service (DMS) replication task. A replication task moves a set of data from the source endpoint to the target endpoint.
    public struct AwsDmsReplicationTaskDetails {
        /// Indicates when you want a change data capture (CDC) operation to start. CCdcStartPosition or CCdcStartTime specifies when you want a CDC operation to start. Only a value for one of these fields is included.
        public var cdcStartPosition: Swift.String?
        /// Indicates the start time for a CDC operation. CdcStartPosition or CCdcStartTime specifies when you want a CDC operation to start. Only a value for one of these fields is included.
        public var cdcStartTime: Swift.String?
        /// Indicates when you want a CDC operation to stop. The value can be either server time or commit time.
        public var cdcStopPosition: Swift.String?
        /// The identifier of the replication task.
        public var id: Swift.String?
        /// The migration type.
        public var migrationType: Swift.String?
        /// The Amazon Resource Name (ARN) of a replication instance.
        public var replicationInstanceArn: Swift.String?
        /// The user-defined replication task identifier or name.
        public var replicationTaskIdentifier: Swift.String?
        /// The settings for the replication task.
        public var replicationTaskSettings: Swift.String?
        /// A display name for the resource identifier at the end of the EndpointArn response parameter. If you don't specify a ResourceIdentifier value, DMS generates a default identifier value for the end of EndpointArn.
        public var resourceIdentifier: Swift.String?
        /// The ARN of the source endpoint.
        public var sourceEndpointArn: Swift.String?
        /// The table mappings for the replication task, in JSON format.
        public var tableMappings: Swift.String?
        /// The ARN of the target endpoint.
        public var targetEndpointArn: Swift.String?
        /// Supplemental information that the task requires to migrate the data for certain source and target endpoints.
        public var taskData: Swift.String?

        public init(
            cdcStartPosition: Swift.String? = nil,
            cdcStartTime: Swift.String? = nil,
            cdcStopPosition: Swift.String? = nil,
            id: Swift.String? = nil,
            migrationType: Swift.String? = nil,
            replicationInstanceArn: Swift.String? = nil,
            replicationTaskIdentifier: Swift.String? = nil,
            replicationTaskSettings: Swift.String? = nil,
            resourceIdentifier: Swift.String? = nil,
            sourceEndpointArn: Swift.String? = nil,
            tableMappings: Swift.String? = nil,
            targetEndpointArn: Swift.String? = nil,
            taskData: Swift.String? = nil
        )
        {
            self.cdcStartPosition = cdcStartPosition
            self.cdcStartTime = cdcStartTime
            self.cdcStopPosition = cdcStopPosition
            self.id = id
            self.migrationType = migrationType
            self.replicationInstanceArn = replicationInstanceArn
            self.replicationTaskIdentifier = replicationTaskIdentifier
            self.replicationTaskSettings = replicationTaskSettings
            self.resourceIdentifier = resourceIdentifier
            self.sourceEndpointArn = sourceEndpointArn
            self.tableMappings = tableMappings
            self.targetEndpointArn = targetEndpointArn
            self.taskData = taskData
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains a definition of an attribute for the table.
    public struct AwsDynamoDbTableAttributeDefinition {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The type of the attribute.
        public var attributeType: Swift.String?

        public init(
            attributeName: Swift.String? = nil,
            attributeType: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the billing for read/write capacity on the table.
    public struct AwsDynamoDbTableBillingModeSummary {
        /// The method used to charge for read and write throughput and to manage capacity.
        public var billingMode: Swift.String?
        /// If the billing mode is PAY_PER_REQUEST, indicates when the billing mode was set to that value. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastUpdateToPayPerRequestDateTime: Swift.String?

        public init(
            billingMode: Swift.String? = nil,
            lastUpdateToPayPerRequestDateTime: Swift.String? = nil
        )
        {
            self.billingMode = billingMode
            self.lastUpdateToPayPerRequestDateTime = lastUpdateToPayPerRequestDateTime
        }
    }

}

extension SecurityHubClientTypes {
    /// A component of the key schema for the DynamoDB table, a global secondary index, or a local secondary index.
    public struct AwsDynamoDbTableKeySchema {
        /// The name of the key schema attribute.
        public var attributeName: Swift.String?
        /// The type of key used for the key schema attribute. Valid values are HASH or RANGE.
        public var keyType: Swift.String?

        public init(
            attributeName: Swift.String? = nil,
            keyType: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.keyType = keyType
        }
    }

}

extension SecurityHubClientTypes {
    /// For global and local secondary indexes, identifies the attributes that are copied from the table into the index.
    public struct AwsDynamoDbTableProjection {
        /// The nonkey attributes that are projected into the index. For each attribute, provide the attribute name.
        public var nonKeyAttributes: [Swift.String]?
        /// The types of attributes that are projected into the index. Valid values are as follows:
        ///
        /// * ALL
        ///
        /// * INCLUDE
        ///
        /// * KEYS_ONLY
        public var projectionType: Swift.String?

        public init(
            nonKeyAttributes: [Swift.String]? = nil,
            projectionType: Swift.String? = nil
        )
        {
            self.nonKeyAttributes = nonKeyAttributes
            self.projectionType = projectionType
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the provisioned throughput for the table or for a global secondary index.
    public struct AwsDynamoDbTableProvisionedThroughput {
        /// Indicates when the provisioned throughput was last decreased. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastDecreaseDateTime: Swift.String?
        /// Indicates when the provisioned throughput was last increased. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastIncreaseDateTime: Swift.String?
        /// The number of times during the current UTC calendar day that the provisioned throughput was decreased.
        public var numberOfDecreasesToday: Swift.Int?
        /// The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ThrottlingException.
        public var readCapacityUnits: Swift.Int?
        /// The maximum number of writes consumed per second before DynamoDB returns a ThrottlingException.
        public var writeCapacityUnits: Swift.Int?

        public init(
            lastDecreaseDateTime: Swift.String? = nil,
            lastIncreaseDateTime: Swift.String? = nil,
            numberOfDecreasesToday: Swift.Int? = nil,
            readCapacityUnits: Swift.Int? = nil,
            writeCapacityUnits: Swift.Int? = nil
        )
        {
            self.lastDecreaseDateTime = lastDecreaseDateTime
            self.lastIncreaseDateTime = lastIncreaseDateTime
            self.numberOfDecreasesToday = numberOfDecreasesToday
            self.readCapacityUnits = readCapacityUnits
            self.writeCapacityUnits = writeCapacityUnits
        }
    }

}

extension SecurityHubClientTypes {
    /// Information abut a global secondary index for the table.
    public struct AwsDynamoDbTableGlobalSecondaryIndex {
        /// Whether the index is currently backfilling.
        public var backfilling: Swift.Bool?
        /// The ARN of the index.
        public var indexArn: Swift.String?
        /// The name of the index.
        public var indexName: Swift.String?
        /// The total size in bytes of the index.
        public var indexSizeBytes: Swift.Int?
        /// The current status of the index.
        ///
        /// * ACTIVE
        ///
        /// * CREATING
        ///
        /// * DELETING
        ///
        /// * UPDATING
        public var indexStatus: Swift.String?
        /// The number of items in the index.
        public var itemCount: Swift.Int?
        /// The key schema for the index.
        public var keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]?
        /// Attributes that are copied from the table into an index.
        public var projection: SecurityHubClientTypes.AwsDynamoDbTableProjection?
        /// Information about the provisioned throughput settings for the indexes.
        public var provisionedThroughput: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput?

        public init(
            backfilling: Swift.Bool? = nil,
            indexArn: Swift.String? = nil,
            indexName: Swift.String? = nil,
            indexSizeBytes: Swift.Int? = nil,
            indexStatus: Swift.String? = nil,
            itemCount: Swift.Int? = nil,
            keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]? = nil,
            projection: SecurityHubClientTypes.AwsDynamoDbTableProjection? = nil,
            provisionedThroughput: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput? = nil
        )
        {
            self.backfilling = backfilling
            self.indexArn = indexArn
            self.indexName = indexName
            self.indexSizeBytes = indexSizeBytes
            self.indexStatus = indexStatus
            self.itemCount = itemCount
            self.keySchema = keySchema
            self.projection = projection
            self.provisionedThroughput = provisionedThroughput
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a local secondary index for a DynamoDB table.
    public struct AwsDynamoDbTableLocalSecondaryIndex {
        /// The ARN of the index.
        public var indexArn: Swift.String?
        /// The name of the index.
        public var indexName: Swift.String?
        /// The complete key schema for the index.
        public var keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]?
        /// Attributes that are copied from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        public var projection: SecurityHubClientTypes.AwsDynamoDbTableProjection?

        public init(
            indexArn: Swift.String? = nil,
            indexName: Swift.String? = nil,
            keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]? = nil,
            projection: SecurityHubClientTypes.AwsDynamoDbTableProjection? = nil
        )
        {
            self.indexArn = indexArn
            self.indexName = indexName
            self.keySchema = keySchema
            self.projection = projection
        }
    }

}

extension SecurityHubClientTypes {
    /// Replica-specific configuration for the provisioned throughput.
    public struct AwsDynamoDbTableProvisionedThroughputOverride {
        /// The read capacity units for the replica.
        public var readCapacityUnits: Swift.Int?

        public init(
            readCapacityUnits: Swift.Int? = nil
        )
        {
            self.readCapacityUnits = readCapacityUnits
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a global secondary index for a DynamoDB table replica.
    public struct AwsDynamoDbTableReplicaGlobalSecondaryIndex {
        /// The name of the index.
        public var indexName: Swift.String?
        /// Replica-specific configuration for the provisioned throughput for the index.
        public var provisionedThroughputOverride: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride?

        public init(
            indexName: Swift.String? = nil,
            provisionedThroughputOverride: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride? = nil
        )
        {
            self.indexName = indexName
            self.provisionedThroughputOverride = provisionedThroughputOverride
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a replica of a DynamoDB table.
    public struct AwsDynamoDbTableReplica {
        /// List of global secondary indexes for the replica.
        public var globalSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex]?
        /// The identifier of the KMS key that will be used for KMS encryption for the replica.
        public var kmsMasterKeyId: Swift.String?
        /// Replica-specific configuration for the provisioned throughput.
        public var provisionedThroughputOverride: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride?
        /// The name of the Region where the replica is located.
        public var regionName: Swift.String?
        /// The current status of the replica. Valid values are as follows:
        ///
        /// * ACTIVE
        ///
        /// * CREATING
        ///
        /// * CREATION_FAILED
        ///
        /// * DELETING
        ///
        /// * UPDATING
        public var replicaStatus: Swift.String?
        /// Detailed information about the replica status.
        public var replicaStatusDescription: Swift.String?

        public init(
            globalSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex]? = nil,
            kmsMasterKeyId: Swift.String? = nil,
            provisionedThroughputOverride: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride? = nil,
            regionName: Swift.String? = nil,
            replicaStatus: Swift.String? = nil,
            replicaStatusDescription: Swift.String? = nil
        )
        {
            self.globalSecondaryIndexes = globalSecondaryIndexes
            self.kmsMasterKeyId = kmsMasterKeyId
            self.provisionedThroughputOverride = provisionedThroughputOverride
            self.regionName = regionName
            self.replicaStatus = replicaStatus
            self.replicaStatusDescription = replicaStatusDescription
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the restore for the table.
    public struct AwsDynamoDbTableRestoreSummary {
        /// Indicates the point in time that the table was restored to. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var restoreDateTime: Swift.String?
        /// Whether a restore is currently in progress.
        public var restoreInProgress: Swift.Bool?
        /// The ARN of the source backup from which the table was restored.
        public var sourceBackupArn: Swift.String?
        /// The ARN of the source table for the backup.
        public var sourceTableArn: Swift.String?

        public init(
            restoreDateTime: Swift.String? = nil,
            restoreInProgress: Swift.Bool? = nil,
            sourceBackupArn: Swift.String? = nil,
            sourceTableArn: Swift.String? = nil
        )
        {
            self.restoreDateTime = restoreDateTime
            self.restoreInProgress = restoreInProgress
            self.sourceBackupArn = sourceBackupArn
            self.sourceTableArn = sourceTableArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the server-side encryption for the table.
    public struct AwsDynamoDbTableSseDescription {
        /// If the key is inaccessible, the date and time when DynamoDB detected that the key was inaccessible. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var inaccessibleEncryptionDateTime: Swift.String?
        /// The ARN of the KMS key that is used for the KMS encryption.
        public var kmsMasterKeyArn: Swift.String?
        /// The type of server-side encryption.
        public var sseType: Swift.String?
        /// The status of the server-side encryption.
        public var status: Swift.String?

        public init(
            inaccessibleEncryptionDateTime: Swift.String? = nil,
            kmsMasterKeyArn: Swift.String? = nil,
            sseType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.inaccessibleEncryptionDateTime = inaccessibleEncryptionDateTime
            self.kmsMasterKeyArn = kmsMasterKeyArn
            self.sseType = sseType
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// The current DynamoDB Streams configuration for the table.
    public struct AwsDynamoDbTableStreamSpecification {
        /// Indicates whether DynamoDB Streams is enabled on the table.
        public var streamEnabled: Swift.Bool?
        /// Determines the information that is written to the table.
        public var streamViewType: Swift.String?

        public init(
            streamEnabled: Swift.Bool? = nil,
            streamViewType: Swift.String? = nil
        )
        {
            self.streamEnabled = streamEnabled
            self.streamViewType = streamViewType
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about a DynamoDB table.
    public struct AwsDynamoDbTableDetails {
        /// A list of attribute definitions for the table.
        public var attributeDefinitions: [SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition]?
        /// Information about the billing for read/write capacity on the table.
        public var billingModeSummary: SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary?
        /// Indicates when the table was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var creationDateTime: Swift.String?
        /// Indicates whether deletion protection is to be enabled (true) or disabled (false) on the table.
        public var deletionProtectionEnabled: Swift.Bool?
        /// List of global secondary indexes for the table.
        public var globalSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex]?
        /// The version of global tables being used.
        public var globalTableVersion: Swift.String?
        /// The number of items in the table.
        public var itemCount: Swift.Int?
        /// The primary key structure for the table.
        public var keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]?
        /// The ARN of the latest stream for the table.
        public var latestStreamArn: Swift.String?
        /// The label of the latest stream. The label is not a unique identifier.
        public var latestStreamLabel: Swift.String?
        /// The list of local secondary indexes for the table.
        public var localSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex]?
        /// Information about the provisioned throughput for the table.
        public var provisionedThroughput: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput?
        /// The list of replicas of this table.
        public var replicas: [SecurityHubClientTypes.AwsDynamoDbTableReplica]?
        /// Information about the restore for the table.
        public var restoreSummary: SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary?
        /// Information about the server-side encryption for the table.
        public var sseDescription: SecurityHubClientTypes.AwsDynamoDbTableSseDescription?
        /// The current DynamoDB Streams configuration for the table.
        public var streamSpecification: SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification?
        /// The identifier of the table.
        public var tableId: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?
        /// The total size of the table in bytes.
        public var tableSizeBytes: Swift.Int?
        /// The current status of the table. Valid values are as follows:
        ///
        /// * ACTIVE
        ///
        /// * ARCHIVED
        ///
        /// * ARCHIVING
        ///
        /// * CREATING
        ///
        /// * DELETING
        ///
        /// * INACCESSIBLE_ENCRYPTION_CREDENTIALS
        ///
        /// * UPDATING
        public var tableStatus: Swift.String?

        public init(
            attributeDefinitions: [SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition]? = nil,
            billingModeSummary: SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary? = nil,
            creationDateTime: Swift.String? = nil,
            deletionProtectionEnabled: Swift.Bool? = nil,
            globalSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex]? = nil,
            globalTableVersion: Swift.String? = nil,
            itemCount: Swift.Int? = nil,
            keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]? = nil,
            latestStreamArn: Swift.String? = nil,
            latestStreamLabel: Swift.String? = nil,
            localSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex]? = nil,
            provisionedThroughput: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput? = nil,
            replicas: [SecurityHubClientTypes.AwsDynamoDbTableReplica]? = nil,
            restoreSummary: SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary? = nil,
            sseDescription: SecurityHubClientTypes.AwsDynamoDbTableSseDescription? = nil,
            streamSpecification: SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification? = nil,
            tableId: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tableSizeBytes: Swift.Int? = nil,
            tableStatus: Swift.String? = nil
        )
        {
            self.attributeDefinitions = attributeDefinitions
            self.billingModeSummary = billingModeSummary
            self.creationDateTime = creationDateTime
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.globalSecondaryIndexes = globalSecondaryIndexes
            self.globalTableVersion = globalTableVersion
            self.itemCount = itemCount
            self.keySchema = keySchema
            self.latestStreamArn = latestStreamArn
            self.latestStreamLabel = latestStreamLabel
            self.localSecondaryIndexes = localSecondaryIndexes
            self.provisionedThroughput = provisionedThroughput
            self.replicas = replicas
            self.restoreSummary = restoreSummary
            self.sseDescription = sseDescription
            self.streamSpecification = streamSpecification
            self.tableId = tableId
            self.tableName = tableName
            self.tableSizeBytes = tableSizeBytes
            self.tableStatus = tableStatus
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Active Directory that’s used to authenticate an Client VPN endpoint.
    public struct AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails {
        /// The ID of the Active Directory used for authentication.
        public var directoryId: Swift.String?

        public init(
            directoryId: Swift.String? = nil
        )
        {
            self.directoryId = directoryId
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes the IAM SAML identity providers used for federated authentication.
    public struct AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails {
        /// The Amazon Resource Name (ARN) of the IAM SAML identity provider.
        public var samlProviderArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM SAML identity provider for the self-service portal.
        public var selfServiceSamlProviderArn: Swift.String?

        public init(
            samlProviderArn: Swift.String? = nil,
            selfServiceSamlProviderArn: Swift.String? = nil
        )
        {
            self.samlProviderArn = samlProviderArn
            self.selfServiceSamlProviderArn = selfServiceSamlProviderArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the client certificate used for authentication.
    public struct AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails {
        /// The Amazon Resource Name (ARN) of the client certificate.
        public var clientRootCertificateChain: Swift.String?

        public init(
            clientRootCertificateChain: Swift.String? = nil
        )
        {
            self.clientRootCertificateChain = clientRootCertificateChain
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the authentication method used by the Client VPN endpoint.
    public struct AwsEc2ClientVpnEndpointAuthenticationOptionsDetails {
        /// Information about the Active Directory, if applicable. With Active Directory authentication, clients are authenticated against existing Active Directory groups.
        public var activeDirectory: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails?
        /// Information about the IAM SAML identity provider, if applicable.
        public var federatedAuthentication: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails?
        /// Information about the authentication certificates, if applicable.
        public var mutualAuthentication: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails?
        /// The authentication type used.
        public var type: Swift.String?

        public init(
            activeDirectory: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails? = nil,
            federatedAuthentication: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails? = nil,
            mutualAuthentication: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails? = nil,
            type: Swift.String? = nil
        )
        {
            self.activeDirectory = activeDirectory
            self.federatedAuthentication = federatedAuthentication
            self.mutualAuthentication = mutualAuthentication
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes the status of the Client VPN endpoint attribute.
    public struct AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails {
        /// The status code.
        public var code: Swift.String?
        /// The status message.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension SecurityHubClientTypes {
    /// The options for managing connection authorization for new client connections.
    public struct AwsEc2ClientVpnEndpointClientConnectOptionsDetails {
        /// Indicates whether client connect options are enabled.
        public var enabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the Lambda function used for connection authorization.
        public var lambdaFunctionArn: Swift.String?
        /// The status of any updates to the client connect options.
        public var status: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails?

        public init(
            enabled: Swift.Bool? = nil,
            lambdaFunctionArn: Swift.String? = nil,
            status: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails? = nil
        )
        {
            self.enabled = enabled
            self.lambdaFunctionArn = lambdaFunctionArn
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Options for enabling a customizable text banner that will be displayed on Amazon Web Services provided clients when a VPN session is established.
    public struct AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails {
        /// Customizable text that will be displayed in a banner on Amazon Web Services provided clients when a VPN session is established.
        public var bannerText: Swift.String?
        /// Current state of text banner feature.
        public var enabled: Swift.Bool?

        public init(
            bannerText: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.bannerText = bannerText
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the client connection logging options for the Client VPN endpoint.
    public struct AwsEc2ClientVpnEndpointConnectionLogOptionsDetails {
        /// The name of the Amazon CloudWatch Logs log group to which connection logging data is published.
        public var cloudwatchLogGroup: Swift.String?
        /// The name of the Amazon CloudWatch Logs log stream to which connection logging data is published.
        public var cloudwatchLogStream: Swift.String?
        /// Indicates whether client connection logging is enabled for the Client VPN endpoint.
        public var enabled: Swift.Bool?

        public init(
            cloudwatchLogGroup: Swift.String? = nil,
            cloudwatchLogStream: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.cloudwatchLogGroup = cloudwatchLogGroup
            self.cloudwatchLogStream = cloudwatchLogStream
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes an Client VPN endpoint. A Client VPN endpoint is the resource that you create and configure to enable and manage client VPN sessions. It's the termination point for all client VPN sessions.
    public struct AwsEc2ClientVpnEndpointDetails {
        /// Information about the authentication method used by the Client VPN endpoint.
        public var authenticationOptions: [SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsDetails]?
        /// The IPv4 address range, in CIDR notation, from which client IP addresses are assigned.
        public var clientCidrBlock: Swift.String?
        /// The options for managing connection authorization for new client connections.
        public var clientConnectOptions: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsDetails?
        /// Options for enabling a customizable text banner that will be displayed on Amazon Web Services provided clients when a VPN session is established.
        public var clientLoginBannerOptions: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails?
        /// The ID of the Client VPN endpoint.
        public var clientVpnEndpointId: Swift.String?
        /// Information about the client connection logging options for the Client VPN endpoint.
        public var connectionLogOptions: SecurityHubClientTypes.AwsEc2ClientVpnEndpointConnectionLogOptionsDetails?
        /// A brief description of the endpoint.
        public var description: Swift.String?
        /// Information about the DNS servers to be used for DNS resolution.
        public var dnsServer: [Swift.String]?
        /// The IDs of the security groups for the target network.
        public var securityGroupIdSet: [Swift.String]?
        /// The URL of the self-service portal.
        public var selfServicePortalUrl: Swift.String?
        /// The Amazon Resource Name (ARN) of the server certificate.
        public var serverCertificateArn: Swift.String?
        /// The maximum VPN session duration time in hours.
        public var sessionTimeoutHours: Swift.Int?
        /// Indicates whether split-tunnel is enabled in the Client VPN endpoint.
        public var splitTunnel: Swift.Bool?
        /// The transport protocol used by the Client VPN endpoint.
        public var transportProtocol: Swift.String?
        /// The ID of the VPC.
        public var vpcId: Swift.String?
        /// The port number for the Client VPN endpoint.
        public var vpnPort: Swift.Int?

        public init(
            authenticationOptions: [SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsDetails]? = nil,
            clientCidrBlock: Swift.String? = nil,
            clientConnectOptions: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsDetails? = nil,
            clientLoginBannerOptions: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails? = nil,
            clientVpnEndpointId: Swift.String? = nil,
            connectionLogOptions: SecurityHubClientTypes.AwsEc2ClientVpnEndpointConnectionLogOptionsDetails? = nil,
            description: Swift.String? = nil,
            dnsServer: [Swift.String]? = nil,
            securityGroupIdSet: [Swift.String]? = nil,
            selfServicePortalUrl: Swift.String? = nil,
            serverCertificateArn: Swift.String? = nil,
            sessionTimeoutHours: Swift.Int? = nil,
            splitTunnel: Swift.Bool? = nil,
            transportProtocol: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            vpnPort: Swift.Int? = nil
        )
        {
            self.authenticationOptions = authenticationOptions
            self.clientCidrBlock = clientCidrBlock
            self.clientConnectOptions = clientConnectOptions
            self.clientLoginBannerOptions = clientLoginBannerOptions
            self.clientVpnEndpointId = clientVpnEndpointId
            self.connectionLogOptions = connectionLogOptions
            self.description = description
            self.dnsServer = dnsServer
            self.securityGroupIdSet = securityGroupIdSet
            self.selfServicePortalUrl = selfServicePortalUrl
            self.serverCertificateArn = serverCertificateArn
            self.sessionTimeoutHours = sessionTimeoutHours
            self.splitTunnel = splitTunnel
            self.transportProtocol = transportProtocol
            self.vpcId = vpcId
            self.vpnPort = vpnPort
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an Elastic IP address.
    public struct AwsEc2EipDetails {
        /// The identifier that Amazon Web Services assigns to represent the allocation of the Elastic IP address for use with Amazon VPC.
        public var allocationId: Swift.String?
        /// The identifier that represents the association of the Elastic IP address with an EC2 instance.
        public var associationId: Swift.String?
        /// The domain in which to allocate the address. If the address is for use with EC2 instances in a VPC, then Domain is vpc. Otherwise, Domain is standard.
        public var domain: Swift.String?
        /// The identifier of the EC2 instance.
        public var instanceId: Swift.String?
        /// The name of the location from which the Elastic IP address is advertised.
        public var networkBorderGroup: Swift.String?
        /// The identifier of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The Amazon Web Services account ID of the owner of the network interface.
        public var networkInterfaceOwnerId: Swift.String?
        /// The private IP address that is associated with the Elastic IP address.
        public var privateIpAddress: Swift.String?
        /// A public IP address that is associated with the EC2 instance.
        public var publicIp: Swift.String?
        /// The identifier of an IP address pool. This parameter allows Amazon EC2 to select an IP address from the address pool.
        public var publicIpv4Pool: Swift.String?

        public init(
            allocationId: Swift.String? = nil,
            associationId: Swift.String? = nil,
            domain: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            networkBorderGroup: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            networkInterfaceOwnerId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            publicIpv4Pool: Swift.String? = nil
        )
        {
            self.allocationId = allocationId
            self.associationId = associationId
            self.domain = domain
            self.instanceId = instanceId
            self.networkBorderGroup = networkBorderGroup
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfaceOwnerId = networkInterfaceOwnerId
            self.privateIpAddress = privateIpAddress
            self.publicIp = publicIp
            self.publicIpv4Pool = publicIpv4Pool
        }
    }

}

extension SecurityHubClientTypes {
    /// Metadata options that allow you to configure and secure the Amazon EC2 instance.
    public struct AwsEc2InstanceMetadataOptions {
        /// Enables or disables the HTTP metadata endpoint on the instance.
        public var httpEndpoint: Swift.String?
        /// Enables or disables the IPv6 endpoint for the instance metadata service.
        public var httpProtocolIpv6: Swift.String?
        /// The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        public var httpPutResponseHopLimit: Swift.Int?
        /// The state of token usage for your instance metadata requests.
        public var httpTokens: Swift.String?
        /// Specifies whether to allow access to instance tags from the instance metadata.
        public var instanceMetadataTags: Swift.String?

        public init(
            httpEndpoint: Swift.String? = nil,
            httpProtocolIpv6: Swift.String? = nil,
            httpPutResponseHopLimit: Swift.Int? = nil,
            httpTokens: Swift.String? = nil,
            instanceMetadataTags: Swift.String? = nil
        )
        {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }
    }

}

extension SecurityHubClientTypes {
    /// The type of monitoring that’s turned on for an Amazon EC2 instance.
    public struct AwsEc2InstanceMonitoringDetails {
        /// Indicates whether detailed monitoring is turned on. Otherwise, basic monitoring is turned on.
        public var state: Swift.String?

        public init(
            state: Swift.String? = nil
        )
        {
            self.state = state
        }
    }

}

extension SecurityHubClientTypes {
    /// Identifies a network interface for the Amazon EC2 instance.
    public struct AwsEc2InstanceNetworkInterfacesDetails {
        /// The identifier of the network interface. The details are in a corresponding AwsEc2NetworkInterfacesDetails object.
        public var networkInterfaceId: Swift.String?

        public init(
            networkInterfaceId: Swift.String? = nil
        )
        {
            self.networkInterfaceId = networkInterfaceId
        }
    }

}

extension SecurityHubClientTypes {
    /// The details of an Amazon EC2 instance.
    public struct AwsEc2InstanceDetails {
        /// The IAM profile ARN of the instance.
        public var iamInstanceProfileArn: Swift.String?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public var imageId: Swift.String?
        /// The IPv4 addresses associated with the instance.
        public var ipV4Addresses: [Swift.String]?
        /// The IPv6 addresses associated with the instance.
        public var ipV6Addresses: [Swift.String]?
        /// The key name associated with the instance.
        public var keyName: Swift.String?
        /// Indicates when the instance was launched. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var launchedAt: Swift.String?
        /// Details about the metadata options for the Amazon EC2 instance.
        public var metadataOptions: SecurityHubClientTypes.AwsEc2InstanceMetadataOptions?
        /// Describes the type of monitoring that’s turned on for an instance.
        public var monitoring: SecurityHubClientTypes.AwsEc2InstanceMonitoringDetails?
        /// The identifiers of the network interfaces for the EC2 instance. The details for each network interface are in a corresponding AwsEc2NetworkInterfacesDetails object.
        public var networkInterfaces: [SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails]?
        /// The identifier of the subnet that the instance was launched in.
        public var subnetId: Swift.String?
        /// The instance type of the instance.
        public var type: Swift.String?
        /// The virtualization type of the Amazon Machine Image (AMI) required to launch the instance.
        public var virtualizationType: Swift.String?
        /// The identifier of the VPC that the instance was launched in.
        public var vpcId: Swift.String?

        public init(
            iamInstanceProfileArn: Swift.String? = nil,
            imageId: Swift.String? = nil,
            ipV4Addresses: [Swift.String]? = nil,
            ipV6Addresses: [Swift.String]? = nil,
            keyName: Swift.String? = nil,
            launchedAt: Swift.String? = nil,
            metadataOptions: SecurityHubClientTypes.AwsEc2InstanceMetadataOptions? = nil,
            monitoring: SecurityHubClientTypes.AwsEc2InstanceMonitoringDetails? = nil,
            networkInterfaces: [SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails]? = nil,
            subnetId: Swift.String? = nil,
            type: Swift.String? = nil,
            virtualizationType: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.metadataOptions = metadataOptions
            self.monitoring = monitoring
            self.networkInterfaces = networkInterfaces
            self.subnetId = subnetId
            self.type = type
            self.virtualizationType = virtualizationType
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Parameters for a block device for an Amazon Elastic Block Store (Amazon EBS) volume in an Amazon EC2 launch template.
    public struct AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails {
        /// Indicates whether the EBS volume is deleted on instance termination.
        public var deleteOnTermination: Swift.Bool?
        /// Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you're creating a volume from a snapshot, you can't specify an encryption value.
        public var encrypted: Swift.Bool?
        /// The number of I/O operations per second (IOPS).
        public var iops: Swift.Int?
        /// The Amazon Resource Name (ARN) of the symmetric Key Management Service (KMS) customer managed key used for encryption.
        public var kmsKeyId: Swift.String?
        /// The ID of the EBS snapshot.
        public var snapshotId: Swift.String?
        /// The throughput to provision for a gp3 volume, with a maximum of 1,000 MiB/s.
        public var throughput: Swift.Int?
        /// The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
        public var volumeSize: Swift.Int?
        /// The volume type.
        public var volumeType: Swift.String?

        public init(
            deleteOnTermination: Swift.Bool? = nil,
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            snapshotId: Swift.String? = nil,
            throughput: Swift.Int? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a block device mapping for an Amazon Elastic Compute Cloud (Amazon EC2) launch template.
    public struct AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails {
        /// The device name.
        public var deviceName: Swift.String?
        /// Parameters used to automatically set up Amazon EBS volumes when the instance is launched.
        public var ebs: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails?
        /// Omits the device from the block device mapping when an empty string is specified.
        public var noDevice: Swift.String?
        /// The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type.
        public var virtualName: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            ebs: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the target Capacity Reservation or Capacity Reservation group in which to run an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails {
        /// The ID of the Capacity Reservation in which to run the instance.
        public var capacityReservationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Capacity Reservation resource group in which to run the instance.
        public var capacityReservationResourceGroupArn: Swift.String?

        public init(
            capacityReservationId: Swift.String? = nil,
            capacityReservationResourceGroupArn: Swift.String? = nil
        )
        {
            self.capacityReservationId = capacityReservationId
            self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the Capacity Reservation targeting option of an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails {
        /// Indicates the instance's Capacity Reservation preferences. If equal to open, the instance can run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). If equal to none, the instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        public var capacityReservationPreference: Swift.String?
        /// Specifies a target Capacity Reservation.
        public var capacityReservationTarget: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails?

        public init(
            capacityReservationPreference: Swift.String? = nil,
            capacityReservationTarget: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails? = nil
        )
        {
            self.capacityReservationPreference = capacityReservationPreference
            self.capacityReservationTarget = capacityReservationTarget
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the CPU options for an Amazon EC2 instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the Amazon Elastic Compute Cloud User Guide.
    public struct AwsEc2LaunchTemplateDataCpuOptionsDetails {
        /// The number of CPU cores for the instance.
        public var coreCount: Swift.Int?
        /// The number of threads per CPU core. A value of 1 disables multithreading for the instance, The default value is 2.
        public var threadsPerCore: Swift.Int?

        public init(
            coreCount: Swift.Int? = nil,
            threadsPerCore: Swift.Int? = nil
        )
        {
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the credit option for CPU usage of a T2, T3, or T3a Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataCreditSpecificationDetails {
        /// The credit option for CPU usage of a T instance.
        public var cpuCredits: Swift.String?

        public init(
            cpuCredits: Swift.String? = nil
        )
        {
            self.cpuCredits = cpuCredits
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Elastic Graphics specification for an Amazon EC2 launch template.
    public struct AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails {
        /// The type of Elastic Graphics accelerator.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details for an Amazon Elastic Inference accelerator.
    public struct AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails {
        /// The number of Elastic Inference accelerators to attach to the instance.
        public var count: Swift.Int?
        /// The type of Elastic Inference accelerator.
        public var type: Swift.String?

        public init(
            count: Swift.Int? = nil,
            type: Swift.String? = nil
        )
        {
            self.count = count
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.
    public struct AwsEc2LaunchTemplateDataEnclaveOptionsDetails {
        /// If this parameter is set to true, the instance is enabled for Amazon Web Services Nitro Enclaves.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies whether your Amazon EC2 instance is configured for hibernation.
    public struct AwsEc2LaunchTemplateDataHibernationOptionsDetails {
        /// If you set this parameter to true, the instance is enabled for hibernation.
        public var configured: Swift.Bool?

        public init(
            configured: Swift.Bool? = nil
        )
        {
            self.configured = configured
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details for an Identity and Access Management (IAM) instance profile, which is a container for an IAM role for your instance.
    public struct AwsEc2LaunchTemplateDataIamInstanceProfileDetails {
        /// The Amazon Resource Name (ARN) of the instance profile.
        public var arn: Swift.String?
        /// The name of the instance profile.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the market (purchasing) options for Spot Instances.
    public struct AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails {
        /// Deprecated.
        public var blockDurationMinutes: Swift.Int?
        /// The behavior when a Spot Instance is interrupted.
        public var instanceInterruptionBehavior: Swift.String?
        /// The maximum hourly price you're willing to pay for the Spot Instances.
        public var maxPrice: Swift.String?
        /// The Spot Instance request type.
        public var spotInstanceType: Swift.String?
        /// The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ), for persistent requests.
        public var validUntil: Swift.String?

        public init(
            blockDurationMinutes: Swift.Int? = nil,
            instanceInterruptionBehavior: Swift.String? = nil,
            maxPrice: Swift.String? = nil,
            spotInstanceType: Swift.String? = nil,
            validUntil: Swift.String? = nil
        )
        {
            self.blockDurationMinutes = blockDurationMinutes
            self.instanceInterruptionBehavior = instanceInterruptionBehavior
            self.maxPrice = maxPrice
            self.spotInstanceType = spotInstanceType
            self.validUntil = validUntil
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the market (purchasing) option for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails {
        /// The market type.
        public var marketType: Swift.String?
        /// The options for Spot Instances.
        public var spotOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails?

        public init(
            marketType: Swift.String? = nil,
            spotOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails? = nil
        )
        {
            self.marketType = marketType
            self.spotOptions = spotOptions
        }
    }

}

extension SecurityHubClientTypes {
    /// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails {
        /// The maximum number of accelerators. If this parameter isn't specified, there's no maximum limit. To exclude accelerator-enabled instance types, set Max to 0.
        public var max: Swift.Int?
        /// The minimum number of accelerators. If this parameter isn't specified, there's no minimum limit.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The minimum and maximum amount of memory, in MiB, for the accelerators on an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails {
        /// The maximum amount of memory, in MiB. If this parameter isn't specified, there's no maximum limit.
        public var max: Swift.Int?
        /// The minimum amount of memory, in MiB. If 0 is specified, there's no maximum limit.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The minimum and maximum baseline bandwidth to Amazon Elastic Block Store (Amazon EBS), in Mbps. For more information, see [Amazon EBS–optimized instances ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the Amazon EC2 User Guide.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails {
        /// The maximum baseline bandwidth, in Mbps. If this parameter is omitted, there's no maximum limit.
        public var max: Swift.Int?
        /// The minimum baseline bandwidth, in Mbps. If this parameter is omitted, there's no minimum limit.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The minimum and maximum amount of memory per vCPU, in GiB.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails {
        /// The maximum amount of memory per vCPU, in GiB. If this parameter is omitted, there's no maximum limit.
        public var max: Swift.Double?
        /// The minimum amount of memory per vCPU, in GiB. If this parameter is omitted, there's no maximum limit.
        public var min: Swift.Double?

        public init(
            max: Swift.Double? = nil,
            min: Swift.Double? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The minimum and maximum amount of memory, in MiB, for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails {
        /// The maximum amount of memory, in MiB.
        public var max: Swift.Int?
        /// The minimum amount of memory, in MiB.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The minimum and maximum number of network interfaces to be attached to an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails {
        /// The maximum number of network interfaces.
        public var max: Swift.Int?
        /// The minimum number of network interfaces.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The minimum and maximum amount of total local storage, in GB, that an Amazon EC2 instance uses.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails {
        /// The maximum amount of total local storage, in GB.
        public var max: Swift.Double?
        /// The minimum amount of total local storage, in GB.
        public var min: Swift.Double?

        public init(
            max: Swift.Double? = nil,
            min: Swift.Double? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The minimum and maximum number of vCPUs for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails {
        /// The maximum number of vCPUs.
        public var max: Swift.Int?
        /// The minimum number of vCPUs.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The attributes for the Amazon EC2 instance types.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsDetails {
        /// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an instance.
        public var acceleratorCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails?
        /// Indicates whether instance types must have accelerators by specific manufacturers.
        public var acceleratorManufacturers: [Swift.String]?
        /// The accelerators that must be on the instance type.
        public var acceleratorNames: [Swift.String]?
        /// The minimum and maximum amount of total accelerator memory, in MiB.
        public var acceleratorTotalMemoryMiB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails?
        /// The accelerator types that must be on the instance type.
        public var acceleratorTypes: [Swift.String]?
        /// Indicates whether bare metal instance types must be included, excluded, or required.
        public var bareMetal: Swift.String?
        /// The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBS optimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the Amazon EC2 User Guide.
        public var baselineEbsBandwidthMbps: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails?
        /// Indicates whether burstable performance T instance types are included, excluded, or required. For more information, [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the Amazon EC2 User Guide.
        public var burstablePerformance: Swift.String?
        /// The CPU manufacturers to include.
        public var cpuManufacturers: [Swift.String]?
        /// The instance types to exclude.
        public var excludedInstanceTypes: [Swift.String]?
        /// Indicates whether current or previous generation instance types are included.
        public var instanceGenerations: [Swift.String]?
        /// Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, see [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the Amazon EC2 User Guide.
        public var localStorage: Swift.String?
        /// The type of local storage that is required.
        public var localStorageTypes: [Swift.String]?
        /// The minimum and maximum amount of memory per vCPU, in GiB.
        public var memoryGiBPerVCpu: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails?
        /// The minimum and maximum amount of memory, in MiB.
        public var memoryMiB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails?
        /// The minimum and maximum number of network interfaces.
        public var networkInterfaceCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails?
        /// The price protection threshold for On-Demand Instances. This is the maximum you'll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. A high value, such as 999999, turns off price protection.
        public var onDemandMaxPricePercentageOverLowestPrice: Swift.Int?
        /// Indicates whether instance types must support hibernation for On-Demand Instances.
        public var requireHibernateSupport: Swift.Bool?
        /// The price protection threshold for Spot Instances. This is the maximum you'll pay for a Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. A high value, such as 999999, turns off price protection.
        public var spotMaxPricePercentageOverLowestPrice: Swift.Int?
        /// The minimum and maximum amount of total local storage, in GB.
        public var totalLocalStorageGB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails?
        /// The minimum and maximum number of vCPUs.
        public var vCpuCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails?

        public init(
            acceleratorCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails? = nil,
            acceleratorManufacturers: [Swift.String]? = nil,
            acceleratorNames: [Swift.String]? = nil,
            acceleratorTotalMemoryMiB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails? = nil,
            acceleratorTypes: [Swift.String]? = nil,
            bareMetal: Swift.String? = nil,
            baselineEbsBandwidthMbps: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails? = nil,
            burstablePerformance: Swift.String? = nil,
            cpuManufacturers: [Swift.String]? = nil,
            excludedInstanceTypes: [Swift.String]? = nil,
            instanceGenerations: [Swift.String]? = nil,
            localStorage: Swift.String? = nil,
            localStorageTypes: [Swift.String]? = nil,
            memoryGiBPerVCpu: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails? = nil,
            memoryMiB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails? = nil,
            networkInterfaceCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails? = nil,
            onDemandMaxPricePercentageOverLowestPrice: Swift.Int? = nil,
            requireHibernateSupport: Swift.Bool? = nil,
            spotMaxPricePercentageOverLowestPrice: Swift.Int? = nil,
            totalLocalStorageGB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails? = nil,
            vCpuCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails? = nil
        )
        {
            self.acceleratorCount = acceleratorCount
            self.acceleratorManufacturers = acceleratorManufacturers
            self.acceleratorNames = acceleratorNames
            self.acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB
            self.acceleratorTypes = acceleratorTypes
            self.bareMetal = bareMetal
            self.baselineEbsBandwidthMbps = baselineEbsBandwidthMbps
            self.burstablePerformance = burstablePerformance
            self.cpuManufacturers = cpuManufacturers
            self.excludedInstanceTypes = excludedInstanceTypes
            self.instanceGenerations = instanceGenerations
            self.localStorage = localStorage
            self.localStorageTypes = localStorageTypes
            self.memoryGiBPerVCpu = memoryGiBPerVCpu
            self.memoryMiB = memoryMiB
            self.networkInterfaceCount = networkInterfaceCount
            self.onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPrice
            self.requireHibernateSupport = requireHibernateSupport
            self.spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPrice
            self.totalLocalStorageGB = totalLocalStorageGB
            self.vCpuCount = vCpuCount
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the license configuration for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataLicenseSetDetails {
        /// The Amazon Resource Name (ARN) of the license configuration.
        public var licenseConfigurationArn: Swift.String?

        public init(
            licenseConfigurationArn: Swift.String? = nil
        )
        {
            self.licenseConfigurationArn = licenseConfigurationArn
        }
    }

}

extension SecurityHubClientTypes {
    /// The maintenance options of an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataMaintenanceOptionsDetails {
        /// Disables the automatic recovery behavior of your instance or sets it to default.
        public var autoRecovery: Swift.String?

        public init(
            autoRecovery: Swift.String? = nil
        )
        {
            self.autoRecovery = autoRecovery
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the metadata options for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataMetadataOptionsDetails {
        /// Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled, and you won't be able to access your instance metadata.
        public var httpEndpoint: Swift.String?
        /// Enables or disables the IPv6 endpoint for the instance metadata service.
        public var httpProtocolIpv6: Swift.String?
        /// The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        public var httpPutResponseHopLimit: Swift.Int?
        /// The state of token usage for your instance metadata requests.
        public var httpTokens: Swift.String?
        /// When set to enabled, this parameter allows access to instance tags from the instance metadata. When set to disabled, it turns off access to instance tags from the instance metadata. For more information, see [Work with instance tags in instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS) in the Amazon EC2 User Guide.
        public var instanceMetadataTags: Swift.String?

        public init(
            httpEndpoint: Swift.String? = nil,
            httpProtocolIpv6: Swift.String? = nil,
            httpPutResponseHopLimit: Swift.Int? = nil,
            httpTokens: Swift.String? = nil,
            instanceMetadataTags: Swift.String? = nil
        )
        {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }
    }

}

extension SecurityHubClientTypes {
    /// The monitoring for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataMonitoringDetails {
        /// Enables detailed monitoring when true is specified. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the Amazon EC2 User Guide.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details on one or more IPv4 prefixes for a network interface.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails {
        /// The IPv4 prefix. For more information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the Amazon Elastic Compute Cloud User Guide.
        public var ipv4Prefix: Swift.String?

        public init(
            ipv4Prefix: Swift.String? = nil
        )
        {
            self.ipv4Prefix = ipv4Prefix
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies an IPv6 address in an Amazon EC2 launch template.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails {
        /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
        public var ipv6Address: Swift.String?

        public init(
            ipv6Address: Swift.String? = nil
        )
        {
            self.ipv6Address = ipv6Address
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details on one or more IPv6 prefixes to be assigned to the network interface.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails {
        /// The IPv6 prefix.
        public var ipv6Prefix: Swift.String?

        public init(
            ipv6Prefix: Swift.String? = nil
        )
        {
            self.ipv6Prefix = ipv6Prefix
        }
    }

}

extension SecurityHubClientTypes {
    /// One or more private IPv4 addresses.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails {
        /// Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        public var primary: Swift.Bool?
        /// The private IPv4 address.
        public var privateIpAddress: Swift.String?

        public init(
            primary: Swift.Bool? = nil,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }
    }

}

extension SecurityHubClientTypes {
    /// One or more network interfaces to attach to an Amazon EC2 instance. If you specify a network interface, you must specify security groups and subnets as part of the network interface.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails {
        /// Indicates whether to associate a Carrier IP address with eth0 for a new network interface. You use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information, see [Carrier IP address](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the Wavelength Developer Guide.
        public var associateCarrierIpAddress: Swift.Bool?
        /// Associates a public IPv4 address with eth0 for a new network interface.
        public var associatePublicIpAddress: Swift.Bool?
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public var deleteOnTermination: Swift.Bool?
        /// A description for the network interface.
        public var description: Swift.String?
        /// The device index for the network interface attachment.
        public var deviceIndex: Swift.Int?
        /// The IDs of one or more security groups.
        public var groups: [Swift.String]?
        /// The type of network interface.
        public var interfaceType: Swift.String?
        /// The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the Ipv4Prefixes option.
        public var ipv4PrefixCount: Swift.Int?
        /// One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the Ipv4PrefixCount option.
        public var ipv4Prefixes: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]?
        /// The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if you use Ipv6Addresses.
        public var ipv6AddressCount: Swift.Int?
        /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you use Ipv6AddressCount.
        public var ipv6Addresses: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]?
        /// The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the Ipv6Prefix option.
        public var ipv6PrefixCount: Swift.Int?
        /// One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the Ipv6PrefixCount option.
        public var ipv6Prefixes: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]?
        /// The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        public var networkCardIndex: Swift.Int?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The primary private IPv4 address of the network interface.
        public var privateIpAddress: Swift.String?
        /// One or more private IPv4 addresses.
        public var privateIpAddresses: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]?
        /// The number of secondary private IPv4 addresses to assign to a network interface.
        public var secondaryPrivateIpAddressCount: Swift.Int?
        /// The ID of the subnet for the network interface.
        public var subnetId: Swift.String?

        public init(
            associateCarrierIpAddress: Swift.Bool? = nil,
            associatePublicIpAddress: Swift.Bool? = nil,
            deleteOnTermination: Swift.Bool? = nil,
            description: Swift.String? = nil,
            deviceIndex: Swift.Int? = nil,
            groups: [Swift.String]? = nil,
            interfaceType: Swift.String? = nil,
            ipv4PrefixCount: Swift.Int? = nil,
            ipv4Prefixes: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]? = nil,
            ipv6AddressCount: Swift.Int? = nil,
            ipv6Addresses: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]? = nil,
            ipv6PrefixCount: Swift.Int? = nil,
            ipv6Prefixes: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]? = nil,
            networkCardIndex: Swift.Int? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]? = nil,
            secondaryPrivateIpAddressCount: Swift.Int? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.associateCarrierIpAddress = associateCarrierIpAddress
            self.associatePublicIpAddress = associatePublicIpAddress
            self.deleteOnTermination = deleteOnTermination
            self.description = description
            self.deviceIndex = deviceIndex
            self.groups = groups
            self.interfaceType = interfaceType
            self.ipv4PrefixCount = ipv4PrefixCount
            self.ipv4Prefixes = ipv4Prefixes
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.ipv6PrefixCount = ipv6PrefixCount
            self.ipv6Prefixes = ipv6Prefixes
            self.networkCardIndex = networkCardIndex
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.subnetId = subnetId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the placement of an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataPlacementDetails {
        /// The affinity setting for an instance on an EC2 Dedicated Host.
        public var affinity: Swift.String?
        /// The Availability Zone for the instance.
        public var availabilityZone: Swift.String?
        /// The name of the placement group for the instance.
        public var groupName: Swift.String?
        /// The ID of the Dedicated Host for the instance.
        public var hostId: Swift.String?
        /// The Amazon Resource Name (ARN) of the host resource group in which to launch the instances.
        public var hostResourceGroupArn: Swift.String?
        /// The number of the partition the instance should launch in.
        public var partitionNumber: Swift.Int?
        /// Reserved for future use.
        public var spreadDomain: Swift.String?
        /// The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.
        public var tenancy: Swift.String?

        public init(
            affinity: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            groupName: Swift.String? = nil,
            hostId: Swift.String? = nil,
            hostResourceGroupArn: Swift.String? = nil,
            partitionNumber: Swift.Int? = nil,
            spreadDomain: Swift.String? = nil,
            tenancy: Swift.String? = nil
        )
        {
            self.affinity = affinity
            self.availabilityZone = availabilityZone
            self.groupName = groupName
            self.hostId = hostId
            self.hostResourceGroupArn = hostResourceGroupArn
            self.partitionNumber = partitionNumber
            self.spreadDomain = spreadDomain
            self.tenancy = tenancy
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes the options for Amazon EC2 instance hostnames.
    public struct AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails {
        /// Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        public var enableResourceNameDnsAAAARecord: Swift.Bool?
        /// Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        public var enableResourceNameDnsARecord: Swift.Bool?
        /// The type of hostname for EC2 instances.
        public var hostnameType: Swift.String?

        public init(
            enableResourceNameDnsAAAARecord: Swift.Bool? = nil,
            enableResourceNameDnsARecord: Swift.Bool? = nil,
            hostnameType: Swift.String? = nil
        )
        {
            self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
            self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
            self.hostnameType = hostnameType
        }
    }

}

extension SecurityHubClientTypes {
    /// The information to include in an Amazon Elastic Compute Cloud (Amazon EC2) launch template.
    public struct AwsEc2LaunchTemplateDataDetails {
        /// Information about a block device mapping for an Amazon EC2 launch template.
        public var blockDeviceMappingSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]?
        /// Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
        public var capacityReservationSpecification: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails?
        /// Specifies the CPU options for an instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the Amazon Elastic Compute Cloud User Guide.
        public var cpuOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails?
        /// Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
        public var creditSpecification: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails?
        /// Indicates whether to enable the instance for stop protection. For more information, see [Enable stop protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html#Using_StopProtection) in the Amazon EC2 User Guide.
        public var disableApiStop: Swift.Bool?
        /// If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API. If set to true, you can.
        public var disableApiTermination: Swift.Bool?
        /// Indicates whether the instance is optimized for Amazon EBS I/O.
        public var ebsOptimized: Swift.Bool?
        /// Provides details about Elastic Graphics accelerators to associate with the instance.
        public var elasticGpuSpecificationSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]?
        /// The Amazon Elastic Inference accelerator for the instance.
        public var elasticInferenceAcceleratorSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]?
        /// Indicates whether the Amazon EC2 instance is enabled for Amazon Web Services Nitro Enclaves.
        public var enclaveOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails?
        /// Specifies whether your Amazon EC2 instance is configured for hibernation.
        public var hibernationOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails?
        /// The name or Amazon Resource Name (ARN) of an IAM instance profile.
        public var iamInstanceProfile: SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails?
        /// The ID of the Amazon Machine Image (AMI).
        public var imageId: Swift.String?
        /// Provides the options for specifying the instance initiated shutdown behavior.
        public var instanceInitiatedShutdownBehavior: Swift.String?
        /// Specifies the market (purchasing) option for an instance.
        public var instanceMarketOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails?
        /// The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes. If you specify InstanceRequirements, you can't specify InstanceType.
        public var instanceRequirements: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails?
        /// The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the Amazon EC2 User Guide. If you specify InstanceType, you can't specify InstanceRequirements.
        public var instanceType: Swift.String?
        /// The ID of the kernel.
        public var kernelId: Swift.String?
        /// The name of the key pair that allows users to connect to the instance.
        public var keyName: Swift.String?
        /// Specifies a license configuration for an instance.
        public var licenseSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails]?
        /// The maintenance options of your instance.
        public var maintenanceOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails?
        /// The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the Amazon EC2 User Guide.
        public var metadataOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails?
        /// The monitoring for the instance.
        public var monitoring: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails?
        /// Specifies the parameters for a network interface that is attached to the instance.
        public var networkInterfaceSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]?
        /// Specifies the placement of an instance.
        public var placement: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails?
        /// The options for the instance hostname.
        public var privateDnsNameOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails?
        /// The ID of the RAM disk.
        public var ramDiskId: Swift.String?
        /// One or more security group IDs.
        public var securityGroupIdSet: [Swift.String]?
        /// One or more security group names. For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.
        public var securityGroupSet: [Swift.String]?
        /// The user data to make available to the instance.
        public var userData: Swift.String?

        public init(
            blockDeviceMappingSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]? = nil,
            capacityReservationSpecification: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails? = nil,
            cpuOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails? = nil,
            creditSpecification: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails? = nil,
            disableApiStop: Swift.Bool? = nil,
            disableApiTermination: Swift.Bool? = nil,
            ebsOptimized: Swift.Bool? = nil,
            elasticGpuSpecificationSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]? = nil,
            elasticInferenceAcceleratorSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]? = nil,
            enclaveOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails? = nil,
            hibernationOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails? = nil,
            iamInstanceProfile: SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails? = nil,
            imageId: Swift.String? = nil,
            instanceInitiatedShutdownBehavior: Swift.String? = nil,
            instanceMarketOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails? = nil,
            instanceRequirements: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails? = nil,
            instanceType: Swift.String? = nil,
            kernelId: Swift.String? = nil,
            keyName: Swift.String? = nil,
            licenseSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails]? = nil,
            maintenanceOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails? = nil,
            metadataOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails? = nil,
            monitoring: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails? = nil,
            networkInterfaceSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]? = nil,
            placement: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails? = nil,
            privateDnsNameOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails? = nil,
            ramDiskId: Swift.String? = nil,
            securityGroupIdSet: [Swift.String]? = nil,
            securityGroupSet: [Swift.String]? = nil,
            userData: Swift.String? = nil
        )
        {
            self.blockDeviceMappingSet = blockDeviceMappingSet
            self.capacityReservationSpecification = capacityReservationSpecification
            self.cpuOptions = cpuOptions
            self.creditSpecification = creditSpecification
            self.disableApiStop = disableApiStop
            self.disableApiTermination = disableApiTermination
            self.ebsOptimized = ebsOptimized
            self.elasticGpuSpecificationSet = elasticGpuSpecificationSet
            self.elasticInferenceAcceleratorSet = elasticInferenceAcceleratorSet
            self.enclaveOptions = enclaveOptions
            self.hibernationOptions = hibernationOptions
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.instanceMarketOptions = instanceMarketOptions
            self.instanceRequirements = instanceRequirements
            self.instanceType = instanceType
            self.kernelId = kernelId
            self.keyName = keyName
            self.licenseSet = licenseSet
            self.maintenanceOptions = maintenanceOptions
            self.metadataOptions = metadataOptions
            self.monitoring = monitoring
            self.networkInterfaceSet = networkInterfaceSet
            self.placement = placement
            self.privateDnsNameOptions = privateDnsNameOptions
            self.ramDiskId = ramDiskId
            self.securityGroupIdSet = securityGroupIdSet
            self.securityGroupSet = securityGroupSet
            self.userData = userData
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the properties for creating an Amazon Elastic Compute Cloud (Amazon EC2) launch template.
    public struct AwsEc2LaunchTemplateDetails {
        /// The default version of the launch template.
        public var defaultVersionNumber: Swift.Int?
        /// An ID for the launch template.
        public var id: Swift.String?
        /// The latest version of the launch template.
        public var latestVersionNumber: Swift.Int?
        /// The information to include in the launch template.
        public var launchTemplateData: SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails?
        /// A name for the launch template.
        public var launchTemplateName: Swift.String?

        public init(
            defaultVersionNumber: Swift.Int? = nil,
            id: Swift.String? = nil,
            latestVersionNumber: Swift.Int? = nil,
            launchTemplateData: SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails? = nil,
            launchTemplateName: Swift.String? = nil
        )
        {
            self.defaultVersionNumber = defaultVersionNumber
            self.id = id
            self.latestVersionNumber = latestVersionNumber
            self.launchTemplateData = launchTemplateData
            self.launchTemplateName = launchTemplateName
        }
    }

}

extension SecurityHubClientTypes {
    /// An association between the network ACL and a subnet.
    public struct AwsEc2NetworkAclAssociation {
        /// The identifier of the association between the network ACL and the subnet.
        public var networkAclAssociationId: Swift.String?
        /// The identifier of the network ACL.
        public var networkAclId: Swift.String?
        /// The identifier of the subnet that is associated with the network ACL.
        public var subnetId: Swift.String?

        public init(
            networkAclAssociationId: Swift.String? = nil,
            networkAclId: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.networkAclAssociationId = networkAclAssociationId
            self.networkAclId = networkAclId
            self.subnetId = subnetId
        }
    }

}

extension SecurityHubClientTypes {
    /// An Internet Control Message Protocol (ICMP) type and code.
    public struct IcmpTypeCode {
        /// The ICMP code for which to deny or allow access. To deny or allow all codes, use the value -1.
        public var code: Swift.Int?
        /// The ICMP type for which to deny or allow access. To deny or allow all types, use the value -1.
        public var type: Swift.Int?

        public init(
            code: Swift.Int? = nil,
            type: Swift.Int? = nil
        )
        {
            self.code = code
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// A range of ports.
    public struct PortRangeFromTo {
        /// The first port in the port range.
        public var from: Swift.Int?
        /// The last port in the port range.
        public var to: Swift.Int?

        public init(
            from: Swift.Int? = nil,
            to: Swift.Int? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension SecurityHubClientTypes {
    /// A rule for the network ACL. Each rule allows or denies access based on the IP address, traffic direction, port, and protocol.
    public struct AwsEc2NetworkAclEntry {
        /// The IPV4 network range for which to deny or allow access.
        public var cidrBlock: Swift.String?
        /// Whether the rule is an egress rule. An egress rule is a rule that applies to traffic that leaves the subnet.
        public var egress: Swift.Bool?
        /// The Internet Control Message Protocol (ICMP) type and code for which to deny or allow access.
        public var icmpTypeCode: SecurityHubClientTypes.IcmpTypeCode?
        /// The IPV6 network range for which to deny or allow access.
        public var ipv6CidrBlock: Swift.String?
        /// For TCP or UDP protocols, the range of ports that the rule applies to.
        public var portRange: SecurityHubClientTypes.PortRangeFromTo?
        /// The protocol that the rule applies to. To deny or allow access to all protocols, use the value -1.
        public var `protocol`: Swift.String?
        /// Whether the rule is used to allow access or deny access.
        public var ruleAction: Swift.String?
        /// The rule number. The rules are processed in order by their number.
        public var ruleNumber: Swift.Int?

        public init(
            cidrBlock: Swift.String? = nil,
            egress: Swift.Bool? = nil,
            icmpTypeCode: SecurityHubClientTypes.IcmpTypeCode? = nil,
            ipv6CidrBlock: Swift.String? = nil,
            portRange: SecurityHubClientTypes.PortRangeFromTo? = nil,
            `protocol`: Swift.String? = nil,
            ruleAction: Swift.String? = nil,
            ruleNumber: Swift.Int? = nil
        )
        {
            self.cidrBlock = cidrBlock
            self.egress = egress
            self.icmpTypeCode = icmpTypeCode
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.ruleNumber = ruleNumber
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains details about an Amazon EC2 network access control list (ACL).
    public struct AwsEc2NetworkAclDetails {
        /// Associations between the network ACL and subnets.
        public var associations: [SecurityHubClientTypes.AwsEc2NetworkAclAssociation]?
        /// The set of rules in the network ACL.
        public var entries: [SecurityHubClientTypes.AwsEc2NetworkAclEntry]?
        /// Whether this is the default network ACL for the VPC.
        public var isDefault: Swift.Bool?
        /// The identifier of the network ACL.
        public var networkAclId: Swift.String?
        /// The identifier of the Amazon Web Services account that owns the network ACL.
        public var ownerId: Swift.String?
        /// The identifier of the VPC for the network ACL.
        public var vpcId: Swift.String?

        public init(
            associations: [SecurityHubClientTypes.AwsEc2NetworkAclAssociation]? = nil,
            entries: [SecurityHubClientTypes.AwsEc2NetworkAclEntry]? = nil,
            isDefault: Swift.Bool? = nil,
            networkAclId: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.associations = associations
            self.entries = entries
            self.isDefault = isDefault
            self.networkAclId = networkAclId
            self.ownerId = ownerId
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the network interface attachment.
    public struct AwsEc2NetworkInterfaceAttachment {
        /// Indicates when the attachment initiated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var attachTime: Swift.String?
        /// The identifier of the network interface attachment
        public var attachmentId: Swift.String?
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public var deleteOnTermination: Swift.Bool?
        /// The device index of the network interface attachment on the instance.
        public var deviceIndex: Swift.Int?
        /// The ID of the instance.
        public var instanceId: Swift.String?
        /// The Amazon Web Services account ID of the owner of the instance.
        public var instanceOwnerId: Swift.String?
        /// The attachment state. Valid values: attaching | attached | detaching | detached
        public var status: Swift.String?

        public init(
            attachTime: Swift.String? = nil,
            attachmentId: Swift.String? = nil,
            deleteOnTermination: Swift.Bool? = nil,
            deviceIndex: Swift.Int? = nil,
            instanceId: Swift.String? = nil,
            instanceOwnerId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.attachTime = attachTime
            self.attachmentId = attachmentId
            self.deleteOnTermination = deleteOnTermination
            self.deviceIndex = deviceIndex
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an IPV6 address that is associated with the network interface.
    public struct AwsEc2NetworkInterfaceIpV6AddressDetail {
        /// The IPV6 address.
        public var ipV6Address: Swift.String?

        public init(
            ipV6Address: Swift.String? = nil
        )
        {
            self.ipV6Address = ipV6Address
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about a private IPv4 address that is with the network interface.
    public struct AwsEc2NetworkInterfacePrivateIpAddressDetail {
        /// The private DNS name for the IP address.
        public var privateDnsName: Swift.String?
        /// The IP address.
        public var privateIpAddress: Swift.String?

        public init(
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }
    }

}

extension SecurityHubClientTypes {
    /// A security group associated with the network interface.
    public struct AwsEc2NetworkInterfaceSecurityGroup {
        /// The ID of the security group.
        public var groupId: Swift.String?
        /// The name of the security group.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the network interface
    public struct AwsEc2NetworkInterfaceDetails {
        /// The network interface attachment.
        public var attachment: SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment?
        /// The IPv6 addresses associated with the network interface.
        public var ipV6Addresses: [SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail]?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The private IPv4 addresses associated with the network interface.
        public var privateIpAddresses: [SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail]?
        /// The public DNS name of the network interface.
        public var publicDnsName: Swift.String?
        /// The address of the Elastic IP address bound to the network interface.
        public var publicIp: Swift.String?
        /// Security groups for the network interface.
        public var securityGroups: [SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup]?
        /// Indicates whether traffic to or from the instance is validated.
        public var sourceDestCheck: Swift.Bool?

        public init(
            attachment: SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment? = nil,
            ipV6Addresses: [SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail]? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateIpAddresses: [SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail]? = nil,
            publicDnsName: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            securityGroups: [SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup]? = nil,
            sourceDestCheck: Swift.Bool? = nil
        )
        {
            self.attachment = attachment
            self.ipV6Addresses = ipV6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.sourceDestCheck = sourceDestCheck
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes a virtual private gateway propagating route.
    public struct PropagatingVgwSetDetails {
        /// The ID of the virtual private gateway.
        public var gatewayId: Swift.String?

        public init(
            gatewayId: Swift.String? = nil
        )
        {
            self.gatewayId = gatewayId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the routes in the route table.
    public struct RouteSetDetails {
        /// The ID of the carrier gateway.
        public var carrierGatewayId: Swift.String?
        /// The Amazon Resource Name (ARN) of the core network.
        public var coreNetworkArn: Swift.String?
        /// The IPv4 CIDR block used for the destination match.
        public var destinationCidrBlock: Swift.String?
        /// The IPv6 CIDR block used for the destination match.
        public var destinationIpv6CidrBlock: Swift.String?
        /// The prefix of the destination Amazon Web Servicesservice.
        public var destinationPrefixListId: Swift.String?
        /// The ID of the egress-only internet gateway.
        public var egressOnlyInternetGatewayId: Swift.String?
        /// The ID of a gateway attached to your VPC.
        public var gatewayId: Swift.String?
        /// The ID of a NAT instance in your VPC.
        public var instanceId: Swift.String?
        /// The ID of the Amazon Web Services account that owns the instance.
        public var instanceOwnerId: Swift.String?
        /// The ID of the local gateway.
        public var localGatewayId: Swift.String?
        /// The ID of a NAT gateway.
        public var natGatewayId: Swift.String?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// Describes how the route was created.
        public var origin: Swift.String?
        /// The state of the route.
        public var state: Swift.String?
        /// The ID of a transit gateway.
        public var transitGatewayId: Swift.String?
        /// The ID of a VPC peering connection.
        public var vpcPeeringConnectionId: Swift.String?

        public init(
            carrierGatewayId: Swift.String? = nil,
            coreNetworkArn: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            egressOnlyInternetGatewayId: Swift.String? = nil,
            gatewayId: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceOwnerId: Swift.String? = nil,
            localGatewayId: Swift.String? = nil,
            natGatewayId: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            origin: Swift.String? = nil,
            state: Swift.String? = nil,
            transitGatewayId: Swift.String? = nil,
            vpcPeeringConnectionId: Swift.String? = nil
        )
        {
            self.carrierGatewayId = carrierGatewayId
            self.coreNetworkArn = coreNetworkArn
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.egressOnlyInternetGatewayId = egressOnlyInternetGatewayId
            self.gatewayId = gatewayId
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.localGatewayId = localGatewayId
            self.natGatewayId = natGatewayId
            self.networkInterfaceId = networkInterfaceId
            self.origin = origin
            self.state = state
            self.transitGatewayId = transitGatewayId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about a route table for the specified VPC.
    public struct AwsEc2RouteTableDetails {
        /// The associations between a route table and one or more subnets or a gateway.
        public var associationSet: [SecurityHubClientTypes.AssociationSetDetails]?
        /// The ID of the Amazon Web Services account that owns the route table.
        public var ownerId: Swift.String?
        /// Describes a virtual private gateway propagating route.
        public var propagatingVgwSet: [SecurityHubClientTypes.PropagatingVgwSetDetails]?
        /// The routes in the route table.
        public var routeSet: [SecurityHubClientTypes.RouteSetDetails]?
        /// The ID of the route table.
        public var routeTableId: Swift.String?
        /// The ID of the virtual private cloud (VPC).
        public var vpcId: Swift.String?

        public init(
            associationSet: [SecurityHubClientTypes.AssociationSetDetails]? = nil,
            ownerId: Swift.String? = nil,
            propagatingVgwSet: [SecurityHubClientTypes.PropagatingVgwSetDetails]? = nil,
            routeSet: [SecurityHubClientTypes.RouteSetDetails]? = nil,
            routeTableId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.associationSet = associationSet
            self.ownerId = ownerId
            self.propagatingVgwSet = propagatingVgwSet
            self.routeSet = routeSet
            self.routeTableId = routeTableId
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// A range of IPv4 addresses.
    public struct AwsEc2SecurityGroupIpRange {
        /// The IPv4 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv4 address, use the /32 prefix length.
        public var cidrIp: Swift.String?

        public init(
            cidrIp: Swift.String? = nil
        )
        {
            self.cidrIp = cidrIp
        }
    }

}

extension SecurityHubClientTypes {
    /// A range of IPv6 addresses.
    public struct AwsEc2SecurityGroupIpv6Range {
        /// The IPv6 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv6 address, use the /128 prefix length.
        public var cidrIpv6: Swift.String?

        public init(
            cidrIpv6: Swift.String? = nil
        )
        {
            self.cidrIpv6 = cidrIpv6
        }
    }

}

extension SecurityHubClientTypes {
    /// A prefix list ID.
    public struct AwsEc2SecurityGroupPrefixListId {
        /// The ID of the prefix.
        public var prefixListId: Swift.String?

        public init(
            prefixListId: Swift.String? = nil
        )
        {
            self.prefixListId = prefixListId
        }
    }

}

extension SecurityHubClientTypes {
    /// A relationship between a security group and a user.
    public struct AwsEc2SecurityGroupUserIdGroupPair {
        /// The ID of the security group.
        public var groupId: Swift.String?
        /// The name of the security group.
        public var groupName: Swift.String?
        /// The status of a VPC peering connection, if applicable.
        public var peeringStatus: Swift.String?
        /// The ID of an Amazon Web Services account. For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned. [EC2-Classic] Required when adding or removing rules that reference a security group in another VPC.
        public var userId: Swift.String?
        /// The ID of the VPC for the referenced security group, if applicable.
        public var vpcId: Swift.String?
        /// The ID of the VPC peering connection, if applicable.
        public var vpcPeeringConnectionId: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            peeringStatus: Swift.String? = nil,
            userId: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            vpcPeeringConnectionId: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
            self.peeringStatus = peeringStatus
            self.userId = userId
            self.vpcId = vpcId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

}

extension SecurityHubClientTypes {
    /// An IP permission for an EC2 security group.
    public struct AwsEc2SecurityGroupIpPermission {
        /// The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        public var fromPort: Swift.Int?
        /// The IP protocol name (tcp, udp, icmp, icmpv6) or number. [VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For icmpv6, the port range is optional. If you omit the port range, traffic for all types and codes is allowed.
        public var ipProtocol: Swift.String?
        /// The IPv4 ranges.
        public var ipRanges: [SecurityHubClientTypes.AwsEc2SecurityGroupIpRange]?
        /// The IPv6 ranges.
        public var ipv6Ranges: [SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range]?
        /// [VPC only] The prefix list IDs for an Amazon Web Services service. With outbound rules, this is the Amazon Web Services service to access through a VPC endpoint from instances associated with the security group.
        public var prefixListIds: [SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId]?
        /// The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        public var toPort: Swift.Int?
        /// The security group and Amazon Web Services account ID pairs.
        public var userIdGroupPairs: [SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair]?

        public init(
            fromPort: Swift.Int? = nil,
            ipProtocol: Swift.String? = nil,
            ipRanges: [SecurityHubClientTypes.AwsEc2SecurityGroupIpRange]? = nil,
            ipv6Ranges: [SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range]? = nil,
            prefixListIds: [SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId]? = nil,
            toPort: Swift.Int? = nil,
            userIdGroupPairs: [SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair]? = nil
        )
        {
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.ipRanges = ipRanges
            self.ipv6Ranges = ipv6Ranges
            self.prefixListIds = prefixListIds
            self.toPort = toPort
            self.userIdGroupPairs = userIdGroupPairs
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an Amazon EC2 security group.
    public struct AwsEc2SecurityGroupDetails {
        /// The ID of the security group.
        public var groupId: Swift.String?
        /// The name of the security group.
        public var groupName: Swift.String?
        /// The inbound rules associated with the security group.
        public var ipPermissions: [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]?
        /// [VPC only] The outbound rules associated with the security group.
        public var ipPermissionsEgress: [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]?
        /// The Amazon Web Services account ID of the owner of the security group.
        public var ownerId: Swift.String?
        /// [VPC only] The ID of the VPC for the security group.
        public var vpcId: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            ipPermissions: [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]? = nil,
            ipPermissionsEgress: [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]? = nil,
            ownerId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.ipPermissionsEgress = ipPermissionsEgress
            self.ownerId = ownerId
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// An IPV6 CIDR block association.
    public struct Ipv6CidrBlockAssociation {
        /// The association ID for the IPv6 CIDR block.
        public var associationId: Swift.String?
        /// Information about the state of the CIDR block. Valid values are as follows:
        ///
        /// * associating
        ///
        /// * associated
        ///
        /// * disassociating
        ///
        /// * disassociated
        ///
        /// * failed
        ///
        /// * failing
        public var cidrBlockState: Swift.String?
        /// The IPv6 CIDR block.
        public var ipv6CidrBlock: Swift.String?

        public init(
            associationId: Swift.String? = nil,
            cidrBlockState: Swift.String? = nil,
            ipv6CidrBlock: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.cidrBlockState = cidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about a subnet in Amazon EC2.
    public struct AwsEc2SubnetDetails {
        /// Whether to assign an IPV6 address to a network interface that is created in this subnet.
        public var assignIpv6AddressOnCreation: Swift.Bool?
        /// The Availability Zone for the subnet.
        public var availabilityZone: Swift.String?
        /// The identifier of the Availability Zone for the subnet.
        public var availabilityZoneId: Swift.String?
        /// The number of available IPV4 addresses in the subnet. Does not include addresses for stopped instances.
        public var availableIpAddressCount: Swift.Int?
        /// The IPV4 CIDR block that is assigned to the subnet.
        public var cidrBlock: Swift.String?
        /// Whether this subnet is the default subnet for the Availability Zone.
        public var defaultForAz: Swift.Bool?
        /// The IPV6 CIDR blocks that are associated with the subnet.
        public var ipv6CidrBlockAssociationSet: [SecurityHubClientTypes.Ipv6CidrBlockAssociation]?
        /// Whether instances in this subnet receive a public IP address.
        public var mapPublicIpOnLaunch: Swift.Bool?
        /// The identifier of the Amazon Web Services account that owns the subnet.
        public var ownerId: Swift.String?
        /// The current state of the subnet. Valid values are available or pending.
        public var state: Swift.String?
        /// The ARN of the subnet.
        public var subnetArn: Swift.String?
        /// The identifier of the subnet.
        public var subnetId: Swift.String?
        /// The identifier of the VPC that contains the subnet.
        public var vpcId: Swift.String?

        public init(
            assignIpv6AddressOnCreation: Swift.Bool? = nil,
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            availableIpAddressCount: Swift.Int? = nil,
            cidrBlock: Swift.String? = nil,
            defaultForAz: Swift.Bool? = nil,
            ipv6CidrBlockAssociationSet: [SecurityHubClientTypes.Ipv6CidrBlockAssociation]? = nil,
            mapPublicIpOnLaunch: Swift.Bool? = nil,
            ownerId: Swift.String? = nil,
            state: Swift.String? = nil,
            subnetArn: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.availableIpAddressCount = availableIpAddressCount
            self.cidrBlock = cidrBlock
            self.defaultForAz = defaultForAz
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.ownerId = ownerId
            self.state = state
            self.subnetArn = subnetArn
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an Amazon Web Services Amazon EC2 Transit Gateway that interconnects virtual private clouds (VPCs) and on-premises networks.
    public struct AwsEc2TransitGatewayDetails {
        /// A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
        public var amazonSideAsn: Swift.Int?
        /// The ID of the default association route table.
        public var associationDefaultRouteTableId: Swift.String?
        /// Turn on or turn off automatic acceptance of attachment requests.
        public var autoAcceptSharedAttachments: Swift.String?
        /// Turn on or turn off automatic association with the default association route table.
        public var defaultRouteTableAssociation: Swift.String?
        /// Turn on or turn off automatic propagation of routes to the default propagation route table.
        public var defaultRouteTablePropagation: Swift.String?
        /// The description of the transit gateway.
        public var description: Swift.String?
        /// Turn on or turn off DNS support.
        public var dnsSupport: Swift.String?
        /// The ID of the transit gateway.
        public var id: Swift.String?
        /// Indicates whether multicast is supported on the transit gateway.
        public var multicastSupport: Swift.String?
        /// The ID of the default propagation route table.
        public var propagationDefaultRouteTableId: Swift.String?
        /// The transit gateway Classless Inter-Domain Routing (CIDR) blocks.
        public var transitGatewayCidrBlocks: [Swift.String]?
        /// Turn on or turn off Equal Cost Multipath Protocol (ECMP) support.
        public var vpnEcmpSupport: Swift.String?

        public init(
            amazonSideAsn: Swift.Int? = nil,
            associationDefaultRouteTableId: Swift.String? = nil,
            autoAcceptSharedAttachments: Swift.String? = nil,
            defaultRouteTableAssociation: Swift.String? = nil,
            defaultRouteTablePropagation: Swift.String? = nil,
            description: Swift.String? = nil,
            dnsSupport: Swift.String? = nil,
            id: Swift.String? = nil,
            multicastSupport: Swift.String? = nil,
            propagationDefaultRouteTableId: Swift.String? = nil,
            transitGatewayCidrBlocks: [Swift.String]? = nil,
            vpnEcmpSupport: Swift.String? = nil
        )
        {
            self.amazonSideAsn = amazonSideAsn
            self.associationDefaultRouteTableId = associationDefaultRouteTableId
            self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
            self.defaultRouteTableAssociation = defaultRouteTableAssociation
            self.defaultRouteTablePropagation = defaultRouteTablePropagation
            self.description = description
            self.dnsSupport = dnsSupport
            self.id = id
            self.multicastSupport = multicastSupport
            self.propagationDefaultRouteTableId = propagationDefaultRouteTableId
            self.transitGatewayCidrBlocks = transitGatewayCidrBlocks
            self.vpnEcmpSupport = vpnEcmpSupport
        }
    }

}

extension SecurityHubClientTypes {
    /// An attachment to an Amazon EC2 volume.
    public struct AwsEc2VolumeAttachment {
        /// The datetime when the attachment initiated.
        public var attachTime: Swift.String?
        /// Whether the EBS volume is deleted when the EC2 instance is terminated.
        public var deleteOnTermination: Swift.Bool?
        /// The identifier of the EC2 instance.
        public var instanceId: Swift.String?
        /// The attachment state of the volume. Valid values are as follows:
        ///
        /// * attaching
        ///
        /// * attached
        ///
        /// * busy
        ///
        /// * detaching
        ///
        /// * detached
        public var status: Swift.String?

        public init(
            attachTime: Swift.String? = nil,
            deleteOnTermination: Swift.Bool? = nil,
            instanceId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.instanceId = instanceId
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an EC2 volume.
    public struct AwsEc2VolumeDetails {
        /// The volume attachments.
        public var attachments: [SecurityHubClientTypes.AwsEc2VolumeAttachment]?
        /// Indicates when the volume was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createTime: Swift.String?
        /// The device name for the volume that is attached to the instance.
        public var deviceName: Swift.String?
        /// Specifies whether the volume is encrypted.
        public var encrypted: Swift.Bool?
        /// The ARN of the KMS key that was used to protect the volume encryption key for the volume.
        public var kmsKeyId: Swift.String?
        /// The size of the volume, in GiBs.
        public var size: Swift.Int?
        /// The snapshot from which the volume was created.
        public var snapshotId: Swift.String?
        /// The volume state. Valid values are as follows:
        ///
        /// * available
        ///
        /// * creating
        ///
        /// * deleted
        ///
        /// * deleting
        ///
        /// * error
        ///
        /// * in-use
        public var status: Swift.String?
        /// The ID of the volume.
        public var volumeId: Swift.String?
        /// Indicates whether the volume was scanned or skipped.
        public var volumeScanStatus: Swift.String?
        /// The volume type.
        public var volumeType: Swift.String?

        public init(
            attachments: [SecurityHubClientTypes.AwsEc2VolumeAttachment]? = nil,
            createTime: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            size: Swift.Int? = nil,
            snapshotId: Swift.String? = nil,
            status: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeScanStatus: Swift.String? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.attachments = attachments
            self.createTime = createTime
            self.deviceName = deviceName
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.size = size
            self.snapshotId = snapshotId
            self.status = status
            self.volumeId = volumeId
            self.volumeScanStatus = volumeScanStatus
            self.volumeType = volumeType
        }
    }

}

extension SecurityHubClientTypes {
    /// An IPv4 CIDR block association.
    public struct CidrBlockAssociation {
        /// The association ID for the IPv4 CIDR block.
        public var associationId: Swift.String?
        /// The IPv4 CIDR block.
        public var cidrBlock: Swift.String?
        /// Information about the state of the IPv4 CIDR block.
        public var cidrBlockState: Swift.String?

        public init(
            associationId: Swift.String? = nil,
            cidrBlock: Swift.String? = nil,
            cidrBlockState: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.cidrBlock = cidrBlock
            self.cidrBlockState = cidrBlockState
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an EC2 VPC.
    public struct AwsEc2VpcDetails {
        /// Information about the IPv4 CIDR blocks associated with the VPC.
        public var cidrBlockAssociationSet: [SecurityHubClientTypes.CidrBlockAssociation]?
        /// The identifier of the set of Dynamic Host Configuration Protocol (DHCP) options that are associated with the VPC. If the default options are associated with the VPC, then this is default.
        public var dhcpOptionsId: Swift.String?
        /// Information about the IPv6 CIDR blocks associated with the VPC.
        public var ipv6CidrBlockAssociationSet: [SecurityHubClientTypes.Ipv6CidrBlockAssociation]?
        /// The current state of the VPC. Valid values are available or pending.
        public var state: Swift.String?

        public init(
            cidrBlockAssociationSet: [SecurityHubClientTypes.CidrBlockAssociation]? = nil,
            dhcpOptionsId: Swift.String? = nil,
            ipv6CidrBlockAssociationSet: [SecurityHubClientTypes.Ipv6CidrBlockAssociation]? = nil,
            state: Swift.String? = nil
        )
        {
            self.cidrBlockAssociationSet = cidrBlockAssociationSet
            self.dhcpOptionsId = dhcpOptionsId
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.state = state
        }
    }

}

extension SecurityHubClientTypes {
    /// The service type information for a VPC endpoint service.
    public struct AwsEc2VpcEndpointServiceServiceTypeDetails {
        /// The type of service.
        public var serviceType: Swift.String?

        public init(
            serviceType: Swift.String? = nil
        )
        {
            self.serviceType = serviceType
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains details about the service configuration for a VPC endpoint service.
    public struct AwsEc2VpcEndpointServiceDetails {
        /// Whether requests from other Amazon Web Services accounts to create an endpoint to the service must first be accepted.
        public var acceptanceRequired: Swift.Bool?
        /// The Availability Zones where the service is available.
        public var availabilityZones: [Swift.String]?
        /// The DNS names for the service.
        public var baseEndpointDnsNames: [Swift.String]?
        /// The ARNs of the Gateway Load Balancers for the service.
        public var gatewayLoadBalancerArns: [Swift.String]?
        /// Whether the service manages its VPC endpoints.
        public var managesVpcEndpoints: Swift.Bool?
        /// The ARNs of the Network Load Balancers for the service.
        public var networkLoadBalancerArns: [Swift.String]?
        /// The private DNS name for the service.
        public var privateDnsName: Swift.String?
        /// The identifier of the service.
        public var serviceId: Swift.String?
        /// The name of the service.
        public var serviceName: Swift.String?
        /// The current state of the service. Valid values are as follows:
        ///
        /// * Available
        ///
        /// * Deleted
        ///
        /// * Deleting
        ///
        /// * Failed
        ///
        /// * Pending
        public var serviceState: Swift.String?
        /// The types for the service.
        public var serviceType: [SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails]?

        public init(
            acceptanceRequired: Swift.Bool? = nil,
            availabilityZones: [Swift.String]? = nil,
            baseEndpointDnsNames: [Swift.String]? = nil,
            gatewayLoadBalancerArns: [Swift.String]? = nil,
            managesVpcEndpoints: Swift.Bool? = nil,
            networkLoadBalancerArns: [Swift.String]? = nil,
            privateDnsName: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceState: Swift.String? = nil,
            serviceType: [SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails]? = nil
        )
        {
            self.acceptanceRequired = acceptanceRequired
            self.availabilityZones = availabilityZones
            self.baseEndpointDnsNames = baseEndpointDnsNames
            self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
            self.managesVpcEndpoints = managesVpcEndpoints
            self.networkLoadBalancerArns = networkLoadBalancerArns
            self.privateDnsName = privateDnsName
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceState = serviceState
            self.serviceType = serviceType
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the IPv4 CIDR blocks for the VPC.
    public struct VpcInfoCidrBlockSetDetails {
        /// The IPv4 CIDR block for the VPC.
        public var cidrBlock: Swift.String?

        public init(
            cidrBlock: Swift.String? = nil
        )
        {
            self.cidrBlock = cidrBlock
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the IPv6 CIDR blocks for the VPC.
    public struct VpcInfoIpv6CidrBlockSetDetails {
        /// The IPv6 CIDR block for the VPC.
        public var ipv6CidrBlock: Swift.String?

        public init(
            ipv6CidrBlock: Swift.String? = nil
        )
        {
            self.ipv6CidrBlock = ipv6CidrBlock
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the VPC peering connection options for the accepter or requester VPC.
    public struct VpcInfoPeeringOptionsDetails {
        /// Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.
        public var allowDnsResolutionFromRemoteVpc: Swift.Bool?
        /// Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.
        public var allowEgressFromLocalClassicLinkToRemoteVpc: Swift.Bool?
        /// Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.
        public var allowEgressFromLocalVpcToRemoteClassicLink: Swift.Bool?

        public init(
            allowDnsResolutionFromRemoteVpc: Swift.Bool? = nil,
            allowEgressFromLocalClassicLinkToRemoteVpc: Swift.Bool? = nil,
            allowEgressFromLocalVpcToRemoteClassicLink: Swift.Bool? = nil
        )
        {
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes a VPC in a VPC peering connection.
    public struct AwsEc2VpcPeeringConnectionVpcInfoDetails {
        /// The IPv4 CIDR block for the VPC.
        public var cidrBlock: Swift.String?
        /// Information about the IPv4 CIDR blocks for the VPC.
        public var cidrBlockSet: [SecurityHubClientTypes.VpcInfoCidrBlockSetDetails]?
        /// The IPv6 CIDR block for the VPC.
        public var ipv6CidrBlockSet: [SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails]?
        /// The ID of the Amazon Web Services account that owns the VPC.
        public var ownerId: Swift.String?
        /// Information about the VPC peering connection options for the accepter or requester VPC.
        public var peeringOptions: SecurityHubClientTypes.VpcInfoPeeringOptionsDetails?
        /// The Amazon Web Services Region in which the VPC is located.
        public var region: Swift.String?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            cidrBlock: Swift.String? = nil,
            cidrBlockSet: [SecurityHubClientTypes.VpcInfoCidrBlockSetDetails]? = nil,
            ipv6CidrBlockSet: [SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails]? = nil,
            ownerId: Swift.String? = nil,
            peeringOptions: SecurityHubClientTypes.VpcInfoPeeringOptionsDetails? = nil,
            region: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.cidrBlock = cidrBlock
            self.cidrBlockSet = cidrBlockSet
            self.ipv6CidrBlockSet = ipv6CidrBlockSet
            self.ownerId = ownerId
            self.peeringOptions = peeringOptions
            self.region = region
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the status of the VPC peering connection.
    public struct AwsEc2VpcPeeringConnectionStatusDetails {
        /// The status of the VPC peering connection.
        public var code: Swift.String?
        /// A message that provides more information about the status, if applicable.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about a VPC peering connection between two VPCs: a requester VPC that you own and an accepter VPC with which to create the connection.
    public struct AwsEc2VpcPeeringConnectionDetails {
        /// Information about the accepter VPC.
        public var accepterVpcInfo: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails?
        /// The time at which an unaccepted VPC peering connection will expire.
        public var expirationTime: Swift.String?
        /// Information about the requester VPC.
        public var requesterVpcInfo: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails?
        /// The status of the VPC peering connection.
        public var status: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails?
        /// The ID of the VPC peering connection.
        public var vpcPeeringConnectionId: Swift.String?

        public init(
            accepterVpcInfo: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails? = nil,
            expirationTime: Swift.String? = nil,
            requesterVpcInfo: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails? = nil,
            status: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails? = nil,
            vpcPeeringConnectionId: Swift.String? = nil
        )
        {
            self.accepterVpcInfo = accepterVpcInfo
            self.expirationTime = expirationTime
            self.requesterVpcInfo = requesterVpcInfo
            self.status = status
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

}

extension SecurityHubClientTypes {
    /// The VPN tunnel options.
    public struct AwsEc2VpnConnectionOptionsTunnelOptionsDetails {
        /// The number of seconds after which a Dead Peer Detection (DPD) timeout occurs.
        public var dpdTimeoutSeconds: Swift.Int?
        /// The Internet Key Exchange (IKE) versions that are permitted for the VPN tunnel.
        public var ikeVersions: [Swift.String]?
        /// The external IP address of the VPN tunnel.
        public var outsideIpAddress: Swift.String?
        /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.
        public var phase1DhGroupNumbers: [Swift.Int]?
        /// The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.
        public var phase1EncryptionAlgorithms: [Swift.String]?
        /// The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.
        public var phase1IntegrityAlgorithms: [Swift.String]?
        /// The lifetime for phase 1 of the IKE negotiation, in seconds.
        public var phase1LifetimeSeconds: Swift.Int?
        /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.
        public var phase2DhGroupNumbers: [Swift.Int]?
        /// The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.
        public var phase2EncryptionAlgorithms: [Swift.String]?
        /// The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.
        public var phase2IntegrityAlgorithms: [Swift.String]?
        /// The lifetime for phase 2 of the IKE negotiation, in seconds.
        public var phase2LifetimeSeconds: Swift.Int?
        /// The preshared key to establish initial authentication between the virtual private gateway and the customer gateway.
        public var preSharedKey: Swift.String?
        /// The percentage of the rekey window, which is determined by RekeyMarginTimeSeconds during which the rekey time is randomly selected.
        public var rekeyFuzzPercentage: Swift.Int?
        /// The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey.
        public var rekeyMarginTimeSeconds: Swift.Int?
        /// The number of packets in an IKE replay window.
        public var replayWindowSize: Swift.Int?
        /// The range of inside IPv4 addresses for the tunnel.
        public var tunnelInsideCidr: Swift.String?

        public init(
            dpdTimeoutSeconds: Swift.Int? = nil,
            ikeVersions: [Swift.String]? = nil,
            outsideIpAddress: Swift.String? = nil,
            phase1DhGroupNumbers: [Swift.Int]? = nil,
            phase1EncryptionAlgorithms: [Swift.String]? = nil,
            phase1IntegrityAlgorithms: [Swift.String]? = nil,
            phase1LifetimeSeconds: Swift.Int? = nil,
            phase2DhGroupNumbers: [Swift.Int]? = nil,
            phase2EncryptionAlgorithms: [Swift.String]? = nil,
            phase2IntegrityAlgorithms: [Swift.String]? = nil,
            phase2LifetimeSeconds: Swift.Int? = nil,
            preSharedKey: Swift.String? = nil,
            rekeyFuzzPercentage: Swift.Int? = nil,
            rekeyMarginTimeSeconds: Swift.Int? = nil,
            replayWindowSize: Swift.Int? = nil,
            tunnelInsideCidr: Swift.String? = nil
        )
        {
            self.dpdTimeoutSeconds = dpdTimeoutSeconds
            self.ikeVersions = ikeVersions
            self.outsideIpAddress = outsideIpAddress
            self.phase1DhGroupNumbers = phase1DhGroupNumbers
            self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
            self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
            self.phase1LifetimeSeconds = phase1LifetimeSeconds
            self.phase2DhGroupNumbers = phase2DhGroupNumbers
            self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
            self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
            self.phase2LifetimeSeconds = phase2LifetimeSeconds
            self.preSharedKey = preSharedKey
            self.rekeyFuzzPercentage = rekeyFuzzPercentage
            self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
            self.replayWindowSize = replayWindowSize
            self.tunnelInsideCidr = tunnelInsideCidr
        }
    }

}

extension SecurityHubClientTypes {
    /// VPN connection options.
    public struct AwsEc2VpnConnectionOptionsDetails {
        /// Whether the VPN connection uses static routes only.
        public var staticRoutesOnly: Swift.Bool?
        /// The VPN tunnel options.
        public var tunnelOptions: [SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails]?

        public init(
            staticRoutesOnly: Swift.Bool? = nil,
            tunnelOptions: [SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails]? = nil
        )
        {
            self.staticRoutesOnly = staticRoutesOnly
            self.tunnelOptions = tunnelOptions
        }
    }

}

extension SecurityHubClientTypes {
    /// A static routes associated with the VPN connection.
    public struct AwsEc2VpnConnectionRoutesDetails {
        /// The CIDR block associated with the local subnet of the customer data center.
        public var destinationCidrBlock: Swift.String?
        /// The current state of the static route.
        public var state: Swift.String?

        public init(
            destinationCidrBlock: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.destinationCidrBlock = destinationCidrBlock
            self.state = state
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the VPN tunnel.
    public struct AwsEc2VpnConnectionVgwTelemetryDetails {
        /// The number of accepted routes.
        public var acceptedRouteCount: Swift.Int?
        /// The ARN of the VPN tunnel endpoint certificate.
        public var certificateArn: Swift.String?
        /// The date and time of the last change in status. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastStatusChange: Swift.String?
        /// The Internet-routable IP address of the virtual private gateway's outside interface.
        public var outsideIpAddress: Swift.String?
        /// The status of the VPN tunnel. Valid values are DOWN or UP.
        public var status: Swift.String?
        /// If an error occurs, a description of the error.
        public var statusMessage: Swift.String?

        public init(
            acceptedRouteCount: Swift.Int? = nil,
            certificateArn: Swift.String? = nil,
            lastStatusChange: Swift.String? = nil,
            outsideIpAddress: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.acceptedRouteCount = acceptedRouteCount
            self.certificateArn = certificateArn
            self.lastStatusChange = lastStatusChange
            self.outsideIpAddress = outsideIpAddress
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an Amazon EC2 VPN connection.
    public struct AwsEc2VpnConnectionDetails {
        /// The category of the VPN connection. VPN indicates an Amazon Web Services VPN connection. VPN-Classic indicates an Amazon Web Services Classic VPN connection.
        public var category: Swift.String?
        /// The configuration information for the VPN connection's customer gateway, in the native XML format.
        public var customerGatewayConfiguration: Swift.String?
        /// The identifier of the customer gateway that is at your end of the VPN connection.
        public var customerGatewayId: Swift.String?
        /// The VPN connection options.
        public var options: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails?
        /// The static routes that are associated with the VPN connection.
        public var routes: [SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails]?
        /// The current state of the VPN connection. Valid values are as follows:
        ///
        /// * available
        ///
        /// * deleted
        ///
        /// * deleting
        ///
        /// * pending
        public var state: Swift.String?
        /// The identifier of the transit gateway that is associated with the VPN connection.
        public var transitGatewayId: Swift.String?
        /// The type of VPN connection.
        public var type: Swift.String?
        /// Information about the VPN tunnel.
        public var vgwTelemetry: [SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails]?
        /// The identifier of the VPN connection.
        public var vpnConnectionId: Swift.String?
        /// The identifier of the virtual private gateway that is at the Amazon Web Services side of the VPN connection.
        public var vpnGatewayId: Swift.String?

        public init(
            category: Swift.String? = nil,
            customerGatewayConfiguration: Swift.String? = nil,
            customerGatewayId: Swift.String? = nil,
            options: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails? = nil,
            routes: [SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails]? = nil,
            state: Swift.String? = nil,
            transitGatewayId: Swift.String? = nil,
            type: Swift.String? = nil,
            vgwTelemetry: [SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails]? = nil,
            vpnConnectionId: Swift.String? = nil,
            vpnGatewayId: Swift.String? = nil
        )
        {
            self.category = category
            self.customerGatewayConfiguration = customerGatewayConfiguration
            self.customerGatewayId = customerGatewayId
            self.options = options
            self.routes = routes
            self.state = state
            self.transitGatewayId = transitGatewayId
            self.type = type
            self.vgwTelemetry = vgwTelemetry
            self.vpnConnectionId = vpnConnectionId
            self.vpnGatewayId = vpnGatewayId
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an Amazon ECR image.
    public struct AwsEcrContainerImageDetails {
        /// The architecture of the image. Valid values are as follows:
        ///
        /// * arm64
        ///
        /// * i386
        ///
        /// * x86_64
        public var architecture: Swift.String?
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The date and time when the image was pushed to the repository. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var imagePublishedAt: Swift.String?
        /// The list of tags that are associated with the image.
        public var imageTags: [Swift.String]?
        /// The Amazon Web Services account identifier that is associated with the registry that the image belongs to.
        public var registryId: Swift.String?
        /// The name of the repository that the image belongs to.
        public var repositoryName: Swift.String?

        public init(
            architecture: Swift.String? = nil,
            imageDigest: Swift.String? = nil,
            imagePublishedAt: Swift.String? = nil,
            imageTags: [Swift.String]? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.imageDigest = imageDigest
            self.imagePublishedAt = imagePublishedAt
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension SecurityHubClientTypes {
    /// The image scanning configuration for a repository.
    public struct AwsEcrRepositoryImageScanningConfigurationDetails {
        /// Whether to scan images after they are pushed to a repository.
        public var scanOnPush: Swift.Bool?

        public init(
            scanOnPush: Swift.Bool? = nil
        )
        {
            self.scanOnPush = scanOnPush
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the lifecycle policy for the repository.
    public struct AwsEcrRepositoryLifecyclePolicyDetails {
        /// The text of the lifecycle policy.
        public var lifecyclePolicyText: Swift.String?
        /// The Amazon Web Services account identifier that is associated with the registry that contains the repository.
        public var registryId: Swift.String?

        public init(
            lifecyclePolicyText: Swift.String? = nil,
            registryId: Swift.String? = nil
        )
        {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon Elastic Container Registry repository.
    public struct AwsEcrRepositoryDetails {
        /// The ARN of the repository.
        public var arn: Swift.String?
        /// The image scanning configuration for a repository.
        public var imageScanningConfiguration: SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails?
        /// The tag mutability setting for the repository. Valid values are IMMUTABLE or MUTABLE.
        public var imageTagMutability: Swift.String?
        /// Information about the lifecycle policy for the repository.
        public var lifecyclePolicy: SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails?
        /// The name of the repository.
        public var repositoryName: Swift.String?
        /// The text of the repository policy.
        public var repositoryPolicyText: Swift.String?

        public init(
            arn: Swift.String? = nil,
            imageScanningConfiguration: SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails? = nil,
            imageTagMutability: Swift.String? = nil,
            lifecyclePolicy: SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails? = nil,
            repositoryName: Swift.String? = nil,
            repositoryPolicyText: Swift.String? = nil
        )
        {
            self.arn = arn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.lifecyclePolicy = lifecyclePolicy
            self.repositoryName = repositoryName
            self.repositoryPolicyText = repositoryPolicyText
        }
    }

}

extension SecurityHubClientTypes {
    /// Indicates whether to enable CloudWatch Container Insights for the ECS cluster.
    public struct AwsEcsClusterClusterSettingsDetails {
        /// The name of the setting. The valid value is containerInsights.
        public var name: Swift.String?
        /// The value of the setting. Valid values are disabled or enabled.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// The log configuration for the results of the run command actions.
    public struct AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails {
        /// Whether to enable encryption on the CloudWatch logs.
        public var cloudWatchEncryptionEnabled: Swift.Bool?
        /// The name of the CloudWatch log group to send the logs to.
        public var cloudWatchLogGroupName: Swift.String?
        /// The name of the S3 bucket to send logs to.
        public var s3BucketName: Swift.String?
        /// Whether to encrypt the logs that are sent to the S3 bucket.
        public var s3EncryptionEnabled: Swift.Bool?
        /// Identifies the folder in the S3 bucket to send the logs to.
        public var s3KeyPrefix: Swift.String?

        public init(
            cloudWatchEncryptionEnabled: Swift.Bool? = nil,
            cloudWatchLogGroupName: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3EncryptionEnabled: Swift.Bool? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.cloudWatchEncryptionEnabled = cloudWatchEncryptionEnabled
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.s3BucketName = s3BucketName
            self.s3EncryptionEnabled = s3EncryptionEnabled
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains the run command configuration for the cluster.
    public struct AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {
        /// The identifier of the KMS key that is used to encrypt the data between the local client and the container.
        public var kmsKeyId: Swift.String?
        /// The log configuration for the results of the run command actions. Required if Logging is NONE.
        public var logConfiguration: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails?
        /// The log setting to use for redirecting logs for run command results.
        public var logging: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            logConfiguration: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails? = nil,
            logging: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.logConfiguration = logConfiguration
            self.logging = logging
        }
    }

}

extension SecurityHubClientTypes {
    /// The run command configuration for the cluster.
    public struct AwsEcsClusterConfigurationDetails {
        /// Contains the run command configuration for the cluster.
        public var executeCommandConfiguration: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails?

        public init(
            executeCommandConfiguration: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails? = nil
        )
        {
            self.executeCommandConfiguration = executeCommandConfiguration
        }
    }

}

extension SecurityHubClientTypes {
    /// The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.
    public struct AwsEcsClusterDefaultCapacityProviderStrategyDetails {
        /// The minimum number of tasks to run on the specified capacity provider.
        public var base: Swift.Int?
        /// The name of the capacity provider.
        public var capacityProvider: Swift.String?
        /// The relative percentage of the total number of tasks launched that should use the capacity provider.
        public var weight: Swift.Int?

        public init(
            base: Swift.Int? = nil,
            capacityProvider: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon ECS cluster.
    public struct AwsEcsClusterDetails {
        /// The number of services that are running on the cluster in an ACTIVE state. You can view these services with the Amazon ECS [ListServices](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListServices.html) API operation.
        public var activeServicesCount: Swift.Int?
        /// The short name of one or more capacity providers to associate with the cluster.
        public var capacityProviders: [Swift.String]?
        /// The Amazon Resource Name (ARN) that identifies the cluster.
        public var clusterArn: Swift.String?
        /// A name that you use to identify your cluster.
        public var clusterName: Swift.String?
        /// The setting to use to create the cluster. Specifically used to configure whether to enable CloudWatch Container Insights for the cluster.
        public var clusterSettings: [SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails]?
        /// The run command configuration for the cluster.
        public var configuration: SecurityHubClientTypes.AwsEcsClusterConfigurationDetails?
        /// The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.
        public var defaultCapacityProviderStrategy: [SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails]?
        /// The number of container instances registered into the cluster. This includes container instances in both ACTIVE and DRAINING status.
        public var registeredContainerInstancesCount: Swift.Int?
        /// The number of tasks in the cluster that are in the RUNNING state.
        public var runningTasksCount: Swift.Int?
        /// The status of the cluster.
        public var status: Swift.String?

        public init(
            activeServicesCount: Swift.Int? = nil,
            capacityProviders: [Swift.String]? = nil,
            clusterArn: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            clusterSettings: [SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails]? = nil,
            configuration: SecurityHubClientTypes.AwsEcsClusterConfigurationDetails? = nil,
            defaultCapacityProviderStrategy: [SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails]? = nil,
            registeredContainerInstancesCount: Swift.Int? = nil,
            runningTasksCount: Swift.Int? = nil,
            status: Swift.String? = nil
        )
        {
            self.activeServicesCount = activeServicesCount
            self.capacityProviders = capacityProviders
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterSettings = clusterSettings
            self.configuration = configuration
            self.defaultCapacityProviderStrategy = defaultCapacityProviderStrategy
            self.registeredContainerInstancesCount = registeredContainerInstancesCount
            self.runningTasksCount = runningTasksCount
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Details for a volume mount point that's used in a container definition.
    public struct AwsMountPoint {
        /// The path on the container to mount the host volume at.
        public var containerPath: Swift.String?
        /// The name of the volume to mount. Must be a volume name referenced in the name parameter of task definition volume.
        public var sourceVolume: Swift.String?

        public init(
            containerPath: Swift.String? = nil,
            sourceVolume: Swift.String? = nil
        )
        {
            self.containerPath = containerPath
            self.sourceVolume = sourceVolume
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon ECS container.
    public struct AwsEcsContainerDetails {
        /// The image used for the container.
        public var image: Swift.String?
        /// The mount points for data volumes in your container.
        public var mountPoints: [SecurityHubClientTypes.AwsMountPoint]?
        /// The name of the container.
        public var name: Swift.String?
        /// When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user).
        public var privileged: Swift.Bool?

        public init(
            image: Swift.String? = nil,
            mountPoints: [SecurityHubClientTypes.AwsMountPoint]? = nil,
            name: Swift.String? = nil,
            privileged: Swift.Bool? = nil
        )
        {
            self.image = image
            self.mountPoints = mountPoints
            self.name = name
            self.privileged = privileged
        }
    }

}

extension SecurityHubClientTypes {
    /// Strategy item for the capacity provider strategy that the service uses.
    public struct AwsEcsServiceCapacityProviderStrategyDetails {
        /// The minimum number of tasks to run on the capacity provider. Only one strategy item can specify a value for Base. The value must be between 0 and 100000.
        public var base: Swift.Int?
        /// The short name of the capacity provider.
        public var capacityProvider: Swift.String?
        /// The relative percentage of the total number of tasks that should use the capacity provider. If no weight is specified, the default value is 0. At least one capacity provider must have a weight greater than 0. The value can be between 0 and 1000.
        public var weight: Swift.Int?

        public init(
            base: Swift.Int? = nil,
            capacityProvider: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }
    }

}

extension SecurityHubClientTypes {
    /// Determines whether a service deployment fails if a service cannot reach a steady state.
    public struct AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails {
        /// Whether to enable the deployment circuit breaker logic for the service.
        public var enable: Swift.Bool?
        /// Whether to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
        public var rollback: Swift.Bool?

        public init(
            enable: Swift.Bool? = nil,
            rollback: Swift.Bool? = nil
        )
        {
            self.enable = enable
            self.rollback = rollback
        }
    }

}

extension SecurityHubClientTypes {
    /// Optional deployment parameters for the service.
    public struct AwsEcsServiceDeploymentConfigurationDetails {
        /// Determines whether a service deployment fails if a service cannot reach a steady state.
        public var deploymentCircuitBreaker: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails?
        /// For a service that uses the rolling update (ECS) deployment type, the maximum number of tasks in a service that are allowed in the RUNNING or PENDING state during a deployment, and for tasks that use the EC2 launch type, when any container instances are in the DRAINING state. Provided as a percentage of the desired number of tasks. The default value is 200%. For a service that uses the blue/green (CODE_DEPLOY) or EXTERNAL deployment types, and tasks that use the EC2 launch type, the maximum number of tasks in the service that remain in the RUNNING state while the container instances are in the DRAINING state. For the Fargate launch type, the maximum percent value is not used.
        public var maximumPercent: Swift.Int?
        /// For a service that uses the rolling update (ECS) deployment type, the minimum number of tasks in a service that must remain in the RUNNING state during a deployment, and while any container instances are in the DRAINING state if the service contains tasks using the EC2 launch type. Expressed as a percentage of the desired number of tasks. The default value is 100%. For a service that uses the blue/green (CODE_DEPLOY) or EXTERNAL deployment types and tasks that use the EC2 launch type, the minimum number of the tasks in the service that remain in the RUNNING state while the container instances are in the DRAINING state. For the Fargate launch type, the minimum healthy percent value is not used.
        public var minimumHealthyPercent: Swift.Int?

        public init(
            deploymentCircuitBreaker: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails? = nil,
            maximumPercent: Swift.Int? = nil,
            minimumHealthyPercent: Swift.Int? = nil
        )
        {
            self.deploymentCircuitBreaker = deploymentCircuitBreaker
            self.maximumPercent = maximumPercent
            self.minimumHealthyPercent = minimumHealthyPercent
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the deployment controller type that the service uses.
    public struct AwsEcsServiceDeploymentControllerDetails {
        /// The rolling update (ECS) deployment type replaces the current running version of the container with the latest version. The blue/green (CODE_DEPLOY) deployment type uses the blue/green deployment model that is powered by CodeDeploy. This deployment model a new deployment of a service can be verified before production traffic is sent to it. The external (EXTERNAL) deployment type allows the use of any third-party deployment controller for full control over the deployment process for an Amazon ECS service. Valid values: ECS | CODE_DEPLOY | EXTERNAL
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a load balancer that the service uses.
    public struct AwsEcsServiceLoadBalancersDetails {
        /// The name of the container to associate with the load balancer.
        public var containerName: Swift.String?
        /// The port on the container to associate with the load balancer. This port must correspond to a containerPort in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the hostPort of the port mapping.
        public var containerPort: Swift.Int?
        /// The name of the load balancer to associate with the Amazon ECS service or task set. Only specified when using a Classic Load Balancer. For an Application Load Balancer or a Network Load Balancer, the load balancer name is omitted.
        public var loadBalancerName: Swift.String?
        /// The ARN of the Elastic Load Balancing target group or groups associated with a service or task set. Only specified when using an Application Load Balancer or a Network Load Balancer. For a Classic Load Balancer, the target group ARN is omitted.
        public var targetGroupArn: Swift.String?

        public init(
            containerName: Swift.String? = nil,
            containerPort: Swift.Int? = nil,
            loadBalancerName: Swift.String? = nil,
            targetGroupArn: Swift.String? = nil
        )
        {
            self.containerName = containerName
            self.containerPort = containerPort
            self.loadBalancerName = loadBalancerName
            self.targetGroupArn = targetGroupArn
        }
    }

}

extension SecurityHubClientTypes {
    /// For tasks that use the awsvpc networking mode, the VPC subnet and security group configuration.
    public struct AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {
        /// Whether the task's elastic network interface receives a public IP address. The default value is DISABLED. Valid values: ENABLED | DISABLED
        public var assignPublicIp: Swift.String?
        /// The IDs of the security groups associated with the task or service. You can provide up to five security groups.
        public var securityGroups: [Swift.String]?
        /// The IDs of the subnets associated with the task or service. You can provide up to 16 subnets.
        public var subnets: [Swift.String]?

        public init(
            assignPublicIp: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension SecurityHubClientTypes {
    /// For tasks that use the awsvpc networking mode, the VPC subnet and security group configuration.
    public struct AwsEcsServiceNetworkConfigurationDetails {
        /// The VPC subnet and security group configuration.
        public var awsVpcConfiguration: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails?

        public init(
            awsVpcConfiguration: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails? = nil
        )
        {
            self.awsVpcConfiguration = awsVpcConfiguration
        }
    }

}

extension SecurityHubClientTypes {
    /// A placement constraint for the tasks in the service.
    public struct AwsEcsServicePlacementConstraintsDetails {
        /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance.
        public var expression: Swift.String?
        /// The type of constraint. Use distinctInstance to run each task in a particular group on a different container instance. Use memberOf to restrict the selection to a group of valid candidates. Valid values: distinctInstance | memberOf
        public var type: Swift.String?

        public init(
            expression: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.expression = expression
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// A placement strategy that determines how to place the tasks for the service.
    public struct AwsEcsServicePlacementStrategiesDetails {
        /// The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this attribute is not used.
        public var field: Swift.String?
        /// The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the value of Field. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified in Field. Valid values: random | spread | binpack
        public var type: Swift.String?

        public init(
            field: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.field = field
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a service discovery registry to assign to the service.
    public struct AwsEcsServiceServiceRegistriesDetails {
        /// The container name value to use for the service discovery service. If the task definition uses the bridge or host network mode, you must specify ContainerName and ContainerPort. If the task definition uses the awsvpc network mode and a type SRV DNS record, you must specify either ContainerName and ContainerPort, or Port , but not both.
        public var containerName: Swift.String?
        /// The port value to use for the service discovery service. If the task definition uses the bridge or host network mode, you must specify ContainerName and ContainerPort. If the task definition uses the awsvpc network mode and a type SRV DNS record, you must specify either ContainerName and ContainerPort, or Port , but not both.
        public var containerPort: Swift.Int?
        /// The port value to use for a service discovery service that specifies an SRV record. This field can be used if both the awsvpcawsvpc network mode and SRV records are used.
        public var port: Swift.Int?
        /// The ARN of the service registry.
        public var registryArn: Swift.String?

        public init(
            containerName: Swift.String? = nil,
            containerPort: Swift.Int? = nil,
            port: Swift.Int? = nil,
            registryArn: Swift.String? = nil
        )
        {
            self.containerName = containerName
            self.containerPort = containerPort
            self.port = port
            self.registryArn = registryArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about a service within an ECS cluster.
    public struct AwsEcsServiceDetails {
        /// The capacity provider strategy that the service uses.
        public var capacityProviderStrategy: [SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails]?
        /// The ARN of the cluster that hosts the service.
        public var cluster: Swift.String?
        /// Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.
        public var deploymentConfiguration: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails?
        /// Contains the deployment controller type that the service uses.
        public var deploymentController: SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails?
        /// The number of instantiations of the task definition to run on the service.
        public var desiredCount: Swift.Int?
        /// Whether to enable Amazon ECS managed tags for the tasks in the service.
        public var enableEcsManagedTags: Swift.Bool?
        /// Whether the execute command functionality is enabled for the service.
        public var enableExecuteCommand: Swift.Bool?
        /// After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.
        public var healthCheckGracePeriodSeconds: Swift.Int?
        /// The launch type that the service uses. Valid values: EC2 | FARGATE | EXTERNAL
        public var launchType: Swift.String?
        /// Information about the load balancers that the service uses.
        public var loadBalancers: [SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails]?
        /// The name of the service.
        public var name: Swift.String?
        /// For tasks that use the awsvpc networking mode, the VPC subnet and security group configuration.
        public var networkConfiguration: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails?
        /// The placement constraints for the tasks in the service.
        public var placementConstraints: [SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails]?
        /// Information about how tasks for the service are placed.
        public var placementStrategies: [SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails]?
        /// The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the LATEST platform version is used by default.
        public var platformVersion: Swift.String?
        /// Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated. Valid values: TASK_DEFINITION | SERVICE
        public var propagateTags: Swift.String?
        /// The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.
        public var role: Swift.String?
        /// The scheduling strategy to use for the service. The REPLICA scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions. The DAEMON scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints. Valid values: REPLICA | DAEMON
        public var schedulingStrategy: Swift.String?
        /// The ARN of the service.
        public var serviceArn: Swift.String?
        /// The name of the service. The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.
        public var serviceName: Swift.String?
        /// Information about the service discovery registries to assign to the service.
        public var serviceRegistries: [SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails]?
        /// The task definition to use for tasks in the service.
        public var taskDefinition: Swift.String?

        public init(
            capacityProviderStrategy: [SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails]? = nil,
            cluster: Swift.String? = nil,
            deploymentConfiguration: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails? = nil,
            deploymentController: SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails? = nil,
            desiredCount: Swift.Int? = nil,
            enableEcsManagedTags: Swift.Bool? = nil,
            enableExecuteCommand: Swift.Bool? = nil,
            healthCheckGracePeriodSeconds: Swift.Int? = nil,
            launchType: Swift.String? = nil,
            loadBalancers: [SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails]? = nil,
            name: Swift.String? = nil,
            networkConfiguration: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails? = nil,
            placementConstraints: [SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails]? = nil,
            placementStrategies: [SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails]? = nil,
            platformVersion: Swift.String? = nil,
            propagateTags: Swift.String? = nil,
            role: Swift.String? = nil,
            schedulingStrategy: Swift.String? = nil,
            serviceArn: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceRegistries: [SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails]? = nil,
            taskDefinition: Swift.String? = nil
        )
        {
            self.capacityProviderStrategy = capacityProviderStrategy
            self.cluster = cluster
            self.deploymentConfiguration = deploymentConfiguration
            self.deploymentController = deploymentController
            self.desiredCount = desiredCount
            self.enableEcsManagedTags = enableEcsManagedTags
            self.enableExecuteCommand = enableExecuteCommand
            self.healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds
            self.launchType = launchType
            self.loadBalancers = loadBalancers
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.placementConstraints = placementConstraints
            self.placementStrategies = placementStrategies
            self.platformVersion = platformVersion
            self.propagateTags = propagateTags
            self.role = role
            self.schedulingStrategy = schedulingStrategy
            self.serviceArn = serviceArn
            self.serviceName = serviceName
            self.serviceRegistries = serviceRegistries
            self.taskDefinition = taskDefinition
        }
    }

}

extension SecurityHubClientTypes {
    /// A dependency that is defined for container startup and shutdown.
    public struct AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {
        /// The dependency condition of the dependent container. Indicates the required status of the dependent container before the current container can start. Valid values are as follows:
        ///
        /// * COMPLETE
        ///
        /// * HEALTHY
        ///
        /// * SUCCESS
        ///
        /// * START
        public var condition: Swift.String?
        /// The name of the dependent container.
        public var containerName: Swift.String?

        public init(
            condition: Swift.String? = nil,
            containerName: Swift.String? = nil
        )
        {
            self.condition = condition
            self.containerName = containerName
        }
    }

}

extension SecurityHubClientTypes {
    /// An environment variable to pass to the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {
        /// The name of the environment variable.
        public var name: Swift.String?
        /// The value of the environment variable.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// A file that contain environment variables to pass to a container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {
        /// The type of environment file. The valid value is s3.
        public var type: Swift.String?
        /// The ARN of the S3 object that contains the environment variable file.
        public var value: Swift.String?

        public init(
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// A hostname and IP address mapping to append to the /etc/hosts file on the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {
        /// The hostname to use in the /etc/hosts entry.
        public var hostname: Swift.String?
        /// The IP address to use in the /etc/hosts entry.
        public var ipAddress: Swift.String?

        public init(
            hostname: Swift.String? = nil,
            ipAddress: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.ipAddress = ipAddress
        }
    }

}

extension SecurityHubClientTypes {
    /// The FireLens configuration for the container. The configuration specifies and configures a log router for container logs.
    public struct AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails {
        /// The options to use to configure the log router. The valid option keys are as follows:
        ///
        /// * enable-ecs-log-metadata. The value can be true or false.
        ///
        /// * config-file-type. The value can be s3 or file.
        ///
        /// * config-file-value. The value is either an S3 ARN or a file path.
        public var options: [Swift.String: Swift.String]?
        /// The log router to use. Valid values are fluentbit or fluentd.
        public var type: Swift.String?

        public init(
            options: [Swift.String: Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.options = options
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// The container health check command and associated configuration parameters for the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {
        /// The command that the container runs to determine whether it is healthy.
        public var command: [Swift.String]?
        /// The time period in seconds between each health check execution. The default value is 30 seconds.
        public var interval: Swift.Int?
        /// The number of times to retry a failed health check before the container is considered unhealthy. The default value is 3.
        public var retries: Swift.Int?
        /// The optional grace period in seconds that allows containers time to bootstrap before failed health checks count towards the maximum number of retries.
        public var startPeriod: Swift.Int?
        /// The time period in seconds to wait for a health check to succeed before it is considered a failure. The default value is 5.
        public var timeout: Swift.Int?

        public init(
            command: [Swift.String]? = nil,
            interval: Swift.Int? = nil,
            retries: Swift.Int? = nil,
            startPeriod: Swift.Int? = nil,
            timeout: Swift.Int? = nil
        )
        {
            self.command = command
            self.interval = interval
            self.retries = retries
            self.startPeriod = startPeriod
            self.timeout = timeout
        }
    }

}

extension SecurityHubClientTypes {
    /// The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails {
        /// The Linux capabilities for the container that are added to the default configuration provided by Docker. Valid values are as follows: Valid values: "ALL" | "AUDIT_CONTROL" | "AUDIT_WRITE" | "BLOCK_SUSPEND" | "CHOWN" | "DAC_OVERRIDE" | "DAC_READ_SEARCH" | "FOWNER" | "FSETID" | "IPC_LOCK" | "IPC_OWNER" | "KILL" | "LEASE" | "LINUX_IMMUTABLE" | "MAC_ADMIN" | "MAC_OVERRIDE" | "MKNOD" | "NET_ADMIN" | "NET_BIND_SERVICE" | "NET_BROADCAST" | "NET_RAW" | "SETFCAP" | "SETGID" | "SETPCAP" | "SETUID" | "SYS_ADMIN" | "SYS_BOOT" | "SYS_CHROOT" | "SYS_MODULE" | "SYS_NICE" | "SYS_PACCT" | "SYS_PTRACE" | "SYS_RAWIO" | "SYS_RESOURCE" | "SYS_TIME" | "SYS_TTY_CONFIG" | "SYSLOG" | "WAKE_ALARM"
        public var add: [Swift.String]?
        /// The Linux capabilities for the container that are dropped from the default configuration provided by Docker. Valid values: "ALL" | "AUDIT_CONTROL" | "AUDIT_WRITE" | "BLOCK_SUSPEND" | "CHOWN" | "DAC_OVERRIDE" | "DAC_READ_SEARCH" | "FOWNER" | "FSETID" | "IPC_LOCK" | "IPC_OWNER" | "KILL" | "LEASE" | "LINUX_IMMUTABLE" | "MAC_ADMIN" | "MAC_OVERRIDE" | "MKNOD" | "NET_ADMIN" | "NET_BIND_SERVICE" | "NET_BROADCAST" | "NET_RAW" | "SETFCAP" | "SETGID" | "SETPCAP" | "SETUID" | "SYS_ADMIN" | "SYS_BOOT" | "SYS_CHROOT" | "SYS_MODULE" | "SYS_NICE" | "SYS_PACCT" | "SYS_PTRACE" | "SYS_RAWIO" | "SYS_RESOURCE" | "SYS_TIME" | "SYS_TTY_CONFIG" | "SYSLOG" | "WAKE_ALARM"
        public var drop: [Swift.String]?

        public init(
            add: [Swift.String]? = nil,
            drop: [Swift.String]? = nil
        )
        {
            self.add = add
            self.drop = drop
        }
    }

}

extension SecurityHubClientTypes {
    /// A host device to expose to the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails {
        /// The path inside the container at which to expose the host device.
        public var containerPath: Swift.String?
        /// The path for the device on the host container instance.
        public var hostPath: Swift.String?
        /// The explicit permissions to provide to the container for the device. By default, the container has permissions for read, write, and mknod for the device.
        public var permissions: [Swift.String]?

        public init(
            containerPath: Swift.String? = nil,
            hostPath: Swift.String? = nil,
            permissions: [Swift.String]? = nil
        )
        {
            self.containerPath = containerPath
            self.hostPath = hostPath
            self.permissions = permissions
        }
    }

}

extension SecurityHubClientTypes {
    /// The container path, mount options, and size (in MiB) of a tmpfs mount.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails {
        /// The absolute file path where the tmpfs volume is to be mounted.
        public var containerPath: Swift.String?
        /// The list of tmpfs volume mount options. Valid values: "defaults" | "ro" | "rw" | "suid" | "nosuid" | "dev" | "nodev" | "exec" | "noexec" | "sync" | "async" | "dirsync" | "remount" | "mand" | "nomand" | "atime" | "noatime" | "diratime" | "nodiratime" | "bind" | "rbind" | "unbindable" | "runbindable" | "private" | "rprivate" | "shared" | "rshared" | "slave" | "rslave" | "relatime" | "norelatime" | "strictatime" | "nostrictatime" | "mode" | "uid" | "gid" | "nr_inodes" | "nr_blocks" | "mpol"
        public var mountOptions: [Swift.String]?
        /// The maximum size (in MiB) of the tmpfs volume.
        public var size: Swift.Int?

        public init(
            containerPath: Swift.String? = nil,
            mountOptions: [Swift.String]? = nil,
            size: Swift.Int? = nil
        )
        {
            self.containerPath = containerPath
            self.mountOptions = mountOptions
            self.size = size
        }
    }

}

extension SecurityHubClientTypes {
    /// >Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {
        /// The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.
        public var capabilities: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails?
        /// The host devices to expose to the container.
        public var devices: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]?
        /// Whether to run an init process inside the container that forwards signals and reaps processes.
        public var initProcessEnabled: Swift.Bool?
        /// The total amount of swap memory (in MiB) that a container can use.
        public var maxSwap: Swift.Int?
        /// The value for the size (in MiB) of the /dev/shm volume.
        public var sharedMemorySize: Swift.Int?
        /// Configures the container's memory swappiness behavior. Determines how aggressively pages are swapped. The higher the value, the more aggressive the swappiness. The default is 60.
        public var swappiness: Swift.Int?
        /// The container path, mount options, and size (in MiB) of the tmpfs mount.
        public var tmpfs: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]?

        public init(
            capabilities: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails? = nil,
            devices: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]? = nil,
            initProcessEnabled: Swift.Bool? = nil,
            maxSwap: Swift.Int? = nil,
            sharedMemorySize: Swift.Int? = nil,
            swappiness: Swift.Int? = nil,
            tmpfs: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]? = nil
        )
        {
            self.capabilities = capabilities
            self.devices = devices
            self.initProcessEnabled = initProcessEnabled
            self.maxSwap = maxSwap
            self.sharedMemorySize = sharedMemorySize
            self.swappiness = swappiness
            self.tmpfs = tmpfs
        }
    }

}

extension SecurityHubClientTypes {
    /// A secret to pass to the log configuration.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails {
        /// The name of the secret.
        public var name: Swift.String?
        /// The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.
        public var valueFrom: Swift.String?

        public init(
            name: Swift.String? = nil,
            valueFrom: Swift.String? = nil
        )
        {
            self.name = name
            self.valueFrom = valueFrom
        }
    }

}

extension SecurityHubClientTypes {
    /// The log configuration specification for the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails {
        /// The log driver to use for the container. Valid values on Fargate are as follows:
        ///
        /// * awsfirelens
        ///
        /// * awslogs
        ///
        /// * splunk
        ///
        ///
        /// Valid values on Amazon EC2 are as follows:
        ///
        /// * awsfirelens
        ///
        /// * awslogs
        ///
        /// * fluentd
        ///
        /// * gelf
        ///
        /// * journald
        ///
        /// * json-file
        ///
        /// * logentries
        ///
        /// * splunk
        ///
        /// * syslog
        public var logDriver: Swift.String?
        /// The configuration options to send to the log driver. Requires version 1.19 of the Docker Remote API or greater on your container instance.
        public var options: [Swift.String: Swift.String]?
        /// The secrets to pass to the log configuration.
        public var secretOptions: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]?

        public init(
            logDriver: Swift.String? = nil,
            options: [Swift.String: Swift.String]? = nil,
            secretOptions: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]? = nil
        )
        {
            self.logDriver = logDriver
            self.options = options
            self.secretOptions = secretOptions
        }
    }

}

extension SecurityHubClientTypes {
    /// A mount point for the data volumes in the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {
        /// The path on the container to mount the host volume at.
        public var containerPath: Swift.String?
        /// Whether the container has read-only access to the volume.
        public var readOnly: Swift.Bool?
        /// The name of the volume to mount. Must match the name of a volume listed in VolumeDetails for the task definition.
        public var sourceVolume: Swift.String?

        public init(
            containerPath: Swift.String? = nil,
            readOnly: Swift.Bool? = nil,
            sourceVolume: Swift.String? = nil
        )
        {
            self.containerPath = containerPath
            self.readOnly = readOnly
            self.sourceVolume = sourceVolume
        }
    }

}

extension SecurityHubClientTypes {
    /// A port mapping for the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {
        /// The port number on the container that is bound to the user-specified or automatically assigned host port.
        public var containerPort: Swift.Int?
        /// The port number on the container instance to reserve for the container.
        public var hostPort: Swift.Int?
        /// The protocol used for the port mapping. The default is tcp.
        public var `protocol`: Swift.String?

        public init(
            containerPort: Swift.Int? = nil,
            hostPort: Swift.Int? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.containerPort = containerPort
            self.hostPort = hostPort
            self.`protocol` = `protocol`
        }
    }

}

extension SecurityHubClientTypes {
    /// The private repository authentication credentials to use.
    public struct AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails {
        /// The ARN of the secret that contains the private repository credentials.
        public var credentialsParameter: Swift.String?

        public init(
            credentialsParameter: Swift.String? = nil
        )
        {
            self.credentialsParameter = credentialsParameter
        }
    }

}

extension SecurityHubClientTypes {
    /// A resource to assign to a container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails {
        /// The type of resource to assign to a container. Valid values are GPU or InferenceAccelerator.
        public var type: Swift.String?
        /// The value for the specified resource type. For GPU, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container. For InferenceAccelerator, the value should match the DeviceName attribute of an entry in InferenceAccelerators.
        public var value: Swift.String?

        public init(
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// A secret to pass to the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {
        /// The name of the secret.
        public var name: Swift.String?
        /// The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.
        public var valueFrom: Swift.String?

        public init(
            name: Swift.String? = nil,
            valueFrom: Swift.String? = nil
        )
        {
            self.name = name
            self.valueFrom = valueFrom
        }
    }

}

extension SecurityHubClientTypes {
    /// A namespaced kernel parameter to set in the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {
        /// The namespaced kernel parameter for which to set a value.
        public var namespace: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init(
            namespace: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.namespace = namespace
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// A ulimit to set in the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {
        /// The hard limit for the ulimit type.
        public var hardLimit: Swift.Int?
        /// The type of the ulimit. Valid values are as follows:
        ///
        /// * core
        ///
        /// * cpu
        ///
        /// * data
        ///
        /// * fsize
        ///
        /// * locks
        ///
        /// * memlock
        ///
        /// * msgqueue
        ///
        /// * nice
        ///
        /// * nofile
        ///
        /// * nproc
        ///
        /// * rss
        ///
        /// * rtprio
        ///
        /// * rttime
        ///
        /// * sigpending
        ///
        /// * stack
        public var name: Swift.String?
        /// The soft limit for the ulimit type.
        public var softLimit: Swift.Int?

        public init(
            hardLimit: Swift.Int? = nil,
            name: Swift.String? = nil,
            softLimit: Swift.Int? = nil
        )
        {
            self.hardLimit = hardLimit
            self.name = name
            self.softLimit = softLimit
        }
    }

}

extension SecurityHubClientTypes {
    /// A data volume to mount from another container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {
        /// Whether the container has read-only access to the volume.
        public var readOnly: Swift.Bool?
        /// The name of another container within the same task definition from which to mount volumes.
        public var sourceContainer: Swift.String?

        public init(
            readOnly: Swift.Bool? = nil,
            sourceContainer: Swift.String? = nil
        )
        {
            self.readOnly = readOnly
            self.sourceContainer = sourceContainer
        }
    }

}

extension SecurityHubClientTypes {
    /// A container definition that describes a container in the task.
    public struct AwsEcsTaskDefinitionContainerDefinitionsDetails {
        /// The command that is passed to the container.
        public var command: [Swift.String]?
        /// The number of CPU units reserved for the container.
        public var cpu: Swift.Int?
        /// The dependencies that are defined for container startup and shutdown.
        public var dependsOn: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]?
        /// Whether to disable networking within the container.
        public var disableNetworking: Swift.Bool?
        /// A list of DNS search domains that are presented to the container.
        public var dnsSearchDomains: [Swift.String]?
        /// A list of DNS servers that are presented to the container.
        public var dnsServers: [Swift.String]?
        /// A key-value map of labels to add to the container.
        public var dockerLabels: [Swift.String: Swift.String]?
        /// A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems.
        public var dockerSecurityOptions: [Swift.String]?
        /// The entry point that is passed to the container.
        public var entryPoint: [Swift.String]?
        /// The environment variables to pass to a container.
        public var environment: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]?
        /// A list of files containing the environment variables to pass to a container.
        public var environmentFiles: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]?
        /// Whether the container is essential. All tasks must have at least one essential container.
        public var essential: Swift.Bool?
        /// A list of hostnames and IP address mappings to append to the /etc/hosts file on the container.
        public var extraHosts: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]?
        /// The FireLens configuration for the container. Specifies and configures a log router for container logs.
        public var firelensConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails?
        /// The container health check command and associated configuration parameters for the container.
        public var healthCheck: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails?
        /// The hostname to use for the container.
        public var hostname: Swift.String?
        /// The image used to start the container.
        public var image: Swift.String?
        /// If set to true, then containerized applications can be deployed that require stdin or a tty to be allocated.
        public var interactive: Swift.Bool?
        /// A list of links for the container in the form  container_name:alias . Allows containers to communicate with each other without the need for port mappings.
        public var links: [Swift.String]?
        /// Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.
        public var linuxParameters: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails?
        /// The log configuration specification for the container.
        public var logConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails?
        /// The amount (in MiB) of memory to present to the container. If the container attempts to exceed the memory specified here, the container is shut down. The total amount of memory reserved for all containers within a task must be lower than the task memory value, if one is specified.
        public var memory: Swift.Int?
        /// The soft limit (in MiB) of memory to reserve for the container.
        public var memoryReservation: Swift.Int?
        /// The mount points for the data volumes in the container.
        public var mountPoints: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]?
        /// The name of the container.
        public var name: Swift.String?
        /// The list of port mappings for the container.
        public var portMappings: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]?
        /// Whether the container is given elevated privileges on the host container instance. The elevated privileges are similar to the root user.
        public var privileged: Swift.Bool?
        /// Whether to allocate a TTY to the container.
        public var pseudoTerminal: Swift.Bool?
        /// Whether the container is given read-only access to its root file system.
        public var readonlyRootFilesystem: Swift.Bool?
        /// The private repository authentication credentials to use.
        public var repositoryCredentials: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails?
        /// The type and amount of a resource to assign to a container. The only supported resource is a GPU.
        public var resourceRequirements: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]?
        /// The secrets to pass to the container.
        public var secrets: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]?
        /// The number of seconds to wait before giving up on resolving dependencies for a container.
        public var startTimeout: Swift.Int?
        /// The number of seconds to wait before the container is stopped if it doesn't shut down normally on its own.
        public var stopTimeout: Swift.Int?
        /// A list of namespaced kernel parameters to set in the container.
        public var systemControls: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]?
        /// A list of ulimits to set in the container.
        public var ulimits: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]?
        /// The user to use inside the container. The value can use one of the following formats.
        ///
        /// * user
        ///
        /// * user : group
        ///
        /// * uid
        ///
        /// * uid : gid
        ///
        /// * user : gid
        ///
        /// * uid : group
        public var user: Swift.String?
        /// Data volumes to mount from another container.
        public var volumesFrom: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]?
        /// The working directory in which to run commands inside the container.
        public var workingDirectory: Swift.String?

        public init(
            command: [Swift.String]? = nil,
            cpu: Swift.Int? = nil,
            dependsOn: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]? = nil,
            disableNetworking: Swift.Bool? = nil,
            dnsSearchDomains: [Swift.String]? = nil,
            dnsServers: [Swift.String]? = nil,
            dockerLabels: [Swift.String: Swift.String]? = nil,
            dockerSecurityOptions: [Swift.String]? = nil,
            entryPoint: [Swift.String]? = nil,
            environment: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]? = nil,
            environmentFiles: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]? = nil,
            essential: Swift.Bool? = nil,
            extraHosts: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]? = nil,
            firelensConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails? = nil,
            healthCheck: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails? = nil,
            hostname: Swift.String? = nil,
            image: Swift.String? = nil,
            interactive: Swift.Bool? = nil,
            links: [Swift.String]? = nil,
            linuxParameters: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails? = nil,
            logConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails? = nil,
            memory: Swift.Int? = nil,
            memoryReservation: Swift.Int? = nil,
            mountPoints: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]? = nil,
            name: Swift.String? = nil,
            portMappings: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]? = nil,
            privileged: Swift.Bool? = nil,
            pseudoTerminal: Swift.Bool? = nil,
            readonlyRootFilesystem: Swift.Bool? = nil,
            repositoryCredentials: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails? = nil,
            resourceRequirements: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]? = nil,
            secrets: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]? = nil,
            startTimeout: Swift.Int? = nil,
            stopTimeout: Swift.Int? = nil,
            systemControls: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]? = nil,
            ulimits: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]? = nil,
            user: Swift.String? = nil,
            volumesFrom: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.command = command
            self.cpu = cpu
            self.dependsOn = dependsOn
            self.disableNetworking = disableNetworking
            self.dnsSearchDomains = dnsSearchDomains
            self.dnsServers = dnsServers
            self.dockerLabels = dockerLabels
            self.dockerSecurityOptions = dockerSecurityOptions
            self.entryPoint = entryPoint
            self.environment = environment
            self.environmentFiles = environmentFiles
            self.essential = essential
            self.extraHosts = extraHosts
            self.firelensConfiguration = firelensConfiguration
            self.healthCheck = healthCheck
            self.hostname = hostname
            self.image = image
            self.interactive = interactive
            self.links = links
            self.linuxParameters = linuxParameters
            self.logConfiguration = logConfiguration
            self.memory = memory
            self.memoryReservation = memoryReservation
            self.mountPoints = mountPoints
            self.name = name
            self.portMappings = portMappings
            self.privileged = privileged
            self.pseudoTerminal = pseudoTerminal
            self.readonlyRootFilesystem = readonlyRootFilesystem
            self.repositoryCredentials = repositoryCredentials
            self.resourceRequirements = resourceRequirements
            self.secrets = secrets
            self.startTimeout = startTimeout
            self.stopTimeout = stopTimeout
            self.systemControls = systemControls
            self.ulimits = ulimits
            self.user = user
            self.volumesFrom = volumesFrom
            self.workingDirectory = workingDirectory
        }
    }

}

extension SecurityHubClientTypes {
    /// An Elastic Inference accelerator to use for the containers in the task.
    public struct AwsEcsTaskDefinitionInferenceAcceleratorsDetails {
        /// The Elastic Inference accelerator device name.
        public var deviceName: Swift.String?
        /// The Elastic Inference accelerator type to use.
        public var deviceType: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            deviceType: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.deviceType = deviceType
        }
    }

}

extension SecurityHubClientTypes {
    /// A placement constraint object to use for tasks.
    public struct AwsEcsTaskDefinitionPlacementConstraintsDetails {
        /// A cluster query language expression to apply to the constraint.
        public var expression: Swift.String?
        /// The type of constraint.
        public var type: Swift.String?

        public init(
            expression: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.expression = expression
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// A network configuration parameter to provide to the Container Network Interface (CNI) plugin.
    public struct AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails {
        /// The name of the property.
        public var name: Swift.String?
        /// The value of the property.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// The configuration details for the App Mesh proxy.
    public struct AwsEcsTaskDefinitionProxyConfigurationDetails {
        /// The name of the container that will serve as the App Mesh proxy.
        public var containerName: Swift.String?
        /// The set of network configuration parameters to provide to the Container Network Interface (CNI) plugin, specified as key-value pairs.
        public var proxyConfigurationProperties: [SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]?
        /// The proxy type.
        public var type: Swift.String?

        public init(
            containerName: Swift.String? = nil,
            proxyConfigurationProperties: [SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]? = nil,
            type: Swift.String? = nil
        )
        {
            self.containerName = containerName
            self.proxyConfigurationProperties = proxyConfigurationProperties
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a Docker volume.
    public struct AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {
        /// Whether to create the Docker volume automatically if it does not already exist.
        public var autoprovision: Swift.Bool?
        /// The Docker volume driver to use.
        public var driver: Swift.String?
        /// A map of Docker driver-specific options that are passed through.
        public var driverOpts: [Swift.String: Swift.String]?
        /// Custom metadata to add to the Docker volume.
        public var labels: [Swift.String: Swift.String]?
        /// The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a task are provisioned automatically when the task starts and destroyed when the task stops. Docker volumes that are shared persist after the task stops. Valid values are shared or task.
        public var scope: Swift.String?

        public init(
            autoprovision: Swift.Bool? = nil,
            driver: Swift.String? = nil,
            driverOpts: [Swift.String: Swift.String]? = nil,
            labels: [Swift.String: Swift.String]? = nil,
            scope: Swift.String? = nil
        )
        {
            self.autoprovision = autoprovision
            self.driver = driver
            self.driverOpts = driverOpts
            self.labels = labels
            self.scope = scope
        }
    }

}

extension SecurityHubClientTypes {
    ///
    public struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails {
        /// The Amazon EFS access point identifier to use.
        public var accessPointId: Swift.String?
        /// Whether to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system.
        public var iam: Swift.String?

        public init(
            accessPointId: Swift.String? = nil,
            iam: Swift.String? = nil
        )
        {
            self.accessPointId = accessPointId
            self.iam = iam
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the Amazon Elastic File System file system that is used for task storage.
    public struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {
        /// The authorization configuration details for the Amazon EFS file system.
        public var authorizationConfig: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails?
        /// The Amazon EFS file system identifier to use.
        public var filesystemId: Swift.String?
        /// The directory within the Amazon EFS file system to mount as the root directory inside the host.
        public var rootDirectory: Swift.String?
        /// Whether to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server.
        public var transitEncryption: Swift.String?
        /// The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server.
        public var transitEncryptionPort: Swift.Int?

        public init(
            authorizationConfig: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails? = nil,
            filesystemId: Swift.String? = nil,
            rootDirectory: Swift.String? = nil,
            transitEncryption: Swift.String? = nil,
            transitEncryptionPort: Swift.Int? = nil
        )
        {
            self.authorizationConfig = authorizationConfig
            self.filesystemId = filesystemId
            self.rootDirectory = rootDirectory
            self.transitEncryption = transitEncryption
            self.transitEncryptionPort = transitEncryptionPort
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a bind mount host volume.
    public struct AwsEcsTaskDefinitionVolumesHostDetails {
        /// The path on the host container instance that is presented to the container.
        public var sourcePath: Swift.String?

        public init(
            sourcePath: Swift.String? = nil
        )
        {
            self.sourcePath = sourcePath
        }
    }

}

extension SecurityHubClientTypes {
    /// A data volume to mount from another container.
    public struct AwsEcsTaskDefinitionVolumesDetails {
        /// Information about a Docker volume.
        public var dockerVolumeConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails?
        /// Information about the Amazon Elastic File System file system that is used for task storage.
        public var efsVolumeConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails?
        /// Information about a bind mount host volume.
        public var host: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails?
        /// The name of the data volume.
        public var name: Swift.String?

        public init(
            dockerVolumeConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails? = nil,
            efsVolumeConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails? = nil,
            host: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails? = nil,
            name: Swift.String? = nil
        )
        {
            self.dockerVolumeConfiguration = dockerVolumeConfiguration
            self.efsVolumeConfiguration = efsVolumeConfiguration
            self.host = host
            self.name = name
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.
    public struct AwsEcsTaskDefinitionDetails {
        /// The container definitions that describe the containers that make up the task.
        public var containerDefinitions: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails]?
        /// The number of CPU units used by the task.Valid values are as follows:
        ///
        /// * 256 (.25 vCPU)
        ///
        /// * 512 (.5 vCPU)
        ///
        /// * 1024 (1 vCPU)
        ///
        /// * 2048 (2 vCPU)
        ///
        /// * 4096 (4 vCPU)
        public var cpu: Swift.String?
        /// The ARN of the task execution role that grants the container agent permission to make API calls on behalf of the container user.
        public var executionRoleArn: Swift.String?
        /// The name of a family that this task definition is registered to.
        public var family: Swift.String?
        /// The Elastic Inference accelerators to use for the containers in the task.
        public var inferenceAccelerators: [SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails]?
        /// The inter-process communication (IPC) resource namespace to use for the containers in the task. Valid values are as follows:
        ///
        /// * host
        ///
        /// * none
        ///
        /// * task
        public var ipcMode: Swift.String?
        /// The amount (in MiB) of memory used by the task. For tasks that are hosted on Amazon EC2, you can provide a task-level memory value or a container-level memory value. For tasks that are hosted on Fargate, you must use one of the [specified values](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#task_size) in the Amazon Elastic Container Service Developer Guide , which determines your range of supported values for the Cpu and Memory parameters.
        public var memory: Swift.String?
        /// The Docker networking mode to use for the containers in the task. Valid values are as follows:
        ///
        /// * awsvpc
        ///
        /// * bridge
        ///
        /// * host
        ///
        /// * none
        public var networkMode: Swift.String?
        /// The process namespace to use for the containers in the task. Valid values are host or task.
        public var pidMode: Swift.String?
        /// The placement constraint objects to use for tasks.
        public var placementConstraints: [SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails]?
        /// The configuration details for the App Mesh proxy.
        public var proxyConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails?
        /// The task launch types that the task definition was validated against.
        public var requiresCompatibilities: [Swift.String]?
        /// The status of the task definition.
        public var status: Swift.String?
        /// The short name or ARN of the IAM role that grants containers in the task permission to call Amazon Web Services API operations on your behalf.
        public var taskRoleArn: Swift.String?
        /// The data volume definitions for the task.
        public var volumes: [SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails]?

        public init(
            containerDefinitions: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails]? = nil,
            cpu: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            family: Swift.String? = nil,
            inferenceAccelerators: [SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails]? = nil,
            ipcMode: Swift.String? = nil,
            memory: Swift.String? = nil,
            networkMode: Swift.String? = nil,
            pidMode: Swift.String? = nil,
            placementConstraints: [SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails]? = nil,
            proxyConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails? = nil,
            requiresCompatibilities: [Swift.String]? = nil,
            status: Swift.String? = nil,
            taskRoleArn: Swift.String? = nil,
            volumes: [SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails]? = nil
        )
        {
            self.containerDefinitions = containerDefinitions
            self.cpu = cpu
            self.executionRoleArn = executionRoleArn
            self.family = family
            self.inferenceAccelerators = inferenceAccelerators
            self.ipcMode = ipcMode
            self.memory = memory
            self.networkMode = networkMode
            self.pidMode = pidMode
            self.placementConstraints = placementConstraints
            self.proxyConfiguration = proxyConfiguration
            self.requiresCompatibilities = requiresCompatibilities
            self.status = status
            self.taskRoleArn = taskRoleArn
            self.volumes = volumes
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details on a container instance bind mount host volume.
    public struct AwsEcsTaskVolumeHostDetails {
        /// When the host parameter is used, specify a sourcePath to declare the path on the host container instance that's presented to the container.
        public var sourcePath: Swift.String?

        public init(
            sourcePath: Swift.String? = nil
        )
        {
            self.sourcePath = sourcePath
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about a data volume that's used in a task definition.
    public struct AwsEcsTaskVolumeDetails {
        /// This parameter is specified when you use bind mount host volumes. The contents of the host parameter determine whether your bind mount host volume persists on the host container instance and where it's stored.
        public var host: SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails?
        /// The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. This name is referenced in the sourceVolume parameter of container definition mountPoints.
        public var name: Swift.String?

        public init(
            host: SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails? = nil,
            name: Swift.String? = nil
        )
        {
            self.host = host
            self.name = name
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about a task in a cluster.
    public struct AwsEcsTaskDetails {
        /// The Amazon Resource Name (ARN) of the cluster that hosts the task.
        public var clusterArn: Swift.String?
        /// The containers that are associated with the task.
        public var containers: [SecurityHubClientTypes.AwsEcsContainerDetails]?
        /// The Unix timestamp for the time when the task was created. More specifically, it's for the time when the task entered the PENDING state.
        public var createdAt: Swift.String?
        /// The name of the task group that's associated with the task.
        public var group: Swift.String?
        /// The Unix timestamp for the time when the task started. More specifically, it's for the time when the task transitioned from the PENDING state to the RUNNING state.
        public var startedAt: Swift.String?
        /// The tag specified when a task is started. If an Amazon ECS service started the task, the startedBy parameter contains the deployment ID of that service.
        public var startedBy: Swift.String?
        /// The ARN of the task definition that creates the task.
        public var taskDefinitionArn: Swift.String?
        /// The version counter for the task.
        public var version: Swift.String?
        /// Details about the data volume that is used in a task definition.
        public var volumes: [SecurityHubClientTypes.AwsEcsTaskVolumeDetails]?

        public init(
            clusterArn: Swift.String? = nil,
            containers: [SecurityHubClientTypes.AwsEcsContainerDetails]? = nil,
            createdAt: Swift.String? = nil,
            group: Swift.String? = nil,
            startedAt: Swift.String? = nil,
            startedBy: Swift.String? = nil,
            taskDefinitionArn: Swift.String? = nil,
            version: Swift.String? = nil,
            volumes: [SecurityHubClientTypes.AwsEcsTaskVolumeDetails]? = nil
        )
        {
            self.clusterArn = clusterArn
            self.containers = containers
            self.createdAt = createdAt
            self.group = group
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.taskDefinitionArn = taskDefinitionArn
            self.version = version
            self.volumes = volumes
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details for all file system operations using this Amazon EFS access point.
    public struct AwsEfsAccessPointPosixUserDetails {
        /// The POSIX group ID used for all file system operations using this access point.
        public var gid: Swift.String?
        /// Secondary POSIX group IDs used for all file system operations using this access point.
        public var secondaryGids: [Swift.String]?
        /// The POSIX user ID used for all file system operations using this access point.
        public var uid: Swift.String?

        public init(
            gid: Swift.String? = nil,
            secondaryGids: [Swift.String]? = nil,
            uid: Swift.String? = nil
        )
        {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the settings that Amazon EFS uses to create the root directory when a client connects to an access point.
    public struct AwsEfsAccessPointRootDirectoryCreationInfoDetails {
        /// Specifies the POSIX group ID to apply to the root directory.
        public var ownerGid: Swift.String?
        /// Specifies the POSIX user ID to apply to the root directory.
        public var ownerUid: Swift.String?
        /// Specifies the POSIX permissions to apply to the root directory, in the format of an octal number representing the file's mode bits.
        public var permissions: Swift.String?

        public init(
            ownerGid: Swift.String? = nil,
            ownerUid: Swift.String? = nil,
            permissions: Swift.String? = nil
        )
        {
            self.ownerGid = ownerGid
            self.ownerUid = ownerUid
            self.permissions = permissions
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.
    public struct AwsEfsAccessPointRootDirectoryDetails {
        /// Specifies the POSIX IDs and permissions to apply to the access point's root directory.
        public var creationInfo: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails?
        /// Specifies the path on the Amazon EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide CreationInfo.
        public var path: Swift.String?

        public init(
            creationInfo: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails? = nil,
            path: Swift.String? = nil
        )
        {
            self.creationInfo = creationInfo
            self.path = path
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon EFS access point.
    public struct AwsEfsAccessPointDetails {
        /// The ID of the Amazon EFS access point.
        public var accessPointId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point.
        public var arn: Swift.String?
        /// The opaque string specified in the request to ensure idempotent creation.
        public var clientToken: Swift.String?
        /// The ID of the Amazon EFS file system that the access point applies to.
        public var fileSystemId: Swift.String?
        /// The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point, that is used for all file operations by NFS clients using the access point.
        public var posixUser: SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails?
        /// The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.
        public var rootDirectory: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails?

        public init(
            accessPointId: Swift.String? = nil,
            arn: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            posixUser: SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails? = nil,
            rootDirectory: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails? = nil
        )
        {
            self.accessPointId = accessPointId
            self.arn = arn
            self.clientToken = clientToken
            self.fileSystemId = fileSystemId
            self.posixUser = posixUser
            self.rootDirectory = rootDirectory
        }
    }

}

extension SecurityHubClientTypes {
    /// Details for a cluster logging configuration.
    public struct AwsEksClusterLoggingClusterLoggingDetails {
        /// Whether the logging types that are listed in Types are enabled.
        public var enabled: Swift.Bool?
        /// A list of logging types. Valid values are as follows:
        ///
        /// * api
        ///
        /// * audit
        ///
        /// * authenticator
        ///
        /// * controllerManager
        ///
        /// * scheduler
        public var types: [Swift.String]?

        public init(
            enabled: Swift.Bool? = nil,
            types: [Swift.String]? = nil
        )
        {
            self.enabled = enabled
            self.types = types
        }
    }

}

extension SecurityHubClientTypes {
    /// The logging configuration for an Amazon EKS cluster.
    public struct AwsEksClusterLoggingDetails {
        /// Cluster logging configurations.
        public var clusterLogging: [SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails]?

        public init(
            clusterLogging: [SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails]? = nil
        )
        {
            self.clusterLogging = clusterLogging
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the VPC configuration used by the cluster control plane.
    public struct AwsEksClusterResourcesVpcConfigDetails {
        /// Indicates whether the Amazon EKS public API server endpoint is turned on. If the Amazon EKS public API server endpoint is turned off, your cluster's Kubernetes API server can only receive requests that originate from within the cluster VPC.
        public var endpointPublicAccess: Swift.Bool?
        /// The security groups that are associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Amazon EKS control plane.
        public var securityGroupIds: [Swift.String]?
        /// The subnets that are associated with the cluster.
        public var subnetIds: [Swift.String]?

        public init(
            endpointPublicAccess: Swift.Bool? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.endpointPublicAccess = endpointPublicAccess
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon EKS cluster.
    public struct AwsEksClusterDetails {
        /// The ARN of the cluster.
        public var arn: Swift.String?
        /// The certificate authority data for the cluster.
        public var certificateAuthorityData: Swift.String?
        /// The status of the cluster. Valid values are as follows:
        ///
        /// * ACTIVE
        ///
        /// * CREATING
        ///
        /// * DELETING
        ///
        /// * FAILED
        ///
        /// * PENDING
        ///
        /// * UPDATING
        public var clusterStatus: Swift.String?
        /// The endpoint for the Amazon EKS API server.
        public var endpoint: Swift.String?
        /// The logging configuration for the cluster.
        public var logging: SecurityHubClientTypes.AwsEksClusterLoggingDetails?
        /// The name of the cluster.
        public var name: Swift.String?
        /// The VPC configuration used by the cluster control plane.
        public var resourcesVpcConfig: SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails?
        /// The ARN of the IAM role that provides permissions for the Amazon EKS control plane to make calls to Amazon Web Services API operations on your behalf.
        public var roleArn: Swift.String?
        /// The Amazon EKS server version for the cluster.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            certificateAuthorityData: Swift.String? = nil,
            clusterStatus: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            logging: SecurityHubClientTypes.AwsEksClusterLoggingDetails? = nil,
            name: Swift.String? = nil,
            resourcesVpcConfig: SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails? = nil,
            roleArn: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.certificateAuthorityData = certificateAuthorityData
            self.clusterStatus = clusterStatus
            self.endpoint = endpoint
            self.logging = logging
            self.name = name
            self.resourcesVpcConfig = resourcesVpcConfig
            self.roleArn = roleArn
            self.version = version
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about a link to another environment that is in the same group.
    public struct AwsElasticBeanstalkEnvironmentEnvironmentLink {
        /// The name of the linked environment.
        public var environmentName: Swift.String?
        /// The name of the environment link.
        public var linkName: Swift.String?

        public init(
            environmentName: Swift.String? = nil,
            linkName: Swift.String? = nil
        )
        {
            self.environmentName = environmentName
            self.linkName = linkName
        }
    }

}

extension SecurityHubClientTypes {
    /// A configuration option setting for the environment.
    public struct AwsElasticBeanstalkEnvironmentOptionSetting {
        /// The type of resource that the configuration option is associated with.
        public var namespace: Swift.String?
        /// The name of the option.
        public var optionName: Swift.String?
        /// The name of the resource.
        public var resourceName: Swift.String?
        /// The value of the configuration setting.
        public var value: Swift.String?

        public init(
            namespace: Swift.String? = nil,
            optionName: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.namespace = namespace
            self.optionName = optionName
            self.resourceName = resourceName
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the tier of the environment.
    public struct AwsElasticBeanstalkEnvironmentTier {
        /// The name of the environment tier. Valid values are WebServer or Worker.
        public var name: Swift.String?
        /// The type of environment tier. Valid values are Standard or SQS/HTTP.
        public var type: Swift.String?
        /// The version of the environment tier.
        public var version: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.version = version
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains details about an Elastic Beanstalk environment.
    public struct AwsElasticBeanstalkEnvironmentDetails {
        /// The name of the application that is associated with the environment.
        public var applicationName: Swift.String?
        /// The URL to the CNAME for this environment.
        public var cname: Swift.String?
        /// The creation date for this environment.
        public var dateCreated: Swift.String?
        /// The date when this environment was last modified.
        public var dateUpdated: Swift.String?
        /// A description of the environment.
        public var description: Swift.String?
        /// For load-balanced, autoscaling environments, the URL to the load balancer. For single-instance environments, the IP address of the instance.
        public var endpointUrl: Swift.String?
        /// The ARN of the environment.
        public var environmentArn: Swift.String?
        /// The identifier of the environment.
        public var environmentId: Swift.String?
        /// Links to other environments in the same group.
        public var environmentLinks: [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink]?
        /// The name of the environment.
        public var environmentName: Swift.String?
        /// The configuration setting for the environment.
        public var optionSettings: [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting]?
        /// The ARN of the platform version for the environment.
        public var platformArn: Swift.String?
        /// The name of the solution stack that is deployed with the environment.
        public var solutionStackName: Swift.String?
        /// The current operational status of the environment. Valid values are as follows:
        ///
        /// * Aborting
        ///
        /// * Launching
        ///
        /// * LinkingFrom
        ///
        /// * LinkingTo
        ///
        /// * Ready
        ///
        /// * Terminated
        ///
        /// * Terminating
        ///
        /// * Updating
        public var status: Swift.String?
        /// The tier of the environment.
        public var tier: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier?
        /// The application version of the environment.
        public var versionLabel: Swift.String?

        public init(
            applicationName: Swift.String? = nil,
            cname: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            endpointUrl: Swift.String? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            environmentLinks: [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink]? = nil,
            environmentName: Swift.String? = nil,
            optionSettings: [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting]? = nil,
            platformArn: Swift.String? = nil,
            solutionStackName: Swift.String? = nil,
            status: Swift.String? = nil,
            tier: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier? = nil,
            versionLabel: Swift.String? = nil
        )
        {
            self.applicationName = applicationName
            self.cname = cname
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.endpointUrl = endpointUrl
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentLinks = environmentLinks
            self.environmentName = environmentName
            self.optionSettings = optionSettings
            self.platformArn = platformArn
            self.solutionStackName = solutionStackName
            self.status = status
            self.tier = tier
            self.versionLabel = versionLabel
        }
    }

}

extension SecurityHubClientTypes {
    /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
    public struct AwsElasticsearchDomainDomainEndpointOptions {
        /// Whether to require that all traffic to the domain arrive over HTTPS.
        public var enforceHTTPS: Swift.Bool?
        /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain. Valid values:
        ///
        /// * Policy-Min-TLS-1-0-2019-07, which supports TLSv1.0 and higher
        ///
        /// * Policy-Min-TLS-1-2-2019-07, which only supports TLSv1.2
        public var tlsSecurityPolicy: Swift.String?

        public init(
            enforceHTTPS: Swift.Bool? = nil,
            tlsSecurityPolicy: Swift.String? = nil
        )
        {
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }
    }

}

extension SecurityHubClientTypes {
    /// Configuration options for zone awareness.
    public struct AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails {
        /// he number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.
        public var availabilityZoneCount: Swift.Int?

        public init(
            availabilityZoneCount: Swift.Int? = nil
        )
        {
            self.availabilityZoneCount = availabilityZoneCount
        }
    }

}

extension SecurityHubClientTypes {
    /// details about the configuration of an OpenSearch cluster.
    public struct AwsElasticsearchDomainElasticsearchClusterConfigDetails {
        /// The number of instances to use for the master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public var dedicatedMasterCount: Swift.Int?
        /// Whether to use a dedicated master node for the Elasticsearch domain. A dedicated master node performs cluster management tasks, but doesn't hold data or respond to data upload requests.
        public var dedicatedMasterEnabled: Swift.Bool?
        /// The hardware configuration of the computer that hosts the dedicated master node. A sample value is m3.medium.elasticsearch. If this attribute is specified, then DedicatedMasterEnabled must be true. For a list of valid values, see [Supported instance types in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html) in the Amazon OpenSearch Service Developer Guide.
        public var dedicatedMasterType: Swift.String?
        /// The number of data nodes to use in the Elasticsearch domain.
        public var instanceCount: Swift.Int?
        /// The instance type for your data nodes. For example, m3.medium.elasticsearch. For a list of valid values, see [Supported instance types in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html) in the Amazon OpenSearch Service Developer Guide.
        public var instanceType: Swift.String?
        /// Configuration options for zone awareness. Provided if ZoneAwarenessEnabled is true.
        public var zoneAwarenessConfig: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails?
        /// Whether to enable zone awareness for the Elasticsearch domain. When zone awareness is enabled, OpenSearch allocates the cluster's nodes and replica index shards across Availability Zones in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.
        public var zoneAwarenessEnabled: Swift.Bool?

        public init(
            dedicatedMasterCount: Swift.Int? = nil,
            dedicatedMasterEnabled: Swift.Bool? = nil,
            dedicatedMasterType: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            instanceType: Swift.String? = nil,
            zoneAwarenessConfig: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails? = nil,
            zoneAwarenessEnabled: Swift.Bool? = nil
        )
        {
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the configuration for encryption at rest.
    public struct AwsElasticsearchDomainEncryptionAtRestOptions {
        /// Whether encryption at rest is enabled.
        public var enabled: Swift.Bool?
        /// The KMS key ID. Takes the form 1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a.
        public var kmsKeyId: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension SecurityHubClientTypes {
    /// The log configuration.
    public struct AwsElasticsearchDomainLogPublishingOptionsLogConfig {
        /// The ARN of the CloudWatch Logs group to publish the logs to.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Whether the log publishing is enabled.
        public var enabled: Swift.Bool?

        public init(
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// configures the CloudWatch Logs to publish for the Elasticsearch domain.
    public struct AwsElasticsearchDomainLogPublishingOptions {
        /// The log configuration.
        public var auditLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig?
        /// Configures the OpenSearch index logs publishing.
        public var indexSlowLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig?
        /// Configures the OpenSearch search slow log publishing.
        public var searchSlowLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig?

        public init(
            auditLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil,
            indexSlowLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil,
            searchSlowLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil
        )
        {
            self.auditLogs = auditLogs
            self.indexSlowLogs = indexSlowLogs
            self.searchSlowLogs = searchSlowLogs
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the configuration for node-to-node encryption.
    public struct AwsElasticsearchDomainNodeToNodeEncryptionOptions {
        /// Whether node-to-node encryption is enabled.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the state of the domain relative to the latest service software.
    public struct AwsElasticsearchDomainServiceSoftwareOptions {
        /// The epoch time when the deployment window closes for required updates. After this time, Amazon OpenSearch Service schedules the software upgrade automatically.
        public var automatedUpdateDate: Swift.String?
        /// Whether a request to update the domain can be canceled.
        public var cancellable: Swift.Bool?
        /// The version of the service software that is currently installed on the domain.
        public var currentVersion: Swift.String?
        /// A more detailed description of the service software status.
        public var description: Swift.String?
        /// The most recent version of the service software.
        public var newVersion: Swift.String?
        /// Whether a service software update is available for the domain.
        public var updateAvailable: Swift.Bool?
        /// The status of the service software update. Valid values are as follows:
        ///
        /// * COMPLETED
        ///
        /// * ELIGIBLE
        ///
        /// * IN_PROGRESS
        ///
        /// * NOT_ELIGIBLE
        ///
        /// * PENDING_UPDATE
        public var updateStatus: Swift.String?

        public init(
            automatedUpdateDate: Swift.String? = nil,
            cancellable: Swift.Bool? = nil,
            currentVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            newVersion: Swift.String? = nil,
            updateAvailable: Swift.Bool? = nil,
            updateStatus: Swift.String? = nil
        )
        {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }
    }

}

extension SecurityHubClientTypes {
    /// Information that OpenSearch derives based on VPCOptions for the domain.
    public struct AwsElasticsearchDomainVPCOptions {
        /// The list of Availability Zones associated with the VPC subnets.
        public var availabilityZones: [Swift.String]?
        /// The list of security group IDs associated with the VPC endpoints for the domain.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs associated with the VPC endpoints for the domain.
        public var subnetIds: [Swift.String]?
        /// ID for the VPC.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an Elasticsearch domain.
    public struct AwsElasticsearchDomainDetails {
        /// IAM policy document specifying the access policies for the new Elasticsearch domain.
        public var accessPolicies: Swift.String?
        /// Additional options for the domain endpoint.
        public var domainEndpointOptions: SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions?
        /// Unique identifier for an Elasticsearch domain.
        public var domainId: Swift.String?
        /// Name of an Elasticsearch domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region. Domain names must start with a lowercase letter and must be between 3 and 28 characters. Valid characters are a-z (lowercase only), 0-9, and – (hyphen).
        public var domainName: Swift.String?
        /// Information about an OpenSearch cluster configuration.
        public var elasticsearchClusterConfig: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails?
        /// OpenSearch version.
        public var elasticsearchVersion: Swift.String?
        /// Details about the configuration for encryption at rest.
        public var encryptionAtRestOptions: SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions?
        /// Domain-specific endpoint used to submit index, search, and data upload requests to an Elasticsearch domain. The endpoint is a service URL.
        public var endpoint: Swift.String?
        /// The key-value pair that exists if the Elasticsearch domain uses VPC endpoints.
        public var endpoints: [Swift.String: Swift.String]?
        /// Configures the CloudWatch Logs to publish for the Elasticsearch domain.
        public var logPublishingOptions: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions?
        /// Details about the configuration for node-to-node encryption.
        public var nodeToNodeEncryptionOptions: SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions?
        /// Information about the status of a domain relative to the latest service software.
        public var serviceSoftwareOptions: SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions?
        /// Information that OpenSearch derives based on VPCOptions for the domain.
        public var vpcOptions: SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions?

        public init(
            accessPolicies: Swift.String? = nil,
            domainEndpointOptions: SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions? = nil,
            domainId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            elasticsearchClusterConfig: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails? = nil,
            elasticsearchVersion: Swift.String? = nil,
            encryptionAtRestOptions: SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions? = nil,
            endpoint: Swift.String? = nil,
            endpoints: [Swift.String: Swift.String]? = nil,
            logPublishingOptions: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions? = nil,
            nodeToNodeEncryptionOptions: SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions? = nil,
            serviceSoftwareOptions: SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions? = nil,
            vpcOptions: SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions? = nil
        )
        {
            self.accessPolicies = accessPolicies
            self.domainEndpointOptions = domainEndpointOptions
            self.domainId = domainId
            self.domainName = domainName
            self.elasticsearchClusterConfig = elasticsearchClusterConfig
            self.elasticsearchVersion = elasticsearchVersion
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.endpoint = endpoint
            self.endpoints = endpoints
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.vpcOptions = vpcOptions
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about a stickiness policy that was created using CreateAppCookieStickinessPolicy.
    public struct AwsElbAppCookieStickinessPolicy {
        /// The name of the application cookie used for stickiness.
        public var cookieName: Swift.String?
        /// The mnemonic name for the policy being created. The name must be unique within the set of policies for the load balancer.
        public var policyName: Swift.String?

        public init(
            cookieName: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.cookieName = cookieName
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about a stickiness policy that was created using CreateLBCookieStickinessPolicy.
    public struct AwsElbLbCookieStickinessPolicy {
        /// The amount of time, in seconds, after which the cookie is considered stale. If an expiration period is not specified, the stickiness session lasts for the duration of the browser session.
        public var cookieExpirationPeriod: Swift.Int?
        /// The name of the policy. The name must be unique within the set of policies for the load balancer.
        public var policyName: Swift.String?

        public init(
            cookieExpirationPeriod: Swift.Int? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.cookieExpirationPeriod = cookieExpirationPeriod
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the access log configuration for the load balancer.
    public struct AwsElbLoadBalancerAccessLog {
        /// The interval in minutes for publishing the access logs. You can publish access logs either every 5 minutes or every 60 minutes.
        public var emitInterval: Swift.Int?
        /// Indicates whether access logs are enabled for the load balancer.
        public var enabled: Swift.Bool?
        /// The name of the S3 bucket where the access logs are stored.
        public var s3BucketName: Swift.String?
        /// The logical hierarchy that was created for the S3 bucket. If a prefix is not provided, the log is placed at the root level of the bucket.
        public var s3BucketPrefix: Swift.String?

        public init(
            emitInterval: Swift.Int? = nil,
            enabled: Swift.Bool? = nil,
            s3BucketName: Swift.String? = nil,
            s3BucketPrefix: Swift.String? = nil
        )
        {
            self.emitInterval = emitInterval
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.s3BucketPrefix = s3BucketPrefix
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about additional attributes for the load balancer.
    public struct AwsElbLoadBalancerAdditionalAttribute {
        /// The name of the attribute.
        public var key: Swift.String?
        /// The value of the attribute.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the connection draining configuration for the load balancer.
    public struct AwsElbLoadBalancerConnectionDraining {
        /// Indicates whether connection draining is enabled for the load balancer.
        public var enabled: Swift.Bool?
        /// The maximum time, in seconds, to keep the existing connections open before deregistering the instances.
        public var timeout: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            timeout: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.timeout = timeout
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains connection settings for the load balancer.
    public struct AwsElbLoadBalancerConnectionSettings {
        /// The time, in seconds, that the connection can be idle (no data is sent over the connection) before it is closed by the load balancer.
        public var idleTimeout: Swift.Int?

        public init(
            idleTimeout: Swift.Int? = nil
        )
        {
            self.idleTimeout = idleTimeout
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains cross-zone load balancing settings for the load balancer.
    public struct AwsElbLoadBalancerCrossZoneLoadBalancing {
        /// Indicates whether cross-zone load balancing is enabled for the load balancer.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains attributes for the load balancer.
    public struct AwsElbLoadBalancerAttributes {
        /// Information about the access log configuration for the load balancer. If the access log is enabled, the load balancer captures detailed information about all requests. It delivers the information to a specified S3 bucket.
        public var accessLog: SecurityHubClientTypes.AwsElbLoadBalancerAccessLog?
        /// Any additional attributes for a load balancer.
        public var additionalAttributes: [SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute]?
        /// Information about the connection draining configuration for the load balancer. If connection draining is enabled, the load balancer allows existing requests to complete before it shifts traffic away from a deregistered or unhealthy instance.
        public var connectionDraining: SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining?
        /// Connection settings for the load balancer. If an idle timeout is configured, the load balancer allows connections to remain idle for the specified duration. When a connection is idle, no data is sent over the connection.
        public var connectionSettings: SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings?
        /// Cross-zone load balancing settings for the load balancer. If cross-zone load balancing is enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones.
        public var crossZoneLoadBalancing: SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing?

        public init(
            accessLog: SecurityHubClientTypes.AwsElbLoadBalancerAccessLog? = nil,
            additionalAttributes: [SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute]? = nil,
            connectionDraining: SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining? = nil,
            connectionSettings: SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings? = nil,
            crossZoneLoadBalancing: SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing? = nil
        )
        {
            self.accessLog = accessLog
            self.additionalAttributes = additionalAttributes
            self.connectionDraining = connectionDraining
            self.connectionSettings = connectionSettings
            self.crossZoneLoadBalancing = crossZoneLoadBalancing
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the configuration of an EC2 instance for the load balancer.
    public struct AwsElbLoadBalancerBackendServerDescription {
        /// The port on which the EC2 instance is listening.
        public var instancePort: Swift.Int?
        /// The names of the policies that are enabled for the EC2 instance.
        public var policyNames: [Swift.String]?

        public init(
            instancePort: Swift.Int? = nil,
            policyNames: [Swift.String]? = nil
        )
        {
            self.instancePort = instancePort
            self.policyNames = policyNames
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the health checks that are conducted on the load balancer.
    public struct AwsElbLoadBalancerHealthCheck {
        /// The number of consecutive health check successes required before the instance is moved to the Healthy state.
        public var healthyThreshold: Swift.Int?
        /// The approximate interval, in seconds, between health checks of an individual instance.
        public var interval: Swift.Int?
        /// The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535. For the HTTP and HTTPS protocols, the target also specifies the ping path. For the TCP protocol, the target is specified as TCP: . For the SSL protocol, the target is specified as SSL. . For the HTTP and HTTPS protocols, the target is specified as  :/ .
        public var target: Swift.String?
        /// The amount of time, in seconds, during which no response means a failed health check.
        public var timeout: Swift.Int?
        /// The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.
        public var unhealthyThreshold: Swift.Int?

        public init(
            healthyThreshold: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            target: Swift.String? = nil,
            timeout: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int? = nil
        )
        {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.target = target
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an EC2 instance for a load balancer.
    public struct AwsElbLoadBalancerInstance {
        /// The instance identifier.
        public var instanceId: Swift.String?

        public init(
            instanceId: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a load balancer listener.
    public struct AwsElbLoadBalancerListener {
        /// The port on which the instance is listening.
        public var instancePort: Swift.Int?
        /// The protocol to use to route traffic to instances. Valid values: HTTP | HTTPS | TCP | SSL
        public var instanceProtocol: Swift.String?
        /// The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.
        public var loadBalancerPort: Swift.Int?
        /// The load balancer transport protocol to use for routing. Valid values: HTTP | HTTPS | TCP | SSL
        public var `protocol`: Swift.String?
        /// The ARN of the server certificate.
        public var sslCertificateId: Swift.String?

        public init(
            instancePort: Swift.Int? = nil,
            instanceProtocol: Swift.String? = nil,
            loadBalancerPort: Swift.Int? = nil,
            `protocol`: Swift.String? = nil,
            sslCertificateId: Swift.String? = nil
        )
        {
            self.instancePort = instancePort
            self.instanceProtocol = instanceProtocol
            self.loadBalancerPort = loadBalancerPort
            self.`protocol` = `protocol`
            self.sslCertificateId = sslCertificateId
        }
    }

}

extension SecurityHubClientTypes {
    /// Lists the policies that are enabled for a load balancer listener.
    public struct AwsElbLoadBalancerListenerDescription {
        /// Information about the listener.
        public var listener: SecurityHubClientTypes.AwsElbLoadBalancerListener?
        /// The policies enabled for the listener.
        public var policyNames: [Swift.String]?

        public init(
            listener: SecurityHubClientTypes.AwsElbLoadBalancerListener? = nil,
            policyNames: [Swift.String]? = nil
        )
        {
            self.listener = listener
            self.policyNames = policyNames
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the policies for a load balancer.
    public struct AwsElbLoadBalancerPolicies {
        /// The stickiness policies that are created using CreateAppCookieStickinessPolicy.
        public var appCookieStickinessPolicies: [SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy]?
        /// The stickiness policies that are created using CreateLBCookieStickinessPolicy.
        public var lbCookieStickinessPolicies: [SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy]?
        /// The policies other than the stickiness policies.
        public var otherPolicies: [Swift.String]?

        public init(
            appCookieStickinessPolicies: [SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy]? = nil,
            lbCookieStickinessPolicies: [SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy]? = nil,
            otherPolicies: [Swift.String]? = nil
        )
        {
            self.appCookieStickinessPolicies = appCookieStickinessPolicies
            self.lbCookieStickinessPolicies = lbCookieStickinessPolicies
            self.otherPolicies = otherPolicies
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about the security group for the load balancer.
    public struct AwsElbLoadBalancerSourceSecurityGroup {
        /// The name of the security group.
        public var groupName: Swift.String?
        /// The owner of the security group.
        public var ownerAlias: Swift.String?

        public init(
            groupName: Swift.String? = nil,
            ownerAlias: Swift.String? = nil
        )
        {
            self.groupName = groupName
            self.ownerAlias = ownerAlias
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains details about a Classic Load Balancer.
    public struct AwsElbLoadBalancerDetails {
        /// The list of Availability Zones for the load balancer.
        public var availabilityZones: [Swift.String]?
        /// Information about the configuration of the EC2 instances.
        public var backendServerDescriptions: [SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription]?
        /// The name of the Amazon Route 53 hosted zone for the load balancer.
        public var canonicalHostedZoneName: Swift.String?
        /// The ID of the Amazon Route 53 hosted zone for the load balancer.
        public var canonicalHostedZoneNameID: Swift.String?
        /// Indicates when the load balancer was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdTime: Swift.String?
        /// The DNS name of the load balancer.
        public var dnsName: Swift.String?
        /// Information about the health checks that are conducted on the load balancer.
        public var healthCheck: SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck?
        /// List of EC2 instances for the load balancer.
        public var instances: [SecurityHubClientTypes.AwsElbLoadBalancerInstance]?
        /// The policies that are enabled for the load balancer listeners.
        public var listenerDescriptions: [SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription]?
        /// The attributes for a load balancer.
        public var loadBalancerAttributes: SecurityHubClientTypes.AwsElbLoadBalancerAttributes?
        /// The name of the load balancer.
        public var loadBalancerName: Swift.String?
        /// The policies for a load balancer.
        public var policies: SecurityHubClientTypes.AwsElbLoadBalancerPolicies?
        /// The type of load balancer. Only provided if the load balancer is in a VPC. If Scheme is internet-facing, the load balancer has a public DNS name that resolves to a public IP address. If Scheme is internal, the load balancer has a public DNS name that resolves to a private IP address.
        public var scheme: Swift.String?
        /// The security groups for the load balancer. Only provided if the load balancer is in a VPC.
        public var securityGroups: [Swift.String]?
        /// Information about the security group for the load balancer. This is the security group that is used for inbound rules.
        public var sourceSecurityGroup: SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup?
        /// The list of subnet identifiers for the load balancer.
        public var subnets: [Swift.String]?
        /// The identifier of the VPC for the load balancer.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [Swift.String]? = nil,
            backendServerDescriptions: [SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription]? = nil,
            canonicalHostedZoneName: Swift.String? = nil,
            canonicalHostedZoneNameID: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            dnsName: Swift.String? = nil,
            healthCheck: SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck? = nil,
            instances: [SecurityHubClientTypes.AwsElbLoadBalancerInstance]? = nil,
            listenerDescriptions: [SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription]? = nil,
            loadBalancerAttributes: SecurityHubClientTypes.AwsElbLoadBalancerAttributes? = nil,
            loadBalancerName: Swift.String? = nil,
            policies: SecurityHubClientTypes.AwsElbLoadBalancerPolicies? = nil,
            scheme: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            sourceSecurityGroup: SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.backendServerDescriptions = backendServerDescriptions
            self.canonicalHostedZoneName = canonicalHostedZoneName
            self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.healthCheck = healthCheck
            self.instances = instances
            self.listenerDescriptions = listenerDescriptions
            self.loadBalancerAttributes = loadBalancerAttributes
            self.loadBalancerName = loadBalancerName
            self.policies = policies
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.sourceSecurityGroup = sourceSecurityGroup
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// A load balancer attribute.
    public struct AwsElbv2LoadBalancerAttribute {
        /// The name of the load balancer attribute.
        public var key: Swift.String?
        /// The value of the load balancer attribute.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the state of the load balancer.
    public struct LoadBalancerState {
        /// The state code. The initial state of the load balancer is provisioning. After the load balancer is fully set up and ready to route traffic, its state is active. If the load balancer could not be set up, its state is failed.
        public var code: Swift.String?
        /// A description of the state.
        public var reason: Swift.String?

        public init(
            code: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.code = code
            self.reason = reason
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a load balancer.
    public struct AwsElbv2LoadBalancerDetails {
        /// The Availability Zones for the load balancer.
        public var availabilityZones: [SecurityHubClientTypes.AvailabilityZone]?
        /// The ID of the Amazon Route 53 hosted zone associated with the load balancer.
        public var canonicalHostedZoneId: Swift.String?
        /// Indicates when the load balancer was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdTime: Swift.String?
        /// The public DNS name of the load balancer.
        public var dnsName: Swift.String?
        /// The type of IP addresses used by the subnets for your load balancer. The possible values are ipv4 (for IPv4 addresses) and dualstack (for IPv4 and IPv6 addresses).
        public var ipAddressType: Swift.String?
        /// Attributes of the load balancer.
        public var loadBalancerAttributes: [SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute]?
        /// The nodes of an Internet-facing load balancer have public IP addresses.
        public var scheme: Swift.String?
        /// The IDs of the security groups for the load balancer.
        public var securityGroups: [Swift.String]?
        /// The state of the load balancer.
        public var state: SecurityHubClientTypes.LoadBalancerState?
        /// The type of load balancer.
        public var type: Swift.String?
        /// The ID of the VPC for the load balancer.
        public var vpcId: Swift.String?

        public init(
            availabilityZones: [SecurityHubClientTypes.AvailabilityZone]? = nil,
            canonicalHostedZoneId: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            dnsName: Swift.String? = nil,
            ipAddressType: Swift.String? = nil,
            loadBalancerAttributes: [SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute]? = nil,
            scheme: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            state: SecurityHubClientTypes.LoadBalancerState? = nil,
            type: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.canonicalHostedZoneId = canonicalHostedZoneId
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.ipAddressType = ipAddressType
            self.loadBalancerAttributes = loadBalancerAttributes
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.state = state
            self.type = type
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// A schema defines the structure of events that are sent to Amazon EventBridge. Schema registries are containers for schemas. They collect and organize schemas so that your schemas are in logical groups.
    public struct AwsEventSchemasRegistryDetails {
        /// A description of the registry to be created.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the registry.
        public var registryArn: Swift.String?
        /// The name of the schema registry.
        public var registryName: Swift.String?

        public init(
            description: Swift.String? = nil,
            registryArn: Swift.String? = nil,
            registryName: Swift.String? = nil
        )
        {
            self.description = description
            self.registryArn = registryArn
            self.registryName = registryName
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the Amazon EventBridge event buses that the endpoint is associated with.
    public struct AwsEventsEndpointEventBusesDetails {
        /// The Amazon Resource Name (ARN) of the event bus that the endpoint is associated with.
        public var eventBusArn: Swift.String?

        public init(
            eventBusArn: Swift.String? = nil
        )
        {
            self.eventBusArn = eventBusArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Indicates whether replication is enabled or disabled for the endpoint. If enabled, the endpoint can replicate all events to a secondary Amazon Web Services Region.
    public struct AwsEventsEndpointReplicationConfigDetails {
        /// The state of event replication.
        public var state: Swift.String?

        public init(
            state: Swift.String? = nil
        )
        {
            self.state = state
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the primary Amazon Web Services Region of the endpoint.
    public struct AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails {
        /// The Amazon Resource Name (ARN) of the health check used by the endpoint to determine whether failover is triggered.
        public var healthCheck: Swift.String?

        public init(
            healthCheck: Swift.String? = nil
        )
        {
            self.healthCheck = healthCheck
        }
    }

}

extension SecurityHubClientTypes {
    /// The Amazon Web Services Region that events are routed to when failover is triggered or event replication is enabled.
    public struct AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails {
        /// Defines the secondary Region.
        public var route: Swift.String?

        public init(
            route: Swift.String? = nil
        )
        {
            self.route = route
        }
    }

}

extension SecurityHubClientTypes {
    /// The failover configuration for an endpoint. This includes what triggers failover and what happens when it's triggered.
    public struct AwsEventsEndpointRoutingConfigFailoverConfigDetails {
        /// The main Region of the endpoint.
        public var primary: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails?
        /// The Region that events are routed to when failover is triggered or event replication is enabled.
        public var secondary: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails?

        public init(
            primary: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails? = nil,
            secondary: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails? = nil
        )
        {
            self.primary = primary
            self.secondary = secondary
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the routing configuration of the endpoint.
    public struct AwsEventsEndpointRoutingConfigDetails {
        /// The failover configuration for an endpoint. This includes what triggers failover and what happens when it's triggered.
        public var failoverConfig: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigDetails?

        public init(
            failoverConfig: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigDetails? = nil
        )
        {
            self.failoverConfig = failoverConfig
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon EventBridge global endpoint. The endpoint can improve your application’s availability by making it Regional-fault tolerant.
    public struct AwsEventsEndpointDetails {
        /// The Amazon Resource Name (ARN) of the endpoint.
        public var arn: Swift.String?
        /// A description of the endpoint.
        public var description: Swift.String?
        /// The URL subdomain of the endpoint. For example, if EndpointUrl is https://abcde.veo.endpoints.event.amazonaws.com, then the EndpointId is abcde.veo.
        public var endpointId: Swift.String?
        /// The URL of the endpoint.
        public var endpointUrl: Swift.String?
        /// The event buses being used by the endpoint.
        public var eventBuses: [SecurityHubClientTypes.AwsEventsEndpointEventBusesDetails]?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// Whether event replication was enabled or disabled for this endpoint. The default state is ENABLED, which means you must supply a RoleArn. If you don't have a RoleArn or you don't want event replication enabled, set the state to DISABLED.
        public var replicationConfig: SecurityHubClientTypes.AwsEventsEndpointReplicationConfigDetails?
        /// The ARN of the role used by event replication for the endpoint.
        public var roleArn: Swift.String?
        /// The routing configuration of the endpoint.
        public var routingConfig: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigDetails?
        /// The current state of the endpoint.
        public var state: Swift.String?
        /// The reason the endpoint is in its current state.
        public var stateReason: Swift.String?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            endpointUrl: Swift.String? = nil,
            eventBuses: [SecurityHubClientTypes.AwsEventsEndpointEventBusesDetails]? = nil,
            name: Swift.String? = nil,
            replicationConfig: SecurityHubClientTypes.AwsEventsEndpointReplicationConfigDetails? = nil,
            roleArn: Swift.String? = nil,
            routingConfig: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigDetails? = nil,
            state: Swift.String? = nil,
            stateReason: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.endpointId = endpointId
            self.endpointUrl = endpointUrl
            self.eventBuses = eventBuses
            self.name = name
            self.replicationConfig = replicationConfig
            self.roleArn = roleArn
            self.routingConfig = routingConfig
            self.state = state
            self.stateReason = stateReason
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about Amazon EventBridge event bus. An event bus is a router that receives events and delivers them to zero or more destinations, or targets. This can be a custom event bus which you can use to receive events from your custom applications and services, or it can be a partner event bus which can be matched to a partner event source.
    public struct AwsEventsEventbusDetails {
        /// The Amazon Resource Name (ARN) of the account permitted to write events to the current account.
        public var arn: Swift.String?
        /// The name of the event bus.
        public var name: Swift.String?
        /// The policy that enables the external account to send events to your account.
        public var policy: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            policy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.policy = policy
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that contains information on the status of CloudTrail as a data source for the detector.
    public struct AwsGuardDutyDetectorDataSourcesCloudTrailDetails {
        /// Specifies whether CloudTrail is activated as a data source for the detector.
        public var status: Swift.String?

        public init(
            status: Swift.String? = nil
        )
        {
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that contains information on the status of DNS logs as a data source for the detector.
    public struct AwsGuardDutyDetectorDataSourcesDnsLogsDetails {
        /// Describes whether DNS logs is enabled as a data source for the detector.
        public var status: Swift.String?

        public init(
            status: Swift.String? = nil
        )
        {
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that contains information on the status of VPC Flow Logs as a data source for the detector.
    public struct AwsGuardDutyDetectorDataSourcesFlowLogsDetails {
        /// Describes whether VPC Flow Logs are activated as a data source for the detector.
        public var status: Swift.String?

        public init(
            status: Swift.String? = nil
        )
        {
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that contains information on the status of Kubernetes audit logs as a data source for the detector.
    public struct AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails {
        /// Describes whether Kubernetes audit logs are activated as a data source for the detector.
        public var status: Swift.String?

        public init(
            status: Swift.String? = nil
        )
        {
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that contains information on the status of Kubernetes data sources for the detector.
    public struct AwsGuardDutyDetectorDataSourcesKubernetesDetails {
        /// Describes whether Kubernetes audit logs are activated as a data source for the detector.
        public var auditLogs: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails?

        public init(
            auditLogs: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes the configuration of scanning EBS volumes (Malware Protection) as a data source.
    public struct AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails {
        /// Specifies the reason why scanning EBS volumes (Malware Protection) isn’t activated as a data source.
        public var reason: Swift.String?
        /// Describes whether scanning EBS volumes is activated as a data source for the detector.
        public var status: Swift.String?

        public init(
            reason: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes the configuration of Malware Protection for EC2 instances with findings.
    public struct AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails {
        /// Describes the configuration of scanning EBS volumes (Malware Protection) as a data source.
        public var ebsVolumes: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails?

        public init(
            ebsVolumes: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails? = nil
        )
        {
            self.ebsVolumes = ebsVolumes
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that contains information on the status of Malware Protection as a data source for the detector.
    public struct AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails {
        /// Describes the configuration of Malware Protection for EC2 instances with findings.
        public var scanEc2InstanceWithFindings: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails?
        /// The GuardDuty Malware Protection service role.
        public var serviceRole: Swift.String?

        public init(
            scanEc2InstanceWithFindings: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails? = nil,
            serviceRole: Swift.String? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
            self.serviceRole = serviceRole
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that contains information on the status of S3 data event logs as a data source for the detector.
    public struct AwsGuardDutyDetectorDataSourcesS3LogsDetails {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of an organization.
        public var status: Swift.String?

        public init(
            status: Swift.String? = nil
        )
        {
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes which data sources are activated for the detector.
    public struct AwsGuardDutyDetectorDataSourcesDetails {
        /// An object that contains information on the status of CloudTrail as a data source for the detector.
        public var cloudTrail: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesCloudTrailDetails?
        /// An object that contains information on the status of DNS logs as a data source for the detector.
        public var dnsLogs: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDnsLogsDetails?
        /// An object that contains information on the status of VPC Flow Logs as a data source for the detector.
        public var flowLogs: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesFlowLogsDetails?
        /// An object that contains information on the status of Kubernetes data sources for the detector.
        public var kubernetes: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesDetails?
        /// An object that contains information on the status of Malware Protection as a data source for the detector.
        public var malwareProtection: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails?
        /// An object that contains information on the status of S3 Data event logs as a data source for the detector.
        public var s3Logs: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesS3LogsDetails?

        public init(
            cloudTrail: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesCloudTrailDetails? = nil,
            dnsLogs: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDnsLogsDetails? = nil,
            flowLogs: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesFlowLogsDetails? = nil,
            kubernetes: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesDetails? = nil,
            malwareProtection: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails? = nil,
            s3Logs: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesS3LogsDetails? = nil
        )
        {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes which features are activated for the detector.
    public struct AwsGuardDutyDetectorFeaturesDetails {
        /// Indicates the name of the feature that is activated for the detector.
        public var name: Swift.String?
        /// Indicates the status of the feature that is activated for the detector.
        public var status: Swift.String?

        public init(
            name: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon GuardDuty detector. A detector is an object that represents the GuardDuty service. A detector is required for GuardDuty to become operational.
    public struct AwsGuardDutyDetectorDetails {
        /// Describes which data sources are activated for the detector.
        public var dataSources: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDetails?
        /// Describes which features are activated for the detector.
        public var features: [SecurityHubClientTypes.AwsGuardDutyDetectorFeaturesDetails]?
        /// The publishing frequency of the finding.
        public var findingPublishingFrequency: Swift.String?
        /// The GuardDuty service role.
        public var serviceRole: Swift.String?
        /// The activation status of the detector.
        public var status: Swift.String?

        public init(
            dataSources: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDetails? = nil,
            features: [SecurityHubClientTypes.AwsGuardDutyDetectorFeaturesDetails]? = nil,
            findingPublishingFrequency: Swift.String? = nil,
            serviceRole: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.dataSources = dataSources
            self.features = features
            self.findingPublishingFrequency = findingPublishingFrequency
            self.serviceRole = serviceRole
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Attributes of the session that the key was used for.
    public struct AwsIamAccessKeySessionContextAttributes {
        /// Indicates when the session was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var creationDate: Swift.String?
        /// Indicates whether the session used multi-factor authentication (MFA).
        public var mfaAuthenticated: Swift.Bool?

        public init(
            creationDate: Swift.String? = nil,
            mfaAuthenticated: Swift.Bool? = nil
        )
        {
            self.creationDate = creationDate
            self.mfaAuthenticated = mfaAuthenticated
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the entity that created the session.
    public struct AwsIamAccessKeySessionContextSessionIssuer {
        /// The identifier of the Amazon Web Services account that created the session.
        public var accountId: Swift.String?
        /// The ARN of the session.
        public var arn: Swift.String?
        /// The principal ID of the principal (user, role, or group) that created the session.
        public var principalId: Swift.String?
        /// The type of principal (user, role, or group) that created the session.
        public var type: Swift.String?
        /// The name of the principal that created the session.
        public var userName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            type: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.type = type
            self.userName = userName
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the session that the key was used for.
    public struct AwsIamAccessKeySessionContext {
        /// Attributes of the session that the key was used for.
        public var attributes: SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes?
        /// Information about the entity that created the session.
        public var sessionIssuer: SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer?

        public init(
            attributes: SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes? = nil,
            sessionIssuer: SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer? = nil
        )
        {
            self.attributes = attributes
            self.sessionIssuer = sessionIssuer
        }
    }

}

extension SecurityHubClientTypes {

    public enum AwsIamAccessKeyStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsIamAccessKeyStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// IAM access key details related to a finding.
    public struct AwsIamAccessKeyDetails {
        /// The identifier of the access key.
        public var accessKeyId: Swift.String?
        /// The Amazon Web Services account ID of the account for the key.
        public var accountId: Swift.String?
        /// Indicates when the IAM access key was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdAt: Swift.String?
        /// The ID of the principal associated with an access key.
        public var principalId: Swift.String?
        /// The name of the principal.
        public var principalName: Swift.String?
        /// The type of principal associated with an access key.
        public var principalType: Swift.String?
        /// Information about the session that the key was used for.
        public var sessionContext: SecurityHubClientTypes.AwsIamAccessKeySessionContext?
        /// The status of the IAM access key related to a finding.
        public var status: SecurityHubClientTypes.AwsIamAccessKeyStatus?
        /// The user associated with the IAM access key related to a finding. The UserName parameter has been replaced with the PrincipalName parameter because access keys can also be assigned to principals that are not IAM users.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use PrincipalName.")
        public var userName: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            accountId: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalName: Swift.String? = nil,
            principalType: Swift.String? = nil,
            sessionContext: SecurityHubClientTypes.AwsIamAccessKeySessionContext? = nil,
            status: SecurityHubClientTypes.AwsIamAccessKeyStatus? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.createdAt = createdAt
            self.principalId = principalId
            self.principalName = principalName
            self.principalType = principalType
            self.sessionContext = sessionContext
            self.status = status
            self.userName = userName
        }
    }

}

extension SecurityHubClientTypes {
    /// A managed policy that is attached to an IAM principal.
    public struct AwsIamAttachedManagedPolicy {
        /// The ARN of the policy.
        public var policyArn: Swift.String?
        /// The name of the policy.
        public var policyName: Swift.String?

        public init(
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes {
    /// A managed policy that is attached to the IAM group.
    public struct AwsIamGroupPolicy {
        /// The name of the policy.
        public var policyName: Swift.String?

        public init(
            policyName: Swift.String? = nil
        )
        {
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains details about an IAM group.
    public struct AwsIamGroupDetails {
        /// A list of the managed policies that are attached to the IAM group.
        public var attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]?
        /// Indicates when the IAM group was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createDate: Swift.String?
        /// The identifier of the IAM group.
        public var groupId: Swift.String?
        /// The name of the IAM group.
        public var groupName: Swift.String?
        /// The list of inline policies that are embedded in the group.
        public var groupPolicyList: [SecurityHubClientTypes.AwsIamGroupPolicy]?
        /// The path to the group.
        public var path: Swift.String?

        public init(
            attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]? = nil,
            createDate: Swift.String? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            groupPolicyList: [SecurityHubClientTypes.AwsIamGroupPolicy]? = nil,
            path: Swift.String? = nil
        )
        {
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.groupPolicyList = groupPolicyList
            self.path = path
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a role associated with an instance profile.
    public struct AwsIamInstanceProfileRole {
        /// The ARN of the role.
        public var arn: Swift.String?
        /// The policy that grants an entity permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// Indicates when the role was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createDate: Swift.String?
        /// The path to the role.
        public var path: Swift.String?
        /// The identifier of the role.
        public var roleId: Swift.String?
        /// The name of the role.
        public var roleName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            createDate: Swift.String? = nil,
            path: Swift.String? = nil,
            roleId: Swift.String? = nil,
            roleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.path = path
            self.roleId = roleId
            self.roleName = roleName
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an instance profile.
    public struct AwsIamInstanceProfile {
        /// The ARN of the instance profile.
        public var arn: Swift.String?
        /// Indicates when the instance profile was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createDate: Swift.String?
        /// The identifier of the instance profile.
        public var instanceProfileId: Swift.String?
        /// The name of the instance profile.
        public var instanceProfileName: Swift.String?
        /// The path to the instance profile.
        public var path: Swift.String?
        /// The roles associated with the instance profile.
        public var roles: [SecurityHubClientTypes.AwsIamInstanceProfileRole]?

        public init(
            arn: Swift.String? = nil,
            createDate: Swift.String? = nil,
            instanceProfileId: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            path: Swift.String? = nil,
            roles: [SecurityHubClientTypes.AwsIamInstanceProfileRole]? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.instanceProfileId = instanceProfileId
            self.instanceProfileName = instanceProfileName
            self.path = path
            self.roles = roles
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the policy used to set the permissions boundary for an IAM principal.
    public struct AwsIamPermissionsBoundary {
        /// The ARN of the policy used to set the permissions boundary.
        public var permissionsBoundaryArn: Swift.String?
        /// The usage type for the permissions boundary.
        public var permissionsBoundaryType: Swift.String?

        public init(
            permissionsBoundaryArn: Swift.String? = nil,
            permissionsBoundaryType: Swift.String? = nil
        )
        {
            self.permissionsBoundaryArn = permissionsBoundaryArn
            self.permissionsBoundaryType = permissionsBoundaryType
        }
    }

}

extension SecurityHubClientTypes {
    /// A version of an IAM policy.
    public struct AwsIamPolicyVersion {
        /// Indicates when the version was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createDate: Swift.String?
        /// Whether the version is the default version.
        public var isDefaultVersion: Swift.Bool?
        /// The identifier of the policy version.
        public var versionId: Swift.String?

        public init(
            createDate: Swift.String? = nil,
            isDefaultVersion: Swift.Bool? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

extension SecurityHubClientTypes {
    /// Represents an IAM permissions policy.
    public struct AwsIamPolicyDetails {
        /// The number of users, groups, and roles that the policy is attached to.
        public var attachmentCount: Swift.Int?
        /// When the policy was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createDate: Swift.String?
        /// The identifier of the default version of the policy.
        public var defaultVersionId: Swift.String?
        /// A description of the policy.
        public var description: Swift.String?
        /// Whether the policy can be attached to a user, group, or role.
        public var isAttachable: Swift.Bool?
        /// The path to the policy.
        public var path: Swift.String?
        /// The number of users and roles that use the policy to set the permissions boundary.
        public var permissionsBoundaryUsageCount: Swift.Int?
        /// The unique identifier of the policy.
        public var policyId: Swift.String?
        /// The name of the policy.
        public var policyName: Swift.String?
        /// List of versions of the policy.
        public var policyVersionList: [SecurityHubClientTypes.AwsIamPolicyVersion]?
        /// When the policy was most recently updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var updateDate: Swift.String?

        public init(
            attachmentCount: Swift.Int? = nil,
            createDate: Swift.String? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool? = nil,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyVersionList: [SecurityHubClientTypes.AwsIamPolicyVersion]? = nil,
            updateDate: Swift.String? = nil
        )
        {
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.policyVersionList = policyVersionList
            self.updateDate = updateDate
        }
    }

}

extension SecurityHubClientTypes {
    /// An inline policy that is embedded in the role.
    public struct AwsIamRolePolicy {
        /// The name of the policy.
        public var policyName: Swift.String?

        public init(
            policyName: Swift.String? = nil
        )
        {
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information about an IAM role, including all of the role's policies.
    public struct AwsIamRoleDetails {
        /// The trust policy that grants permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// The list of the managed policies that are attached to the role.
        public var attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]?
        /// Indicates when the role was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createDate: Swift.String?
        /// The list of instance profiles that contain this role.
        public var instanceProfileList: [SecurityHubClientTypes.AwsIamInstanceProfile]?
        /// The maximum session duration (in seconds) that you want to set for the specified role.
        public var maxSessionDuration: Swift.Int?
        /// The path to the role.
        public var path: Swift.String?
        /// Information about the policy used to set the permissions boundary for an IAM principal.
        public var permissionsBoundary: SecurityHubClientTypes.AwsIamPermissionsBoundary?
        /// The stable and unique string identifying the role.
        public var roleId: Swift.String?
        /// The friendly name that identifies the role.
        public var roleName: Swift.String?
        /// The list of inline policies that are embedded in the role.
        public var rolePolicyList: [SecurityHubClientTypes.AwsIamRolePolicy]?

        public init(
            assumeRolePolicyDocument: Swift.String? = nil,
            attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]? = nil,
            createDate: Swift.String? = nil,
            instanceProfileList: [SecurityHubClientTypes.AwsIamInstanceProfile]? = nil,
            maxSessionDuration: Swift.Int? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: SecurityHubClientTypes.AwsIamPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleName: Swift.String? = nil,
            rolePolicyList: [SecurityHubClientTypes.AwsIamRolePolicy]? = nil
        )
        {
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.instanceProfileList = instanceProfileList
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleName = roleName
            self.rolePolicyList = rolePolicyList
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an inline policy that is embedded in the user.
    public struct AwsIamUserPolicy {
        /// The name of the policy.
        public var policyName: Swift.String?

        public init(
            policyName: Swift.String? = nil
        )
        {
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an IAM user.
    public struct AwsIamUserDetails {
        /// A list of the managed policies that are attached to the user.
        public var attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]?
        /// Indicates when the user was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createDate: Swift.String?
        /// A list of IAM groups that the user belongs to.
        public var groupList: [Swift.String]?
        /// The path to the user.
        public var path: Swift.String?
        /// The permissions boundary for the user.
        public var permissionsBoundary: SecurityHubClientTypes.AwsIamPermissionsBoundary?
        /// The unique identifier for the user.
        public var userId: Swift.String?
        /// The name of the user.
        public var userName: Swift.String?
        /// The list of inline policies that are embedded in the user.
        public var userPolicyList: [SecurityHubClientTypes.AwsIamUserPolicy]?

        public init(
            attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]? = nil,
            createDate: Swift.String? = nil,
            groupList: [Swift.String]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: SecurityHubClientTypes.AwsIamPermissionsBoundary? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userPolicyList: [SecurityHubClientTypes.AwsIamUserPolicy]? = nil
        )
        {
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupList = groupList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.userId = userId
            self.userName = userName
            self.userPolicyList = userPolicyList
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about stream encryption.
    public struct AwsKinesisStreamStreamEncryptionDetails {
        /// The encryption type to use.
        public var encryptionType: Swift.String?
        /// The globally unique identifier for the customer-managed KMS key to use for encryption.
        public var keyId: Swift.String?

        public init(
            encryptionType: Swift.String? = nil,
            keyId: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.keyId = keyId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon Kinesis data stream.
    public struct AwsKinesisStreamDetails {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public var arn: Swift.String?
        /// The name of the Kinesis stream. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the stream name.
        public var name: Swift.String?
        /// The number of hours for the data records that are stored in shards to remain accessible.
        public var retentionPeriodHours: Swift.Int?
        /// The number of shards that the stream uses.
        public var shardCount: Swift.Int?
        /// When specified, enables or updates server-side encryption using an KMS key for a specified stream. Removing this property from your stack template and updating your stack disables encryption.
        public var streamEncryption: SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            retentionPeriodHours: Swift.Int? = nil,
            shardCount: Swift.Int? = nil,
            streamEncryption: SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.retentionPeriodHours = retentionPeriodHours
            self.shardCount = shardCount
            self.streamEncryption = streamEncryption
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains metadata about an KMS key.
    public struct AwsKmsKeyDetails {
        /// The twelve-digit account ID of the Amazon Web Services account that owns the KMS key.
        public var awsAccountId: Swift.String?
        /// Indicates when the KMS key was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var creationDate: Swift.Double?
        /// A description of the KMS key.
        public var description: Swift.String?
        /// The globally unique identifier for the KMS key.
        public var keyId: Swift.String?
        /// The manager of the KMS key. KMS keys in your Amazon Web Services account are either customer managed or Amazon Web Services managed.
        public var keyManager: Swift.String?
        /// Whether the key has key rotation enabled.
        public var keyRotationStatus: Swift.Bool?
        /// The state of the KMS key. Valid values are as follows:
        ///
        /// * Disabled
        ///
        /// * Enabled
        ///
        /// * PendingDeletion
        ///
        /// * PendingImport
        ///
        /// * Unavailable
        public var keyState: Swift.String?
        /// The source of the KMS key material. When this value is AWS_KMS, KMS created the key material. When this value is EXTERNAL, the key material was imported from your existing key management infrastructure or the KMS key lacks key material. When this value is AWS_CLOUDHSM, the key material was created in the CloudHSM cluster associated with a custom key store.
        public var origin: Swift.String?

        public init(
            awsAccountId: Swift.String? = nil,
            creationDate: Swift.Double? = nil,
            description: Swift.String? = nil,
            keyId: Swift.String? = nil,
            keyManager: Swift.String? = nil,
            keyRotationStatus: Swift.Bool? = nil,
            keyState: Swift.String? = nil,
            origin: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.creationDate = creationDate
            self.description = description
            self.keyId = keyId
            self.keyManager = keyManager
            self.keyRotationStatus = keyRotationStatus
            self.keyState = keyState
            self.origin = origin
        }
    }

}

extension SecurityHubClientTypes {
    /// The code for the Lambda function. You can specify either an object in Amazon S3, or upload a deployment package directly.
    public struct AwsLambdaFunctionCode {
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the deployment package.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the deployment package object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public var zipFile: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }

}

extension SecurityHubClientTypes {
    /// The dead-letter queue for failed asynchronous invocations.
    public struct AwsLambdaFunctionDeadLetterConfig {
        /// The ARN of an SQS queue or SNS topic.
        public var targetArn: Swift.String?

        public init(
            targetArn: Swift.String? = nil
        )
        {
            self.targetArn = targetArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Error messages for environment variables that could not be applied.
    public struct AwsLambdaFunctionEnvironmentError {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension SecurityHubClientTypes {
    /// A function's environment variable settings.
    public struct AwsLambdaFunctionEnvironment {
        /// An AwsLambdaFunctionEnvironmentError object.
        public var error: SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError?
        /// Environment variable key-value pairs.
        public var variables: [Swift.String: Swift.String]?

        public init(
            error: SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError? = nil,
            variables: [Swift.String: Swift.String]? = nil
        )
        {
            self.error = error
            self.variables = variables
        }
    }

}

extension SecurityHubClientTypes {
    /// An Lambda layer.
    public struct AwsLambdaFunctionLayer {
        /// The ARN of the function layer.
        public var arn: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            codeSize: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.codeSize = codeSize
        }
    }

}

extension SecurityHubClientTypes {
    /// The function's X-Ray tracing configuration.
    public struct AwsLambdaFunctionTracingConfig {
        /// The tracing mode.
        public var mode: Swift.String?

        public init(
            mode: Swift.String? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension SecurityHubClientTypes {
    /// The VPC security groups and subnets that are attached to a Lambda function.
    public struct AwsLambdaFunctionVpcConfig {
        /// A list of VPC security groups IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an Lambda function's configuration.
    public struct AwsLambdaFunctionDetails {
        /// The instruction set architecture that the function uses. Valid values are x86_64 or arm64.
        public var architectures: [Swift.String]?
        /// An AwsLambdaFunctionCode object.
        public var code: SecurityHubClientTypes.AwsLambdaFunctionCode?
        /// The SHA256 hash of the function's deployment package.
        public var codeSha256: Swift.String?
        /// The function's dead letter queue.
        public var deadLetterConfig: SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig?
        /// The function's environment variables.
        public var environment: SecurityHubClientTypes.AwsLambdaFunctionEnvironment?
        /// The name of the function.
        public var functionName: Swift.String?
        /// The function that Lambda calls to begin executing your function.
        public var handler: Swift.String?
        /// The KMS key that is used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed customer managed key.
        public var kmsKeyArn: Swift.String?
        /// Indicates when the function was last updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastModified: Swift.String?
        /// The function's layers.
        public var layers: [SecurityHubClientTypes.AwsLambdaFunctionLayer]?
        /// For Lambda@Edge functions, the ARN of the master function.
        public var masterArn: Swift.String?
        /// The memory that is allocated to the function.
        public var memorySize: Swift.Int?
        /// The type of deployment package that's used to deploy the function code to Lambda. Set to Image for a container image and Zip for a .zip file archive.
        public var packageType: Swift.String?
        /// The latest updated revision of the function or alias.
        public var revisionId: Swift.String?
        /// The function's execution role.
        public var role: Swift.String?
        /// The runtime environment for the Lambda function.
        public var runtime: Swift.String?
        /// The amount of time that Lambda allows a function to run before stopping it.
        public var timeout: Swift.Int?
        /// The function's X-Ray tracing configuration.
        public var tracingConfig: SecurityHubClientTypes.AwsLambdaFunctionTracingConfig?
        /// The version of the Lambda function.
        public var version: Swift.String?
        /// The function's networking configuration.
        public var vpcConfig: SecurityHubClientTypes.AwsLambdaFunctionVpcConfig?

        public init(
            architectures: [Swift.String]? = nil,
            code: SecurityHubClientTypes.AwsLambdaFunctionCode? = nil,
            codeSha256: Swift.String? = nil,
            deadLetterConfig: SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig? = nil,
            environment: SecurityHubClientTypes.AwsLambdaFunctionEnvironment? = nil,
            functionName: Swift.String? = nil,
            handler: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            layers: [SecurityHubClientTypes.AwsLambdaFunctionLayer]? = nil,
            masterArn: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            packageType: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            role: Swift.String? = nil,
            runtime: Swift.String? = nil,
            timeout: Swift.Int? = nil,
            tracingConfig: SecurityHubClientTypes.AwsLambdaFunctionTracingConfig? = nil,
            version: Swift.String? = nil,
            vpcConfig: SecurityHubClientTypes.AwsLambdaFunctionVpcConfig? = nil
        )
        {
            self.architectures = architectures
            self.code = code
            self.codeSha256 = codeSha256
            self.deadLetterConfig = deadLetterConfig
            self.environment = environment
            self.functionName = functionName
            self.handler = handler
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about a Lambda layer version.
    public struct AwsLambdaLayerVersionDetails {
        /// The layer's compatible [function runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). The following list includes deprecated runtimes. For more information, see [Runtime deprecation policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy) in the Lambda Developer Guide. Array Members: Maximum number of 5 items. Valid Values: nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 | nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 | dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 | nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 | nodejs18.x | python3.10 | java17 | ruby3.2 | python3.11 | nodejs20.x | provided.al2023 | python3.12 | java21
        public var compatibleRuntimes: [Swift.String]?
        /// Indicates when the version was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdDate: Swift.String?
        /// The version number.
        public var version: Swift.Int?

        public init(
            compatibleRuntimes: [Swift.String]? = nil,
            createdDate: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.version = version
        }
    }

}

extension SecurityHubClientTypes {
    /// Details for SASL/IAM client authentication.
    public struct AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails {
        /// Indicates whether SASL/IAM authentication is enabled or not.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Details for SASL/SCRAM client authentication.
    public struct AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails {
        /// Indicates whether SASL/SCRAM authentication is enabled or not.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details for client authentication using SASL.
    public struct AwsMskClusterClusterInfoClientAuthenticationSaslDetails {
        /// Provides details for SASL client authentication using IAM.
        public var iam: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails?
        /// Details for SASL client authentication using SCRAM.
        public var scram: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails?

        public init(
            iam: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails? = nil,
            scram: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails? = nil
        )
        {
            self.iam = iam
            self.scram = scram
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details for client authentication using TLS.
    public struct AwsMskClusterClusterInfoClientAuthenticationTlsDetails {
        /// List of Amazon Web Services Private CA Amazon Resource Names (ARNs). Amazon Web Services Private CA enables creation of private certificate authority (CA) hierarchies, including root and subordinate CAs, without the investment and maintenance costs of operating an on-premises CA.
        public var certificateAuthorityArnList: [Swift.String]?
        /// Indicates whether TLS authentication is enabled or not.
        public var enabled: Swift.Bool?

        public init(
            certificateAuthorityArnList: [Swift.String]? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.certificateAuthorityArnList = certificateAuthorityArnList
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details for allowing no client authentication.
    public struct AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails {
        /// Indicates whether unauthenticated is allowed or not.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about different modes of client authentication.
    public struct AwsMskClusterClusterInfoClientAuthenticationDetails {
        /// Provides details for client authentication using SASL.
        public var sasl: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslDetails?
        /// Provides details for client authentication using TLS.
        public var tls: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationTlsDetails?
        /// Provides details for allowing no client authentication.
        public var unauthenticated: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails?

        public init(
            sasl: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslDetails? = nil,
            tls: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationTlsDetails? = nil,
            unauthenticated: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails? = nil
        )
        {
            self.sasl = sasl
            self.tls = tls
            self.unauthenticated = unauthenticated
        }
    }

}

extension SecurityHubClientTypes {
    /// The data-volume encryption details. You can't update encryption at rest settings for existing clusters.
    public struct AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails {
        /// The Amazon Resource Name (ARN) of the KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        public var dataVolumeKMSKeyId: Swift.String?

        public init(
            dataVolumeKMSKeyId: Swift.String? = nil
        )
        {
            self.dataVolumeKMSKeyId = dataVolumeKMSKeyId
        }
    }

}

extension SecurityHubClientTypes {
    /// The settings for encrypting data in transit.
    public struct AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails {
        /// Indicates the encryption setting for data in transit between clients and brokers.
        public var clientBroker: Swift.String?
        /// When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plain text. The default value is true.
        public var inCluster: Swift.Bool?

        public init(
            clientBroker: Swift.String? = nil,
            inCluster: Swift.Bool? = nil
        )
        {
            self.clientBroker = clientBroker
            self.inCluster = inCluster
        }
    }

}

extension SecurityHubClientTypes {
    /// Includes encryption-related information, such as the KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.
    public struct AwsMskClusterClusterInfoEncryptionInfoDetails {
        /// The data-volume encryption details. You can't update encryption at rest settings for existing clusters.
        public var encryptionAtRest: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails?
        /// The settings for encrypting data in transit.
        public var encryptionInTransit: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails?

        public init(
            encryptionAtRest: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails? = nil,
            encryptionInTransit: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails? = nil
        )
        {
            self.encryptionAtRest = encryptionAtRest
            self.encryptionInTransit = encryptionInTransit
        }
    }

}

extension SecurityHubClientTypes {
    /// Provide details about an Amazon Managed Streaming for Apache Kafka (Amazon MSK) cluster.
    public struct AwsMskClusterClusterInfoDetails {
        /// Provides information for different modes of client authentication.
        public var clientAuthentication: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationDetails?
        /// The name of the cluster.
        public var clusterName: Swift.String?
        /// The current version of the cluster.
        public var currentVersion: Swift.String?
        /// Includes encryption-related information, such as the KMS key used for encrypting data at rest and whether you want Amazon MSK to encrypt your data in transit.
        public var encryptionInfo: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoDetails?
        /// Specifies the level of monitoring for the cluster.
        public var enhancedMonitoring: Swift.String?
        /// The number of broker nodes in the cluster.
        public var numberOfBrokerNodes: Swift.Int?

        public init(
            clientAuthentication: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationDetails? = nil,
            clusterName: Swift.String? = nil,
            currentVersion: Swift.String? = nil,
            encryptionInfo: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoDetails? = nil,
            enhancedMonitoring: Swift.String? = nil,
            numberOfBrokerNodes: Swift.Int? = nil
        )
        {
            self.clientAuthentication = clientAuthentication
            self.clusterName = clusterName
            self.currentVersion = currentVersion
            self.encryptionInfo = encryptionInfo
            self.enhancedMonitoring = enhancedMonitoring
            self.numberOfBrokerNodes = numberOfBrokerNodes
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon Managed Streaming for Apache Kafka (Amazon MSK) cluster.
    public struct AwsMskClusterDetails {
        /// Provides information about a cluster.
        public var clusterInfo: SecurityHubClientTypes.AwsMskClusterClusterInfoDetails?

        public init(
            clusterInfo: SecurityHubClientTypes.AwsMskClusterClusterInfoDetails? = nil
        )
        {
            self.clusterInfo = clusterInfo
        }
    }

}

extension SecurityHubClientTypes {
    /// A public subnet that Network Firewall uses for the firewall.
    public struct AwsNetworkFirewallFirewallSubnetMappingsDetails {
        /// The identifier of the subnet
        public var subnetId: Swift.String?

        public init(
            subnetId: Swift.String? = nil
        )
        {
            self.subnetId = subnetId
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an Network Firewall firewall.
    public struct AwsNetworkFirewallFirewallDetails {
        /// Whether the firewall is protected from deletion. If set to true, then the firewall cannot be deleted.
        public var deleteProtection: Swift.Bool?
        /// A description of the firewall.
        public var description: Swift.String?
        /// The ARN of the firewall.
        public var firewallArn: Swift.String?
        /// The identifier of the firewall.
        public var firewallId: Swift.String?
        /// A descriptive name of the firewall.
        public var firewallName: Swift.String?
        /// The ARN of the firewall policy.
        public var firewallPolicyArn: Swift.String?
        /// Whether the firewall is protected from a change to the firewall policy. If set to true, you cannot associate a different policy with the firewall.
        public var firewallPolicyChangeProtection: Swift.Bool?
        /// Whether the firewall is protected from a change to the subnet associations. If set to true, you cannot map different subnets to the firewall.
        public var subnetChangeProtection: Swift.Bool?
        /// The public subnets that Network Firewall uses for the firewall. Each subnet must belong to a different Availability Zone.
        public var subnetMappings: [SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails]?
        /// The identifier of the VPC where the firewall is used.
        public var vpcId: Swift.String?

        public init(
            deleteProtection: Swift.Bool? = nil,
            description: Swift.String? = nil,
            firewallArn: Swift.String? = nil,
            firewallId: Swift.String? = nil,
            firewallName: Swift.String? = nil,
            firewallPolicyArn: Swift.String? = nil,
            firewallPolicyChangeProtection: Swift.Bool? = nil,
            subnetChangeProtection: Swift.Bool? = nil,
            subnetMappings: [SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.deleteProtection = deleteProtection
            self.description = description
            self.firewallArn = firewallArn
            self.firewallId = firewallId
            self.firewallName = firewallName
            self.firewallPolicyArn = firewallPolicyArn
            self.firewallPolicyChangeProtection = firewallPolicyChangeProtection
            self.subnetChangeProtection = subnetChangeProtection
            self.subnetMappings = subnetMappings
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// A stateful rule group that is used by the firewall policy.
    public struct FirewallPolicyStatefulRuleGroupReferencesDetails {
        /// The ARN of the stateful rule group.
        public var resourceArn: Swift.String?

        public init(
            resourceArn: Swift.String? = nil
        )
        {
            self.resourceArn = resourceArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Defines a CloudWatch dimension value to publish.
    public struct StatelessCustomPublishMetricActionDimension {
        /// The value to use for the custom metric dimension.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about metrics to publish to CloudWatch.
    public struct StatelessCustomPublishMetricAction {
        /// Defines CloudWatch dimension values to publish.
        public var dimensions: [SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension]?

        public init(
            dimensions: [SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension]? = nil
        )
        {
            self.dimensions = dimensions
        }
    }

}

extension SecurityHubClientTypes {
    /// The definition of a custom action that can be used for stateless packet handling.
    public struct StatelessCustomActionDefinition {
        /// Information about metrics to publish to CloudWatch.
        public var publishMetricAction: SecurityHubClientTypes.StatelessCustomPublishMetricAction?

        public init(
            publishMetricAction: SecurityHubClientTypes.StatelessCustomPublishMetricAction? = nil
        )
        {
            self.publishMetricAction = publishMetricAction
        }
    }

}

extension SecurityHubClientTypes {
    /// A custom action that can be used for stateless packet handling.
    public struct FirewallPolicyStatelessCustomActionsDetails {
        /// The definition of the custom action.
        public var actionDefinition: SecurityHubClientTypes.StatelessCustomActionDefinition?
        /// The name of the custom action.
        public var actionName: Swift.String?

        public init(
            actionDefinition: SecurityHubClientTypes.StatelessCustomActionDefinition? = nil,
            actionName: Swift.String? = nil
        )
        {
            self.actionDefinition = actionDefinition
            self.actionName = actionName
        }
    }

}

extension SecurityHubClientTypes {
    /// A stateless rule group that is used by the firewall policy.
    public struct FirewallPolicyStatelessRuleGroupReferencesDetails {
        /// The order in which to run the stateless rule group.
        public var priority: Swift.Int?
        /// The ARN of the stateless rule group.
        public var resourceArn: Swift.String?

        public init(
            priority: Swift.Int? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.priority = priority
            self.resourceArn = resourceArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Defines the behavior of the firewall.
    public struct FirewallPolicyDetails {
        /// The stateful rule groups that are used in the firewall policy.
        public var statefulRuleGroupReferences: [SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails]?
        /// The custom action definitions that are available to use in the firewall policy's StatelessDefaultActions setting.
        public var statelessCustomActions: [SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails]?
        /// The actions to take on a packet if it doesn't match any of the stateless rules in the policy. You must specify a standard action (aws:pass, aws:drop, aws:forward_to_sfe), and can optionally include a custom action from StatelessCustomActions.
        public var statelessDefaultActions: [Swift.String]?
        /// The actions to take on a fragmented UDP packet if it doesn't match any of the stateless rules in the policy. You must specify a standard action (aws:pass, aws:drop, aws:forward_to_sfe), and can optionally include a custom action from StatelessCustomActions.
        public var statelessFragmentDefaultActions: [Swift.String]?
        /// The stateless rule groups that are used in the firewall policy.
        public var statelessRuleGroupReferences: [SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails]?

        public init(
            statefulRuleGroupReferences: [SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails]? = nil,
            statelessCustomActions: [SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails]? = nil,
            statelessDefaultActions: [Swift.String]? = nil,
            statelessFragmentDefaultActions: [Swift.String]? = nil,
            statelessRuleGroupReferences: [SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails]? = nil
        )
        {
            self.statefulRuleGroupReferences = statefulRuleGroupReferences
            self.statelessCustomActions = statelessCustomActions
            self.statelessDefaultActions = statelessDefaultActions
            self.statelessFragmentDefaultActions = statelessFragmentDefaultActions
            self.statelessRuleGroupReferences = statelessRuleGroupReferences
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about a firewall policy. A firewall policy defines the behavior of a network firewall.
    public struct AwsNetworkFirewallFirewallPolicyDetails {
        /// A description of the firewall policy.
        public var description: Swift.String?
        /// The firewall policy configuration.
        public var firewallPolicy: SecurityHubClientTypes.FirewallPolicyDetails?
        /// The ARN of the firewall policy.
        public var firewallPolicyArn: Swift.String?
        /// The identifier of the firewall policy.
        public var firewallPolicyId: Swift.String?
        /// The name of the firewall policy.
        public var firewallPolicyName: Swift.String?

        public init(
            description: Swift.String? = nil,
            firewallPolicy: SecurityHubClientTypes.FirewallPolicyDetails? = nil,
            firewallPolicyArn: Swift.String? = nil,
            firewallPolicyId: Swift.String? = nil,
            firewallPolicyName: Swift.String? = nil
        )
        {
            self.description = description
            self.firewallPolicy = firewallPolicy
            self.firewallPolicyArn = firewallPolicyArn
            self.firewallPolicyId = firewallPolicyId
            self.firewallPolicyName = firewallPolicyName
        }
    }

}

extension SecurityHubClientTypes {
    /// Stateful inspection criteria for a domain list rule group.
    public struct RuleGroupSourceListDetails {
        /// Indicates whether to allow or deny access to the domains listed in Targets.
        public var generatedRulesType: Swift.String?
        /// The protocols that you want to inspect. Specify LS_SNI for HTTPS. Specify HTTP_HOST for HTTP. You can specify either or both.
        public var targetTypes: [Swift.String]?
        /// The domains that you want to inspect for in your traffic flows. You can provide full domain names, or use the '.' prefix as a wildcard. For example, .example.com matches all domains that end with example.com.
        public var targets: [Swift.String]?

        public init(
            generatedRulesType: Swift.String? = nil,
            targetTypes: [Swift.String]? = nil,
            targets: [Swift.String]? = nil
        )
        {
            self.generatedRulesType = generatedRulesType
            self.targetTypes = targetTypes
            self.targets = targets
        }
    }

}

extension SecurityHubClientTypes {
    /// The inspection criteria for a stateful rule.
    public struct RuleGroupSourceStatefulRulesHeaderDetails {
        /// The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify ANY.
        public var destination: Swift.String?
        /// The destination port to inspect for. You can specify an individual port, such as 1994. You also can specify a port range, such as 1990:1994. To match with any port, specify ANY.
        public var destinationPort: Swift.String?
        /// The direction of traffic flow to inspect. If set to ANY, the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to FORWARD, the inspection only matches traffic going from the source to the destination.
        public var direction: Swift.String?
        /// The protocol to inspect for. To inspector for all protocols, use IP.
        public var `protocol`: Swift.String?
        /// The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify ANY.
        public var source: Swift.String?
        /// The source port to inspect for. You can specify an individual port, such as 1994. You also can specify a port range, such as 1990:1994. To match with any port, specify ANY.
        public var sourcePort: Swift.String?

        public init(
            destination: Swift.String? = nil,
            destinationPort: Swift.String? = nil,
            direction: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            source: Swift.String? = nil,
            sourcePort: Swift.String? = nil
        )
        {
            self.destination = destination
            self.destinationPort = destinationPort
            self.direction = direction
            self.`protocol` = `protocol`
            self.source = source
            self.sourcePort = sourcePort
        }
    }

}

extension SecurityHubClientTypes {
    /// A rule option for a stateful rule.
    public struct RuleGroupSourceStatefulRulesOptionsDetails {
        /// A keyword to look for.
        public var keyword: Swift.String?
        /// A list of settings.
        public var settings: [Swift.String]?

        public init(
            keyword: Swift.String? = nil,
            settings: [Swift.String]? = nil
        )
        {
            self.keyword = keyword
            self.settings = settings
        }
    }

}

extension SecurityHubClientTypes {
    /// A Suricata rule specification.
    public struct RuleGroupSourceStatefulRulesDetails {
        /// Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria.
        public var action: Swift.String?
        /// The stateful inspection criteria for the rule.
        public var header: SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails?
        /// Additional options for the rule.
        public var ruleOptions: [SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails]?

        public init(
            action: Swift.String? = nil,
            header: SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails? = nil,
            ruleOptions: [SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails]? = nil
        )
        {
            self.action = action
            self.header = header
            self.ruleOptions = ruleOptions
        }
    }

}

extension SecurityHubClientTypes {
    /// A custom action definition. A custom action is an optional, non-standard action to use for stateless packet handling.
    public struct RuleGroupSourceCustomActionsDetails {
        /// The definition of a custom action.
        public var actionDefinition: SecurityHubClientTypes.StatelessCustomActionDefinition?
        /// A descriptive name of the custom action.
        public var actionName: Swift.String?

        public init(
            actionDefinition: SecurityHubClientTypes.StatelessCustomActionDefinition? = nil,
            actionName: Swift.String? = nil
        )
        {
            self.actionDefinition = actionDefinition
            self.actionName = actionName
        }
    }

}

extension SecurityHubClientTypes {
    /// A port range to specify the destination ports to inspect for.
    public struct RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {
        /// The starting port value for the port range.
        public var fromPort: Swift.Int?
        /// The ending port value for the port range.
        public var toPort: Swift.Int?

        public init(
            fromPort: Swift.Int? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.toPort = toPort
        }
    }

}

extension SecurityHubClientTypes {
    /// A destination IP address or range.
    public struct RuleGroupSourceStatelessRuleMatchAttributesDestinations {
        /// An IP address or a block of IP addresses.
        public var addressDefinition: Swift.String?

        public init(
            addressDefinition: Swift.String? = nil
        )
        {
            self.addressDefinition = addressDefinition
        }
    }

}

extension SecurityHubClientTypes {
    /// A port range to specify the source ports to inspect for.
    public struct RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {
        /// The starting port value for the port range.
        public var fromPort: Swift.Int?
        /// The ending port value for the port range.
        public var toPort: Swift.Int?

        public init(
            fromPort: Swift.Int? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.toPort = toPort
        }
    }

}

extension SecurityHubClientTypes {
    /// A source IP addresses and address range to inspect for.
    public struct RuleGroupSourceStatelessRuleMatchAttributesSources {
        /// An IP address or a block of IP addresses.
        public var addressDefinition: Swift.String?

        public init(
            addressDefinition: Swift.String? = nil
        )
        {
            self.addressDefinition = addressDefinition
        }
    }

}

extension SecurityHubClientTypes {
    /// A set of TCP flags and masks to inspect for.
    public struct RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {
        /// Defines the flags from the Masks setting that must be set in order for the packet to match. Flags that are listed must be set. Flags that are not listed must not be set.
        public var flags: [Swift.String]?
        /// The set of flags to consider in the inspection. If not specified, then all flags are inspected.
        public var masks: [Swift.String]?

        public init(
            flags: [Swift.String]? = nil,
            masks: [Swift.String]? = nil
        )
        {
            self.flags = flags
            self.masks = masks
        }
    }

}

extension SecurityHubClientTypes {
    /// Criteria for the stateless rule.
    public struct RuleGroupSourceStatelessRuleMatchAttributes {
        /// A list of port ranges to specify the destination ports to inspect for.
        public var destinationPorts: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]?
        /// The destination IP addresses and address ranges to inspect for, in CIDR notation.
        public var destinations: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations]?
        /// The protocols to inspect for.
        public var protocols: [Swift.Int]?
        /// A list of port ranges to specify the source ports to inspect for.
        public var sourcePorts: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]?
        /// The source IP addresses and address ranges to inspect for, in CIDR notation.
        public var sources: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources]?
        /// The TCP flags and masks to inspect for.
        public var tcpFlags: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]?

        public init(
            destinationPorts: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]? = nil,
            destinations: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations]? = nil,
            protocols: [Swift.Int]? = nil,
            sourcePorts: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]? = nil,
            sources: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources]? = nil,
            tcpFlags: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]? = nil
        )
        {
            self.destinationPorts = destinationPorts
            self.destinations = destinations
            self.protocols = protocols
            self.sourcePorts = sourcePorts
            self.sources = sources
            self.tcpFlags = tcpFlags
        }
    }

}

extension SecurityHubClientTypes {
    /// The definition of the stateless rule.
    public struct RuleGroupSourceStatelessRuleDefinition {
        /// The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action (aws:pass, aws:drop, or aws:forward_to_sfe). You can then add custom actions.
        public var actions: [Swift.String]?
        /// The criteria for Network Firewall to use to inspect an individual packet in a stateless rule inspection.
        public var matchAttributes: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes?

        public init(
            actions: [Swift.String]? = nil,
            matchAttributes: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes? = nil
        )
        {
            self.actions = actions
            self.matchAttributes = matchAttributes
        }
    }

}

extension SecurityHubClientTypes {
    /// A stateless rule in the rule group.
    public struct RuleGroupSourceStatelessRulesDetails {
        /// Indicates the order in which to run this rule relative to all of the rules in the stateless rule group.
        public var priority: Swift.Int?
        /// Provides the definition of the stateless rule.
        public var ruleDefinition: SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition?

        public init(
            priority: Swift.Int? = nil,
            ruleDefinition: SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition? = nil
        )
        {
            self.priority = priority
            self.ruleDefinition = ruleDefinition
        }
    }

}

extension SecurityHubClientTypes {
    /// Stateless rules and custom actions for a stateless rule group.
    public struct RuleGroupSourceStatelessRulesAndCustomActionsDetails {
        /// Custom actions for the rule group.
        public var customActions: [SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails]?
        /// Stateless rules for the rule group.
        public var statelessRules: [SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails]?

        public init(
            customActions: [SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails]? = nil,
            statelessRules: [SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails]? = nil
        )
        {
            self.customActions = customActions
            self.statelessRules = statelessRules
        }
    }

}

extension SecurityHubClientTypes {
    /// The rules and actions for the rule group.
    public struct RuleGroupSource {
        /// Stateful inspection criteria for a domain list rule group. A domain list rule group determines access by specific protocols to specific domains.
        public var rulesSourceList: SecurityHubClientTypes.RuleGroupSourceListDetails?
        /// Stateful inspection criteria, provided in Suricata compatible intrusion prevention system (IPS) rules.
        public var rulesString: Swift.String?
        /// Suricata rule specifications.
        public var statefulRules: [SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails]?
        /// The stateless rules and custom actions used by a stateless rule group.
        public var statelessRulesAndCustomActions: SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails?

        public init(
            rulesSourceList: SecurityHubClientTypes.RuleGroupSourceListDetails? = nil,
            rulesString: Swift.String? = nil,
            statefulRules: [SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails]? = nil,
            statelessRulesAndCustomActions: SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails? = nil
        )
        {
            self.rulesSourceList = rulesSourceList
            self.rulesString = rulesString
            self.statefulRules = statefulRules
            self.statelessRulesAndCustomActions = statelessRulesAndCustomActions
        }
    }

}

extension SecurityHubClientTypes {
    /// A list of IP addresses and address ranges, in CIDR notation.
    public struct RuleGroupVariablesIpSetsDetails {
        /// The list of IP addresses and ranges.
        public var definition: [Swift.String]?

        public init(
            definition: [Swift.String]? = nil
        )
        {
            self.definition = definition
        }
    }

}

extension SecurityHubClientTypes {
    /// A list of port ranges.
    public struct RuleGroupVariablesPortSetsDetails {
        /// The list of port ranges.
        public var definition: [Swift.String]?

        public init(
            definition: [Swift.String]? = nil
        )
        {
            self.definition = definition
        }
    }

}

extension SecurityHubClientTypes {
    /// Additional settings to use in the specified rules.
    public struct RuleGroupVariables {
        /// A list of IP addresses and address ranges, in CIDR notation.
        public var ipSets: SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails?
        /// A list of port ranges.
        public var portSets: SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails?

        public init(
            ipSets: SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails? = nil,
            portSets: SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails? = nil
        )
        {
            self.ipSets = ipSets
            self.portSets = portSets
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the rule group.
    public struct RuleGroupDetails {
        /// Additional settings to use in the specified rules.
        public var ruleVariables: SecurityHubClientTypes.RuleGroupVariables?
        /// The rules and actions for the rule group. For stateful rule groups, can contain RulesString, RulesSourceList, or StatefulRules. For stateless rule groups, contains StatelessRulesAndCustomActions.
        public var rulesSource: SecurityHubClientTypes.RuleGroupSource?

        public init(
            ruleVariables: SecurityHubClientTypes.RuleGroupVariables? = nil,
            rulesSource: SecurityHubClientTypes.RuleGroupSource? = nil
        )
        {
            self.ruleVariables = ruleVariables
            self.rulesSource = rulesSource
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an Network Firewall rule group. Rule groups are used to inspect and control network traffic. Stateless rule groups apply to individual packets. Stateful rule groups apply to packets in the context of their traffic flow. Rule groups are referenced in firewall policies.
    public struct AwsNetworkFirewallRuleGroupDetails {
        /// The maximum number of operating resources that this rule group can use.
        public var capacity: Swift.Int?
        /// A description of the rule group.
        public var description: Swift.String?
        /// Details about the rule group.
        public var ruleGroup: SecurityHubClientTypes.RuleGroupDetails?
        /// The ARN of the rule group.
        public var ruleGroupArn: Swift.String?
        /// The identifier of the rule group.
        public var ruleGroupId: Swift.String?
        /// The descriptive name of the rule group.
        public var ruleGroupName: Swift.String?
        /// The type of rule group. A rule group can be stateful or stateless.
        public var type: Swift.String?

        public init(
            capacity: Swift.Int? = nil,
            description: Swift.String? = nil,
            ruleGroup: SecurityHubClientTypes.RuleGroupDetails? = nil,
            ruleGroupArn: Swift.String? = nil,
            ruleGroupId: Swift.String? = nil,
            ruleGroupName: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.capacity = capacity
            self.description = description
            self.ruleGroup = ruleGroup
            self.ruleGroupArn = ruleGroupArn
            self.ruleGroupId = ruleGroupId
            self.ruleGroupName = ruleGroupName
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies information about the master user of the domain.
    public struct AwsOpenSearchServiceDomainMasterUserOptionsDetails {
        /// The Amazon Resource Name (ARN) for the master user.
        public var masterUserArn: Swift.String?
        /// The username for the master user.
        public var masterUserName: Swift.String?
        /// The password for the master user.
        public var masterUserPassword: Swift.String?

        public init(
            masterUserArn: Swift.String? = nil,
            masterUserName: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil
        )
        {
            self.masterUserArn = masterUserArn
            self.masterUserName = masterUserName
            self.masterUserPassword = masterUserPassword
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about domain access control options.
    public struct AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {
        /// Enables fine-grained access control.
        public var enabled: Swift.Bool?
        /// Enables the internal user database.
        public var internalUserDatabaseEnabled: Swift.Bool?
        /// Specifies information about the master user of the domain.
        public var masterUserOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails?

        public init(
            enabled: Swift.Bool? = nil,
            internalUserDatabaseEnabled: Swift.Bool? = nil,
            masterUserOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails? = nil
        )
        {
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.masterUserOptions = masterUserOptions
        }
    }

}

extension SecurityHubClientTypes {
    /// Configuration options for zone awareness.
    public struct AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails {
        /// The number of Availability Zones that the domain uses. Valid values are 2 or 3. The default is 2.
        public var availabilityZoneCount: Swift.Int?

        public init(
            availabilityZoneCount: Swift.Int? = nil
        )
        {
            self.availabilityZoneCount = availabilityZoneCount
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the configuration of an OpenSearch cluster.
    public struct AwsOpenSearchServiceDomainClusterConfigDetails {
        /// The number of instances to use for the master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public var dedicatedMasterCount: Swift.Int?
        /// Whether to use a dedicated master node for the OpenSearch domain. A dedicated master node performs cluster management tasks, but does not hold data or respond to data upload requests.
        public var dedicatedMasterEnabled: Swift.Bool?
        /// The hardware configuration of the computer that hosts the dedicated master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public var dedicatedMasterType: Swift.String?
        /// The number of data nodes to use in the OpenSearch domain.
        public var instanceCount: Swift.Int?
        /// The instance type for your data nodes. For a list of valid values, see [Supported instance types in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html) in the Amazon OpenSearch Service Developer Guide.
        public var instanceType: Swift.String?
        /// The number of UltraWarm instances.
        public var warmCount: Swift.Int?
        /// Whether UltraWarm is enabled.
        public var warmEnabled: Swift.Bool?
        /// The type of UltraWarm instance.
        public var warmType: Swift.String?
        /// Configuration options for zone awareness. Provided if ZoneAwarenessEnabled is true.
        public var zoneAwarenessConfig: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails?
        /// Whether to enable zone awareness for the OpenSearch domain. When zone awareness is enabled, OpenSearch Service allocates the cluster's nodes and replica index shards across Availability Zones (AZs) in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.
        public var zoneAwarenessEnabled: Swift.Bool?

        public init(
            dedicatedMasterCount: Swift.Int? = nil,
            dedicatedMasterEnabled: Swift.Bool? = nil,
            dedicatedMasterType: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            instanceType: Swift.String? = nil,
            warmCount: Swift.Int? = nil,
            warmEnabled: Swift.Bool? = nil,
            warmType: Swift.String? = nil,
            zoneAwarenessConfig: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails? = nil,
            zoneAwarenessEnabled: Swift.Bool? = nil
        )
        {
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.warmCount = warmCount
            self.warmEnabled = warmEnabled
            self.warmType = warmType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about additional options for the domain endpoint.
    public struct AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {
        /// The fully qualified URL for the custom endpoint.
        public var customEndpoint: Swift.String?
        /// The ARN for the security certificate. The certificate is managed in ACM.
        public var customEndpointCertificateArn: Swift.String?
        /// Whether to enable a custom endpoint for the domain.
        public var customEndpointEnabled: Swift.Bool?
        /// Whether to require that all traffic to the domain arrive over HTTPS.
        public var enforceHTTPS: Swift.Bool?
        /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.
        public var tlsSecurityPolicy: Swift.String?

        public init(
            customEndpoint: Swift.String? = nil,
            customEndpointCertificateArn: Swift.String? = nil,
            customEndpointEnabled: Swift.Bool? = nil,
            enforceHTTPS: Swift.Bool? = nil,
            tlsSecurityPolicy: Swift.String? = nil
        )
        {
            self.customEndpoint = customEndpoint
            self.customEndpointCertificateArn = customEndpointCertificateArn
            self.customEndpointEnabled = customEndpointEnabled
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the configuration for encryption at rest for the OpenSearch domain.
    public struct AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {
        /// Whether encryption at rest is enabled.
        public var enabled: Swift.Bool?
        /// The KMS key ID.
        public var kmsKeyId: Swift.String?

        public init(
            enabled: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension SecurityHubClientTypes {
    /// Configuration details for a log publishing option.
    public struct AwsOpenSearchServiceDomainLogPublishingOption {
        /// The ARN of the CloudWatch Logs group to publish the logs to.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Whether the log publishing is enabled.
        public var enabled: Swift.Bool?

        public init(
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Configures the CloudWatch Logs to publish for the OpenSearch domain.
    public struct AwsOpenSearchServiceDomainLogPublishingOptionsDetails {
        /// Configures the OpenSearch audit logs publishing.
        public var auditLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption?
        /// Configures the OpenSearch index logs publishing.
        public var indexSlowLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption?
        /// Configures the OpenSearch search slow log publishing.
        public var searchSlowLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption?

        public init(
            auditLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption? = nil,
            indexSlowLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption? = nil,
            searchSlowLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption? = nil
        )
        {
            self.auditLogs = auditLogs
            self.indexSlowLogs = indexSlowLogs
            self.searchSlowLogs = searchSlowLogs
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the configuration for node-to-node encryption.
    public struct AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {
        /// Whether node-to-node encryption is enabled.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the state of the domain relative to the latest service software.
    public struct AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {
        /// The epoch time when the deployment window closes for required updates. After this time, OpenSearch Service schedules the software upgrade automatically.
        public var automatedUpdateDate: Swift.String?
        /// Whether a request to update the domain can be canceled.
        public var cancellable: Swift.Bool?
        /// The version of the service software that is currently installed on the domain.
        public var currentVersion: Swift.String?
        /// A more detailed description of the service software status.
        public var description: Swift.String?
        /// The most recent version of the service software.
        public var newVersion: Swift.String?
        /// Whether the service software update is optional.
        public var optionalDeployment: Swift.Bool?
        /// Whether a service software update is available for the domain.
        public var updateAvailable: Swift.Bool?
        /// The status of the service software update. Valid values are as follows:
        ///
        /// * COMPLETED
        ///
        /// * ELIGIBLE
        ///
        /// * IN_PROGRESS
        ///
        /// * NOT_ELIGIBLE
        ///
        /// * PENDING_UPDATE
        public var updateStatus: Swift.String?

        public init(
            automatedUpdateDate: Swift.String? = nil,
            cancellable: Swift.Bool? = nil,
            currentVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            newVersion: Swift.String? = nil,
            optionalDeployment: Swift.Bool? = nil,
            updateAvailable: Swift.Bool? = nil,
            updateStatus: Swift.String? = nil
        )
        {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.optionalDeployment = optionalDeployment
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains information that OpenSearch Service derives based on the VPCOptions for the domain.
    public struct AwsOpenSearchServiceDomainVpcOptionsDetails {
        /// The list of security group IDs that are associated with the VPC endpoints for the domain.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs that are associated with the VPC endpoints for the domain.
        public var subnetIds: [Swift.String]?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an Amazon OpenSearch Service domain.
    public struct AwsOpenSearchServiceDomainDetails {
        /// IAM policy document that specifies the access policies for the OpenSearch Service domain.
        public var accessPolicies: Swift.String?
        /// Specifies options for fine-grained access control.
        public var advancedSecurityOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails?
        /// The ARN of the OpenSearch Service domain.
        public var arn: Swift.String?
        /// Details about the configuration of an OpenSearch cluster.
        public var clusterConfig: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails?
        /// The domain endpoint.
        public var domainEndpoint: Swift.String?
        /// Additional options for the domain endpoint.
        public var domainEndpointOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails?
        /// The domain endpoints. Used if the OpenSearch domain resides in a VPC. This is a map of key-value pairs. The key is always vpc. The value is the endpoint.
        public var domainEndpoints: [Swift.String: Swift.String]?
        /// The name of the endpoint.
        public var domainName: Swift.String?
        /// Details about the configuration for encryption at rest.
        public var encryptionAtRestOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails?
        /// The version of the domain engine.
        public var engineVersion: Swift.String?
        /// The identifier of the domain.
        public var id: Swift.String?
        /// Configures the CloudWatch Logs to publish for the OpenSearch domain.
        public var logPublishingOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails?
        /// Details about the configuration for node-to-node encryption.
        public var nodeToNodeEncryptionOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails?
        /// Information about the status of a domain relative to the latest service software.
        public var serviceSoftwareOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails?
        /// Information that OpenSearch Service derives based on VPCOptions for the domain.
        public var vpcOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails?

        public init(
            accessPolicies: Swift.String? = nil,
            advancedSecurityOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails? = nil,
            arn: Swift.String? = nil,
            clusterConfig: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails? = nil,
            domainEndpoint: Swift.String? = nil,
            domainEndpointOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails? = nil,
            domainEndpoints: [Swift.String: Swift.String]? = nil,
            domainName: Swift.String? = nil,
            encryptionAtRestOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails? = nil,
            engineVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            logPublishingOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails? = nil,
            nodeToNodeEncryptionOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails? = nil,
            serviceSoftwareOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails? = nil,
            vpcOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails? = nil
        )
        {
            self.accessPolicies = accessPolicies
            self.advancedSecurityOptions = advancedSecurityOptions
            self.arn = arn
            self.clusterConfig = clusterConfig
            self.domainEndpoint = domainEndpoint
            self.domainEndpointOptions = domainEndpointOptions
            self.domainEndpoints = domainEndpoints
            self.domainName = domainName
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.id = id
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.vpcOptions = vpcOptions
        }
    }

}

extension SecurityHubClientTypes {
    /// An IAM role that is associated with the Amazon RDS DB cluster.
    public struct AwsRdsDbClusterAssociatedRole {
        /// The ARN of the IAM role.
        public var roleArn: Swift.String?
        /// The status of the association between the IAM role and the DB cluster. Valid values are as follows:
        ///
        /// * ACTIVE
        ///
        /// * INVALID
        ///
        /// * PENDING
        public var status: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an instance in the DB cluster.
    public struct AwsRdsDbClusterMember {
        /// The status of the DB cluster parameter group for this member of the DB cluster.
        public var dbClusterParameterGroupStatus: Swift.String?
        /// The instance identifier for this member of the DB cluster.
        public var dbInstanceIdentifier: Swift.String?
        /// Whether the cluster member is the primary instance for the DB cluster.
        public var isClusterWriter: Swift.Bool?
        /// Specifies the order in which an Aurora replica is promoted to the primary instance when the existing primary instance fails.
        public var promotionTier: Swift.Int?

        public init(
            dbClusterParameterGroupStatus: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            isClusterWriter: Swift.Bool? = nil,
            promotionTier: Swift.Int? = nil
        )
        {
            self.dbClusterParameterGroupStatus = dbClusterParameterGroupStatus
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.isClusterWriter = isClusterWriter
            self.promotionTier = promotionTier
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an option group membership for a DB cluster.
    public struct AwsRdsDbClusterOptionGroupMembership {
        /// The name of the DB cluster option group.
        public var dbClusterOptionGroupName: Swift.String?
        /// The status of the DB cluster option group.
        public var status: Swift.String?

        public init(
            dbClusterOptionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.dbClusterOptionGroupName = dbClusterOptionGroupName
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an Active Directory domain membership record associated with the DB instance.
    public struct AwsRdsDbDomainMembership {
        /// The identifier of the Active Directory domain.
        public var domain: Swift.String?
        /// The fully qualified domain name of the Active Directory domain.
        public var fqdn: Swift.String?
        /// The name of the IAM role to use when making API calls to the Directory Service.
        public var iamRoleName: Swift.String?
        /// The status of the Active Directory Domain membership for the DB instance.
        public var status: Swift.String?

        public init(
            domain: Swift.String? = nil,
            fqdn: Swift.String? = nil,
            iamRoleName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.domain = domain
            self.fqdn = fqdn
            self.iamRoleName = iamRoleName
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// A VPC security groups that the DB instance belongs to.
    public struct AwsRdsDbInstanceVpcSecurityGroup {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The name of the VPC security group.
        public var vpcSecurityGroupId: Swift.String?

        public init(
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an Amazon RDS DB cluster.
    public struct AwsRdsDbClusterDetails {
        /// The status of the database activity stream. Valid values are as follows:
        ///
        /// * started
        ///
        /// * starting
        ///
        /// * stopped
        ///
        /// * stopping
        public var activityStreamStatus: Swift.String?
        /// For all database engines except Aurora, specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int?
        /// A list of the IAM roles that are associated with the DB cluster.
        public var associatedRoles: [SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole]?
        /// Indicates if minor version upgrades are automatically applied to the cluster.
        public var autoMinorVersionUpgrade: Swift.Bool?
        /// A list of Availability Zones (AZs) where instances in the DB cluster can be created.
        public var availabilityZones: [Swift.String]?
        /// The number of days for which automated backups are retained.
        public var backupRetentionPeriod: Swift.Int?
        /// Indicates when the DB cluster was created, in Universal Coordinated Time (UTC). This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var clusterCreateTime: Swift.String?
        /// Whether tags are copied from the DB cluster to snapshots of the DB cluster.
        public var copyTagsToSnapshot: Swift.Bool?
        /// Whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.
        public var crossAccountClone: Swift.Bool?
        /// A list of custom endpoints for the DB cluster.
        public var customEndpoints: [Swift.String]?
        /// The name of the database.
        public var databaseName: Swift.String?
        /// The DB cluster identifier that the user assigned to the cluster. This identifier is the unique key that identifies a DB cluster.
        public var dbClusterIdentifier: Swift.String?
        /// The list of instances that make up the DB cluster.
        public var dbClusterMembers: [SecurityHubClientTypes.AwsRdsDbClusterMember]?
        /// The list of option group memberships for this DB cluster.
        public var dbClusterOptionGroupMemberships: [SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership]?
        /// The name of the DB cluster parameter group for the DB cluster.
        public var dbClusterParameterGroup: Swift.String?
        /// The identifier of the DB cluster. The identifier must be unique within each Amazon Web Services Region and is immutable.
        public var dbClusterResourceId: Swift.String?
        /// The subnet group that is associated with the DB cluster, including the name, description, and subnets in the subnet group.
        public var dbSubnetGroup: Swift.String?
        /// Whether the DB cluster has deletion protection enabled.
        public var deletionProtection: Swift.Bool?
        /// The Active Directory domain membership records that are associated with the DB cluster.
        public var domainMemberships: [SecurityHubClientTypes.AwsRdsDbDomainMembership]?
        /// A list of log types that this DB cluster is configured to export to CloudWatch Logs.
        public var enabledCloudWatchLogsExports: [Swift.String]?
        /// The connection endpoint for the primary instance of the DB cluster.
        public var endpoint: Swift.String?
        /// The name of the database engine to use for this DB cluster. Valid values are as follows:
        ///
        /// * aurora
        ///
        /// * aurora-mysql
        ///
        /// * aurora-postgresql
        public var engine: Swift.String?
        /// The database engine mode of the DB cluster.Valid values are as follows:
        ///
        /// * global
        ///
        /// * multimaster
        ///
        /// * parallelquery
        ///
        /// * provisioned
        ///
        /// * serverless
        public var engineMode: Swift.String?
        /// The version number of the database engine to use.
        public var engineVersion: Swift.String?
        /// Specifies the identifier that Amazon Route 53 assigns when you create a hosted zone.
        public var hostedZoneId: Swift.String?
        /// Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.
        public var httpEndpointEnabled: Swift.Bool?
        /// Whether the mapping of IAM accounts to database accounts is enabled.
        public var iamDatabaseAuthenticationEnabled: Swift.Bool?
        /// The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.
        public var kmsKeyId: Swift.String?
        /// The name of the master user for the DB cluster.
        public var masterUsername: Swift.String?
        /// Whether the DB cluster has instances in multiple Availability Zones.
        public var multiAz: Swift.Bool?
        /// The port number on which the DB instances in the DB cluster accept connections.
        public var port: Swift.Int?
        /// The range of time each day when automated backups are created, if automated backups are enabled. Uses the format HH:MM-HH:MM. For example, 04:52-05:22.
        public var preferredBackupWindow: Swift.String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Uses the format :HH:MM-:HH:MM. For the day values, use mon|tue|wed|thu|fri|sat|sun. For example, sun:09:32-sun:10:02.
        public var preferredMaintenanceWindow: Swift.String?
        /// The identifiers of the read replicas that are associated with this DB cluster.
        public var readReplicaIdentifiers: [Swift.String]?
        /// The reader endpoint for the DB cluster.
        public var readerEndpoint: Swift.String?
        /// The current status of this DB cluster.
        public var status: Swift.String?
        /// Whether the DB cluster is encrypted.
        public var storageEncrypted: Swift.Bool?
        /// A list of VPC security groups that the DB cluster belongs to.
        public var vpcSecurityGroups: [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]?

        public init(
            activityStreamStatus: Swift.String? = nil,
            allocatedStorage: Swift.Int? = nil,
            associatedRoles: [SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole]? = nil,
            autoMinorVersionUpgrade: Swift.Bool? = nil,
            availabilityZones: [Swift.String]? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            clusterCreateTime: Swift.String? = nil,
            copyTagsToSnapshot: Swift.Bool? = nil,
            crossAccountClone: Swift.Bool? = nil,
            customEndpoints: [Swift.String]? = nil,
            databaseName: Swift.String? = nil,
            dbClusterIdentifier: Swift.String? = nil,
            dbClusterMembers: [SecurityHubClientTypes.AwsRdsDbClusterMember]? = nil,
            dbClusterOptionGroupMemberships: [SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership]? = nil,
            dbClusterParameterGroup: Swift.String? = nil,
            dbClusterResourceId: Swift.String? = nil,
            dbSubnetGroup: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            domainMemberships: [SecurityHubClientTypes.AwsRdsDbDomainMembership]? = nil,
            enabledCloudWatchLogsExports: [Swift.String]? = nil,
            endpoint: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineMode: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            httpEndpointEnabled: Swift.Bool? = nil,
            iamDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            multiAz: Swift.Bool? = nil,
            port: Swift.Int? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            readReplicaIdentifiers: [Swift.String]? = nil,
            readerEndpoint: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool? = nil,
            vpcSecurityGroups: [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]? = nil
        )
        {
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZones = availabilityZones
            self.backupRetentionPeriod = backupRetentionPeriod
            self.clusterCreateTime = clusterCreateTime
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.crossAccountClone = crossAccountClone
            self.customEndpoints = customEndpoints
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterMembers = dbClusterMembers
            self.dbClusterOptionGroupMemberships = dbClusterOptionGroupMemberships
            self.dbClusterParameterGroup = dbClusterParameterGroup
            self.dbClusterResourceId = dbClusterResourceId
            self.dbSubnetGroup = dbSubnetGroup
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.hostedZoneId = hostedZoneId
            self.httpEndpointEnabled = httpEndpointEnabled
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.masterUsername = masterUsername
            self.multiAz = multiAz
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.readReplicaIdentifiers = readReplicaIdentifiers
            self.readerEndpoint = readerEndpoint
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains the name and values of a manual Amazon Relational Database Service (RDS) DB cluster snapshot attribute.
    public struct AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute {
        /// The name of the manual DB cluster snapshot attribute. The attribute named restore refers to the list of Amazon Web Services accounts that have permission to copy or restore the manual DB cluster snapshot.
        public var attributeName: Swift.String?
        /// The value(s) for the manual DB cluster snapshot attribute. If the AttributeName field is set to restore, then this element returns a list of IDs of the Amazon Web Services accounts that are authorized to copy or restore the manual DB cluster snapshot. If a value of all is in the list, then the manual DB cluster snapshot is public and available for any Amazon Web Services account to copy or restore.
        public var attributeValues: [Swift.String]?

        public init(
            attributeName: Swift.String? = nil,
            attributeValues: [Swift.String]? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeValues = attributeValues
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about an Amazon RDS DB cluster snapshot.
    public struct AwsRdsDbClusterSnapshotDetails {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int?
        /// A list of Availability Zones where instances in the DB cluster can be created.
        public var availabilityZones: [Swift.String]?
        /// Indicates when the DB cluster was created, in Universal Coordinated Time (UTC). This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var clusterCreateTime: Swift.String?
        /// The DB cluster identifier.
        public var dbClusterIdentifier: Swift.String?
        /// Contains the name and values of a manual DB cluster snapshot attribute.
        public var dbClusterSnapshotAttributes: [SecurityHubClientTypes.AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute]?
        /// The identifier of the DB cluster snapshot.
        public var dbClusterSnapshotIdentifier: Swift.String?
        /// The name of the database engine that you want to use for this DB instance.
        public var engine: Swift.String?
        /// The version of the database engine to use.
        public var engineVersion: Swift.String?
        /// Whether mapping of IAM accounts to database accounts is enabled.
        public var iamDatabaseAuthenticationEnabled: Swift.Bool?
        /// The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.
        public var kmsKeyId: Swift.String?
        /// The license model information for this DB cluster snapshot.
        public var licenseModel: Swift.String?
        /// The name of the master user for the DB cluster.
        public var masterUsername: Swift.String?
        /// Specifies the percentage of the estimated data that has been transferred.
        public var percentProgress: Swift.Int?
        /// The port number on which the DB instances in the DB cluster accept connections.
        public var port: Swift.Int?
        /// Indicates when the snapshot was taken. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var snapshotCreateTime: Swift.String?
        /// The type of DB cluster snapshot.
        public var snapshotType: Swift.String?
        /// The status of this DB cluster snapshot.
        public var status: Swift.String?
        /// Whether the DB cluster is encrypted.
        public var storageEncrypted: Swift.Bool?
        /// The VPC ID that is associated with the DB cluster snapshot.
        public var vpcId: Swift.String?

        public init(
            allocatedStorage: Swift.Int? = nil,
            availabilityZones: [Swift.String]? = nil,
            clusterCreateTime: Swift.String? = nil,
            dbClusterIdentifier: Swift.String? = nil,
            dbClusterSnapshotAttributes: [SecurityHubClientTypes.AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute]? = nil,
            dbClusterSnapshotIdentifier: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iamDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            percentProgress: Swift.Int? = nil,
            port: Swift.Int? = nil,
            snapshotCreateTime: Swift.String? = nil,
            snapshotType: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZones = availabilityZones
            self.clusterCreateTime = clusterCreateTime
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterSnapshotAttributes = dbClusterSnapshotAttributes
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.percentProgress = percentProgress
            self.port = port
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// An IAM role associated with the DB instance.
    public struct AwsRdsDbInstanceAssociatedRole {
        /// The name of the feature associated with the IAM role.
        public var featureName: Swift.String?
        /// The ARN of the IAM role that is associated with the DB instance.
        public var roleArn: Swift.String?
        /// Describes the state of the association between the IAM role and the DB instance. The Status property returns one of the following values:
        ///
        /// * ACTIVE - The IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.
        ///
        /// * PENDING - The IAM role ARN is being associated with the DB instance.
        ///
        /// * INVALID - The IAM role ARN is associated with the DB instance. But the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf.
        public var status: Swift.String?

        public init(
            featureName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about a parameter group for a DB instance.
    public struct AwsRdsDbParameterGroup {
        /// The name of the parameter group.
        public var dbParameterGroupName: Swift.String?
        /// The status of parameter updates.
        public var parameterApplyStatus: Swift.String?

        public init(
            dbParameterGroupName: Swift.String? = nil,
            parameterApplyStatus: Swift.String? = nil
        )
        {
            self.dbParameterGroupName = dbParameterGroupName
            self.parameterApplyStatus = parameterApplyStatus
        }
    }

}

extension SecurityHubClientTypes {
    /// An Availability Zone for a subnet in a subnet group.
    public struct AwsRdsDbSubnetGroupSubnetAvailabilityZone {
        /// The name of the Availability Zone for a subnet in the subnet group.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a subnet in a subnet group.
    public struct AwsRdsDbSubnetGroupSubnet {
        /// Information about the Availability Zone for a subnet in the subnet group.
        public var subnetAvailabilityZone: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone?
        /// The identifier of a subnet in the subnet group.
        public var subnetIdentifier: Swift.String?
        /// The status of a subnet in the subnet group.
        public var subnetStatus: Swift.String?

        public init(
            subnetAvailabilityZone: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the subnet group for the database instance.
    public struct AwsRdsDbSubnetGroup {
        /// The ARN of the subnet group.
        public var dbSubnetGroupArn: Swift.String?
        /// The description of the subnet group.
        public var dbSubnetGroupDescription: Swift.String?
        /// The name of the subnet group.
        public var dbSubnetGroupName: Swift.String?
        /// The status of the subnet group.
        public var subnetGroupStatus: Swift.String?
        /// A list of subnets in the subnet group.
        public var subnets: [SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet]?
        /// The VPC ID of the subnet group.
        public var vpcId: Swift.String?

        public init(
            dbSubnetGroupArn: Swift.String? = nil,
            dbSubnetGroupDescription: Swift.String? = nil,
            dbSubnetGroupName: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.dbSubnetGroupArn = dbSubnetGroupArn
            self.dbSubnetGroupDescription = dbSubnetGroupDescription
            self.dbSubnetGroupName = dbSubnetGroupName
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the connection endpoint.
    public struct AwsRdsDbInstanceEndpoint {
        /// Specifies the DNS address of the DB instance.
        public var address: Swift.String?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public var hostedZoneId: Swift.String?
        /// Specifies the port that the database engine is listening on.
        public var port: Swift.Int?

        public init(
            address: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.address = address
            self.hostedZoneId = hostedZoneId
            self.port = port
        }
    }

}

extension SecurityHubClientTypes {
    /// An option group membership.
    public struct AwsRdsDbOptionGroupMembership {
        /// The name of the option group.
        public var optionGroupName: Swift.String?
        /// The status of the option group membership.
        public var status: Swift.String?

        public init(
            optionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.optionGroupName = optionGroupName
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Identifies the log types to enable and disable.
    public struct AwsRdsPendingCloudWatchLogsExports {
        /// A list of log types that are being disabled.
        public var logTypesToDisable: [Swift.String]?
        /// A list of log types that are being enabled.
        public var logTypesToEnable: [Swift.String]?

        public init(
            logTypesToDisable: [Swift.String]? = nil,
            logTypesToEnable: [Swift.String]? = nil
        )
        {
            self.logTypesToDisable = logTypesToDisable
            self.logTypesToEnable = logTypesToEnable
        }
    }

}

extension SecurityHubClientTypes {
    /// A processor feature.
    public struct AwsRdsDbProcessorFeature {
        /// The name of the processor feature. Valid values are coreCount or threadsPerCore.
        public var name: Swift.String?
        /// The value of the processor feature.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Changes to a DB instance that are currently pending.
    public struct AwsRdsDbPendingModifiedValues {
        /// The new value of the allocated storage for the DB instance.
        public var allocatedStorage: Swift.Int?
        /// The new backup retention period for the DB instance.
        public var backupRetentionPeriod: Swift.Int?
        /// The new CA certificate identifier for the DB instance.
        public var caCertificateIdentifier: Swift.String?
        /// The new DB instance class for the DB instance.
        public var dbInstanceClass: Swift.String?
        /// The new DB instance identifier for the DB instance.
        public var dbInstanceIdentifier: Swift.String?
        /// The name of the new subnet group for the DB instance.
        public var dbSubnetGroupName: Swift.String?
        /// The new engine version for the DB instance.
        public var engineVersion: Swift.String?
        /// The new provisioned IOPS value for the DB instance.
        public var iops: Swift.Int?
        /// The new license model value for the DB instance.
        public var licenseModel: Swift.String?
        /// The new master user password for the DB instance.
        public var masterUserPassword: Swift.String?
        /// Indicates that a single Availability Zone DB instance is changing to a multiple Availability Zone deployment.
        public var multiAZ: Swift.Bool?
        /// A list of log types that are being enabled or disabled.
        public var pendingCloudWatchLogsExports: SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports?
        /// The new port for the DB instance.
        public var port: Swift.Int?
        /// Processor features that are being updated.
        public var processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]?
        /// The new storage type for the DB instance.
        public var storageType: Swift.String?

        public init(
            allocatedStorage: Swift.Int? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            caCertificateIdentifier: Swift.String? = nil,
            dbInstanceClass: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            dbSubnetGroupName: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iops: Swift.Int? = nil,
            licenseModel: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil,
            multiAZ: Swift.Bool? = nil,
            pendingCloudWatchLogsExports: SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports? = nil,
            port: Swift.Int? = nil,
            processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbSubnetGroupName = dbSubnetGroupName
            self.engineVersion = engineVersion
            self.iops = iops
            self.licenseModel = licenseModel
            self.masterUserPassword = masterUserPassword
            self.multiAZ = multiAZ
            self.pendingCloudWatchLogsExports = pendingCloudWatchLogsExports
            self.port = port
            self.processorFeatures = processorFeatures
            self.storageType = storageType
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the status of a read replica.
    public struct AwsRdsDbStatusInfo {
        /// If the read replica is currently in an error state, provides the error details.
        public var message: Swift.String?
        /// Whether the read replica instance is operating normally.
        public var normal: Swift.Bool?
        /// The status of the read replica instance.
        public var status: Swift.String?
        /// The type of status. For a read replica, the status type is read replication.
        public var statusType: Swift.String?

        public init(
            message: Swift.String? = nil,
            normal: Swift.Bool? = nil,
            status: Swift.String? = nil,
            statusType: Swift.String? = nil
        )
        {
            self.message = message
            self.normal = normal
            self.status = status
            self.statusType = statusType
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains the details of an Amazon RDS DB instance.
    public struct AwsRdsDbInstanceDetails {
        /// The amount of storage (in gigabytes) to initially allocate for the DB instance.
        public var allocatedStorage: Swift.Int?
        /// The IAM roles associated with the DB instance.
        public var associatedRoles: [SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole]?
        /// Indicates whether minor version patches are applied automatically.
        public var autoMinorVersionUpgrade: Swift.Bool?
        /// The Availability Zone where the DB instance will be created.
        public var availabilityZone: Swift.String?
        /// The number of days for which to retain automated backups.
        public var backupRetentionPeriod: Swift.Int?
        /// The identifier of the CA certificate for this DB instance.
        public var caCertificateIdentifier: Swift.String?
        /// The name of the character set that this DB instance is associated with.
        public var characterSetName: Swift.String?
        /// Whether to copy resource tags to snapshots of the DB instance.
        public var copyTagsToSnapshot: Swift.Bool?
        /// If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.
        public var dbClusterIdentifier: Swift.String?
        /// Contains the name of the compute and memory capacity class of the DB instance.
        public var dbInstanceClass: Swift.String?
        /// Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.
        public var dbInstanceIdentifier: Swift.String?
        /// Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.
        public var dbInstancePort: Swift.Int?
        /// The current status of the DB instance.
        public var dbInstanceStatus: Swift.String?
        /// The meaning of this parameter differs according to the database engine you use. MySQL, MariaDB, SQL Server, PostgreSQL Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance. Oracle Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance.
        public var dbName: Swift.String?
        /// A list of the DB parameter groups to assign to the DB instance.
        public var dbParameterGroups: [SecurityHubClientTypes.AwsRdsDbParameterGroup]?
        /// A list of the DB security groups to assign to the DB instance.
        public var dbSecurityGroups: [Swift.String]?
        /// Information about the subnet group that is associated with the DB instance.
        public var dbSubnetGroup: SecurityHubClientTypes.AwsRdsDbSubnetGroup?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in CloudTrail log entries whenever the KMS key for the DB instance is accessed.
        public var dbiResourceId: Swift.String?
        /// Indicates whether the DB instance has deletion protection enabled. When deletion protection is enabled, the database cannot be deleted.
        public var deletionProtection: Swift.Bool?
        /// The Active Directory domain membership records associated with the DB instance.
        public var domainMemberships: [SecurityHubClientTypes.AwsRdsDbDomainMembership]?
        /// A list of log types that this DB instance is configured to export to CloudWatch Logs.
        public var enabledCloudWatchLogsExports: [Swift.String]?
        /// Specifies the connection endpoint.
        public var endpoint: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint?
        /// Provides the name of the database engine to use for this DB instance.
        public var engine: Swift.String?
        /// Indicates the database engine version.
        public var engineVersion: Swift.String?
        /// The ARN of the CloudWatch Logs log stream that receives the enhanced monitoring metrics data for the DB instance.
        public var enhancedMonitoringResourceArn: Swift.String?
        /// True if mapping of IAM accounts to database accounts is enabled, and otherwise false. IAM database authentication can be enabled for the following database engines.
        ///
        /// * For MySQL 5.6, minor version 5.6.34 or higher
        ///
        /// * For MySQL 5.7, minor version 5.7.16 or higher
        ///
        /// * Aurora 5.6 or higher
        public var iamDatabaseAuthenticationEnabled: Swift.Bool?
        /// Indicates when the DB instance was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var instanceCreateTime: Swift.String?
        /// Specifies the provisioned IOPS (I/O operations per second) for this DB instance.
        public var iops: Swift.Int?
        /// If StorageEncrypted is true, the KMS key identifier for the encrypted DB instance.
        public var kmsKeyId: Swift.String?
        /// Specifies the latest time to which a database can be restored with point-in-time restore. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var latestRestorableTime: Swift.String?
        /// License model information for this DB instance.
        public var licenseModel: Swift.String?
        /// Specifies the connection endpoint.
        public var listenerEndpoint: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint?
        /// The master user name of the DB instance.
        public var masterUsername: Swift.String?
        /// The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.
        public var maxAllocatedStorage: Swift.Int?
        /// The interval, in seconds, between points when enhanced monitoring metrics are collected for the DB instance.
        public var monitoringInterval: Swift.Int?
        /// The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring metrics to CloudWatch Logs.
        public var monitoringRoleArn: Swift.String?
        /// Whether the DB instance is a multiple Availability Zone deployment.
        public var multiAz: Swift.Bool?
        /// The list of option group memberships for this DB instance.
        public var optionGroupMemberships: [SecurityHubClientTypes.AwsRdsDbOptionGroupMembership]?
        /// Changes to the DB instance that are currently pending.
        public var pendingModifiedValues: SecurityHubClientTypes.AwsRdsDbPendingModifiedValues?
        /// Indicates whether Performance Insights is enabled for the DB instance.
        public var performanceInsightsEnabled: Swift.Bool?
        /// The identifier of the KMS key used to encrypt the Performance Insights data.
        public var performanceInsightsKmsKeyId: Swift.String?
        /// The number of days to retain Performance Insights data.
        public var performanceInsightsRetentionPeriod: Swift.Int?
        /// The range of time each day when automated backups are created, if automated backups are enabled. Uses the format HH:MM-HH:MM. For example, 04:52-05:22.
        public var preferredBackupWindow: Swift.String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Uses the format :HH:MM-:HH:MM. For the day values, use mon|tue|wed|thu|fri|sat|sun. For example, sun:09:32-sun:10:02.
        public var preferredMaintenanceWindow: Swift.String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public var processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]?
        /// The order in which to promote an Aurora replica to the primary instance after a failure of the existing primary instance.
        public var promotionTier: Swift.Int?
        /// Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address.
        public var publiclyAccessible: Swift.Bool?
        /// List of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica.
        public var readReplicaDBClusterIdentifiers: [Swift.String]?
        /// List of identifiers of the read replicas associated with this DB instance.
        public var readReplicaDBInstanceIdentifiers: [Swift.String]?
        /// If this DB instance is a read replica, contains the identifier of the source DB instance.
        public var readReplicaSourceDBInstanceIdentifier: Swift.String?
        /// For a DB instance with multi-Availability Zone support, the name of the secondary Availability Zone.
        public var secondaryAvailabilityZone: Swift.String?
        /// The status of a read replica. If the instance isn't a read replica, this is empty.
        public var statusInfos: [SecurityHubClientTypes.AwsRdsDbStatusInfo]?
        /// Specifies whether the DB instance is encrypted.
        public var storageEncrypted: Swift.Bool?
        /// The storage type for the DB instance.
        public var storageType: Swift.String?
        /// The ARN from the key store with which the instance is associated for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the DB instance.
        public var timezone: Swift.String?
        /// A list of VPC security groups that the DB instance belongs to.
        public var vpcSecurityGroups: [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]?

        public init(
            allocatedStorage: Swift.Int? = nil,
            associatedRoles: [SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole]? = nil,
            autoMinorVersionUpgrade: Swift.Bool? = nil,
            availabilityZone: Swift.String? = nil,
            backupRetentionPeriod: Swift.Int? = nil,
            caCertificateIdentifier: Swift.String? = nil,
            characterSetName: Swift.String? = nil,
            copyTagsToSnapshot: Swift.Bool? = nil,
            dbClusterIdentifier: Swift.String? = nil,
            dbInstanceClass: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            dbInstancePort: Swift.Int? = nil,
            dbInstanceStatus: Swift.String? = nil,
            dbName: Swift.String? = nil,
            dbParameterGroups: [SecurityHubClientTypes.AwsRdsDbParameterGroup]? = nil,
            dbSecurityGroups: [Swift.String]? = nil,
            dbSubnetGroup: SecurityHubClientTypes.AwsRdsDbSubnetGroup? = nil,
            dbiResourceId: Swift.String? = nil,
            deletionProtection: Swift.Bool? = nil,
            domainMemberships: [SecurityHubClientTypes.AwsRdsDbDomainMembership]? = nil,
            enabledCloudWatchLogsExports: [Swift.String]? = nil,
            endpoint: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            enhancedMonitoringResourceArn: Swift.String? = nil,
            iamDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            instanceCreateTime: Swift.String? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            latestRestorableTime: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            listenerEndpoint: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint? = nil,
            masterUsername: Swift.String? = nil,
            maxAllocatedStorage: Swift.Int? = nil,
            monitoringInterval: Swift.Int? = nil,
            monitoringRoleArn: Swift.String? = nil,
            multiAz: Swift.Bool? = nil,
            optionGroupMemberships: [SecurityHubClientTypes.AwsRdsDbOptionGroupMembership]? = nil,
            pendingModifiedValues: SecurityHubClientTypes.AwsRdsDbPendingModifiedValues? = nil,
            performanceInsightsEnabled: Swift.Bool? = nil,
            performanceInsightsKmsKeyId: Swift.String? = nil,
            performanceInsightsRetentionPeriod: Swift.Int? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]? = nil,
            promotionTier: Swift.Int? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            readReplicaDBClusterIdentifiers: [Swift.String]? = nil,
            readReplicaDBInstanceIdentifiers: [Swift.String]? = nil,
            readReplicaSourceDBInstanceIdentifier: Swift.String? = nil,
            secondaryAvailabilityZone: Swift.String? = nil,
            statusInfos: [SecurityHubClientTypes.AwsRdsDbStatusInfo]? = nil,
            storageEncrypted: Swift.Bool? = nil,
            storageType: Swift.String? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcSecurityGroups: [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbInstancePort = dbInstancePort
            self.dbInstanceStatus = dbInstanceStatus
            self.dbName = dbName
            self.dbParameterGroups = dbParameterGroups
            self.dbSecurityGroups = dbSecurityGroups
            self.dbSubnetGroup = dbSubnetGroup
            self.dbiResourceId = dbiResourceId
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.licenseModel = licenseModel
            self.listenerEndpoint = listenerEndpoint
            self.masterUsername = masterUsername
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAz = multiAz
            self.optionGroupMemberships = optionGroupMemberships
            self.pendingModifiedValues = pendingModifiedValues
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKmsKeyId = performanceInsightsKmsKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
            self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
            self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.statusInfos = statusInfos
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension SecurityHubClientTypes {
    /// EC2 security group information for an RDS DB security group.
    public struct AwsRdsDbSecurityGroupEc2SecurityGroup {
        /// Specifies the ID for the EC2 security group.
        public var ec2SecurityGroupId: Swift.String?
        /// Specifies the name of the EC2 security group.
        public var ec2SecurityGroupName: Swift.String?
        /// Provides the Amazon Web Services ID of the owner of the EC2 security group.
        public var ec2SecurityGroupOwnerId: Swift.String?
        /// Provides the status of the EC2 security group.
        public var status: Swift.String?

        public init(
            ec2SecurityGroupId: Swift.String? = nil,
            ec2SecurityGroupName: Swift.String? = nil,
            ec2SecurityGroupOwnerId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.ec2SecurityGroupId = ec2SecurityGroupId
            self.ec2SecurityGroupName = ec2SecurityGroupName
            self.ec2SecurityGroupOwnerId = ec2SecurityGroupOwnerId
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// IP range information for an RDS DB security group.
    public struct AwsRdsDbSecurityGroupIpRange {
        /// Specifies the IP range.
        public var cidrIp: Swift.String?
        /// Specifies the status of the IP range.
        public var status: Swift.String?

        public init(
            cidrIp: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.cidrIp = cidrIp
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon RDS DB security group.
    public struct AwsRdsDbSecurityGroupDetails {
        /// The ARN for the DB security group.
        public var dbSecurityGroupArn: Swift.String?
        /// Provides the description of the DB security group.
        public var dbSecurityGroupDescription: Swift.String?
        /// Specifies the name of the DB security group.
        public var dbSecurityGroupName: Swift.String?
        /// Contains a list of EC2 security groups.
        public var ec2SecurityGroups: [SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup]?
        /// Contains a list of IP ranges.
        public var ipRanges: [SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange]?
        /// Provides the Amazon Web Services ID of the owner of a specific DB security group.
        public var ownerId: Swift.String?
        /// Provides VPC ID associated with the DB security group.
        public var vpcId: Swift.String?

        public init(
            dbSecurityGroupArn: Swift.String? = nil,
            dbSecurityGroupDescription: Swift.String? = nil,
            dbSecurityGroupName: Swift.String? = nil,
            ec2SecurityGroups: [SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup]? = nil,
            ipRanges: [SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange]? = nil,
            ownerId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.dbSecurityGroupArn = dbSecurityGroupArn
            self.dbSecurityGroupDescription = dbSecurityGroupDescription
            self.dbSecurityGroupName = dbSecurityGroupName
            self.ec2SecurityGroups = ec2SecurityGroups
            self.ipRanges = ipRanges
            self.ownerId = ownerId
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon RDS DB cluster snapshot.
    public struct AwsRdsDbSnapshotDetails {
        /// The amount of storage (in gigabytes) to be initially allocated for the database instance.
        public var allocatedStorage: Swift.Int?
        /// Specifies the name of the Availability Zone in which the DB instance was located at the time of the DB snapshot.
        public var availabilityZone: Swift.String?
        /// A name for the DB instance.
        public var dbInstanceIdentifier: Swift.String?
        /// The name or ARN of the DB snapshot that is used to restore the DB instance.
        public var dbSnapshotIdentifier: Swift.String?
        /// The identifier for the source DB instance.
        public var dbiResourceId: Swift.String?
        /// Whether the DB snapshot is encrypted.
        public var encrypted: Swift.Bool?
        /// The name of the database engine to use for this DB instance. Valid values are as follows:
        ///
        /// * aurora
        ///
        /// * aurora-mysql
        ///
        /// * aurora-postgresql
        ///
        /// * c
        ///
        /// * mariadb
        ///
        /// * mysql
        ///
        /// * oracle-ee
        ///
        /// * oracle-se
        ///
        /// * oracle-se1
        ///
        /// * oracle-se2
        ///
        /// * sqlserver-ee
        ///
        /// * sqlserver-ex
        ///
        /// * sqlserver-se
        ///
        /// * sqlserver-web
        public var engine: Swift.String?
        /// The version of the database engine.
        public var engineVersion: Swift.String?
        /// Whether mapping of IAM accounts to database accounts is enabled.
        public var iamDatabaseAuthenticationEnabled: Swift.Bool?
        /// Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.
        public var instanceCreateTime: Swift.String?
        /// The provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.
        public var iops: Swift.Int?
        /// If Encrypted is true, the KMS key identifier for the encrypted DB snapshot.
        public var kmsKeyId: Swift.String?
        /// License model information for the restored DB instance.
        public var licenseModel: Swift.String?
        /// The master user name for the DB snapshot.
        public var masterUsername: Swift.String?
        /// The option group name for the DB snapshot.
        public var optionGroupName: Swift.String?
        /// The percentage of the estimated data that has been transferred.
        public var percentProgress: Swift.Int?
        /// The port that the database engine was listening on at the time of the snapshot.
        public var port: Swift.Int?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public var processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]?
        /// When the snapshot was taken in Coordinated Universal Time (UTC).
        public var snapshotCreateTime: Swift.String?
        /// The type of the DB snapshot.
        public var snapshotType: Swift.String?
        /// The DB snapshot ARN that the DB snapshot was copied from.
        public var sourceDbSnapshotIdentifier: Swift.String?
        /// The Amazon Web Services Region that the DB snapshot was created in or copied from.
        public var sourceRegion: Swift.String?
        /// The status of this DB snapshot.
        public var status: Swift.String?
        /// The storage type associated with the DB snapshot. Valid values are as follows:
        ///
        /// * gp2
        ///
        /// * io1
        ///
        /// * standard
        public var storageType: Swift.String?
        /// The ARN from the key store with which to associate the instance for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the DB snapshot.
        public var timezone: Swift.String?
        /// The VPC ID associated with the DB snapshot.
        public var vpcId: Swift.String?

        public init(
            allocatedStorage: Swift.Int? = nil,
            availabilityZone: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            dbSnapshotIdentifier: Swift.String? = nil,
            dbiResourceId: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iamDatabaseAuthenticationEnabled: Swift.Bool? = nil,
            instanceCreateTime: Swift.String? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            optionGroupName: Swift.String? = nil,
            percentProgress: Swift.Int? = nil,
            port: Swift.Int? = nil,
            processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]? = nil,
            snapshotCreateTime: Swift.String? = nil,
            snapshotType: Swift.String? = nil,
            sourceDbSnapshotIdentifier: Swift.String? = nil,
            sourceRegion: Swift.String? = nil,
            status: Swift.String? = nil,
            storageType: Swift.String? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.dbiResourceId = dbiResourceId
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.optionGroupName = optionGroupName
            self.percentProgress = percentProgress
            self.port = port
            self.processorFeatures = processorFeatures
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.sourceDbSnapshotIdentifier = sourceDbSnapshotIdentifier
            self.sourceRegion = sourceRegion
            self.status = status
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an Amazon RDS event notification subscription. The subscription allows Amazon RDS to post events to an SNS topic.
    public struct AwsRdsEventSubscriptionDetails {
        /// The identifier of the account that is associated with the event notification subscription.
        public var custSubscriptionId: Swift.String?
        /// The identifier of the event notification subscription.
        public var customerAwsId: Swift.String?
        /// Whether the event notification subscription is enabled.
        public var enabled: Swift.Bool?
        /// The list of event categories for the event notification subscription.
        public var eventCategoriesList: [Swift.String]?
        /// The ARN of the event notification subscription.
        public var eventSubscriptionArn: Swift.String?
        /// The ARN of the SNS topic to post the event notifications to.
        public var snsTopicArn: Swift.String?
        /// A list of source identifiers for the event notification subscription.
        public var sourceIdsList: [Swift.String]?
        /// The source type for the event notification subscription.
        public var sourceType: Swift.String?
        /// The status of the event notification subscription. Valid values: creating | modifying | deleting | active | no-permission | topic-not-exist
        public var status: Swift.String?
        /// The datetime when the event notification subscription was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var subscriptionCreationTime: Swift.String?

        public init(
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            eventCategoriesList: [Swift.String]? = nil,
            eventSubscriptionArn: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: Swift.String? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.eventSubscriptionArn = eventSubscriptionArn
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }
    }

}

extension SecurityHubClientTypes {
    /// A node in an Amazon Redshift cluster.
    public struct AwsRedshiftClusterClusterNode {
        /// The role of the node. A node might be a leader node or a compute node.
        public var nodeRole: Swift.String?
        /// The private IP address of the node.
        public var privateIpAddress: Swift.String?
        /// The public IP address of the node.
        public var publicIpAddress: Swift.String?

        public init(
            nodeRole: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIpAddress: Swift.String? = nil
        )
        {
            self.nodeRole = nodeRole
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
        }
    }

}

extension SecurityHubClientTypes {
    /// The status of a parameter in a cluster parameter group for an Amazon Redshift cluster.
    public struct AwsRedshiftClusterClusterParameterStatus {
        /// The error that prevented the parameter from being applied to the database.
        public var parameterApplyErrorDescription: Swift.String?
        /// The status of the parameter. Indicates whether the parameter is in sync with the database, waiting for a cluster reboot, or encountered an error when it was applied. Valid values: in-sync | pending-reboot | applying | invalid-parameter | apply-deferred | apply-error | unknown-error
        public var parameterApplyStatus: Swift.String?
        /// The name of the parameter.
        public var parameterName: Swift.String?

        public init(
            parameterApplyErrorDescription: Swift.String? = nil,
            parameterApplyStatus: Swift.String? = nil,
            parameterName: Swift.String? = nil
        )
        {
            self.parameterApplyErrorDescription = parameterApplyErrorDescription
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterName = parameterName
        }
    }

}

extension SecurityHubClientTypes {
    /// A cluster parameter group that is associated with an Amazon Redshift cluster.
    public struct AwsRedshiftClusterClusterParameterGroup {
        /// The list of parameter statuses.
        public var clusterParameterStatusList: [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus]?
        /// The status of updates to the parameters.
        public var parameterApplyStatus: Swift.String?
        /// The name of the parameter group.
        public var parameterGroupName: Swift.String?

        public init(
            clusterParameterStatusList: [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus]? = nil,
            parameterApplyStatus: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil
        )
        {
            self.clusterParameterStatusList = clusterParameterStatusList
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterGroupName = parameterGroupName
        }
    }

}

extension SecurityHubClientTypes {
    /// A security group that is associated with the cluster.
    public struct AwsRedshiftClusterClusterSecurityGroup {
        /// The name of the cluster security group.
        public var clusterSecurityGroupName: Swift.String?
        /// The status of the cluster security group.
        public var status: Swift.String?

        public init(
            clusterSecurityGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.clusterSecurityGroupName = clusterSecurityGroupName
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// You can configure Amazon Redshift to copy snapshots for a cluster to another Amazon Web Services Region. This parameter provides information about a cross-Region snapshot copy.
    public struct AwsRedshiftClusterClusterSnapshotCopyStatus {
        /// The destination Region that snapshots are automatically copied to when cross-Region snapshot copy is enabled.
        public var destinationRegion: Swift.String?
        /// The number of days that manual snapshots are retained in the destination Region after they are copied from a source Region. If the value is -1, then the manual snapshot is retained indefinitely. Valid values: Either -1 or an integer between 1 and 3,653
        public var manualSnapshotRetentionPeriod: Swift.Int?
        /// The number of days to retain automated snapshots in the destination Region after they are copied from a source Region.
        public var retentionPeriod: Swift.Int?
        /// The name of the snapshot copy grant.
        public var snapshotCopyGrantName: Swift.String?

        public init(
            destinationRegion: Swift.String? = nil,
            manualSnapshotRetentionPeriod: Swift.Int? = nil,
            retentionPeriod: Swift.Int? = nil,
            snapshotCopyGrantName: Swift.String? = nil
        )
        {
            self.destinationRegion = destinationRegion
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.retentionPeriod = retentionPeriod
            self.snapshotCopyGrantName = snapshotCopyGrantName
        }
    }

}

extension SecurityHubClientTypes {
    /// A time windows during which maintenance was deferred for an Amazon Redshift cluster.
    public struct AwsRedshiftClusterDeferredMaintenanceWindow {
        /// The end of the time window for which maintenance was deferred. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var deferMaintenanceEndTime: Swift.String?
        /// The identifier of the maintenance window.
        public var deferMaintenanceIdentifier: Swift.String?
        /// The start of the time window for which maintenance was deferred. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var deferMaintenanceStartTime: Swift.String?

        public init(
            deferMaintenanceEndTime: Swift.String? = nil,
            deferMaintenanceIdentifier: Swift.String? = nil,
            deferMaintenanceStartTime: Swift.String? = nil
        )
        {
            self.deferMaintenanceEndTime = deferMaintenanceEndTime
            self.deferMaintenanceIdentifier = deferMaintenanceIdentifier
            self.deferMaintenanceStartTime = deferMaintenanceStartTime
        }
    }

}

extension SecurityHubClientTypes {
    /// The status of the elastic IP (EIP) address for an Amazon Redshift cluster.
    public struct AwsRedshiftClusterElasticIpStatus {
        /// The elastic IP address for the cluster.
        public var elasticIp: Swift.String?
        /// The status of the elastic IP address.
        public var status: Swift.String?

        public init(
            elasticIp: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.elasticIp = elasticIp
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// The connection endpoint for an Amazon Redshift cluster.
    public struct AwsRedshiftClusterEndpoint {
        /// The DNS address of the cluster.
        public var address: Swift.String?
        /// The port that the database engine listens on.
        public var port: Swift.Int?

        public init(
            address: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.address = address
            self.port = port
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about whether an Amazon Redshift cluster finished applying any hardware changes to security module (HSM) settings that were specified in a modify cluster command.
    public struct AwsRedshiftClusterHsmStatus {
        /// The name of the HSM client certificate that the Amazon Redshift cluster uses to retrieve the data encryption keys that are stored in an HSM.
        public var hsmClientCertificateIdentifier: Swift.String?
        /// The name of the HSM configuration that contains the information that the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
        public var hsmConfigurationIdentifier: Swift.String?
        /// Indicates whether the Amazon Redshift cluster has finished applying any HSM settings changes specified in a modify cluster command. Type: String Valid values: active | applying
        public var status: Swift.String?

        public init(
            hsmClientCertificateIdentifier: Swift.String? = nil,
            hsmConfigurationIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
            self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// An IAM role that the cluster can use to access other Amazon Web Services services.
    public struct AwsRedshiftClusterIamRole {
        /// The status of the IAM role's association with the cluster. Valid values: in-sync | adding | removing
        public var applyStatus: Swift.String?
        /// The ARN of the IAM role.
        public var iamRoleArn: Swift.String?

        public init(
            applyStatus: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.applyStatus = applyStatus
            self.iamRoleArn = iamRoleArn
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the logging status of the cluster.
    public struct AwsRedshiftClusterLoggingStatus {
        /// The name of the S3 bucket where the log files are stored.
        public var bucketName: Swift.String?
        /// The message indicating that the logs failed to be delivered.
        public var lastFailureMessage: Swift.String?
        /// The last time when logs failed to be delivered. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastFailureTime: Swift.String?
        /// The last time that logs were delivered successfully. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastSuccessfulDeliveryTime: Swift.String?
        /// Indicates whether logging is enabled.
        public var loggingEnabled: Swift.Bool?
        /// Provides the prefix applied to the log file names.
        public var s3KeyPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            lastFailureTime: Swift.String? = nil,
            lastSuccessfulDeliveryTime: Swift.String? = nil,
            loggingEnabled: Swift.Bool? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.lastFailureMessage = lastFailureMessage
            self.lastFailureTime = lastFailureTime
            self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
            self.loggingEnabled = loggingEnabled
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension SecurityHubClientTypes {
    /// Changes to the Amazon Redshift cluster that are currently pending.
    public struct AwsRedshiftClusterPendingModifiedValues {
        /// The pending or in-progress change to the automated snapshot retention period.
        public var automatedSnapshotRetentionPeriod: Swift.Int?
        /// The pending or in-progress change to the identifier for the cluster.
        public var clusterIdentifier: Swift.String?
        /// The pending or in-progress change to the cluster type.
        public var clusterType: Swift.String?
        /// The pending or in-progress change to the service version.
        public var clusterVersion: Swift.String?
        /// The encryption type for a cluster.
        public var encryptionType: Swift.String?
        /// Indicates whether to create the cluster with enhanced VPC routing enabled.
        public var enhancedVpcRouting: Swift.Bool?
        /// The name of the maintenance track that the cluster changes to during the next maintenance window.
        public var maintenanceTrackName: Swift.String?
        /// The pending or in-progress change to the master user password for the cluster.
        public var masterUserPassword: Swift.String?
        /// The pending or in-progress change to the cluster's node type.
        public var nodeType: Swift.String?
        /// The pending or in-progress change to the number of nodes in the cluster.
        public var numberOfNodes: Swift.Int?
        /// The pending or in-progress change to whether the cluster can be connected to from the public network.
        public var publiclyAccessible: Swift.Bool?

        public init(
            automatedSnapshotRetentionPeriod: Swift.Int? = nil,
            clusterIdentifier: Swift.String? = nil,
            clusterType: Swift.String? = nil,
            clusterVersion: Swift.String? = nil,
            encryptionType: Swift.String? = nil,
            enhancedVpcRouting: Swift.Bool? = nil,
            maintenanceTrackName: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numberOfNodes: Swift.Int? = nil,
            publiclyAccessible: Swift.Bool? = nil
        )
        {
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.clusterIdentifier = clusterIdentifier
            self.clusterType = clusterType
            self.clusterVersion = clusterVersion
            self.encryptionType = encryptionType
            self.enhancedVpcRouting = enhancedVpcRouting
            self.maintenanceTrackName = maintenanceTrackName
            self.masterUserPassword = masterUserPassword
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.publiclyAccessible = publiclyAccessible
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the resize operation for the cluster.
    public struct AwsRedshiftClusterResizeInfo {
        /// Indicates whether the resize operation can be canceled.
        public var allowCancelResize: Swift.Bool?
        /// The type of resize operation. Valid values: ClassicResize
        public var resizeType: Swift.String?

        public init(
            allowCancelResize: Swift.Bool? = nil,
            resizeType: Swift.String? = nil
        )
        {
            self.allowCancelResize = allowCancelResize
            self.resizeType = resizeType
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the status of a cluster restore action. It only applies if the cluster was created by restoring a snapshot.
    public struct AwsRedshiftClusterRestoreStatus {
        /// The number of megabytes per second being transferred from the backup storage. Returns the average rate for a completed backup. This field is only updated when you restore to DC2 and DS2 node types.
        public var currentRestoreRateInMegaBytesPerSecond: Swift.Double?
        /// The amount of time an in-progress restore has been running, or the amount of time it took a completed restore to finish. This field is only updated when you restore to DC2 and DS2 node types.
        public var elapsedTimeInSeconds: Swift.Int?
        /// The estimate of the time remaining before the restore is complete. Returns 0 for a completed restore. This field is only updated when you restore to DC2 and DS2 node types.
        public var estimatedTimeToCompletionInSeconds: Swift.Int?
        /// The number of megabytes that were transferred from snapshot storage. This field is only updated when you restore to DC2 and DS2 node types.
        public var progressInMegaBytes: Swift.Int?
        /// The size of the set of snapshot data that was used to restore the cluster. This field is only updated when you restore to DC2 and DS2 node types.
        public var snapshotSizeInMegaBytes: Swift.Int?
        /// The status of the restore action. Valid values: starting | restoring | completed | failed
        public var status: Swift.String?

        public init(
            currentRestoreRateInMegaBytesPerSecond: Swift.Double? = nil,
            elapsedTimeInSeconds: Swift.Int? = nil,
            estimatedTimeToCompletionInSeconds: Swift.Int? = nil,
            progressInMegaBytes: Swift.Int? = nil,
            snapshotSizeInMegaBytes: Swift.Int? = nil,
            status: Swift.String? = nil
        )
        {
            self.currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecond
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
            self.progressInMegaBytes = progressInMegaBytes
            self.snapshotSizeInMegaBytes = snapshotSizeInMegaBytes
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// A VPC security group that the cluster belongs to, if the cluster is in a VPC.
    public struct AwsRedshiftClusterVpcSecurityGroup {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The identifier of the VPC security group.
        public var vpcSecurityGroupId: Swift.String?

        public init(
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an Amazon Redshift cluster.
    public struct AwsRedshiftClusterDetails {
        /// Indicates whether major version upgrades are applied automatically to the cluster during the maintenance window.
        public var allowVersionUpgrade: Swift.Bool?
        /// The number of days that automatic cluster snapshots are retained.
        public var automatedSnapshotRetentionPeriod: Swift.Int?
        /// The name of the Availability Zone in which the cluster is located.
        public var availabilityZone: Swift.String?
        /// The availability status of the cluster for queries. Possible values are the following:
        ///
        /// * Available - The cluster is available for queries.
        ///
        /// * Unavailable - The cluster is not available for queries.
        ///
        /// * Maintenance - The cluster is intermittently available for queries due to maintenance activities.
        ///
        /// * Modifying -The cluster is intermittently available for queries due to changes that modify the cluster.
        ///
        /// * Failed - The cluster failed and is not available for queries.
        public var clusterAvailabilityStatus: Swift.String?
        /// Indicates when the cluster was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var clusterCreateTime: Swift.String?
        /// The unique identifier of the cluster.
        public var clusterIdentifier: Swift.String?
        /// The nodes in the cluster.
        public var clusterNodes: [SecurityHubClientTypes.AwsRedshiftClusterClusterNode]?
        /// The list of cluster parameter groups that are associated with this cluster.
        public var clusterParameterGroups: [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup]?
        /// The public key for the cluster.
        public var clusterPublicKey: Swift.String?
        /// The specific revision number of the database in the cluster.
        public var clusterRevisionNumber: Swift.String?
        /// A list of cluster security groups that are associated with the cluster.
        public var clusterSecurityGroups: [SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup]?
        /// Information about the destination Region and retention period for the cross-Region snapshot copy.
        public var clusterSnapshotCopyStatus: SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus?
        /// The current status of the cluster. Valid values: available | available, prep-for-resize | available, resize-cleanup | cancelling-resize | creating | deleting | final-snapshot | hardware-failure | incompatible-hsm | incompatible-network | incompatible-parameters | incompatible-restore | modifying | paused | rebooting | renaming | resizing | rotating-keys | storage-full | updating-hsm
        public var clusterStatus: Swift.String?
        /// The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.
        public var clusterSubnetGroupName: Swift.String?
        /// The version ID of the Amazon Redshift engine that runs on the cluster.
        public var clusterVersion: Swift.String?
        /// The name of the initial database that was created when the cluster was created. The same name is returned for the life of the cluster. If an initial database is not specified, a database named devdev is created by default.
        public var dbName: Swift.String?
        /// List of time windows during which maintenance was deferred.
        public var deferredMaintenanceWindows: [SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow]?
        /// Information about the status of the Elastic IP (EIP) address.
        public var elasticIpStatus: SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus?
        /// The number of nodes that you can use the elastic resize method to resize the cluster to.
        public var elasticResizeNumberOfNodeOptions: Swift.String?
        /// Indicates whether the data in the cluster is encrypted at rest.
        public var encrypted: Swift.Bool?
        /// The connection endpoint.
        public var endpoint: SecurityHubClientTypes.AwsRedshiftClusterEndpoint?
        /// Indicates whether to create the cluster with enhanced VPC routing enabled.
        public var enhancedVpcRouting: Swift.Bool?
        /// Indicates when the next snapshot is expected to be taken. The cluster must have a valid snapshot schedule and have backups enabled. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var expectedNextSnapshotScheduleTime: Swift.String?
        /// The status of the next expected snapshot. Valid values: OnTrack | Pending
        public var expectedNextSnapshotScheduleTimeStatus: Swift.String?
        /// Information about whether the Amazon Redshift cluster finished applying any changes to hardware security module (HSM) settings that were specified in a modify cluster command.
        public var hsmStatus: SecurityHubClientTypes.AwsRedshiftClusterHsmStatus?
        /// A list of IAM roles that the cluster can use to access other Amazon Web Services services.
        public var iamRoles: [SecurityHubClientTypes.AwsRedshiftClusterIamRole]?
        /// The identifier of the KMS encryption key that is used to encrypt data in the cluster.
        public var kmsKeyId: Swift.String?
        /// Information about the logging status of the cluster.
        public var loggingStatus: SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus?
        /// The name of the maintenance track for the cluster.
        public var maintenanceTrackName: Swift.String?
        /// The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots. Valid values: Either -1 or an integer between 1 and 3,653
        public var manualSnapshotRetentionPeriod: Swift.Int?
        /// The master user name for the cluster. This name is used to connect to the database that is specified in as the value of DBName.
        public var masterUsername: Swift.String?
        /// Indicates the start of the next maintenance window. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var nextMaintenanceWindowStartTime: Swift.String?
        /// The node type for the nodes in the cluster.
        public var nodeType: Swift.String?
        /// The number of compute nodes in the cluster.
        public var numberOfNodes: Swift.Int?
        /// A list of cluster operations that are waiting to start.
        public var pendingActions: [Swift.String]?
        /// A list of changes to the cluster that are currently pending.
        public var pendingModifiedValues: SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues?
        /// The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur. Format:  :HH:MM-:HH:MM For the day values, use mon | tue | wed | thu | fri | sat | sun For example, sun:09:32-sun:10:02
        public var preferredMaintenanceWindow: Swift.String?
        /// Whether the cluster can be accessed from a public network.
        public var publiclyAccessible: Swift.Bool?
        /// Information about the resize operation for the cluster.
        public var resizeInfo: SecurityHubClientTypes.AwsRedshiftClusterResizeInfo?
        /// Information about the status of a cluster restore action. Only applies to a cluster that was created by restoring a snapshot.
        public var restoreStatus: SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus?
        /// A unique identifier for the cluster snapshot schedule.
        public var snapshotScheduleIdentifier: Swift.String?
        /// The current state of the cluster snapshot schedule. Valid values: MODIFYING | ACTIVE | FAILED
        public var snapshotScheduleState: Swift.String?
        /// The identifier of the VPC that the cluster is in, if the cluster is in a VPC.
        public var vpcId: Swift.String?
        /// The list of VPC security groups that the cluster belongs to, if the cluster is in a VPC.
        public var vpcSecurityGroups: [SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup]?

        public init(
            allowVersionUpgrade: Swift.Bool? = nil,
            automatedSnapshotRetentionPeriod: Swift.Int? = nil,
            availabilityZone: Swift.String? = nil,
            clusterAvailabilityStatus: Swift.String? = nil,
            clusterCreateTime: Swift.String? = nil,
            clusterIdentifier: Swift.String? = nil,
            clusterNodes: [SecurityHubClientTypes.AwsRedshiftClusterClusterNode]? = nil,
            clusterParameterGroups: [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup]? = nil,
            clusterPublicKey: Swift.String? = nil,
            clusterRevisionNumber: Swift.String? = nil,
            clusterSecurityGroups: [SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup]? = nil,
            clusterSnapshotCopyStatus: SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus? = nil,
            clusterStatus: Swift.String? = nil,
            clusterSubnetGroupName: Swift.String? = nil,
            clusterVersion: Swift.String? = nil,
            dbName: Swift.String? = nil,
            deferredMaintenanceWindows: [SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow]? = nil,
            elasticIpStatus: SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus? = nil,
            elasticResizeNumberOfNodeOptions: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            endpoint: SecurityHubClientTypes.AwsRedshiftClusterEndpoint? = nil,
            enhancedVpcRouting: Swift.Bool? = nil,
            expectedNextSnapshotScheduleTime: Swift.String? = nil,
            expectedNextSnapshotScheduleTimeStatus: Swift.String? = nil,
            hsmStatus: SecurityHubClientTypes.AwsRedshiftClusterHsmStatus? = nil,
            iamRoles: [SecurityHubClientTypes.AwsRedshiftClusterIamRole]? = nil,
            kmsKeyId: Swift.String? = nil,
            loggingStatus: SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus? = nil,
            maintenanceTrackName: Swift.String? = nil,
            manualSnapshotRetentionPeriod: Swift.Int? = nil,
            masterUsername: Swift.String? = nil,
            nextMaintenanceWindowStartTime: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numberOfNodes: Swift.Int? = nil,
            pendingActions: [Swift.String]? = nil,
            pendingModifiedValues: SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            publiclyAccessible: Swift.Bool? = nil,
            resizeInfo: SecurityHubClientTypes.AwsRedshiftClusterResizeInfo? = nil,
            restoreStatus: SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus? = nil,
            snapshotScheduleIdentifier: Swift.String? = nil,
            snapshotScheduleState: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            vpcSecurityGroups: [SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup]? = nil
        )
        {
            self.allowVersionUpgrade = allowVersionUpgrade
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.availabilityZone = availabilityZone
            self.clusterAvailabilityStatus = clusterAvailabilityStatus
            self.clusterCreateTime = clusterCreateTime
            self.clusterIdentifier = clusterIdentifier
            self.clusterNodes = clusterNodes
            self.clusterParameterGroups = clusterParameterGroups
            self.clusterPublicKey = clusterPublicKey
            self.clusterRevisionNumber = clusterRevisionNumber
            self.clusterSecurityGroups = clusterSecurityGroups
            self.clusterSnapshotCopyStatus = clusterSnapshotCopyStatus
            self.clusterStatus = clusterStatus
            self.clusterSubnetGroupName = clusterSubnetGroupName
            self.clusterVersion = clusterVersion
            self.dbName = dbName
            self.deferredMaintenanceWindows = deferredMaintenanceWindows
            self.elasticIpStatus = elasticIpStatus
            self.elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions
            self.encrypted = encrypted
            self.endpoint = endpoint
            self.enhancedVpcRouting = enhancedVpcRouting
            self.expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime
            self.expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus
            self.hsmStatus = hsmStatus
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.loggingStatus = loggingStatus
            self.maintenanceTrackName = maintenanceTrackName
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.masterUsername = masterUsername
            self.nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.pendingActions = pendingActions
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.resizeInfo = resizeInfo
            self.restoreStatus = restoreStatus
            self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
            self.snapshotScheduleState = snapshotScheduleState
            self.vpcId = vpcId
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that contains an optional comment about your Amazon Route 53 hosted zone.
    public struct AwsRoute53HostedZoneConfigDetails {
        /// Any comments that you include about the hosted zone.
        public var comment: Swift.String?

        public init(
            comment: Swift.String? = nil
        )
        {
            self.comment = comment
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that contains information about an Amazon Route 53 hosted zone.
    public struct AwsRoute53HostedZoneObjectDetails {
        /// An object that includes the Comment element.
        public var config: SecurityHubClientTypes.AwsRoute53HostedZoneConfigDetails?
        /// The ID that Route 53 assigns to the hosted zone when you create it.
        public var id: Swift.String?
        /// The name of the domain. For public hosted zones, this is the name that you have registered with your DNS registrar.
        public var name: Swift.String?

        public init(
            config: SecurityHubClientTypes.AwsRoute53HostedZoneConfigDetails? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.config = config
            self.id = id
            self.name = name
        }
    }

}

extension SecurityHubClientTypes {
    /// The Amazon Resource Name (ARN) and other details of the Amazon CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
    public struct CloudWatchLogsLogGroupArnConfigDetails {
        /// The ARN of the CloudWatch Logs log group that Route 53 is publishing logs to.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// The ID of the hosted zone that CloudWatch Logs is logging queries for.
        public var hostedZoneId: Swift.String?
        /// The ID for a DNS query logging configuration.
        public var id: Swift.String?

        public init(
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.hostedZoneId = hostedZoneId
            self.id = id
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about a specified Amazon Route 53 configuration for DNS query logging.
    public struct AwsRoute53QueryLoggingConfigDetails {
        /// The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group that Route 53 is publishing logs to.
        public var cloudWatchLogsLogGroupArn: SecurityHubClientTypes.CloudWatchLogsLogGroupArnConfigDetails?

        public init(
            cloudWatchLogsLogGroupArn: SecurityHubClientTypes.CloudWatchLogsLogGroupArnConfigDetails? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        }
    }

}

extension SecurityHubClientTypes {
    /// For private hosted zones, this is a complex type that contains information about an Amazon VPC.
    public struct AwsRoute53HostedZoneVpcDetails {
        /// The identifier of an Amazon VPC.
        public var id: Swift.String?
        /// The Amazon Web Services Region that an Amazon VPC was created in.
        public var region: Swift.String?

        public init(
            id: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.id = id
            self.region = region
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about a specified Amazon Route 53 hosted zone, including the four name servers assigned to the hosted zone. A hosted zone represents a collection of records that can be managed together, belonging to a single parent domain name.
    public struct AwsRoute53HostedZoneDetails {
        /// An object that contains information about the specified hosted zone.
        public var hostedZone: SecurityHubClientTypes.AwsRoute53HostedZoneObjectDetails?
        /// An object that contains a list of the authoritative name servers for a hosted zone or for a reusable delegation set.
        public var nameServers: [Swift.String]?
        /// An array that contains one QueryLoggingConfig element for each DNS query logging configuration that is associated with the current Amazon Web Services account.
        public var queryLoggingConfig: SecurityHubClientTypes.AwsRoute53QueryLoggingConfigDetails?
        /// An object that contains information about the Amazon Virtual Private Clouds (Amazon VPCs) that are associated with the specified hosted zone.
        public var vpcs: [SecurityHubClientTypes.AwsRoute53HostedZoneVpcDetails]?

        public init(
            hostedZone: SecurityHubClientTypes.AwsRoute53HostedZoneObjectDetails? = nil,
            nameServers: [Swift.String]? = nil,
            queryLoggingConfig: SecurityHubClientTypes.AwsRoute53QueryLoggingConfigDetails? = nil,
            vpcs: [SecurityHubClientTypes.AwsRoute53HostedZoneVpcDetails]? = nil
        )
        {
            self.hostedZone = hostedZone
            self.nameServers = nameServers
            self.queryLoggingConfig = queryLoggingConfig
            self.vpcs = vpcs
        }
    }

}

extension SecurityHubClientTypes {
    /// provides information about the Amazon S3 Public Access Block configuration for accounts.
    public struct AwsS3AccountPublicAccessBlockDetails {
        /// Indicates whether to reject calls to update an S3 bucket if the calls include a public access control list (ACL).
        public var blockPublicAcls: Swift.Bool?
        /// Indicates whether to reject calls to update the access policy for an S3 bucket or access point if the policy allows public access.
        public var blockPublicPolicy: Swift.Bool?
        /// Indicates whether Amazon S3 ignores public ACLs that are associated with an S3 bucket.
        public var ignorePublicAcls: Swift.Bool?
        /// Indicates whether to restrict access to an access point or S3 bucket that has a public policy to only Amazon Web Services service principals and authorized users within the S3 bucket owner's account.
        public var restrictPublicBuckets: Swift.Bool?

        public init(
            blockPublicAcls: Swift.Bool? = nil,
            blockPublicPolicy: Swift.Bool? = nil,
            ignorePublicAcls: Swift.Bool? = nil,
            restrictPublicBuckets: Swift.Bool? = nil
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension SecurityHubClientTypes {
    /// The virtual private cloud (VPC) configuration for an Amazon S3 access point.
    public struct AwsS3AccessPointVpcConfigurationDetails {
        /// If this field is specified, this access point will only allow connections from the specified VPC ID.
        public var vpcId: Swift.String?

        public init(
            vpcId: Swift.String? = nil
        )
        {
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes {
    /// Returns configuration information about the specified Amazon S3 access point. S3 access points are named network endpoints that are attached to buckets that you can use to perform S3 object operations.
    public struct AwsS3AccessPointDetails {
        /// The Amazon Resource Name (ARN) of the access point.
        public var accessPointArn: Swift.String?
        /// The name or alias of the access point.
        public var alias: Swift.String?
        /// The name of the S3 bucket associated with the specified access point.
        public var bucket: Swift.String?
        /// The Amazon Web Services account ID associated with the S3 bucket associated with this access point.
        public var bucketAccountId: Swift.String?
        /// The name of the specified access point.
        public var name: Swift.String?
        /// Indicates whether this access point allows access from the public internet.
        public var networkOrigin: Swift.String?
        /// provides information about the Amazon S3 Public Access Block configuration for accounts.
        public var publicAccessBlockConfiguration: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails?
        /// Contains the virtual private cloud (VPC) configuration for the specified access point.
        public var vpcConfiguration: SecurityHubClientTypes.AwsS3AccessPointVpcConfigurationDetails?

        public init(
            accessPointArn: Swift.String? = nil,
            alias: Swift.String? = nil,
            bucket: Swift.String? = nil,
            bucketAccountId: Swift.String? = nil,
            name: Swift.String? = nil,
            networkOrigin: Swift.String? = nil,
            publicAccessBlockConfiguration: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails? = nil,
            vpcConfiguration: SecurityHubClientTypes.AwsS3AccessPointVpcConfigurationDetails? = nil
        )
        {
            self.accessPointArn = accessPointArn
            self.alias = alias
            self.bucket = bucket
            self.bucketAccountId = bucketAccountId
            self.name = name
            self.networkOrigin = networkOrigin
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.vpcConfiguration = vpcConfiguration
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about what Amazon S3 does when a multipart upload is incomplete.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails {
        /// The number of days after which Amazon S3 cancels an incomplete multipart upload.
        public var daysAfterInitiation: Swift.Int?

        public init(
            daysAfterInitiation: Swift.Int? = nil
        )
        {
            self.daysAfterInitiation = daysAfterInitiation
        }
    }

}

extension SecurityHubClientTypes {
    /// A tag that is assigned to matching objects.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails {
        /// The tag key.
        public var key: Swift.String?
        /// The tag value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// A value to use for the filter.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails {
        /// Prefix text for matching objects.
        public var `prefix`: Swift.String?
        /// A tag that is assigned to matching objects.
        public var tag: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails?
        /// The type of filter value. Valid values are LifecyclePrefixPredicate or LifecycleTagPredicate.
        public var type: Swift.String?

        public init(
            `prefix`: Swift.String? = nil,
            tag: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails? = nil,
            type: Swift.String? = nil
        )
        {
            self.`prefix` = `prefix`
            self.tag = tag
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// A tag filter.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails {
        /// The tag key.
        public var key: Swift.String?
        /// The tag value
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// The configuration for the filter.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails {
        /// The values to use for the filter.
        public var operands: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]?
        /// A prefix filter.
        public var `prefix`: Swift.String?
        /// A tag filter.
        public var tag: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails?
        /// Whether to use AND or OR to join the operands. Valid values are LifecycleAndOperator or LifecycleOrOperator.
        public var type: Swift.String?

        public init(
            operands: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]? = nil,
            `prefix`: Swift.String? = nil,
            tag: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails? = nil,
            type: Swift.String? = nil
        )
        {
            self.operands = operands
            self.`prefix` = `prefix`
            self.tag = tag
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Identifies the objects that a rule applies to.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {
        /// The configuration for the filter.
        public var predicate: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails?

        public init(
            predicate: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails? = nil
        )
        {
            self.predicate = predicate
        }
    }

}

extension SecurityHubClientTypes {
    /// A transition rule that describes when noncurrent objects transition to a specified storage class.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails {
        /// The number of days that an object is noncurrent before Amazon S3 can perform the associated action.
        public var days: Swift.Int?
        /// The class of storage to change the object to after the object is noncurrent for the specified number of days.
        public var storageClass: Swift.String?

        public init(
            days: Swift.Int? = nil,
            storageClass: Swift.String? = nil
        )
        {
            self.days = days
            self.storageClass = storageClass
        }
    }

}

extension SecurityHubClientTypes {
    /// A rule for when objects transition to specific storage classes.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {
        /// A date on which to transition objects to the specified storage class. If you provide Date, you cannot provide Days. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var date: Swift.String?
        /// The number of days after which to transition the object to the specified storage class. If you provide Days, you cannot provide Date.
        public var days: Swift.Int?
        /// The storage class to transition the object to. Valid values are as follows:
        ///
        /// * DEEP_ARCHIVE
        ///
        /// * GLACIER
        ///
        /// * INTELLIGENT_TIERING
        ///
        /// * ONEZONE_IA
        ///
        /// * STANDARD_IA
        public var storageClass: Swift.String?

        public init(
            date: Swift.String? = nil,
            days: Swift.Int? = nil,
            storageClass: Swift.String? = nil
        )
        {
            self.date = date
            self.days = days
            self.storageClass = storageClass
        }
    }

}

extension SecurityHubClientTypes {
    /// Configuration for a lifecycle rule.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesDetails {
        /// How Amazon S3 responds when a multipart upload is incomplete. Specifically, provides a number of days before Amazon S3 cancels the entire upload.
        public var abortIncompleteMultipartUpload: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails?
        /// The date when objects are moved or deleted. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var expirationDate: Swift.String?
        /// The length in days of the lifetime for objects that are subject to the rule.
        public var expirationInDays: Swift.Int?
        /// Whether Amazon S3 removes a delete marker that has no noncurrent versions. If set to true, the delete marker is expired. If set to false, the policy takes no action. If you provide ExpiredObjectDeleteMarker, you cannot provide ExpirationInDays or ExpirationDate.
        public var expiredObjectDeleteMarker: Swift.Bool?
        /// Identifies the objects that a rule applies to.
        public var filter: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails?
        /// The unique identifier of the rule.
        public var id: Swift.String?
        /// The number of days that an object is noncurrent before Amazon S3 can perform the associated action.
        public var noncurrentVersionExpirationInDays: Swift.Int?
        /// Transition rules that describe when noncurrent objects transition to a specified storage class.
        public var noncurrentVersionTransitions: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]?
        /// A prefix that identifies one or more objects that the rule applies to.
        public var `prefix`: Swift.String?
        /// The current status of the rule. Indicates whether the rule is currently being applied.
        public var status: Swift.String?
        /// Transition rules that indicate when objects transition to a specified storage class.
        public var transitions: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]?

        public init(
            abortIncompleteMultipartUpload: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails? = nil,
            expirationDate: Swift.String? = nil,
            expirationInDays: Swift.Int? = nil,
            expiredObjectDeleteMarker: Swift.Bool? = nil,
            filter: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails? = nil,
            id: Swift.String? = nil,
            noncurrentVersionExpirationInDays: Swift.Int? = nil,
            noncurrentVersionTransitions: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]? = nil,
            `prefix`: Swift.String? = nil,
            status: Swift.String? = nil,
            transitions: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]? = nil
        )
        {
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.expirationDate = expirationDate
            self.expirationInDays = expirationInDays
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
            self.filter = filter
            self.id = id
            self.noncurrentVersionExpirationInDays = noncurrentVersionExpirationInDays
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
            self.`prefix` = `prefix`
            self.status = status
            self.transitions = transitions
        }
    }

}

extension SecurityHubClientTypes {
    /// The lifecycle configuration for the objects in the S3 bucket.
    public struct AwsS3BucketBucketLifecycleConfigurationDetails {
        /// The lifecycle rules.
        public var rules: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails]?

        public init(
            rules: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes the versioning state of an S3 bucket.
    public struct AwsS3BucketBucketVersioningConfiguration {
        /// Specifies whether MFA delete is currently enabled in the S3 bucket versioning configuration. If the S3 bucket was never configured with MFA delete, then this attribute is not included.
        public var isMfaDeleteEnabled: Swift.Bool?
        /// The versioning status of the S3 bucket. Valid values are Enabled or Suspended.
        public var status: Swift.String?

        public init(
            isMfaDeleteEnabled: Swift.Bool? = nil,
            status: Swift.String? = nil
        )
        {
            self.isMfaDeleteEnabled = isMfaDeleteEnabled
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about logging for the S3 bucket
    public struct AwsS3BucketLoggingConfiguration {
        /// The name of the S3 bucket where log files for the S3 bucket are stored.
        public var destinationBucketName: Swift.String?
        /// The prefix added to log files for the S3 bucket.
        public var logFilePrefix: Swift.String?

        public init(
            destinationBucketName: Swift.String? = nil,
            logFilePrefix: Swift.String? = nil
        )
        {
            self.destinationBucketName = destinationBucketName
            self.logFilePrefix = logFilePrefix
        }
    }

}

extension SecurityHubClientTypes {

    public enum AwsS3BucketNotificationConfigurationS3KeyFilterRuleName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `prefix`
        case suffix
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsS3BucketNotificationConfigurationS3KeyFilterRuleName] {
            return [
                .prefix,
                .suffix
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .prefix: return "Prefix"
            case .suffix: return "Suffix"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Details for a filter rule.
    public struct AwsS3BucketNotificationConfigurationS3KeyFilterRule {
        /// Indicates whether the filter is based on the prefix or suffix of the Amazon S3 key.
        public var name: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRuleName?
        /// The filter value.
        public var value: Swift.String?

        public init(
            name: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRuleName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Details for an Amazon S3 filter.
    public struct AwsS3BucketNotificationConfigurationS3KeyFilter {
        /// The filter rules for the filter.
        public var filterRules: [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule]?

        public init(
            filterRules: [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule]? = nil
        )
        {
            self.filterRules = filterRules
        }
    }

}

extension SecurityHubClientTypes {
    /// Filtering information for the notifications. The filtering is based on Amazon S3 key names.
    public struct AwsS3BucketNotificationConfigurationFilter {
        /// Details for an Amazon S3 filter.
        public var s3KeyFilter: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter?

        public init(
            s3KeyFilter: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter? = nil
        )
        {
            self.s3KeyFilter = s3KeyFilter
        }
    }

}

extension SecurityHubClientTypes {
    /// Details for an S3 bucket notification configuration.
    public struct AwsS3BucketNotificationConfigurationDetail {
        /// The ARN of the Lambda function, Amazon SQS queue, or Amazon SNS topic that generates the notification.
        public var destination: Swift.String?
        /// The list of events that trigger a notification.
        public var events: [Swift.String]?
        /// The filters that determine which S3 buckets generate notifications.
        public var filter: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter?
        /// Indicates the type of notification. Notifications can be generated using Lambda functions, Amazon SQS queues, or Amazon SNS topics, with corresponding valid values as follows:
        ///
        /// * LambdaConfiguration
        ///
        /// * QueueConfiguration
        ///
        /// * TopicConfiguration
        public var type: Swift.String?

        public init(
            destination: Swift.String? = nil,
            events: [Swift.String]? = nil,
            filter: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter? = nil,
            type: Swift.String? = nil
        )
        {
            self.destination = destination
            self.events = events
            self.filter = filter
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// The notification configuration for the S3 bucket.
    public struct AwsS3BucketNotificationConfiguration {
        /// Configurations for S3 bucket notifications.
        public var configurations: [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail]?

        public init(
            configurations: [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail]? = nil
        )
        {
            self.configurations = configurations
        }
    }

}

extension SecurityHubClientTypes {
    /// The redirect behavior for requests to the website.
    public struct AwsS3BucketWebsiteConfigurationRedirectTo {
        /// The name of the host to redirect requests to.
        public var hostname: Swift.String?
        /// The protocol to use when redirecting requests. By default, this field uses the same protocol as the original request. Valid values are http or https.
        public var `protocol`: Swift.String?

        public init(
            hostname: Swift.String? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.`protocol` = `protocol`
        }
    }

}

extension SecurityHubClientTypes {
    /// The condition that must be met in order to apply the routing rule.
    public struct AwsS3BucketWebsiteConfigurationRoutingRuleCondition {
        /// Indicates to redirect the request if the HTTP error code matches this value.
        public var httpErrorCodeReturnedEquals: Swift.String?
        /// Indicates to redirect the request if the key prefix matches this value.
        public var keyPrefixEquals: Swift.String?

        public init(
            httpErrorCodeReturnedEquals: Swift.String? = nil,
            keyPrefixEquals: Swift.String? = nil
        )
        {
            self.httpErrorCodeReturnedEquals = httpErrorCodeReturnedEquals
            self.keyPrefixEquals = keyPrefixEquals
        }
    }

}

extension SecurityHubClientTypes {
    /// The rules to redirect the request if the condition in Condition is met.
    public struct AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {
        /// The host name to use in the redirect request.
        public var hostname: Swift.String?
        /// The HTTP redirect code to use in the response.
        public var httpRedirectCode: Swift.String?
        /// The protocol to use to redirect the request. By default, uses the protocol from the original request.
        public var `protocol`: Swift.String?
        /// The object key prefix to use in the redirect request. Cannot be provided if ReplaceKeyWith is present.
        public var replaceKeyPrefixWith: Swift.String?
        /// The specific object key to use in the redirect request. Cannot be provided if ReplaceKeyPrefixWith is present.
        public var replaceKeyWith: Swift.String?

        public init(
            hostname: Swift.String? = nil,
            httpRedirectCode: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            replaceKeyPrefixWith: Swift.String? = nil,
            replaceKeyWith: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.httpRedirectCode = httpRedirectCode
            self.`protocol` = `protocol`
            self.replaceKeyPrefixWith = replaceKeyPrefixWith
            self.replaceKeyWith = replaceKeyWith
        }
    }

}

extension SecurityHubClientTypes {
    /// A rule for redirecting requests to the website.
    public struct AwsS3BucketWebsiteConfigurationRoutingRule {
        /// Provides the condition that must be met in order to apply the routing rule.
        public var condition: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition?
        /// Provides the rules to redirect the request if the condition in Condition is met.
        public var redirect: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect?

        public init(
            condition: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition? = nil,
            redirect: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect? = nil
        )
        {
            self.condition = condition
            self.redirect = redirect
        }
    }

}

extension SecurityHubClientTypes {
    /// Website parameters for the S3 bucket.
    public struct AwsS3BucketWebsiteConfiguration {
        /// The name of the error document for the website.
        public var errorDocument: Swift.String?
        /// The name of the index document for the website.
        public var indexDocumentSuffix: Swift.String?
        /// The redirect behavior for requests to the website.
        public var redirectAllRequestsTo: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo?
        /// The rules for applying redirects for requests to the website.
        public var routingRules: [SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule]?

        public init(
            errorDocument: Swift.String? = nil,
            indexDocumentSuffix: Swift.String? = nil,
            redirectAllRequestsTo: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo? = nil,
            routingRules: [SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule]? = nil
        )
        {
            self.errorDocument = errorDocument
            self.indexDocumentSuffix = indexDocumentSuffix
            self.redirectAllRequestsTo = redirectAllRequestsTo
            self.routingRules = routingRules
        }
    }

}

extension SecurityHubClientTypes {
    /// The default S3 Object Lock retention mode and period that you want to apply to new objects placed in the specified Amazon S3 bucket.
    public struct AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails {
        /// The number of days that you want to specify for the default retention period.
        public var days: Swift.Int?
        /// The default Object Lock retention mode you want to apply to new objects placed in the specified bucket.
        public var mode: Swift.String?
        /// The number of years that you want to specify for the default retention period.
        public var years: Swift.Int?

        public init(
            days: Swift.Int? = nil,
            mode: Swift.String? = nil,
            years: Swift.Int? = nil
        )
        {
            self.days = days
            self.mode = mode
            self.years = years
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the S3 Object Lock rule for the specified object. In Amazon S3, Object Lock can help prevent objects from being deleted or overwritten for a fixed amount of time or indefinitely.
    public struct AwsS3BucketObjectLockConfigurationRuleDetails {
        /// The default Object Lock retention mode and period that you want to apply to new objects placed in the specified bucket.
        public var defaultRetention: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails?

        public init(
            defaultRetention: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails? = nil
        )
        {
            self.defaultRetention = defaultRetention
        }
    }

}

extension SecurityHubClientTypes {
    /// The container element for S3 Object Lock configuration parameters. In Amazon S3, Object Lock can help prevent objects from being deleted or overwritten for a fixed amount of time or indefinitely.
    public struct AwsS3BucketObjectLockConfiguration {
        /// Indicates whether the bucket has an Object Lock configuration enabled.
        public var objectLockEnabled: Swift.String?
        /// Specifies the Object Lock rule for the specified object.
        public var rule: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDetails?

        public init(
            objectLockEnabled: Swift.String? = nil,
            rule: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDetails? = nil
        )
        {
            self.objectLockEnabled = objectLockEnabled
            self.rule = rule
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the default server-side encryption to apply to new objects in the bucket.
    public struct AwsS3BucketServerSideEncryptionByDefault {
        /// KMS key ID to use for the default encryption.
        public var kmsMasterKeyID: Swift.String?
        /// Server-side encryption algorithm to use for the default encryption. Valid values are aws: kms or AES256.
        public var sseAlgorithm: Swift.String?

        public init(
            kmsMasterKeyID: Swift.String? = nil,
            sseAlgorithm: Swift.String? = nil
        )
        {
            self.kmsMasterKeyID = kmsMasterKeyID
            self.sseAlgorithm = sseAlgorithm
        }
    }

}

extension SecurityHubClientTypes {
    /// An encryption rule to apply to the S3 bucket.
    public struct AwsS3BucketServerSideEncryptionRule {
        /// Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT object request doesn't specify any server-side encryption, this default encryption is applied.
        public var applyServerSideEncryptionByDefault: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault?

        public init(
            applyServerSideEncryptionByDefault: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault? = nil
        )
        {
            self.applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault
        }
    }

}

extension SecurityHubClientTypes {
    /// The encryption configuration for the S3 bucket.
    public struct AwsS3BucketServerSideEncryptionConfiguration {
        /// The encryption rules that are applied to the S3 bucket.
        public var rules: [SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule]?

        public init(
            rules: [SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension SecurityHubClientTypes {
    /// The details of an Amazon Simple Storage Service (Amazon S3) bucket.
    public struct AwsS3BucketDetails {
        /// The access control list for the S3 bucket.
        public var accessControlList: Swift.String?
        /// The lifecycle configuration for objects in the specified bucket.
        public var bucketLifecycleConfiguration: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails?
        /// The logging configuration for the S3 bucket.
        public var bucketLoggingConfiguration: SecurityHubClientTypes.AwsS3BucketLoggingConfiguration?
        /// The notification configuration for the S3 bucket.
        public var bucketNotificationConfiguration: SecurityHubClientTypes.AwsS3BucketNotificationConfiguration?
        /// The versioning state of an S3 bucket.
        public var bucketVersioningConfiguration: SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration?
        /// The website configuration parameters for the S3 bucket.
        public var bucketWebsiteConfiguration: SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration?
        /// Indicates when the S3 bucket was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdAt: Swift.String?
        /// The name of the bucket.
        public var name: Swift.String?
        /// Specifies which rule Amazon S3 applies by default to every new object placed in the bucket.
        public var objectLockConfiguration: SecurityHubClientTypes.AwsS3BucketObjectLockConfiguration?
        /// The Amazon Web Services account identifier of the account that owns the S3 bucket.
        public var ownerAccountId: Swift.String?
        /// The canonical user ID of the owner of the S3 bucket.
        public var ownerId: Swift.String?
        /// The display name of the owner of the S3 bucket.
        public var ownerName: Swift.String?
        /// Provides information about the Amazon S3 Public Access Block configuration for the S3 bucket.
        public var publicAccessBlockConfiguration: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails?
        /// The encryption rules that are applied to the S3 bucket.
        public var serverSideEncryptionConfiguration: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration?

        public init(
            accessControlList: Swift.String? = nil,
            bucketLifecycleConfiguration: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails? = nil,
            bucketLoggingConfiguration: SecurityHubClientTypes.AwsS3BucketLoggingConfiguration? = nil,
            bucketNotificationConfiguration: SecurityHubClientTypes.AwsS3BucketNotificationConfiguration? = nil,
            bucketVersioningConfiguration: SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration? = nil,
            bucketWebsiteConfiguration: SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration? = nil,
            createdAt: Swift.String? = nil,
            name: Swift.String? = nil,
            objectLockConfiguration: SecurityHubClientTypes.AwsS3BucketObjectLockConfiguration? = nil,
            ownerAccountId: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            ownerName: Swift.String? = nil,
            publicAccessBlockConfiguration: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails? = nil,
            serverSideEncryptionConfiguration: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration? = nil
        )
        {
            self.accessControlList = accessControlList
            self.bucketLifecycleConfiguration = bucketLifecycleConfiguration
            self.bucketLoggingConfiguration = bucketLoggingConfiguration
            self.bucketNotificationConfiguration = bucketNotificationConfiguration
            self.bucketVersioningConfiguration = bucketVersioningConfiguration
            self.bucketWebsiteConfiguration = bucketWebsiteConfiguration
            self.createdAt = createdAt
            self.name = name
            self.objectLockConfiguration = objectLockConfiguration
            self.ownerAccountId = ownerAccountId
            self.ownerId = ownerId
            self.ownerName = ownerName
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an Amazon S3 object.
    public struct AwsS3ObjectDetails {
        /// A standard MIME type describing the format of the object data.
        public var contentType: Swift.String?
        /// The opaque identifier assigned by a web server to a specific version of a resource found at a URL.
        public var eTag: Swift.String?
        /// Indicates when the object was last modified. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastModified: Swift.String?
        /// If the object is stored using server-side encryption, the value of the server-side encryption algorithm used when storing this object in Amazon S3.
        public var serverSideEncryption: Swift.String?
        /// The identifier of the KMS symmetric customer managed key that was used for the object.
        public var ssekmsKeyId: Swift.String?
        /// The version of the object.
        public var versionId: Swift.String?

        public init(
            contentType: Swift.String? = nil,
            eTag: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            serverSideEncryption: Swift.String? = nil,
            ssekmsKeyId: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.eTag = eTag
            self.lastModified = lastModified
            self.serverSideEncryption = serverSideEncryption
            self.ssekmsKeyId = ssekmsKeyId
            self.versionId = versionId
        }
    }

}

extension SecurityHubClientTypes {
    /// Information on the instance metadata service (IMDS) configuration of the notebook instance.
    public struct AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails {
        /// Indicates the minimum IMDS version that the notebook instance supports.
        public var minimumInstanceMetadataServiceVersion: Swift.String?

        public init(
            minimumInstanceMetadataServiceVersion: Swift.String? = nil
        )
        {
            self.minimumInstanceMetadataServiceVersion = minimumInstanceMetadataServiceVersion
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon SageMaker notebook instance.
    public struct AwsSageMakerNotebookInstanceDetails {
        /// A list of Amazon Elastic Inference instance types to associate with the notebook instance. Currently, only one instance type can be associated with a notebook instance.
        public var acceleratorTypes: [Swift.String]?
        /// An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in [CodeCommit](https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html) or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see [Associating Git repositories with SageMaker notebook instances](https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html) in the Amazon SageMaker Developer Guide.
        public var additionalCodeRepositories: [Swift.String]?
        /// The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in [CodeCommit](https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html) or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see [Associating Git repositories with SageMaker notebook instances](https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html) in the Amazon SageMaker Developer Guide.
        public var defaultCodeRepository: Swift.String?
        /// Sets whether SageMaker provides internet access to the notebook instance. If you set this to Disabled, this notebook instance is able to access resources only in your VPC, and is not be able to connect to SageMaker training and endpoint services unless you configure a Network Address Translation (NAT) Gateway in your VPC.
        public var directInternetAccess: Swift.String?
        /// If status of the instance is Failed, the reason it failed.
        public var failureReason: Swift.String?
        /// Information on the IMDS configuration of the notebook instance.
        public var instanceMetadataServiceConfiguration: SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails?
        /// The type of machine learning (ML) compute instance to launch for the notebook instance.
        public var instanceType: Swift.String?
        /// The Amazon Resource Name (ARN) of an Key Management Service (KMS) key that SageMaker uses to encrypt data on the storage volume attached to your notebook instance. The KMS key you provide must be enabled. For information, see [Enabling and disabling keys](https://docs.aws.amazon.com/kms/latest/developerguide/enabling-keys.html) in the Key Management Service Developer Guide.
        public var kmsKeyId: Swift.String?
        /// The network interface ID that SageMaker created when the instance was created.
        public var networkInterfaceId: Swift.String?
        /// The Amazon Resource Name (ARN) of the notebook instance.
        public var notebookInstanceArn: Swift.String?
        /// The name of a notebook instance lifecycle configuration.
        public var notebookInstanceLifecycleConfigName: Swift.String?
        /// The name of the new notebook instance.
        public var notebookInstanceName: Swift.String?
        /// The status of the notebook instance.
        public var notebookInstanceStatus: Swift.String?
        /// The platform identifier of the notebook instance runtime environment.
        public var platformIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role associated with the instance.
        public var roleArn: Swift.String?
        /// Whether root access is enabled or disabled for users of the notebook instance.
        public var rootAccess: Swift.String?
        /// The VPC security group IDs.
        public var securityGroups: [Swift.String]?
        /// The ID of the VPC subnet to which you have a connectivity from your ML compute instance.
        public var subnetId: Swift.String?
        /// The URL that you use to connect to the Jupyter notebook that is running in your notebook instance.
        public var url: Swift.String?
        /// The size, in GB, of the ML storage volume to attach to the notebook instance.
        public var volumeSizeInGB: Swift.Int?

        public init(
            acceleratorTypes: [Swift.String]? = nil,
            additionalCodeRepositories: [Swift.String]? = nil,
            defaultCodeRepository: Swift.String? = nil,
            directInternetAccess: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            instanceMetadataServiceConfiguration: SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails? = nil,
            instanceType: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            notebookInstanceArn: Swift.String? = nil,
            notebookInstanceLifecycleConfigName: Swift.String? = nil,
            notebookInstanceName: Swift.String? = nil,
            notebookInstanceStatus: Swift.String? = nil,
            platformIdentifier: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            rootAccess: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetId: Swift.String? = nil,
            url: Swift.String? = nil,
            volumeSizeInGB: Swift.Int? = nil
        )
        {
            self.acceleratorTypes = acceleratorTypes
            self.additionalCodeRepositories = additionalCodeRepositories
            self.defaultCodeRepository = defaultCodeRepository
            self.directInternetAccess = directInternetAccess
            self.failureReason = failureReason
            self.instanceMetadataServiceConfiguration = instanceMetadataServiceConfiguration
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.networkInterfaceId = networkInterfaceId
            self.notebookInstanceArn = notebookInstanceArn
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.notebookInstanceName = notebookInstanceName
            self.notebookInstanceStatus = notebookInstanceStatus
            self.platformIdentifier = platformIdentifier
            self.roleArn = roleArn
            self.rootAccess = rootAccess
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.url = url
            self.volumeSizeInGB = volumeSizeInGB
        }
    }

}

extension SecurityHubClientTypes {
    /// Defines the rotation schedule for the secret.
    public struct AwsSecretsManagerSecretRotationRules {
        /// The number of days after the previous rotation to rotate the secret.
        public var automaticallyAfterDays: Swift.Int?

        public init(
            automaticallyAfterDays: Swift.Int? = nil
        )
        {
            self.automaticallyAfterDays = automaticallyAfterDays
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an Secrets Manager secret.
    public struct AwsSecretsManagerSecretDetails {
        /// Whether the secret is deleted.
        public var deleted: Swift.Bool?
        /// The user-provided description of the secret.
        public var description: Swift.String?
        /// The ARN, Key ID, or alias of the KMS key used to encrypt the SecretString or SecretBinary values for versions of this secret.
        public var kmsKeyId: Swift.String?
        /// The name of the secret.
        public var name: Swift.String?
        /// Whether rotation is enabled.
        public var rotationEnabled: Swift.Bool?
        /// The ARN of the Lambda function that rotates the secret.
        public var rotationLambdaArn: Swift.String?
        /// Whether the rotation occurred within the specified rotation frequency.
        public var rotationOccurredWithinFrequency: Swift.Bool?
        /// Defines the rotation schedule for the secret.
        public var rotationRules: SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules?

        public init(
            deleted: Swift.Bool? = nil,
            description: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            rotationEnabled: Swift.Bool? = nil,
            rotationLambdaArn: Swift.String? = nil,
            rotationOccurredWithinFrequency: Swift.Bool? = nil,
            rotationRules: SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules? = nil
        )
        {
            self.deleted = deleted
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.rotationEnabled = rotationEnabled
            self.rotationLambdaArn = rotationLambdaArn
            self.rotationOccurredWithinFrequency = rotationOccurredWithinFrequency
            self.rotationRules = rotationRules
        }
    }

}

extension SecurityHubClientTypes {
    /// A parameter that a security control accepts.
    public struct SecurityControlParameter {
        /// The name of a
        public var name: Swift.String?
        /// The current value of a control parameter.
        public var value: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {

    public enum ComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case notAvailable
        case passed
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceStatus] {
            return [
                .failed,
                .notAvailable,
                .passed,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .notAvailable: return "NOT_AVAILABLE"
            case .passed: return "PASSED"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Provides additional context for the value of Compliance.Status.
    public struct StatusReason {
        /// The corresponding description for the status reason code.
        public var description: Swift.String?
        /// A code that represents a reason for the control status. For the list of status reason codes and their meanings, see [Standards-related information in the ASFF](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff) in the Security Hub User Guide.
        /// This member is required.
        public var reasonCode: Swift.String?

        public init(
            description: Swift.String? = nil,
            reasonCode: Swift.String? = nil
        )
        {
            self.description = description
            self.reasonCode = reasonCode
        }
    }

}

extension SecurityHubClientTypes {
    /// This object typically provides details about a control finding, such as applicable standards and the status of control checks. While finding providers can add custom content in Compliance object fields, they are typically used to review details of Security Hub control findings.
    public struct Compliance {
        /// Typically provides an array of enabled security standards in which a security control is currently enabled.
        public var associatedStandards: [SecurityHubClientTypes.AssociatedStandard]?
        /// Typically provides the industry or regulatory framework requirements that are related to a control. The check for that control is aligned with these requirements. Array Members: Maximum number of 32 items.
        public var relatedRequirements: [Swift.String]?
        /// Typically provides the unique identifier of a control across standards. For Security Hub controls, this field consists of an Amazon Web Servicesservice and a unique number, such as APIGateway.5.
        public var securityControlId: Swift.String?
        /// Typically an object that includes security control parameter names and values.
        public var securityControlParameters: [SecurityHubClientTypes.SecurityControlParameter]?
        /// Typically summarizes the result of a control check. For Security Hub controls, valid values for Status are as follows.
        ///
        ///
        /// * PASSED - Standards check passed for all evaluated resources.
        ///
        /// * WARNING - Some information is missing or this check is not supported for your configuration.
        ///
        /// * FAILED - Standards check failed for at least one evaluated resource.
        ///
        /// * NOT_AVAILABLE - Check could not be performed due to a service outage, API error, or because the result of the Config evaluation was NOT_APPLICABLE. If the Config evaluation result was NOT_APPLICABLE for a Security Hub control, Security Hub automatically archives the finding after 3 days.
        public var status: SecurityHubClientTypes.ComplianceStatus?
        /// Typically used to provide a list of reasons for the value of Status.
        public var statusReasons: [SecurityHubClientTypes.StatusReason]?

        public init(
            associatedStandards: [SecurityHubClientTypes.AssociatedStandard]? = nil,
            relatedRequirements: [Swift.String]? = nil,
            securityControlId: Swift.String? = nil,
            securityControlParameters: [SecurityHubClientTypes.SecurityControlParameter]? = nil,
            status: SecurityHubClientTypes.ComplianceStatus? = nil,
            statusReasons: [SecurityHubClientTypes.StatusReason]? = nil
        )
        {
            self.associatedStandards = associatedStandards
            self.relatedRequirements = relatedRequirements
            self.securityControlId = securityControlId
            self.securityControlParameters = securityControlParameters
            self.status = status
            self.statusReasons = statusReasons
        }
    }

}

extension SecurityHubClientTypes {
    /// The severity assigned to a finding by the finding provider. This object may include one or more of the following attributes:
    ///
    /// * Label
    ///
    /// * Normalized
    ///
    /// * Original
    ///
    /// * Product
    ///
    ///
    /// If a [BatchImportFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchImportFindings.html) request for a new finding only provides Label or only provides Normalized, Security Hub automatically populates the value of the other field. The Normalized and Product attributes are included in the FindingProviderSeverity structure to preserve the historical information associated with the finding, even if the top-level Severity object is later modified using the [BatchUpdateFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateFindings.html) operation. If the top-level Finding.Severity object is present, but Finding.FindingProviderFields isn't present, Security Hub creates the FindingProviderFields.Severity object and copies the entire Finding.Severity object into it. This ensures that the original, provider-supplied details are retained within the FindingProviderFields.Severity object, even if the top-level Severity object is overwritten.
    public struct FindingProviderSeverity {
        /// The severity label assigned to the finding by the finding provider.
        public var label: SecurityHubClientTypes.SeverityLabel?
        /// The finding provider's original value for the severity. Length Constraints: Minimum length of 1. Maximum length of 64.
        public var original: Swift.String?

        public init(
            label: SecurityHubClientTypes.SeverityLabel? = nil,
            original: Swift.String? = nil
        )
        {
            self.label = label
            self.original = original
        }
    }

}

extension SecurityHubClientTypes {
    /// In a [BatchImportFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchImportFindings.html) request, finding providers use FindingProviderFields to provide and update values for the following fields:
    ///
    /// * Confidence
    ///
    /// * Criticality
    ///
    /// * RelatedFindings
    ///
    /// * Severity
    ///
    /// * Types
    ///
    ///
    /// The preceding fields are nested under the FindingProviderFields object, but also have analogues of the same name as top-level ASFF fields. When a new finding is sent to Security Hub by a finding provider, Security Hub populates the FindingProviderFields object automatically, if it is empty, based on the corresponding top-level fields. Finding providers can update FindingProviderFields only by using the BatchImportFindings operation. Finding providers can't update this object with the [BatchUpdateFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateFindings.html) operation. Customers can update the top-level fields by using the BatchUpdateFindings operation. Customers can't update FindingProviderFields. For information about how Security Hub handles updates from BatchImportFindings to FindingProviderFields and to the corresponding top-level attributes, see [Using ]FindingProviderFields(https://docs.aws.amazon.com/securityhub/latest/userguide/finding-update-batchimportfindings.html#batchimportfindings-findingproviderfields) in the Security Hub User Guide.
    public struct FindingProviderFields {
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public var confidence: Swift.Int?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public var criticality: Swift.Int?
        /// A list of findings that are related to the current finding.
        public var relatedFindings: [SecurityHubClientTypes.RelatedFinding]?
        /// The severity of a finding.
        public var severity: SecurityHubClientTypes.FindingProviderSeverity?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public var types: [Swift.String]?

        public init(
            confidence: Swift.Int? = nil,
            criticality: Swift.Int? = nil,
            relatedFindings: [SecurityHubClientTypes.RelatedFinding]? = nil,
            severity: SecurityHubClientTypes.FindingProviderSeverity? = nil,
            types: [Swift.String]? = nil
        )
        {
            self.confidence = confidence
            self.criticality = criticality
            self.relatedFindings = relatedFindings
            self.severity = severity
            self.types = types
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides metadata for the Amazon CodeGuru detector associated with a finding. This field pertains to findings that relate to Lambda functions. Amazon Inspector identifies policy violations and vulnerabilities in Lambda function code based on internal detectors developed in collaboration with Amazon CodeGuru. Security Hub receives those findings.
    public struct GeneratorDetails {
        /// The description of the detector used to identify the code vulnerability.
        public var description: Swift.String?
        /// An array of tags used to identify the detector associated with the finding. Array Members: Minimum number of 0 items. Maximum number of 10 items.
        public var labels: [Swift.String]?
        /// The name of the detector used to identify the code vulnerability.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.labels = labels
            self.name = name
        }
    }

}

extension SecurityHubClientTypes {

    public enum MalwareState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case observed
        case removalFailed
        case removed
        case sdkUnknown(Swift.String)

        public static var allCases: [MalwareState] {
            return [
                .observed,
                .removalFailed,
                .removed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .observed: return "OBSERVED"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removed: return "REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum MalwareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case adware
        case blendedThreat
        case botnetAgent
        case coinMiner
        case exploitKit
        case keylogger
        case macro
        case potentiallyUnwanted
        case ransomware
        case remoteAccess
        case rootkit
        case spyware
        case trojan
        case virus
        case worm
        case sdkUnknown(Swift.String)

        public static var allCases: [MalwareType] {
            return [
                .adware,
                .blendedThreat,
                .botnetAgent,
                .coinMiner,
                .exploitKit,
                .keylogger,
                .macro,
                .potentiallyUnwanted,
                .ransomware,
                .remoteAccess,
                .rootkit,
                .spyware,
                .trojan,
                .virus,
                .worm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .adware: return "ADWARE"
            case .blendedThreat: return "BLENDED_THREAT"
            case .botnetAgent: return "BOTNET_AGENT"
            case .coinMiner: return "COIN_MINER"
            case .exploitKit: return "EXPLOIT_KIT"
            case .keylogger: return "KEYLOGGER"
            case .macro: return "MACRO"
            case .potentiallyUnwanted: return "POTENTIALLY_UNWANTED"
            case .ransomware: return "RANSOMWARE"
            case .remoteAccess: return "REMOTE_ACCESS"
            case .rootkit: return "ROOTKIT"
            case .spyware: return "SPYWARE"
            case .trojan: return "TROJAN"
            case .virus: return "VIRUS"
            case .worm: return "WORM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A list of malware related to a finding.
    public struct Malware {
        /// The name of the malware that was observed. Length Constraints: Minimum of 1. Maximum of 64.
        /// This member is required.
        public var name: Swift.String?
        /// The file system path of the malware that was observed. Length Constraints: Minimum of 1. Maximum of 512.
        public var path: Swift.String?
        /// The state of the malware that was observed.
        public var state: SecurityHubClientTypes.MalwareState?
        /// The type of the malware that was observed.
        public var type: SecurityHubClientTypes.MalwareType?

        public init(
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            state: SecurityHubClientTypes.MalwareState? = nil,
            type: SecurityHubClientTypes.MalwareType? = nil
        )
        {
            self.name = name
            self.path = path
            self.state = state
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {

    public enum NetworkDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `in`
        case out
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkDirection] {
            return [
                .in,
                .out
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .in: return "IN"
            case .out: return "OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A range of ports.
    public struct PortRange {
        /// The first port in the port range.
        public var begin: Swift.Int?
        /// The last port in the port range.
        public var end: Swift.Int?

        public init(
            begin: Swift.Int? = nil,
            end: Swift.Int? = nil
        )
        {
            self.begin = begin
            self.end = end
        }
    }

}

extension SecurityHubClientTypes {
    /// The details of network-related information about a finding.
    public struct Network {
        /// The destination domain of network-related information about a finding. Length Constraints: Minimum of 1. Maximum of 128.
        public var destinationDomain: Swift.String?
        /// The destination IPv4 address of network-related information about a finding.
        public var destinationIpV4: Swift.String?
        /// The destination IPv6 address of network-related information about a finding.
        public var destinationIpV6: Swift.String?
        /// The destination port of network-related information about a finding.
        public var destinationPort: Swift.Int?
        /// The direction of network traffic associated with a finding.
        public var direction: SecurityHubClientTypes.NetworkDirection?
        /// The range of open ports that is present on the network.
        public var openPortRange: SecurityHubClientTypes.PortRange?
        /// The protocol of network-related information about a finding. Length Constraints: Minimum of 1. Maximum of 16.
        public var `protocol`: Swift.String?
        /// The source domain of network-related information about a finding. Length Constraints: Minimum of 1. Maximum of 128.
        public var sourceDomain: Swift.String?
        /// The source IPv4 address of network-related information about a finding.
        public var sourceIpV4: Swift.String?
        /// The source IPv6 address of network-related information about a finding.
        public var sourceIpV6: Swift.String?
        /// The source media access control (MAC) address of network-related information about a finding.
        public var sourceMac: Swift.String?
        /// The source port of network-related information about a finding.
        public var sourcePort: Swift.Int?

        public init(
            destinationDomain: Swift.String? = nil,
            destinationIpV4: Swift.String? = nil,
            destinationIpV6: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            direction: SecurityHubClientTypes.NetworkDirection? = nil,
            openPortRange: SecurityHubClientTypes.PortRange? = nil,
            `protocol`: Swift.String? = nil,
            sourceDomain: Swift.String? = nil,
            sourceIpV4: Swift.String? = nil,
            sourceIpV6: Swift.String? = nil,
            sourceMac: Swift.String? = nil,
            sourcePort: Swift.Int? = nil
        )
        {
            self.destinationDomain = destinationDomain
            self.destinationIpV4 = destinationIpV4
            self.destinationIpV6 = destinationIpV6
            self.destinationPort = destinationPort
            self.direction = direction
            self.openPortRange = openPortRange
            self.`protocol` = `protocol`
            self.sourceDomain = sourceDomain
            self.sourceIpV4 = sourceIpV4
            self.sourceIpV6 = sourceIpV6
            self.sourceMac = sourceMac
            self.sourcePort = sourcePort
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the destination of the next component in the network path.
    public struct NetworkPathComponentDetails {
        /// The IP addresses of the destination.
        public var address: [Swift.String]?
        /// A list of port ranges for the destination.
        public var portRanges: [SecurityHubClientTypes.PortRange]?

        public init(
            address: [Swift.String]? = nil,
            portRanges: [SecurityHubClientTypes.PortRange]? = nil
        )
        {
            self.address = address
            self.portRanges = portRanges
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about a network path component that occurs before or after the current component.
    public struct NetworkHeader {
        /// Information about the destination of the component.
        public var destination: SecurityHubClientTypes.NetworkPathComponentDetails?
        /// The protocol used for the component. Length Constraints: Minimum of 1. Maximum of 16.
        public var `protocol`: Swift.String?
        /// Information about the origin of the component.
        public var source: SecurityHubClientTypes.NetworkPathComponentDetails?

        public init(
            destination: SecurityHubClientTypes.NetworkPathComponentDetails? = nil,
            `protocol`: Swift.String? = nil,
            source: SecurityHubClientTypes.NetworkPathComponentDetails? = nil
        )
        {
            self.destination = destination
            self.`protocol` = `protocol`
            self.source = source
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a network path component.
    public struct NetworkPathComponent {
        /// The identifier of a component in the network path. Length Constraints: Minimum of 1. Maximum of 32.
        public var componentId: Swift.String?
        /// The type of component. Length Constraints: Minimum of 1. Maximum of 32.
        public var componentType: Swift.String?
        /// Information about the component that comes after the current component in the network path.
        public var egress: SecurityHubClientTypes.NetworkHeader?
        /// Information about the component that comes before the current node in the network path.
        public var ingress: SecurityHubClientTypes.NetworkHeader?

        public init(
            componentId: Swift.String? = nil,
            componentType: Swift.String? = nil,
            egress: SecurityHubClientTypes.NetworkHeader? = nil,
            ingress: SecurityHubClientTypes.NetworkHeader? = nil
        )
        {
            self.componentId = componentId
            self.componentType = componentType
            self.egress = egress
            self.ingress = ingress
        }
    }

}

extension SecurityHubClientTypes {
    /// A user-defined note added to a finding.
    public struct Note {
        /// The text of a note. Length Constraints: Minimum of 1. Maximum of 512.
        /// This member is required.
        public var text: Swift.String?
        /// A timestamp that indicates when the note was updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        /// This member is required.
        public var updatedAt: Swift.String?
        /// The principal that created a note.
        /// This member is required.
        public var updatedBy: Swift.String?

        public init(
            text: Swift.String? = nil,
            updatedAt: Swift.String? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.text = text
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides an overview of the patch compliance status for an instance against a selected compliance standard.
    public struct PatchSummary {
        /// The number of patches from the compliance standard that failed to install. The value can be an integer from 0 to 100000.
        public var failedCount: Swift.Int?
        /// The identifier of the compliance standard that was used to determine the patch compliance status. Length Constraints: Minimum length of 1. Maximum length of 256.
        /// This member is required.
        public var id: Swift.String?
        /// The number of patches from the compliance standard that were installed successfully. The value can be an integer from 0 to 100000.
        public var installedCount: Swift.Int?
        /// The number of installed patches that are not part of the compliance standard. The value can be an integer from 0 to 100000.
        public var installedOtherCount: Swift.Int?
        /// The number of patches that were applied, but that require the instance to be rebooted in order to be marked as installed. The value can be an integer from 0 to 100000.
        public var installedPendingReboot: Swift.Int?
        /// The number of patches that are installed but are also on a list of patches that the customer rejected. The value can be an integer from 0 to 100000.
        public var installedRejectedCount: Swift.Int?
        /// The number of patches that are part of the compliance standard but are not installed. The count includes patches that failed to install. The value can be an integer from 0 to 100000.
        public var missingCount: Swift.Int?
        /// The type of patch operation performed. For Patch Manager, the values are SCAN and INSTALL. Length Constraints: Minimum length of 1. Maximum length of 256.
        public var operation: Swift.String?
        /// Indicates when the operation completed. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var operationEndTime: Swift.String?
        /// Indicates when the operation started. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var operationStartTime: Swift.String?
        /// The reboot option specified for the instance. Length Constraints: Minimum length of 1. Maximum length of 256.
        public var rebootOption: Swift.String?

        public init(
            failedCount: Swift.Int? = nil,
            id: Swift.String? = nil,
            installedCount: Swift.Int? = nil,
            installedOtherCount: Swift.Int? = nil,
            installedPendingReboot: Swift.Int? = nil,
            installedRejectedCount: Swift.Int? = nil,
            missingCount: Swift.Int? = nil,
            operation: Swift.String? = nil,
            operationEndTime: Swift.String? = nil,
            operationStartTime: Swift.String? = nil,
            rebootOption: Swift.String? = nil
        )
        {
            self.failedCount = failedCount
            self.id = id
            self.installedCount = installedCount
            self.installedOtherCount = installedOtherCount
            self.installedPendingReboot = installedPendingReboot
            self.installedRejectedCount = installedRejectedCount
            self.missingCount = missingCount
            self.operation = operation
            self.operationEndTime = operationEndTime
            self.operationStartTime = operationStartTime
            self.rebootOption = rebootOption
        }
    }

}

extension SecurityHubClientTypes {
    /// The details of process-related information about a finding.
    public struct ProcessDetails {
        /// Indicates when the process was launched. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var launchedAt: Swift.String?
        /// The name of the process. Length Constraints: Minimum of 1. Maximum of 64.
        public var name: Swift.String?
        /// The parent process ID. This field accepts positive integers between O and 2147483647.
        public var parentPid: Swift.Int?
        /// The path to the process executable. Length Constraints: Minimum of 1. Maximum of 512.
        public var path: Swift.String?
        /// The process ID.
        public var pid: Swift.Int?
        /// Indicates when the process was terminated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var terminatedAt: Swift.String?

        public init(
            launchedAt: Swift.String? = nil,
            name: Swift.String? = nil,
            parentPid: Swift.Int? = nil,
            path: Swift.String? = nil,
            pid: Swift.Int? = nil,
            terminatedAt: Swift.String? = nil
        )
        {
            self.launchedAt = launchedAt
            self.name = name
            self.parentPid = parentPid
            self.path = path
            self.pid = pid
            self.terminatedAt = terminatedAt
        }
    }

}

extension SecurityHubClientTypes {

    public enum RecordState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordState] {
            return [
                .active,
                .archived
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A recommendation on how to remediate the issue identified in a finding.
    public struct Recommendation {
        /// Describes the recommended steps to take to remediate an issue identified in a finding. Length Constraints: Minimum of 1 length. Maximum of 512 length.
        public var text: Swift.String?
        /// A URL to a page or site that contains information about how to remediate a finding.
        public var url: Swift.String?

        public init(
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the remediation steps for a finding.
    public struct Remediation {
        /// A recommendation on the steps to take to remediate the issue identified by a finding.
        public var recommendation: SecurityHubClientTypes.Recommendation?

        public init(
            recommendation: SecurityHubClientTypes.Recommendation? = nil
        )
        {
            self.recommendation = recommendation
        }
    }

}

extension SecurityHubClientTypes {
    /// An occurrence of sensitive data detected in a Microsoft Excel workbook, comma-separated value (CSV) file, or tab-separated value (TSV) file.
    public struct Cell {
        /// For a Microsoft Excel workbook, provides the location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2.
        public var cellReference: Swift.String?
        /// The column number of the column that contains the data. For a Microsoft Excel workbook, the column number corresponds to the alphabetical column identifiers. For example, a value of 1 for Column corresponds to the A column in the workbook.
        public var column: Swift.Int?
        /// The name of the column that contains the data.
        public var columnName: Swift.String?
        /// The row number of the row that contains the data.
        public var row: Swift.Int?

        public init(
            cellReference: Swift.String? = nil,
            column: Swift.Int? = nil,
            columnName: Swift.String? = nil,
            row: Swift.Int? = nil
        )
        {
            self.cellReference = cellReference
            self.column = column
            self.columnName = columnName
            self.row = row
        }
    }

}

extension SecurityHubClientTypes {
    /// Identifies where the sensitive data begins and ends.
    public struct Range {
        /// The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.
        public var end: Swift.Int?
        /// The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.
        public var start: Swift.Int?
        /// In the line where the sensitive data starts, the column within the line where the sensitive data starts.
        public var startColumn: Swift.Int?

        public init(
            end: Swift.Int? = nil,
            start: Swift.Int? = nil,
            startColumn: Swift.Int? = nil
        )
        {
            self.end = end
            self.start = start
            self.startColumn = startColumn
        }
    }

}

extension SecurityHubClientTypes {
    /// An occurrence of sensitive data in an Adobe Portable Document Format (PDF) file.
    public struct Page {
        /// An occurrence of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.
        public var lineRange: SecurityHubClientTypes.Range?
        /// An occurrence of sensitive data detected in a binary text file.
        public var offsetRange: SecurityHubClientTypes.Range?
        /// The page number of the page that contains the sensitive data.
        public var pageNumber: Swift.Int?

        public init(
            lineRange: SecurityHubClientTypes.Range? = nil,
            offsetRange: SecurityHubClientTypes.Range? = nil,
            pageNumber: Swift.Int? = nil
        )
        {
            self.lineRange = lineRange
            self.offsetRange = offsetRange
            self.pageNumber = pageNumber
        }
    }

}

extension SecurityHubClientTypes {
    /// An occurrence of sensitive data in an Apache Avro object container or an Apache Parquet file.
    public struct Record {
        /// The path, as a JSONPath expression, to the field in the record that contains the data. If the field name is longer than 20 characters, it is truncated. If the path is longer than 250 characters, it is truncated.
        public var jsonPath: Swift.String?
        /// The record index, starting from 0, for the record that contains the data.
        public var recordIndex: Swift.Int?

        public init(
            jsonPath: Swift.String? = nil,
            recordIndex: Swift.Int? = nil
        )
        {
            self.jsonPath = jsonPath
            self.recordIndex = recordIndex
        }
    }

}

extension SecurityHubClientTypes {
    /// The detected occurrences of sensitive data.
    public struct Occurrences {
        /// Occurrences of sensitive data detected in Microsoft Excel workbooks, comma-separated value (CSV) files, or tab-separated value (TSV) files.
        public var cells: [SecurityHubClientTypes.Cell]?
        /// Occurrences of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.
        public var lineRanges: [SecurityHubClientTypes.Range]?
        /// Occurrences of sensitive data detected in a binary text file.
        public var offsetRanges: [SecurityHubClientTypes.Range]?
        /// Occurrences of sensitive data in an Adobe Portable Document Format (PDF) file.
        public var pages: [SecurityHubClientTypes.Page]?
        /// Occurrences of sensitive data in an Apache Avro object container or an Apache Parquet file.
        public var records: [SecurityHubClientTypes.Record]?

        public init(
            cells: [SecurityHubClientTypes.Cell]? = nil,
            lineRanges: [SecurityHubClientTypes.Range]? = nil,
            offsetRanges: [SecurityHubClientTypes.Range]? = nil,
            pages: [SecurityHubClientTypes.Page]? = nil,
            records: [SecurityHubClientTypes.Record]? = nil
        )
        {
            self.cells = cells
            self.lineRanges = lineRanges
            self.offsetRanges = offsetRanges
            self.pages = pages
            self.records = records
        }
    }

}

extension SecurityHubClientTypes {
    /// The list of detected instances of sensitive data.
    public struct CustomDataIdentifiersDetections {
        /// The ARN of the custom identifier that was used to detect the sensitive data.
        public var arn: Swift.String?
        /// The total number of occurrences of sensitive data that were detected.
        public var count: Swift.Int?
        /// he name of the custom identifier that detected the sensitive data.
        public var name: Swift.String?
        /// Details about the sensitive data that was detected.
        public var occurrences: SecurityHubClientTypes.Occurrences?

        public init(
            arn: Swift.String? = nil,
            count: Swift.Int? = nil,
            name: Swift.String? = nil,
            occurrences: SecurityHubClientTypes.Occurrences? = nil
        )
        {
            self.arn = arn
            self.count = count
            self.name = name
            self.occurrences = occurrences
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains an instance of sensitive data that was detected by a customer-defined identifier.
    public struct CustomDataIdentifiersResult {
        /// The list of detected instances of sensitive data.
        public var detections: [SecurityHubClientTypes.CustomDataIdentifiersDetections]?
        /// The total number of occurrences of sensitive data.
        public var totalCount: Swift.Int?

        public init(
            detections: [SecurityHubClientTypes.CustomDataIdentifiersDetections]? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.detections = detections
            self.totalCount = totalCount
        }
    }

}

extension SecurityHubClientTypes {
    /// The list of detected instances of sensitive data.
    public struct SensitiveDataDetections {
        /// The total number of occurrences of sensitive data that were detected.
        public var count: Swift.Int?
        /// Details about the sensitive data that was detected.
        public var occurrences: SecurityHubClientTypes.Occurrences?
        /// The type of sensitive data that was detected. For example, the type might indicate that the data is an email address.
        public var type: Swift.String?

        public init(
            count: Swift.Int? = nil,
            occurrences: SecurityHubClientTypes.Occurrences? = nil,
            type: Swift.String? = nil
        )
        {
            self.count = count
            self.occurrences = occurrences
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Contains a detected instance of sensitive data that are based on built-in identifiers.
    public struct SensitiveDataResult {
        /// The category of sensitive data that was detected. For example, the category can indicate that the sensitive data involved credentials, financial information, or personal information.
        public var category: Swift.String?
        /// The list of detected instances of sensitive data.
        public var detections: [SecurityHubClientTypes.SensitiveDataDetections]?
        /// The total number of occurrences of sensitive data.
        public var totalCount: Swift.Int?

        public init(
            category: Swift.String? = nil,
            detections: [SecurityHubClientTypes.SensitiveDataDetections]? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.category = category
            self.detections = detections
            self.totalCount = totalCount
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the current status of the sensitive data detection.
    public struct ClassificationStatus {
        /// The code that represents the status of the sensitive data detection.
        public var code: Swift.String?
        /// A longer description of the current status of the sensitive data detection.
        public var reason: Swift.String?

        public init(
            code: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.code = code
            self.reason = reason
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the sensitive data that was detected on the resource.
    public struct ClassificationResult {
        /// Indicates whether there are additional occurrences of sensitive data that are not included in the finding. This occurs when the number of occurrences exceeds the maximum that can be included.
        public var additionalOccurrences: Swift.Bool?
        /// Provides details about sensitive data that was identified based on customer-defined configuration.
        public var customDataIdentifiers: SecurityHubClientTypes.CustomDataIdentifiersResult?
        /// The type of content that the finding applies to.
        public var mimeType: Swift.String?
        /// Provides details about sensitive data that was identified based on built-in configuration.
        public var sensitiveData: [SecurityHubClientTypes.SensitiveDataResult]?
        /// The total size in bytes of the affected data.
        public var sizeClassified: Swift.Int?
        /// The current status of the sensitive data detection.
        public var status: SecurityHubClientTypes.ClassificationStatus?

        public init(
            additionalOccurrences: Swift.Bool? = nil,
            customDataIdentifiers: SecurityHubClientTypes.CustomDataIdentifiersResult? = nil,
            mimeType: Swift.String? = nil,
            sensitiveData: [SecurityHubClientTypes.SensitiveDataResult]? = nil,
            sizeClassified: Swift.Int? = nil,
            status: SecurityHubClientTypes.ClassificationStatus? = nil
        )
        {
            self.additionalOccurrences = additionalOccurrences
            self.customDataIdentifiers = customDataIdentifiers
            self.mimeType = mimeType
            self.sensitiveData = sensitiveData
            self.sizeClassified = sizeClassified
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about sensitive data that was detected on a resource.
    public struct DataClassificationDetails {
        /// The path to the folder or file that contains the sensitive data.
        public var detailedResultsLocation: Swift.String?
        /// The details about the sensitive data that was detected on the resource.
        public var result: SecurityHubClientTypes.ClassificationResult?

        public init(
            detailedResultsLocation: Swift.String? = nil,
            result: SecurityHubClientTypes.ClassificationResult? = nil
        )
        {
            self.detailedResultsLocation = detailedResultsLocation
            self.result = result
        }
    }

}

extension SecurityHubClientTypes {
    /// A wrapper type for the attributes of an Amazon SNS subscription.
    public struct AwsSnsTopicSubscription {
        /// The subscription's endpoint (format depends on the protocol).
        public var endpoint: Swift.String?
        /// The subscription's protocol.
        public var `protocol`: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.`protocol` = `protocol`
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon SNS topic to which notifications can be published.
    public struct AwsSnsTopicDetails {
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint.
        public var applicationSuccessFeedbackRoleArn: Swift.String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
        public var firehoseFailureFeedbackRoleArn: Swift.String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
        public var firehoseSuccessFeedbackRoleArn: Swift.String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
        public var httpFailureFeedbackRoleArn: Swift.String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
        public var httpSuccessFeedbackRoleArn: Swift.String?
        /// The ID of an Amazon Web Services managed key for Amazon SNS or a customer managed key.
        public var kmsMasterKeyId: Swift.String?
        /// The subscription's owner.
        public var owner: Swift.String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
        public var sqsFailureFeedbackRoleArn: Swift.String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
        public var sqsSuccessFeedbackRoleArn: Swift.String?
        /// Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.
        public var subscription: [SecurityHubClientTypes.AwsSnsTopicSubscription]?
        /// The name of the Amazon SNS topic.
        public var topicName: Swift.String?

        public init(
            applicationSuccessFeedbackRoleArn: Swift.String? = nil,
            firehoseFailureFeedbackRoleArn: Swift.String? = nil,
            firehoseSuccessFeedbackRoleArn: Swift.String? = nil,
            httpFailureFeedbackRoleArn: Swift.String? = nil,
            httpSuccessFeedbackRoleArn: Swift.String? = nil,
            kmsMasterKeyId: Swift.String? = nil,
            owner: Swift.String? = nil,
            sqsFailureFeedbackRoleArn: Swift.String? = nil,
            sqsSuccessFeedbackRoleArn: Swift.String? = nil,
            subscription: [SecurityHubClientTypes.AwsSnsTopicSubscription]? = nil,
            topicName: Swift.String? = nil
        )
        {
            self.applicationSuccessFeedbackRoleArn = applicationSuccessFeedbackRoleArn
            self.firehoseFailureFeedbackRoleArn = firehoseFailureFeedbackRoleArn
            self.firehoseSuccessFeedbackRoleArn = firehoseSuccessFeedbackRoleArn
            self.httpFailureFeedbackRoleArn = httpFailureFeedbackRoleArn
            self.httpSuccessFeedbackRoleArn = httpSuccessFeedbackRoleArn
            self.kmsMasterKeyId = kmsMasterKeyId
            self.owner = owner
            self.sqsFailureFeedbackRoleArn = sqsFailureFeedbackRoleArn
            self.sqsSuccessFeedbackRoleArn = sqsSuccessFeedbackRoleArn
            self.subscription = subscription
            self.topicName = topicName
        }
    }

}

extension SecurityHubClientTypes {
    /// Data about a queue.
    public struct AwsSqsQueueDetails {
        /// The ARN of the dead-letter queue to which Amazon SQS moves messages after the value of maxReceiveCount is exceeded.
        public var deadLetterTargetArn: Swift.String?
        /// The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling KMS again.
        public var kmsDataKeyReusePeriodSeconds: Swift.Int?
        /// The ID of an Amazon Web Services managed key for Amazon SQS or a custom KMS key.
        public var kmsMasterKeyId: Swift.String?
        /// The name of the new queue.
        public var queueName: Swift.String?

        public init(
            deadLetterTargetArn: Swift.String? = nil,
            kmsDataKeyReusePeriodSeconds: Swift.Int? = nil,
            kmsMasterKeyId: Swift.String? = nil,
            queueName: Swift.String? = nil
        )
        {
            self.deadLetterTargetArn = deadLetterTargetArn
            self.kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSeconds
            self.kmsMasterKeyId = kmsMasterKeyId
            self.queueName = queueName
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides the details about the compliance status for a patch.
    public struct AwsSsmComplianceSummary {
        /// The type of resource for which the compliance was determined. For AwsSsmPatchCompliance, ComplianceType is Patch.
        public var complianceType: Swift.String?
        /// For the patches that are compliant, the number that have a severity of CRITICAL.
        public var compliantCriticalCount: Swift.Int?
        /// For the patches that are compliant, the number that have a severity of HIGH.
        public var compliantHighCount: Swift.Int?
        /// For the patches that are compliant, the number that have a severity of INFORMATIONAL.
        public var compliantInformationalCount: Swift.Int?
        /// For the patches that are compliant, the number that have a severity of LOW.
        public var compliantLowCount: Swift.Int?
        /// For the patches that are compliant, the number that have a severity of MEDIUM.
        public var compliantMediumCount: Swift.Int?
        /// For the patches that are compliant, the number that have a severity of UNSPECIFIED.
        public var compliantUnspecifiedCount: Swift.Int?
        /// The type of execution that was used determine compliance.
        public var executionType: Swift.String?
        /// For the patch items that are noncompliant, the number of items that have a severity of CRITICAL.
        public var nonCompliantCriticalCount: Swift.Int?
        /// For the patches that are noncompliant, the number that have a severity of HIGH.
        public var nonCompliantHighCount: Swift.Int?
        /// For the patches that are noncompliant, the number that have a severity of INFORMATIONAL.
        public var nonCompliantInformationalCount: Swift.Int?
        /// For the patches that are noncompliant, the number that have a severity of LOW.
        public var nonCompliantLowCount: Swift.Int?
        /// For the patches that are noncompliant, the number that have a severity of MEDIUM.
        public var nonCompliantMediumCount: Swift.Int?
        /// For the patches that are noncompliant, the number that have a severity of UNSPECIFIED.
        public var nonCompliantUnspecifiedCount: Swift.Int?
        /// The highest severity for the patches. Valid values are as follows:
        ///
        /// * CRITICAL
        ///
        /// * HIGH
        ///
        /// * MEDIUM
        ///
        /// * LOW
        ///
        /// * INFORMATIONAL
        ///
        /// * UNSPECIFIED
        public var overallSeverity: Swift.String?
        /// The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.
        public var patchBaselineId: Swift.String?
        /// The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.
        public var patchGroup: Swift.String?
        /// The current patch compliance status. Valid values are as follows:
        ///
        /// * COMPLIANT
        ///
        /// * NON_COMPLIANT
        ///
        /// * UNSPECIFIED_DATA
        public var status: Swift.String?

        public init(
            complianceType: Swift.String? = nil,
            compliantCriticalCount: Swift.Int? = nil,
            compliantHighCount: Swift.Int? = nil,
            compliantInformationalCount: Swift.Int? = nil,
            compliantLowCount: Swift.Int? = nil,
            compliantMediumCount: Swift.Int? = nil,
            compliantUnspecifiedCount: Swift.Int? = nil,
            executionType: Swift.String? = nil,
            nonCompliantCriticalCount: Swift.Int? = nil,
            nonCompliantHighCount: Swift.Int? = nil,
            nonCompliantInformationalCount: Swift.Int? = nil,
            nonCompliantLowCount: Swift.Int? = nil,
            nonCompliantMediumCount: Swift.Int? = nil,
            nonCompliantUnspecifiedCount: Swift.Int? = nil,
            overallSeverity: Swift.String? = nil,
            patchBaselineId: Swift.String? = nil,
            patchGroup: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.compliantCriticalCount = compliantCriticalCount
            self.compliantHighCount = compliantHighCount
            self.compliantInformationalCount = compliantInformationalCount
            self.compliantLowCount = compliantLowCount
            self.compliantMediumCount = compliantMediumCount
            self.compliantUnspecifiedCount = compliantUnspecifiedCount
            self.executionType = executionType
            self.nonCompliantCriticalCount = nonCompliantCriticalCount
            self.nonCompliantHighCount = nonCompliantHighCount
            self.nonCompliantInformationalCount = nonCompliantInformationalCount
            self.nonCompliantLowCount = nonCompliantLowCount
            self.nonCompliantMediumCount = nonCompliantMediumCount
            self.nonCompliantUnspecifiedCount = nonCompliantUnspecifiedCount
            self.overallSeverity = overallSeverity
            self.patchBaselineId = patchBaselineId
            self.patchGroup = patchGroup
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the compliance for a patch.
    public struct AwsSsmPatch {
        /// The compliance status details for the patch.
        public var complianceSummary: SecurityHubClientTypes.AwsSsmComplianceSummary?

        public init(
            complianceSummary: SecurityHubClientTypes.AwsSsmComplianceSummary? = nil
        )
        {
            self.complianceSummary = complianceSummary
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.
    public struct AwsSsmPatchComplianceDetails {
        /// Information about the status of a patch.
        public var patch: SecurityHubClientTypes.AwsSsmPatch?

        public init(
            patch: SecurityHubClientTypes.AwsSsmPatch? = nil
        )
        {
            self.patch = patch
        }
    }

}

extension SecurityHubClientTypes {
    /// An object describing a CloudWatch log group. For more information, see [ Amazon Web Services::Logs::LogGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html) in the CloudFormation User Guide.
    public struct AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails {
        /// The ARN (ends with :*) of the CloudWatch Logs log group to which you want your logs emitted.
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension SecurityHubClientTypes {
    /// An array of objects that describes where your execution history events will be logged.
    public struct AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails {
        /// An object describing a CloudWatch Logs log group. For more information, see [ Amazon Web Services::Logs::LogGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html) in the CloudFormation User Guide.
        public var cloudWatchLogsLogGroup: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails?

        public init(
            cloudWatchLogsLogGroup: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails? = nil
        )
        {
            self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
        }
    }

}

extension SecurityHubClientTypes {
    /// The LoggingConfiguration data type is used to set CloudWatch Logs options.
    public struct AwsStepFunctionStateMachineLoggingConfigurationDetails {
        /// An array of objects that describes where your execution history events will be logged.
        public var destinations: [SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails]?
        /// Determines whether execution data is included in your log. When set to false, data is excluded.
        public var includeExecutionData: Swift.Bool?
        /// Defines which category of execution history events are logged.
        public var level: Swift.String?

        public init(
            destinations: [SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails]? = nil,
            includeExecutionData: Swift.Bool? = nil,
            level: Swift.String? = nil
        )
        {
            self.destinations = destinations
            self.includeExecutionData = includeExecutionData
            self.level = level
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies whether X-Ray tracing is enabled.
    public struct AwsStepFunctionStateMachineTracingConfigurationDetails {
        /// When set to true, X-Ray tracing is enabled.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about an Step Functions state machine, which is a workflow consisting of a series of event- driven steps.
    public struct AwsStepFunctionStateMachineDetails {
        /// A user-defined or an auto-generated string that identifies a Map state. This parameter is present only if the stateMachineArn specified in input is a qualified state machine ARN.
        public var label: Swift.String?
        /// Used to set CloudWatch Logs options.
        public var loggingConfiguration: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDetails?
        /// The name of the state machine.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role used when creating this state machine.
        public var roleArn: Swift.String?
        /// The ARN that identifies the state machine.
        public var stateMachineArn: Swift.String?
        /// The current status of the state machine.
        public var status: Swift.String?
        /// Specifies whether X-Ray tracing is enabled.
        public var tracingConfiguration: SecurityHubClientTypes.AwsStepFunctionStateMachineTracingConfigurationDetails?
        /// The type of the state machine (STANDARD or EXPRESS).
        public var type: Swift.String?

        public init(
            label: Swift.String? = nil,
            loggingConfiguration: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDetails? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            stateMachineArn: Swift.String? = nil,
            status: Swift.String? = nil,
            tracingConfiguration: SecurityHubClientTypes.AwsStepFunctionStateMachineTracingConfigurationDetails? = nil,
            type: Swift.String? = nil
        )
        {
            self.label = label
            self.loggingConfiguration = loggingConfiguration
            self.name = name
            self.roleArn = roleArn
            self.stateMachineArn = stateMachineArn
            self.status = status
            self.tracingConfiguration = tracingConfiguration
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// A match predicate. A predicate might look for characteristics such as specific IP addresses, geographic locations, or sizes.
    public struct AwsWafRateBasedRuleMatchPredicate {
        /// The unique identifier for the predicate.
        public var dataId: Swift.String?
        /// If set to true, then the rule actions are performed on requests that match the predicate settings. If set to false, then the rule actions are performed on all requests except those that match the predicate settings.
        public var negated: Swift.Bool?
        /// The type of predicate. Valid values are as follows:
        ///
        /// * ByteMatch
        ///
        /// * GeoMatch
        ///
        /// * IPMatch
        ///
        /// * RegexMatch
        ///
        /// * SizeConstraint
        ///
        /// * SqlInjectionMatch
        ///
        /// * XssMatch
        public var type: Swift.String?

        public init(
            dataId: Swift.String? = nil,
            negated: Swift.Bool? = nil,
            type: Swift.String? = nil
        )
        {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about a rate-based rule for global resources. A rate-based rule provides settings to indicate when to allow, block, or count a request. Rate-based rules include the number of requests that arrive over a specified period of time.
    public struct AwsWafRateBasedRuleDetails {
        /// The predicates to include in the rate-based rule.
        public var matchPredicates: [SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate]?
        /// The name of the metrics for the rate-based rule.
        public var metricName: Swift.String?
        /// The name of the rate-based rule.
        public var name: Swift.String?
        /// The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.
        public var rateKey: Swift.String?
        /// The maximum number of requests that have an identical value for the field specified in RateKey that are allowed within a five-minute period. If the number of requests exceeds RateLimit and the other predicates specified in the rule are met, WAF triggers the action for the rule.
        public var rateLimit: Swift.Int?
        /// The unique identifier for the rate-based rule.
        public var ruleId: Swift.String?

        public init(
            matchPredicates: [SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate]? = nil,
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            rateKey: Swift.String? = nil,
            rateLimit: Swift.Int? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.matchPredicates = matchPredicates
            self.metricName = metricName
            self.name = name
            self.rateKey = rateKey
            self.rateLimit = rateLimit
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes {
    /// Details for a match predicate. A predicate might look for characteristics such as specific IP addresses, geographic locations, or sizes.
    public struct AwsWafRegionalRateBasedRuleMatchPredicate {
        /// The unique identifier for the predicate.
        public var dataId: Swift.String?
        /// If set to true, then the rule actions are performed on requests that match the predicate settings. If set to false, then the rule actions are performed on all requests except those that match the predicate settings.
        public var negated: Swift.Bool?
        /// The type of predicate. Valid values are as follows:
        ///
        /// * ByteMatch
        ///
        /// * GeoMatch
        ///
        /// * IPMatch
        ///
        /// * RegexMatch
        ///
        /// * SizeConstraint
        ///
        /// * SqlInjectionMatch
        ///
        /// * XssMatch
        public var type: Swift.String?

        public init(
            dataId: Swift.String? = nil,
            negated: Swift.Bool? = nil,
            type: Swift.String? = nil
        )
        {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// contains details about a rate-based rule for Regional resources. A rate-based rule provides settings to indicate when to allow, block, or count a request. Rate-based rules include the number of requests that arrive over a specified period of time.
    public struct AwsWafRegionalRateBasedRuleDetails {
        /// The predicates to include in the rate-based rule.
        public var matchPredicates: [SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate]?
        /// The name of the metrics for the rate-based rule.
        public var metricName: Swift.String?
        /// The name of the rate-based rule.
        public var name: Swift.String?
        /// The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.
        public var rateKey: Swift.String?
        /// The maximum number of requests that have an identical value for the field specified in RateKey that are allowed within a five-minute period. If the number of requests exceeds RateLimit and the other predicates specified in the rule are met, WAF triggers the action for the rule.
        public var rateLimit: Swift.Int?
        /// The unique identifier for the rate-based rule.
        public var ruleId: Swift.String?

        public init(
            matchPredicates: [SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate]? = nil,
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            rateKey: Swift.String? = nil,
            rateLimit: Swift.Int? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.matchPredicates = matchPredicates
            self.metricName = metricName
            self.name = name
            self.rateKey = rateKey
            self.rateLimit = rateLimit
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
    public struct AwsWafRegionalRulePredicateListDetails {
        /// A unique identifier for a predicate in a rule, such as ByteMatchSetId or IPSetId.
        public var dataId: Swift.String?
        /// Specifies if you want WAF to allow, block, or count requests based on the settings in the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, or SizeConstraintSet.
        public var negated: Swift.Bool?
        /// The type of predicate in a rule, such as ByteMatch or IPSet.
        public var type: Swift.String?

        public init(
            dataId: Swift.String? = nil,
            negated: Swift.Bool? = nil,
            type: Swift.String? = nil
        )
        {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an WAF Regional rule. This rule identifies the web requests that you want to allow, block, or count.
    public struct AwsWafRegionalRuleDetails {
        /// A name for the metrics for the rule.
        public var metricName: Swift.String?
        /// A descriptive name for the rule.
        public var name: Swift.String?
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public var predicateList: [SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails]?
        /// The ID of the rule.
        public var ruleId: Swift.String?

        public init(
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            predicateList: [SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails]? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.name = name
            self.predicateList = predicateList
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes the action that WAF should take on a web request when it matches the criteria defined in the rule.
    public struct AwsWafRegionalRuleGroupRulesActionDetails {
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the rules attached to a rule group
    public struct AwsWafRegionalRuleGroupRulesDetails {
        /// The action that WAF should take on a web request when it matches the criteria defined in the rule.
        public var action: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails?
        /// If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of Priority.
        public var priority: Swift.Int?
        /// The ID for a rule.
        public var ruleId: Swift.String?
        /// The type of rule in the rule group.
        public var type: Swift.String?

        public init(
            action: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails? = nil,
            priority: Swift.Int? = nil,
            ruleId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.action = action
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an WAF Regional rule group. The rule group is a collection of rules for inspecting and controlling web requests.
    public struct AwsWafRegionalRuleGroupDetails {
        /// A name for the metrics for this rule group.
        public var metricName: Swift.String?
        /// The descriptive name of the rule group.
        public var name: Swift.String?
        /// The ID of the rule group.
        public var ruleGroupId: Swift.String?
        /// Provides information about the rule statements used to identify the web requests that you want to allow, block, or count.
        public var rules: [SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails]?

        public init(
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            ruleGroupId: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails]? = nil
        )
        {
            self.metricName = metricName
            self.name = name
            self.ruleGroupId = ruleGroupId
            self.rules = rules
        }
    }

}

extension SecurityHubClientTypes {
    /// The action that WAF takes when a web request matches all conditions in the rule, such as allow, block, or count the request.
    public struct AwsWafRegionalWebAclRulesListActionDetails {
        /// For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the action to use in the place of the action that results from the rule group evaluation.
    public struct AwsWafRegionalWebAclRulesListOverrideActionDetails {
        /// Overrides the rule evaluation result in the rule group.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// A combination of ByteMatchSet, IPSet, and/or SqlInjectionMatchSet objects that identify the web requests that you want to allow, block, or count.
    public struct AwsWafRegionalWebAclRulesListDetails {
        /// The action that WAF takes when a web request matches all conditions in the rule, such as allow, block, or count the request.
        public var action: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails?
        /// Overrides the rule evaluation result in the rule group.
        public var overrideAction: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails?
        /// The order in which WAF evaluates the rules in a web ACL.
        public var priority: Swift.Int?
        /// The ID of an WAF Regional rule to associate with a web ACL.
        public var ruleId: Swift.String?
        /// For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule.
        public var type: Swift.String?

        public init(
            action: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails? = nil,
            overrideAction: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails? = nil,
            priority: Swift.Int? = nil,
            ruleId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.action = action
            self.overrideAction = overrideAction
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the web access control list (web ACL). The web ACL contains the rules that identify the requests that you want to allow, block, or count.
    public struct AwsWafRegionalWebAclDetails {
        /// The action to perform if none of the rules contained in the web ACL match.
        public var defaultAction: Swift.String?
        /// A name for the metrics for this web ACL.
        public var metricName: Swift.String?
        /// A descriptive name for the web ACL.
        public var name: Swift.String?
        /// An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.
        public var rulesList: [SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails]?
        /// The ID of the web ACL.
        public var webAclId: Swift.String?

        public init(
            defaultAction: Swift.String? = nil,
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            rulesList: [SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails]? = nil,
            webAclId: Swift.String? = nil
        )
        {
            self.defaultAction = defaultAction
            self.metricName = metricName
            self.name = name
            self.rulesList = rulesList
            self.webAclId = webAclId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
    public struct AwsWafRulePredicateListDetails {
        /// A unique identifier for a predicate in a rule, such as ByteMatchSetId or IPSetId.
        public var dataId: Swift.String?
        /// Specifies if you want WAF to allow, block, or count requests based on the settings in the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, or SizeConstraintSet.
        public var negated: Swift.Bool?
        /// The type of predicate in a rule, such as ByteMatch or IPSet.
        public var type: Swift.String?

        public init(
            dataId: Swift.String? = nil,
            negated: Swift.Bool? = nil,
            type: Swift.String? = nil
        )
        {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about a WAF rule. This rule specifies the web requests that you want to allow, block, or count.
    public struct AwsWafRuleDetails {
        /// The name of the metrics for this rule.
        public var metricName: Swift.String?
        /// A descriptive name for the rule.
        public var name: Swift.String?
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public var predicateList: [SecurityHubClientTypes.AwsWafRulePredicateListDetails]?
        /// The ID of the WAF rule.
        public var ruleId: Swift.String?

        public init(
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            predicateList: [SecurityHubClientTypes.AwsWafRulePredicateListDetails]? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.name = name
            self.predicateList = predicateList
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule.
    public struct AwsWafRuleGroupRulesActionDetails {
        /// The action that WAF should take on a web request when it matches the rule's statement.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the rules attached to the rule group. These rules identify the web requests that you want to allow, block, or count.
    public struct AwsWafRuleGroupRulesDetails {
        /// Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule.
        public var action: SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails?
        /// If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of Priority.
        public var priority: Swift.Int?
        /// The rule ID for a rule.
        public var ruleId: Swift.String?
        /// The type of rule.
        public var type: Swift.String?

        public init(
            action: SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails? = nil,
            priority: Swift.Int? = nil,
            ruleId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.action = action
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an WAF rule group. A rule group is a collection of rules for inspecting and controlling web requests.
    public struct AwsWafRuleGroupDetails {
        /// The name of the metrics for this rule group.
        public var metricName: Swift.String?
        /// The name of the rule group.
        public var name: Swift.String?
        /// The ID of the rule group.
        public var ruleGroupId: Swift.String?
        /// Provides information about the rules attached to the rule group. These rules identify the web requests that you want to allow, block, or count.
        public var rules: [SecurityHubClientTypes.AwsWafRuleGroupRulesDetails]?

        public init(
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            ruleGroupId: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafRuleGroupRulesDetails]? = nil
        )
        {
            self.metricName = metricName
            self.name = name
            self.ruleGroupId = ruleGroupId
            self.rules = rules
        }
    }

}

extension SecurityHubClientTypes {
    /// A custom header for custom request and response handling.
    public struct AwsWafv2CustomHttpHeader {
        /// The name of the custom header.
        public var name: Swift.String?
        /// The value of the custom header.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Custom request handling behavior that inserts custom headers into a web request. WAF uses custom request handling when the rule action doesn't block the request.
    public struct AwsWafv2CustomRequestHandlingDetails {
        /// The HTTP headers to insert into the request.
        public var insertHeaders: [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]?

        public init(
            insertHeaders: [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]? = nil
        )
        {
            self.insertHeaders = insertHeaders
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies that WAF should allow the request and optionally defines additional custom handling for the request.
    public struct AwsWafv2ActionAllowDetails {
        /// Defines custom handling for the web request. For information about customizing web requests and responses, see [Customizing web requests and responses in WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the WAF Developer Guide..
        public var customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails?

        public init(
            customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails? = nil
        )
        {
            self.customRequestHandling = customRequestHandling
        }
    }

}

extension SecurityHubClientTypes {
    /// A custom response to send to the client. You can define a custom response for rule actions and default web ACL actions that are set to block.
    public struct AwsWafv2CustomResponseDetails {
        /// References the response body that you want WAF to return to the web request client. You can define a custom response for a rule action or a default web ACL action that is set to block.
        public var customResponseBodyKey: Swift.String?
        /// The HTTP status code to return to the client. For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the WAF Developer Guide.
        public var responseCode: Swift.Int?
        /// The HTTP headers to use in the response.
        public var responseHeaders: [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]?

        public init(
            customResponseBodyKey: Swift.String? = nil,
            responseCode: Swift.Int? = nil,
            responseHeaders: [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]? = nil
        )
        {
            self.customResponseBodyKey = customResponseBodyKey
            self.responseCode = responseCode
            self.responseHeaders = responseHeaders
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies that WAF should block the request and optionally defines additional custom handling for the response to the web request.
    public struct AwsWafv2ActionBlockDetails {
        /// Defines a custom response for the web request. For information, see [Customizing web requests and responses in WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the WAF Developer Guide..
        public var customResponse: SecurityHubClientTypes.AwsWafv2CustomResponseDetails?

        public init(
            customResponse: SecurityHubClientTypes.AwsWafv2CustomResponseDetails? = nil
        )
        {
            self.customResponse = customResponse
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies that WAF should run a CAPTCHA check against the request.
    public struct AwsWafv2RulesActionCaptchaDetails {
        /// Defines custom handling for the web request, used when the CAPTCHA inspection determines that the request's token is valid and unexpired. For more information, see [Customizing web requests and responses in WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the WAF Developer Guide..
        public var customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails?

        public init(
            customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails? = nil
        )
        {
            self.customRequestHandling = customRequestHandling
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies that WAF should count the request.
    public struct AwsWafv2RulesActionCountDetails {
        /// Defines custom handling for the web request. For more information, see [Customizing web requests and responses in WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the WAF Developer Guide..
        public var customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails?

        public init(
            customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails? = nil
        )
        {
            self.customRequestHandling = customRequestHandling
        }
    }

}

extension SecurityHubClientTypes {
    /// The action that WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting.
    public struct AwsWafv2RulesActionDetails {
        /// Instructs WAF to allow the web request.
        public var allow: SecurityHubClientTypes.AwsWafv2ActionAllowDetails?
        /// Instructs WAF to block the web request.
        public var block: SecurityHubClientTypes.AwsWafv2ActionBlockDetails?
        /// Instructs WAF to run a CAPTCHA check against the web request.
        public var captcha: SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails?
        /// Instructs WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
        public var count: SecurityHubClientTypes.AwsWafv2RulesActionCountDetails?

        public init(
            allow: SecurityHubClientTypes.AwsWafv2ActionAllowDetails? = nil,
            block: SecurityHubClientTypes.AwsWafv2ActionBlockDetails? = nil,
            captcha: SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails? = nil,
            count: SecurityHubClientTypes.AwsWafv2RulesActionCountDetails? = nil
        )
        {
            self.allow = allow
            self.block = block
            self.captcha = captcha
            self.count = count
        }
    }

}

extension SecurityHubClientTypes {
    /// Defines and enables Amazon CloudWatch metrics and web request sample collection.
    public struct AwsWafv2VisibilityConfigDetails {
        /// A boolean indicating whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [WAF metrics and dimensions](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the WAF Developer Guide.
        public var cloudWatchMetricsEnabled: Swift.Bool?
        /// A name of the Amazon CloudWatch metric.
        public var metricName: Swift.String?
        /// A boolean indicating whether WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the WAF console.
        public var sampledRequestsEnabled: Swift.Bool?

        public init(
            cloudWatchMetricsEnabled: Swift.Bool? = nil,
            metricName: Swift.String? = nil,
            sampledRequestsEnabled: Swift.Bool? = nil
        )
        {
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.metricName = metricName
            self.sampledRequestsEnabled = sampledRequestsEnabled
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about rules in a rule group. A rule identifies web requests that you want to allow, block, or count. Each rule includes one top-level Statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them.
    public struct AwsWafv2RulesDetails {
        /// The action that WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting.
        public var action: SecurityHubClientTypes.AwsWafv2RulesActionDetails?
        /// The name of the rule.
        public var name: Swift.String?
        /// The action to use in the place of the action that results from the rule group evaluation.
        public var overrideAction: Swift.String?
        /// If you define more than one Rule in a WebACL, WAF evaluates each request against the Rules in order based on the value of Priority. WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
        public var priority: Swift.Int?
        /// Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public var visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails?

        public init(
            action: SecurityHubClientTypes.AwsWafv2RulesActionDetails? = nil,
            name: Swift.String? = nil,
            overrideAction: Swift.String? = nil,
            priority: Swift.Int? = nil,
            visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails? = nil
        )
        {
            self.action = action
            self.name = name
            self.overrideAction = overrideAction
            self.priority = priority
            self.visibilityConfig = visibilityConfig
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an WAFv2 rule group.
    public struct AwsWafv2RuleGroupDetails {
        /// The Amazon Resource Name (ARN) of the entity.
        public var arn: Swift.String?
        /// The web ACL capacity units (WCUs) required for this rule group.
        public var capacity: Swift.Int?
        /// A description of the rule group that helps with identification.
        public var description: Swift.String?
        /// A unique identifier for the rule group.
        public var id: Swift.String?
        /// The name of the rule group. You cannot change the name of a rule group after you create it.
        public var name: Swift.String?
        /// The Rule statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them.
        public var rules: [SecurityHubClientTypes.AwsWafv2RulesDetails]?
        /// Specifies whether the rule group is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, an AppSync GraphQL API, or an Amazon Cognito user pool.
        public var scope: Swift.String?
        /// Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public var visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails?

        public init(
            arn: Swift.String? = nil,
            capacity: Swift.Int? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafv2RulesDetails]? = nil,
            scope: Swift.String? = nil,
            visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails? = nil
        )
        {
            self.arn = arn
            self.capacity = capacity
            self.description = description
            self.id = id
            self.name = name
            self.rules = rules
            self.scope = scope
            self.visibilityConfig = visibilityConfig
        }
    }

}

extension SecurityHubClientTypes {
    /// Used for CAPTCHA and challenge token settings. Determines how long a CAPTCHA or challenge timestamp remains valid after WAF updates it for a successful CAPTCHA or challenge response.
    public struct AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails {
        /// The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by WAF.
        public var immunityTime: Swift.Int?

        public init(
            immunityTime: Swift.Int? = nil
        )
        {
            self.immunityTime = immunityTime
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies how WAF should handle CAPTCHA evaluations for rules that don't have their own CaptchaConfig settings.
    public struct AwsWafv2WebAclCaptchaConfigDetails {
        /// Determines how long a CAPTCHA timestamp in the token remains valid after the client successfully solves a CAPTCHA puzzle.
        public var immunityTimeProperty: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails?

        public init(
            immunityTimeProperty: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails? = nil
        )
        {
            self.immunityTimeProperty = immunityTimeProperty
        }
    }

}

extension SecurityHubClientTypes {
    /// Specifies the action that Amazon CloudFront or WAF takes when a web request matches the conditions in the rule.
    public struct AwsWafv2WebAclActionDetails {
        /// Specifies that WAF should allow requests by default.
        public var allow: SecurityHubClientTypes.AwsWafv2ActionAllowDetails?
        /// Specifies that WAF should block requests by default.
        public var block: SecurityHubClientTypes.AwsWafv2ActionBlockDetails?

        public init(
            allow: SecurityHubClientTypes.AwsWafv2ActionAllowDetails? = nil,
            block: SecurityHubClientTypes.AwsWafv2ActionBlockDetails? = nil
        )
        {
            self.allow = allow
            self.block = block
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an WAFv2 web Access Control List (ACL).
    public struct AwsWafv2WebAclDetails {
        /// The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.
        public var arn: Swift.String?
        /// The web ACL capacity units (WCUs) currently being used by this web ACL.
        public var capacity: Swift.Int?
        /// Specifies how WAF should handle CAPTCHA evaluations for rules that don't have their own CaptchaConfig settings.
        public var captchaConfig: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails?
        /// The action to perform if none of the Rules contained in the web ACL match.
        public var defaultAction: SecurityHubClientTypes.AwsWafv2WebAclActionDetails?
        /// A description of the web ACL that helps with identification.
        public var description: Swift.String?
        /// A unique identifier for the web ACL.
        public var id: Swift.String?
        /// Indicates whether this web ACL is managed by Firewall Manager.
        public var managedbyFirewallManager: Swift.Bool?
        /// The name of the web ACL.
        public var name: Swift.String?
        /// The Rule statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them.
        public var rules: [SecurityHubClientTypes.AwsWafv2RulesDetails]?
        /// Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public var visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails?

        public init(
            arn: Swift.String? = nil,
            capacity: Swift.Int? = nil,
            captchaConfig: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails? = nil,
            defaultAction: SecurityHubClientTypes.AwsWafv2WebAclActionDetails? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            managedbyFirewallManager: Swift.Bool? = nil,
            name: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafv2RulesDetails]? = nil,
            visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails? = nil
        )
        {
            self.arn = arn
            self.capacity = capacity
            self.captchaConfig = captchaConfig
            self.defaultAction = defaultAction
            self.description = description
            self.id = id
            self.managedbyFirewallManager = managedbyFirewallManager
            self.name = name
            self.rules = rules
            self.visibilityConfig = visibilityConfig
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about the action that CloudFront or WAF takes when a web request matches the conditions in the rule.
    public struct WafAction {
        /// Specifies how you want WAF to respond to requests that match the settings in a rule. Valid settings include the following:
        ///
        /// * ALLOW - WAF allows requests
        ///
        /// * BLOCK - WAF blocks requests
        ///
        /// * COUNT - WAF increments a counter of the requests that match all of the conditions in the rule. WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify COUNT for the default action for a web ACL.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about a rule to exclude from a rule group.
    public struct WafExcludedRule {
        /// The unique identifier for the rule to exclude from the rule group.
        public var ruleId: Swift.String?

        public init(
            ruleId: Swift.String? = nil
        )
        {
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes {
    /// Details about an override action for a rule.
    public struct WafOverrideAction {
        /// COUNT overrides the action specified by the individual rule within a RuleGroup . If set to NONE, the rule's action takes place.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Details for a rule in an WAF web ACL.
    public struct AwsWafWebAclRule {
        /// Specifies the action that CloudFront or WAF takes when a web request matches the conditions in the rule.
        public var action: SecurityHubClientTypes.WafAction?
        /// Rules to exclude from a rule group.
        public var excludedRules: [SecurityHubClientTypes.WafExcludedRule]?
        /// Use the OverrideAction to test your RuleGroup. Any rule in a RuleGroup can potentially block a request. If you set the OverrideAction to None, the RuleGroup blocks a request if any individual rule in the RuleGroup matches the request and is configured to block that request. However, if you first want to test the RuleGroup, set the OverrideAction to Count. The RuleGroup then overrides any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests are counted. ActivatedRule|OverrideAction applies only when updating or adding a RuleGroup to a web ACL. In this case you do not use ActivatedRuleAction. For all other update requests, ActivatedRuleAction is used instead of ActivatedRuleOverrideAction.
        public var overrideAction: SecurityHubClientTypes.WafOverrideAction?
        /// Specifies the order in which the rules in a web ACL are evaluated. Rules with a lower value for Priority are evaluated before rules with a higher value. The value must be a unique integer. If you add multiple rules to a web ACL, the values do not need to be consecutive.
        public var priority: Swift.Int?
        /// The identifier for a rule.
        public var ruleId: Swift.String?
        /// The rule type. Valid values: REGULAR | RATE_BASED | GROUP The default is REGULAR.
        public var type: Swift.String?

        public init(
            action: SecurityHubClientTypes.WafAction? = nil,
            excludedRules: [SecurityHubClientTypes.WafExcludedRule]? = nil,
            overrideAction: SecurityHubClientTypes.WafOverrideAction? = nil,
            priority: Swift.Int? = nil,
            ruleId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.action = action
            self.excludedRules = excludedRules
            self.overrideAction = overrideAction
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about an WAF web access control list (web ACL).
    public struct AwsWafWebAclDetails {
        /// The action to perform if none of the rules contained in the web ACL match.
        public var defaultAction: Swift.String?
        /// A friendly name or description of the web ACL. You can't change the name of a web ACL after you create it.
        public var name: Swift.String?
        /// An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.
        public var rules: [SecurityHubClientTypes.AwsWafWebAclRule]?
        /// A unique identifier for a web ACL.
        public var webAclId: Swift.String?

        public init(
            defaultAction: Swift.String? = nil,
            name: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafWebAclRule]? = nil,
            webAclId: Swift.String? = nil
        )
        {
            self.defaultAction = defaultAction
            self.name = name
            self.rules = rules
            self.webAclId = webAclId
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about the encryption configuration for X-Ray.
    public struct AwsXrayEncryptionConfigDetails {
        /// The identifier of the KMS key that is used for encryption. Provided if Type is KMS.
        public var keyId: Swift.String?
        /// The current status of the encryption configuration. Valid values are ACTIVE or UPDATING. When Status is equal to UPDATING, X-Ray might use both the old and new encryption.
        public var status: Swift.String?
        /// The type of encryption. KMS indicates that the encryption uses KMS keys. NONE indicates the default encryption.
        public var type: Swift.String?

        public init(
            keyId: Swift.String? = nil,
            status: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.keyId = keyId
            self.status = status
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// Describes the mounting of a volume in a container.
    public struct VolumeMount {
        /// The path in the container at which the volume should be mounted.
        public var mountPath: Swift.String?
        /// The name of the volume.
        public var name: Swift.String?

        public init(
            mountPath: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.mountPath = mountPath
            self.name = name
        }
    }

}

extension SecurityHubClientTypes {
    /// Container details related to a finding.
    public struct ContainerDetails {
        /// The runtime of the container.
        public var containerRuntime: Swift.String?
        /// The identifier of the container image related to a finding.
        public var imageId: Swift.String?
        /// The name of the container image related to a finding.
        public var imageName: Swift.String?
        /// Indicates when the container started. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var launchedAt: Swift.String?
        /// The name of the container related to a finding.
        public var name: Swift.String?
        /// When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user).
        public var privileged: Swift.Bool?
        /// Provides information about the mounting of a volume in a container.
        public var volumeMounts: [SecurityHubClientTypes.VolumeMount]?

        public init(
            containerRuntime: Swift.String? = nil,
            imageId: Swift.String? = nil,
            imageName: Swift.String? = nil,
            launchedAt: Swift.String? = nil,
            name: Swift.String? = nil,
            privileged: Swift.Bool? = nil,
            volumeMounts: [SecurityHubClientTypes.VolumeMount]? = nil
        )
        {
            self.containerRuntime = containerRuntime
            self.imageId = imageId
            self.imageName = imageName
            self.launchedAt = launchedAt
            self.name = name
            self.privileged = privileged
            self.volumeMounts = volumeMounts
        }
    }

}

extension SecurityHubClientTypes {
    /// Additional details about a resource related to a finding. To provide the details, use the object that corresponds to the resource type. For example, if the resource type is AwsEc2Instance, then you use the AwsEc2Instance object to provide the details. If the type-specific object does not contain all of the fields you want to populate, then you use the Other object to populate those additional fields. You also use the Other object to populate the details when the selected type does not have a corresponding object.
    public struct ResourceDetails {
        /// Provides details about AppSync message broker. A message broker allows software applications and components to communicate using various programming languages, operating systems, and formal messaging protocols.
        public var awsAmazonMqBroker: SecurityHubClientTypes.AwsAmazonMqBrokerDetails?
        /// Provides information about a REST API in version 1 of Amazon API Gateway.
        public var awsApiGatewayRestApi: SecurityHubClientTypes.AwsApiGatewayRestApiDetails?
        /// Provides information about a version 1 Amazon API Gateway stage.
        public var awsApiGatewayStage: SecurityHubClientTypes.AwsApiGatewayStageDetails?
        /// Provides information about a version 2 API in Amazon API Gateway.
        public var awsApiGatewayV2Api: SecurityHubClientTypes.AwsApiGatewayV2ApiDetails?
        /// Provides information about a version 2 stage for Amazon API Gateway.
        public var awsApiGatewayV2Stage: SecurityHubClientTypes.AwsApiGatewayV2StageDetails?
        /// Provides details about an AppSync Graph QL API, which lets you query multiple databases, microservices, and APIs from a single GraphQL endpoint.
        public var awsAppSyncGraphQlApi: SecurityHubClientTypes.AwsAppSyncGraphQlApiDetails?
        /// Provides information about an Amazon Athena workgroup. A workgroup helps you separate users, teams, applications, or workloads. It also helps you set limits on data processing and track costs.
        public var awsAthenaWorkGroup: SecurityHubClientTypes.AwsAthenaWorkGroupDetails?
        /// Details for an autoscaling group.
        public var awsAutoScalingAutoScalingGroup: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails?
        /// Provides details about a launch configuration.
        public var awsAutoScalingLaunchConfiguration: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails?
        /// Provides details about an Backup backup plan.
        public var awsBackupBackupPlan: SecurityHubClientTypes.AwsBackupBackupPlanDetails?
        /// Provides details about an Backup backup vault.
        public var awsBackupBackupVault: SecurityHubClientTypes.AwsBackupBackupVaultDetails?
        /// Provides details about an Backup backup, or recovery point.
        public var awsBackupRecoveryPoint: SecurityHubClientTypes.AwsBackupRecoveryPointDetails?
        /// Provides details about an Certificate Manager certificate.
        public var awsCertificateManagerCertificate: SecurityHubClientTypes.AwsCertificateManagerCertificateDetails?
        /// Details about an CloudFormation stack. A stack is a collection of Amazon Web Services resources that you can manage as a single unit.
        public var awsCloudFormationStack: SecurityHubClientTypes.AwsCloudFormationStackDetails?
        /// Details about a CloudFront distribution.
        public var awsCloudFrontDistribution: SecurityHubClientTypes.AwsCloudFrontDistributionDetails?
        /// Provides details about a CloudTrail trail.
        public var awsCloudTrailTrail: SecurityHubClientTypes.AwsCloudTrailTrailDetails?
        /// Details about an Amazon CloudWatch alarm. An alarm allows you to monitor and receive alerts about your Amazon Web Services resources and applications across multiple Regions.
        public var awsCloudWatchAlarm: SecurityHubClientTypes.AwsCloudWatchAlarmDetails?
        /// Details for an CodeBuild project.
        public var awsCodeBuildProject: SecurityHubClientTypes.AwsCodeBuildProjectDetails?
        /// Provides details about an Database Migration Service (DMS) endpoint. An endpoint provides connection, data store type, and location information about your data store.
        public var awsDmsEndpoint: SecurityHubClientTypes.AwsDmsEndpointDetails?
        /// Provides details about an DMS replication instance. DMS uses a replication instance to connect to your source data store, read the source data, and format the data for consumption by the target data store.
        public var awsDmsReplicationInstance: SecurityHubClientTypes.AwsDmsReplicationInstanceDetails?
        /// Provides details about an DMS replication task. A replication task moves a set of data from the source endpoint to the target endpoint.
        public var awsDmsReplicationTask: SecurityHubClientTypes.AwsDmsReplicationTaskDetails?
        /// Details about a DynamoDB table.
        public var awsDynamoDbTable: SecurityHubClientTypes.AwsDynamoDbTableDetails?
        /// Provides details about an Client VPN endpoint. A Client VPN endpoint is the resource that you create and configure to enable and manage client VPN sessions. It's the termination point for all client VPN sessions.
        public var awsEc2ClientVpnEndpoint: SecurityHubClientTypes.AwsEc2ClientVpnEndpointDetails?
        /// Details about an Elastic IP address.
        public var awsEc2Eip: SecurityHubClientTypes.AwsEc2EipDetails?
        /// Details about an EC2 instance related to a finding.
        public var awsEc2Instance: SecurityHubClientTypes.AwsEc2InstanceDetails?
        /// Specifies the properties for creating an Amazon Elastic Compute Cloud (Amazon EC2) launch template.
        public var awsEc2LaunchTemplate: SecurityHubClientTypes.AwsEc2LaunchTemplateDetails?
        /// Details about an EC2 network access control list (ACL).
        public var awsEc2NetworkAcl: SecurityHubClientTypes.AwsEc2NetworkAclDetails?
        /// Details for an EC2 network interface.
        public var awsEc2NetworkInterface: SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails?
        /// Provides details about a route table. A route table contains a set of rules, called routes, that determine where to direct network traffic from your subnet or gateway.
        public var awsEc2RouteTable: SecurityHubClientTypes.AwsEc2RouteTableDetails?
        /// Details for an EC2 security group.
        public var awsEc2SecurityGroup: SecurityHubClientTypes.AwsEc2SecurityGroupDetails?
        /// Details about a subnet in Amazon EC2.
        public var awsEc2Subnet: SecurityHubClientTypes.AwsEc2SubnetDetails?
        /// Details about an Amazon EC2 transit gateway that interconnects your virtual private clouds (VPC) and on-premises networks.
        public var awsEc2TransitGateway: SecurityHubClientTypes.AwsEc2TransitGatewayDetails?
        /// Details for an Amazon EC2 volume.
        public var awsEc2Volume: SecurityHubClientTypes.AwsEc2VolumeDetails?
        /// Details for an Amazon EC2 VPC.
        public var awsEc2Vpc: SecurityHubClientTypes.AwsEc2VpcDetails?
        /// Details about the service configuration for a VPC endpoint service.
        public var awsEc2VpcEndpointService: SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails?
        /// Details about an Amazon EC2 VPC peering connection. A VPC peering connection is a networking connection between two VPCs that enables you to route traffic between them privately.
        public var awsEc2VpcPeeringConnection: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails?
        /// Details about an Amazon EC2 VPN connection.
        public var awsEc2VpnConnection: SecurityHubClientTypes.AwsEc2VpnConnectionDetails?
        /// Information about an Amazon ECR image.
        public var awsEcrContainerImage: SecurityHubClientTypes.AwsEcrContainerImageDetails?
        /// Information about an Amazon Elastic Container Registry repository.
        public var awsEcrRepository: SecurityHubClientTypes.AwsEcrRepositoryDetails?
        /// Details about an Amazon ECS cluster.
        public var awsEcsCluster: SecurityHubClientTypes.AwsEcsClusterDetails?
        /// Provides information about a Docker container that's part of a task.
        public var awsEcsContainer: SecurityHubClientTypes.AwsEcsContainerDetails?
        /// Details about a service within an ECS cluster.
        public var awsEcsService: SecurityHubClientTypes.AwsEcsServiceDetails?
        /// Details about a task in a cluster.
        public var awsEcsTask: SecurityHubClientTypes.AwsEcsTaskDetails?
        /// Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.
        public var awsEcsTaskDefinition: SecurityHubClientTypes.AwsEcsTaskDefinitionDetails?
        /// Details about an Amazon EFS access point. An access point is an application-specific view into an EFS file system that applies an operating system user and group, and a file system path, to any file system request made through the access point.
        public var awsEfsAccessPoint: SecurityHubClientTypes.AwsEfsAccessPointDetails?
        /// Details about an Amazon EKS cluster.
        public var awsEksCluster: SecurityHubClientTypes.AwsEksClusterDetails?
        /// Details about an Elastic Beanstalk environment.
        public var awsElasticBeanstalkEnvironment: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails?
        /// Details for an Elasticsearch domain.
        public var awsElasticsearchDomain: SecurityHubClientTypes.AwsElasticsearchDomainDetails?
        /// Contains details about a Classic Load Balancer.
        public var awsElbLoadBalancer: SecurityHubClientTypes.AwsElbLoadBalancerDetails?
        /// Details about a load balancer.
        public var awsElbv2LoadBalancer: SecurityHubClientTypes.AwsElbv2LoadBalancerDetails?
        /// A schema defines the structure of events that are sent to Amazon EventBridge. Schema registries are containers for schemas. They collect and organize schemas so that your schemas are in logical groups.
        public var awsEventSchemasRegistry: SecurityHubClientTypes.AwsEventSchemasRegistryDetails?
        /// Provides details about an Amazon EventBridge global endpoint. The endpoint can improve your application’s availability by making it Regional-fault tolerant.
        public var awsEventsEndpoint: SecurityHubClientTypes.AwsEventsEndpointDetails?
        /// Provides details about Amazon EventBridge event bus for an endpoint. An event bus is a router that receives events and delivers them to zero or more destinations, or targets.
        public var awsEventsEventbus: SecurityHubClientTypes.AwsEventsEventbusDetails?
        /// Provides details about an Amazon GuardDuty detector. A detector is an object that represents the GuardDuty service. A detector is required for GuardDuty to become operational.
        public var awsGuardDutyDetector: SecurityHubClientTypes.AwsGuardDutyDetectorDetails?
        /// Details about an IAM access key related to a finding.
        public var awsIamAccessKey: SecurityHubClientTypes.AwsIamAccessKeyDetails?
        /// Contains details about an IAM group.
        public var awsIamGroup: SecurityHubClientTypes.AwsIamGroupDetails?
        /// Details about an IAM permissions policy.
        public var awsIamPolicy: SecurityHubClientTypes.AwsIamPolicyDetails?
        /// Details about an IAM role.
        public var awsIamRole: SecurityHubClientTypes.AwsIamRoleDetails?
        /// Details about an IAM user.
        public var awsIamUser: SecurityHubClientTypes.AwsIamUserDetails?
        /// Details about an Amazon Kinesis data stream.
        public var awsKinesisStream: SecurityHubClientTypes.AwsKinesisStreamDetails?
        /// Details about an KMS key.
        public var awsKmsKey: SecurityHubClientTypes.AwsKmsKeyDetails?
        /// Details about a Lambda function.
        public var awsLambdaFunction: SecurityHubClientTypes.AwsLambdaFunctionDetails?
        /// Details for a Lambda layer version.
        public var awsLambdaLayerVersion: SecurityHubClientTypes.AwsLambdaLayerVersionDetails?
        /// Provides details about an Amazon Managed Streaming for Apache Kafka (Amazon MSK) cluster.
        public var awsMskCluster: SecurityHubClientTypes.AwsMskClusterDetails?
        /// Details about an Network Firewall firewall.
        public var awsNetworkFirewallFirewall: SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails?
        /// Details about an Network Firewall firewall policy.
        public var awsNetworkFirewallFirewallPolicy: SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails?
        /// Details about an Network Firewall rule group.
        public var awsNetworkFirewallRuleGroup: SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails?
        /// Details about an Amazon OpenSearch Service domain.
        public var awsOpenSearchServiceDomain: SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails?
        /// Details about an Amazon RDS database cluster.
        public var awsRdsDbCluster: SecurityHubClientTypes.AwsRdsDbClusterDetails?
        /// Details about an Amazon RDS database cluster snapshot.
        public var awsRdsDbClusterSnapshot: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails?
        /// Details about an Amazon RDS database instance.
        public var awsRdsDbInstance: SecurityHubClientTypes.AwsRdsDbInstanceDetails?
        /// Details about an Amazon RDS DB security group.
        public var awsRdsDbSecurityGroup: SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails?
        /// Details about an Amazon RDS database snapshot.
        public var awsRdsDbSnapshot: SecurityHubClientTypes.AwsRdsDbSnapshotDetails?
        /// Details about an RDS event notification subscription.
        public var awsRdsEventSubscription: SecurityHubClientTypes.AwsRdsEventSubscriptionDetails?
        /// Contains details about an Amazon Redshift cluster.
        public var awsRedshiftCluster: SecurityHubClientTypes.AwsRedshiftClusterDetails?
        /// Provides details about an Amazon Route 53 hosted zone, including the four name servers assigned to the hosted zone. A hosted zone represents a collection of records that can be managed together, belonging to a single parent domain name.
        public var awsRoute53HostedZone: SecurityHubClientTypes.AwsRoute53HostedZoneDetails?
        /// Provides details about an Amazon Simple Storage Service (Amazon S3) access point. S3 access points are named network endpoints that are attached to S3 buckets that you can use to perform S3 object operations.
        public var awsS3AccessPoint: SecurityHubClientTypes.AwsS3AccessPointDetails?
        /// Details about the Amazon S3 Public Access Block configuration for an account.
        public var awsS3AccountPublicAccessBlock: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails?
        /// Details about an S3 bucket related to a finding.
        public var awsS3Bucket: SecurityHubClientTypes.AwsS3BucketDetails?
        /// Details about an S3 object related to a finding.
        public var awsS3Object: SecurityHubClientTypes.AwsS3ObjectDetails?
        /// Provides details about an Amazon SageMaker notebook instance.
        public var awsSageMakerNotebookInstance: SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails?
        /// Details about a Secrets Manager secret.
        public var awsSecretsManagerSecret: SecurityHubClientTypes.AwsSecretsManagerSecretDetails?
        /// Details about an SNS topic.
        public var awsSnsTopic: SecurityHubClientTypes.AwsSnsTopicDetails?
        /// Details about an SQS queue.
        public var awsSqsQueue: SecurityHubClientTypes.AwsSqsQueueDetails?
        /// Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.
        public var awsSsmPatchCompliance: SecurityHubClientTypes.AwsSsmPatchComplianceDetails?
        /// Provides details about an Step Functions state machine, which is a workflow consisting of a series of event-driven steps.
        public var awsStepFunctionStateMachine: SecurityHubClientTypes.AwsStepFunctionStateMachineDetails?
        /// Details about a rate-based rule for global resources.
        public var awsWafRateBasedRule: SecurityHubClientTypes.AwsWafRateBasedRuleDetails?
        /// Details about a rate-based rule for Regional resources.
        public var awsWafRegionalRateBasedRule: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails?
        /// Details about an WAF rule for Regional resources.
        public var awsWafRegionalRule: SecurityHubClientTypes.AwsWafRegionalRuleDetails?
        /// Details about an WAF rule group for Regional resources.
        public var awsWafRegionalRuleGroup: SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails?
        /// Details about an WAF web access control list (web ACL) for Regional resources.
        public var awsWafRegionalWebAcl: SecurityHubClientTypes.AwsWafRegionalWebAclDetails?
        /// Details about an WAF rule for global resources.
        public var awsWafRule: SecurityHubClientTypes.AwsWafRuleDetails?
        /// Details about an WAF rule group for global resources.
        public var awsWafRuleGroup: SecurityHubClientTypes.AwsWafRuleGroupDetails?
        /// Details for an WAF web ACL.
        public var awsWafWebAcl: SecurityHubClientTypes.AwsWafWebAclDetails?
        /// Details about an WAFv2 rule group.
        public var awsWafv2RuleGroup: SecurityHubClientTypes.AwsWafv2RuleGroupDetails?
        /// Details about an WAFv2 web Access Control List (ACL).
        public var awsWafv2WebAcl: SecurityHubClientTypes.AwsWafv2WebAclDetails?
        /// Information about the encryption configuration for X-Ray.
        public var awsXrayEncryptionConfig: SecurityHubClientTypes.AwsXrayEncryptionConfigDetails?
        /// Details about a container resource related to a finding.
        public var container: SecurityHubClientTypes.ContainerDetails?
        /// Details about a resource that are not available in a type-specific details object. Use the Other object in the following cases.
        ///
        /// * The type-specific object does not contain all of the fields that you want to populate. In this case, first use the type-specific object to populate those fields. Use the Other object to populate the fields that are missing from the type-specific object.
        ///
        /// * The resource type does not have a corresponding object. This includes resources for which the type is Other.
        public var other: [Swift.String: Swift.String]?

        public init(
            awsAmazonMqBroker: SecurityHubClientTypes.AwsAmazonMqBrokerDetails? = nil,
            awsApiGatewayRestApi: SecurityHubClientTypes.AwsApiGatewayRestApiDetails? = nil,
            awsApiGatewayStage: SecurityHubClientTypes.AwsApiGatewayStageDetails? = nil,
            awsApiGatewayV2Api: SecurityHubClientTypes.AwsApiGatewayV2ApiDetails? = nil,
            awsApiGatewayV2Stage: SecurityHubClientTypes.AwsApiGatewayV2StageDetails? = nil,
            awsAppSyncGraphQlApi: SecurityHubClientTypes.AwsAppSyncGraphQlApiDetails? = nil,
            awsAthenaWorkGroup: SecurityHubClientTypes.AwsAthenaWorkGroupDetails? = nil,
            awsAutoScalingAutoScalingGroup: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails? = nil,
            awsAutoScalingLaunchConfiguration: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails? = nil,
            awsBackupBackupPlan: SecurityHubClientTypes.AwsBackupBackupPlanDetails? = nil,
            awsBackupBackupVault: SecurityHubClientTypes.AwsBackupBackupVaultDetails? = nil,
            awsBackupRecoveryPoint: SecurityHubClientTypes.AwsBackupRecoveryPointDetails? = nil,
            awsCertificateManagerCertificate: SecurityHubClientTypes.AwsCertificateManagerCertificateDetails? = nil,
            awsCloudFormationStack: SecurityHubClientTypes.AwsCloudFormationStackDetails? = nil,
            awsCloudFrontDistribution: SecurityHubClientTypes.AwsCloudFrontDistributionDetails? = nil,
            awsCloudTrailTrail: SecurityHubClientTypes.AwsCloudTrailTrailDetails? = nil,
            awsCloudWatchAlarm: SecurityHubClientTypes.AwsCloudWatchAlarmDetails? = nil,
            awsCodeBuildProject: SecurityHubClientTypes.AwsCodeBuildProjectDetails? = nil,
            awsDmsEndpoint: SecurityHubClientTypes.AwsDmsEndpointDetails? = nil,
            awsDmsReplicationInstance: SecurityHubClientTypes.AwsDmsReplicationInstanceDetails? = nil,
            awsDmsReplicationTask: SecurityHubClientTypes.AwsDmsReplicationTaskDetails? = nil,
            awsDynamoDbTable: SecurityHubClientTypes.AwsDynamoDbTableDetails? = nil,
            awsEc2ClientVpnEndpoint: SecurityHubClientTypes.AwsEc2ClientVpnEndpointDetails? = nil,
            awsEc2Eip: SecurityHubClientTypes.AwsEc2EipDetails? = nil,
            awsEc2Instance: SecurityHubClientTypes.AwsEc2InstanceDetails? = nil,
            awsEc2LaunchTemplate: SecurityHubClientTypes.AwsEc2LaunchTemplateDetails? = nil,
            awsEc2NetworkAcl: SecurityHubClientTypes.AwsEc2NetworkAclDetails? = nil,
            awsEc2NetworkInterface: SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails? = nil,
            awsEc2RouteTable: SecurityHubClientTypes.AwsEc2RouteTableDetails? = nil,
            awsEc2SecurityGroup: SecurityHubClientTypes.AwsEc2SecurityGroupDetails? = nil,
            awsEc2Subnet: SecurityHubClientTypes.AwsEc2SubnetDetails? = nil,
            awsEc2TransitGateway: SecurityHubClientTypes.AwsEc2TransitGatewayDetails? = nil,
            awsEc2Volume: SecurityHubClientTypes.AwsEc2VolumeDetails? = nil,
            awsEc2Vpc: SecurityHubClientTypes.AwsEc2VpcDetails? = nil,
            awsEc2VpcEndpointService: SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails? = nil,
            awsEc2VpcPeeringConnection: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails? = nil,
            awsEc2VpnConnection: SecurityHubClientTypes.AwsEc2VpnConnectionDetails? = nil,
            awsEcrContainerImage: SecurityHubClientTypes.AwsEcrContainerImageDetails? = nil,
            awsEcrRepository: SecurityHubClientTypes.AwsEcrRepositoryDetails? = nil,
            awsEcsCluster: SecurityHubClientTypes.AwsEcsClusterDetails? = nil,
            awsEcsContainer: SecurityHubClientTypes.AwsEcsContainerDetails? = nil,
            awsEcsService: SecurityHubClientTypes.AwsEcsServiceDetails? = nil,
            awsEcsTask: SecurityHubClientTypes.AwsEcsTaskDetails? = nil,
            awsEcsTaskDefinition: SecurityHubClientTypes.AwsEcsTaskDefinitionDetails? = nil,
            awsEfsAccessPoint: SecurityHubClientTypes.AwsEfsAccessPointDetails? = nil,
            awsEksCluster: SecurityHubClientTypes.AwsEksClusterDetails? = nil,
            awsElasticBeanstalkEnvironment: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails? = nil,
            awsElasticsearchDomain: SecurityHubClientTypes.AwsElasticsearchDomainDetails? = nil,
            awsElbLoadBalancer: SecurityHubClientTypes.AwsElbLoadBalancerDetails? = nil,
            awsElbv2LoadBalancer: SecurityHubClientTypes.AwsElbv2LoadBalancerDetails? = nil,
            awsEventSchemasRegistry: SecurityHubClientTypes.AwsEventSchemasRegistryDetails? = nil,
            awsEventsEndpoint: SecurityHubClientTypes.AwsEventsEndpointDetails? = nil,
            awsEventsEventbus: SecurityHubClientTypes.AwsEventsEventbusDetails? = nil,
            awsGuardDutyDetector: SecurityHubClientTypes.AwsGuardDutyDetectorDetails? = nil,
            awsIamAccessKey: SecurityHubClientTypes.AwsIamAccessKeyDetails? = nil,
            awsIamGroup: SecurityHubClientTypes.AwsIamGroupDetails? = nil,
            awsIamPolicy: SecurityHubClientTypes.AwsIamPolicyDetails? = nil,
            awsIamRole: SecurityHubClientTypes.AwsIamRoleDetails? = nil,
            awsIamUser: SecurityHubClientTypes.AwsIamUserDetails? = nil,
            awsKinesisStream: SecurityHubClientTypes.AwsKinesisStreamDetails? = nil,
            awsKmsKey: SecurityHubClientTypes.AwsKmsKeyDetails? = nil,
            awsLambdaFunction: SecurityHubClientTypes.AwsLambdaFunctionDetails? = nil,
            awsLambdaLayerVersion: SecurityHubClientTypes.AwsLambdaLayerVersionDetails? = nil,
            awsMskCluster: SecurityHubClientTypes.AwsMskClusterDetails? = nil,
            awsNetworkFirewallFirewall: SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails? = nil,
            awsNetworkFirewallFirewallPolicy: SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails? = nil,
            awsNetworkFirewallRuleGroup: SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails? = nil,
            awsOpenSearchServiceDomain: SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails? = nil,
            awsRdsDbCluster: SecurityHubClientTypes.AwsRdsDbClusterDetails? = nil,
            awsRdsDbClusterSnapshot: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails? = nil,
            awsRdsDbInstance: SecurityHubClientTypes.AwsRdsDbInstanceDetails? = nil,
            awsRdsDbSecurityGroup: SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails? = nil,
            awsRdsDbSnapshot: SecurityHubClientTypes.AwsRdsDbSnapshotDetails? = nil,
            awsRdsEventSubscription: SecurityHubClientTypes.AwsRdsEventSubscriptionDetails? = nil,
            awsRedshiftCluster: SecurityHubClientTypes.AwsRedshiftClusterDetails? = nil,
            awsRoute53HostedZone: SecurityHubClientTypes.AwsRoute53HostedZoneDetails? = nil,
            awsS3AccessPoint: SecurityHubClientTypes.AwsS3AccessPointDetails? = nil,
            awsS3AccountPublicAccessBlock: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails? = nil,
            awsS3Bucket: SecurityHubClientTypes.AwsS3BucketDetails? = nil,
            awsS3Object: SecurityHubClientTypes.AwsS3ObjectDetails? = nil,
            awsSageMakerNotebookInstance: SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails? = nil,
            awsSecretsManagerSecret: SecurityHubClientTypes.AwsSecretsManagerSecretDetails? = nil,
            awsSnsTopic: SecurityHubClientTypes.AwsSnsTopicDetails? = nil,
            awsSqsQueue: SecurityHubClientTypes.AwsSqsQueueDetails? = nil,
            awsSsmPatchCompliance: SecurityHubClientTypes.AwsSsmPatchComplianceDetails? = nil,
            awsStepFunctionStateMachine: SecurityHubClientTypes.AwsStepFunctionStateMachineDetails? = nil,
            awsWafRateBasedRule: SecurityHubClientTypes.AwsWafRateBasedRuleDetails? = nil,
            awsWafRegionalRateBasedRule: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails? = nil,
            awsWafRegionalRule: SecurityHubClientTypes.AwsWafRegionalRuleDetails? = nil,
            awsWafRegionalRuleGroup: SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails? = nil,
            awsWafRegionalWebAcl: SecurityHubClientTypes.AwsWafRegionalWebAclDetails? = nil,
            awsWafRule: SecurityHubClientTypes.AwsWafRuleDetails? = nil,
            awsWafRuleGroup: SecurityHubClientTypes.AwsWafRuleGroupDetails? = nil,
            awsWafWebAcl: SecurityHubClientTypes.AwsWafWebAclDetails? = nil,
            awsWafv2RuleGroup: SecurityHubClientTypes.AwsWafv2RuleGroupDetails? = nil,
            awsWafv2WebAcl: SecurityHubClientTypes.AwsWafv2WebAclDetails? = nil,
            awsXrayEncryptionConfig: SecurityHubClientTypes.AwsXrayEncryptionConfigDetails? = nil,
            container: SecurityHubClientTypes.ContainerDetails? = nil,
            other: [Swift.String: Swift.String]? = nil
        )
        {
            self.awsAmazonMqBroker = awsAmazonMqBroker
            self.awsApiGatewayRestApi = awsApiGatewayRestApi
            self.awsApiGatewayStage = awsApiGatewayStage
            self.awsApiGatewayV2Api = awsApiGatewayV2Api
            self.awsApiGatewayV2Stage = awsApiGatewayV2Stage
            self.awsAppSyncGraphQlApi = awsAppSyncGraphQlApi
            self.awsAthenaWorkGroup = awsAthenaWorkGroup
            self.awsAutoScalingAutoScalingGroup = awsAutoScalingAutoScalingGroup
            self.awsAutoScalingLaunchConfiguration = awsAutoScalingLaunchConfiguration
            self.awsBackupBackupPlan = awsBackupBackupPlan
            self.awsBackupBackupVault = awsBackupBackupVault
            self.awsBackupRecoveryPoint = awsBackupRecoveryPoint
            self.awsCertificateManagerCertificate = awsCertificateManagerCertificate
            self.awsCloudFormationStack = awsCloudFormationStack
            self.awsCloudFrontDistribution = awsCloudFrontDistribution
            self.awsCloudTrailTrail = awsCloudTrailTrail
            self.awsCloudWatchAlarm = awsCloudWatchAlarm
            self.awsCodeBuildProject = awsCodeBuildProject
            self.awsDmsEndpoint = awsDmsEndpoint
            self.awsDmsReplicationInstance = awsDmsReplicationInstance
            self.awsDmsReplicationTask = awsDmsReplicationTask
            self.awsDynamoDbTable = awsDynamoDbTable
            self.awsEc2ClientVpnEndpoint = awsEc2ClientVpnEndpoint
            self.awsEc2Eip = awsEc2Eip
            self.awsEc2Instance = awsEc2Instance
            self.awsEc2LaunchTemplate = awsEc2LaunchTemplate
            self.awsEc2NetworkAcl = awsEc2NetworkAcl
            self.awsEc2NetworkInterface = awsEc2NetworkInterface
            self.awsEc2RouteTable = awsEc2RouteTable
            self.awsEc2SecurityGroup = awsEc2SecurityGroup
            self.awsEc2Subnet = awsEc2Subnet
            self.awsEc2TransitGateway = awsEc2TransitGateway
            self.awsEc2Volume = awsEc2Volume
            self.awsEc2Vpc = awsEc2Vpc
            self.awsEc2VpcEndpointService = awsEc2VpcEndpointService
            self.awsEc2VpcPeeringConnection = awsEc2VpcPeeringConnection
            self.awsEc2VpnConnection = awsEc2VpnConnection
            self.awsEcrContainerImage = awsEcrContainerImage
            self.awsEcrRepository = awsEcrRepository
            self.awsEcsCluster = awsEcsCluster
            self.awsEcsContainer = awsEcsContainer
            self.awsEcsService = awsEcsService
            self.awsEcsTask = awsEcsTask
            self.awsEcsTaskDefinition = awsEcsTaskDefinition
            self.awsEfsAccessPoint = awsEfsAccessPoint
            self.awsEksCluster = awsEksCluster
            self.awsElasticBeanstalkEnvironment = awsElasticBeanstalkEnvironment
            self.awsElasticsearchDomain = awsElasticsearchDomain
            self.awsElbLoadBalancer = awsElbLoadBalancer
            self.awsElbv2LoadBalancer = awsElbv2LoadBalancer
            self.awsEventSchemasRegistry = awsEventSchemasRegistry
            self.awsEventsEndpoint = awsEventsEndpoint
            self.awsEventsEventbus = awsEventsEventbus
            self.awsGuardDutyDetector = awsGuardDutyDetector
            self.awsIamAccessKey = awsIamAccessKey
            self.awsIamGroup = awsIamGroup
            self.awsIamPolicy = awsIamPolicy
            self.awsIamRole = awsIamRole
            self.awsIamUser = awsIamUser
            self.awsKinesisStream = awsKinesisStream
            self.awsKmsKey = awsKmsKey
            self.awsLambdaFunction = awsLambdaFunction
            self.awsLambdaLayerVersion = awsLambdaLayerVersion
            self.awsMskCluster = awsMskCluster
            self.awsNetworkFirewallFirewall = awsNetworkFirewallFirewall
            self.awsNetworkFirewallFirewallPolicy = awsNetworkFirewallFirewallPolicy
            self.awsNetworkFirewallRuleGroup = awsNetworkFirewallRuleGroup
            self.awsOpenSearchServiceDomain = awsOpenSearchServiceDomain
            self.awsRdsDbCluster = awsRdsDbCluster
            self.awsRdsDbClusterSnapshot = awsRdsDbClusterSnapshot
            self.awsRdsDbInstance = awsRdsDbInstance
            self.awsRdsDbSecurityGroup = awsRdsDbSecurityGroup
            self.awsRdsDbSnapshot = awsRdsDbSnapshot
            self.awsRdsEventSubscription = awsRdsEventSubscription
            self.awsRedshiftCluster = awsRedshiftCluster
            self.awsRoute53HostedZone = awsRoute53HostedZone
            self.awsS3AccessPoint = awsS3AccessPoint
            self.awsS3AccountPublicAccessBlock = awsS3AccountPublicAccessBlock
            self.awsS3Bucket = awsS3Bucket
            self.awsS3Object = awsS3Object
            self.awsSageMakerNotebookInstance = awsSageMakerNotebookInstance
            self.awsSecretsManagerSecret = awsSecretsManagerSecret
            self.awsSnsTopic = awsSnsTopic
            self.awsSqsQueue = awsSqsQueue
            self.awsSsmPatchCompliance = awsSsmPatchCompliance
            self.awsStepFunctionStateMachine = awsStepFunctionStateMachine
            self.awsWafRateBasedRule = awsWafRateBasedRule
            self.awsWafRegionalRateBasedRule = awsWafRegionalRateBasedRule
            self.awsWafRegionalRule = awsWafRegionalRule
            self.awsWafRegionalRuleGroup = awsWafRegionalRuleGroup
            self.awsWafRegionalWebAcl = awsWafRegionalWebAcl
            self.awsWafRule = awsWafRule
            self.awsWafRuleGroup = awsWafRuleGroup
            self.awsWafWebAcl = awsWafWebAcl
            self.awsWafv2RuleGroup = awsWafv2RuleGroup
            self.awsWafv2WebAcl = awsWafv2WebAcl
            self.awsXrayEncryptionConfig = awsXrayEncryptionConfig
            self.container = container
            self.other = other
        }
    }

}

extension SecurityHubClientTypes {

    public enum Partition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case awsCn
        case awsUsGov
        case sdkUnknown(Swift.String)

        public static var allCases: [Partition] {
            return [
                .aws,
                .awsCn,
                .awsUsGov
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "aws"
            case .awsCn: return "aws-cn"
            case .awsUsGov: return "aws-us-gov"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A resource related to a finding.
    public struct Resource {
        /// The Amazon Resource Name (ARN) of the application that is related to a finding.
        public var applicationArn: Swift.String?
        /// The name of the application that is related to a finding.
        public var applicationName: Swift.String?
        /// Contains information about sensitive data that was detected on the resource.
        public var dataClassification: SecurityHubClientTypes.DataClassificationDetails?
        /// Additional details about the resource related to a finding.
        public var details: SecurityHubClientTypes.ResourceDetails?
        /// The canonical identifier for the given resource type.
        /// This member is required.
        public var id: Swift.String?
        /// The canonical Amazon Web Services partition name that the Region is assigned to.
        public var partition: SecurityHubClientTypes.Partition?
        /// The canonical Amazon Web Services external Region name where this resource is located. Length Constraints: Minimum length of 1. Maximum length of 16.
        public var region: Swift.String?
        /// Identifies the role of the resource in the finding. A resource is either the actor or target of the finding activity,
        public var resourceRole: Swift.String?
        /// A list of Amazon Web Services tags associated with a resource at the time the finding was processed. Tags must follow [Amazon Web Services tag naming limits and requirements](https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions).
        public var tags: [Swift.String: Swift.String]?
        /// The type of the resource that details are provided for. If possible, set Type to one of the supported resource types. For example, if the resource is an EC2 instance, then set Type to AwsEc2Instance. If the resource does not match any of the provided types, then set Type to Other. Length Constraints: Minimum length of 1. Maximum length of 256.
        /// This member is required.
        public var type: Swift.String?

        public init(
            applicationArn: Swift.String? = nil,
            applicationName: Swift.String? = nil,
            dataClassification: SecurityHubClientTypes.DataClassificationDetails? = nil,
            details: SecurityHubClientTypes.ResourceDetails? = nil,
            id: Swift.String? = nil,
            partition: SecurityHubClientTypes.Partition? = nil,
            region: Swift.String? = nil,
            resourceRole: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.applicationArn = applicationArn
            self.applicationName = applicationName
            self.dataClassification = dataClassification
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.resourceRole = resourceRole
            self.tags = tags
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// The severity of the finding. The finding provider can provide the initial severity. The finding provider can only update the severity if it hasn't been updated using BatchUpdateFindings. The finding must have either Label or Normalized populated. If only one of these attributes is populated, then Security Hub automatically populates the other one. If neither attribute is populated, then the finding is invalid. Label is the preferred attribute.
    public struct Severity {
        /// The severity value of the finding. The allowed values are the following.
        ///
        /// * INFORMATIONAL - No issue was found.
        ///
        /// * LOW - The issue does not require action on its own.
        ///
        /// * MEDIUM - The issue must be addressed but not urgently.
        ///
        /// * HIGH - The issue must be addressed as a priority.
        ///
        /// * CRITICAL - The issue must be remediated immediately to avoid it escalating.
        ///
        ///
        /// If you provide Normalized and do not provide Label, then Label is set automatically as follows.
        ///
        /// * 0 - INFORMATIONAL
        ///
        /// * 1–39 - LOW
        ///
        /// * 40–69 - MEDIUM
        ///
        /// * 70–89 - HIGH
        ///
        /// * 90–100 - CRITICAL
        public var label: SecurityHubClientTypes.SeverityLabel?
        /// Deprecated. The normalized severity of a finding. Instead of providing Normalized, provide Label. The value of Normalized can be an integer between 0 and 100. If you provide Label and do not provide Normalized, then Normalized is set automatically as follows.
        ///
        /// * INFORMATIONAL - 0
        ///
        /// * LOW - 1
        ///
        /// * MEDIUM - 40
        ///
        /// * HIGH - 70
        ///
        /// * CRITICAL - 90
        public var normalized: Swift.Int?
        /// The native severity from the finding product that generated the finding. Length Constraints: Minimum length of 1. Maximum length of 64.
        public var original: Swift.String?
        /// Deprecated. This attribute isn't included in findings. Instead of providing Product, provide Original. The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.
        public var product: Swift.Double?

        public init(
            label: SecurityHubClientTypes.SeverityLabel? = nil,
            normalized: Swift.Int? = nil,
            original: Swift.String? = nil,
            product: Swift.Double? = nil
        )
        {
            self.label = label
            self.normalized = normalized
            self.original = original
            self.product = product
        }
    }

}

extension SecurityHubClientTypes {

    public enum ThreatIntelIndicatorCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case backdoor
        case cardStealer
        case commandAndControl
        case dropSite
        case exploitSite
        case keylogger
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelIndicatorCategory] {
            return [
                .backdoor,
                .cardStealer,
                .commandAndControl,
                .dropSite,
                .exploitSite,
                .keylogger
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .backdoor: return "BACKDOOR"
            case .cardStealer: return "CARD_STEALER"
            case .commandAndControl: return "COMMAND_AND_CONTROL"
            case .dropSite: return "DROP_SITE"
            case .exploitSite: return "EXPLOIT_SITE"
            case .keylogger: return "KEYLOGGER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum ThreatIntelIndicatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case domain
        case emailAddress
        case hashMd5
        case hashSha1
        case hashSha256
        case hashSha512
        case ipv4Address
        case ipv6Address
        case mutex
        case process
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelIndicatorType] {
            return [
                .domain,
                .emailAddress,
                .hashMd5,
                .hashSha1,
                .hashSha256,
                .hashSha512,
                .ipv4Address,
                .ipv6Address,
                .mutex,
                .process,
                .url
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .domain: return "DOMAIN"
            case .emailAddress: return "EMAIL_ADDRESS"
            case .hashMd5: return "HASH_MD5"
            case .hashSha1: return "HASH_SHA1"
            case .hashSha256: return "HASH_SHA256"
            case .hashSha512: return "HASH_SHA512"
            case .ipv4Address: return "IPV4_ADDRESS"
            case .ipv6Address: return "IPV6_ADDRESS"
            case .mutex: return "MUTEX"
            case .process: return "PROCESS"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Details about the threat intelligence related to a finding.
    public struct ThreatIntelIndicator {
        /// The category of a threat intelligence indicator.
        public var category: SecurityHubClientTypes.ThreatIntelIndicatorCategory?
        /// Indicates when the most recent instance of a threat intelligence indicator was observed. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastObservedAt: Swift.String?
        /// The source of the threat intelligence indicator. Length Constraints: Minimum of 1 length. Maximum of 64 length.
        public var source: Swift.String?
        /// The URL to the page or site where you can get more information about the threat intelligence indicator.
        public var sourceUrl: Swift.String?
        /// The type of threat intelligence indicator.
        public var type: SecurityHubClientTypes.ThreatIntelIndicatorType?
        /// The value of a threat intelligence indicator. Length Constraints: Minimum of 1 length. Maximum of 512 length.
        public var value: Swift.String?

        public init(
            category: SecurityHubClientTypes.ThreatIntelIndicatorCategory? = nil,
            lastObservedAt: Swift.String? = nil,
            source: Swift.String? = nil,
            sourceUrl: Swift.String? = nil,
            type: SecurityHubClientTypes.ThreatIntelIndicatorType? = nil,
            value: Swift.String? = nil
        )
        {
            self.category = category
            self.lastObservedAt = lastObservedAt
            self.source = source
            self.sourceUrl = sourceUrl
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the file paths that were affected by the threat.
    public struct FilePaths {
        /// The name of the infected or suspicious file corresponding to the hash. Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public var fileName: Swift.String?
        /// Path to the infected or suspicious file on the resource it was detected on. Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public var filePath: Swift.String?
        /// The hash value for the infected or suspicious file. Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public var hash: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource on which the threat was detected. Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public var resourceId: Swift.String?

        public init(
            fileName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            hash: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.fileName = fileName
            self.filePath = filePath
            self.hash = hash
            self.resourceId = resourceId
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about the threat detected in a security finding and the file paths that were affected by the threat.
    public struct Threat {
        /// Provides information about the file paths that were affected by the threat. Array Members: Minimum number of 1 item. Maximum number of 5 items.
        public var filePaths: [SecurityHubClientTypes.FilePaths]?
        /// This total number of items in which the threat has been detected.
        public var itemCount: Swift.Int?
        /// The name of the threat. Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public var name: Swift.String?
        /// The severity of the threat. Length Constraints: Minimum of 1 length. Maximum of 128 length.
        public var severity: Swift.String?

        public init(
            filePaths: [SecurityHubClientTypes.FilePaths]? = nil,
            itemCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            severity: Swift.String? = nil
        )
        {
            self.filePaths = filePaths
            self.itemCount = itemCount
            self.name = name
            self.severity = severity
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about where a code vulnerability is located in your Lambda function.
    public struct CodeVulnerabilitiesFilePath {
        /// The line number of the last line of code in which the vulnerability is located.
        public var endLine: Swift.Int?
        /// The name of the file in which the code vulnerability is located.
        public var fileName: Swift.String?
        /// The file path to the code in which the vulnerability is located.
        public var filePath: Swift.String?
        /// The line number of the first line of code in which the vulnerability is located.
        public var startLine: Swift.Int?

        public init(
            endLine: Swift.Int? = nil,
            fileName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            startLine: Swift.Int? = nil
        )
        {
            self.endLine = endLine
            self.fileName = fileName
            self.filePath = filePath
            self.startLine = startLine
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the vulnerabilities found in your Lambda function code. This field pertains to findings that Security Hub receives from Amazon Inspector.
    public struct VulnerabilityCodeVulnerabilities {
        /// The Common Weakness Enumeration (CWE) item associated with the detected code vulnerability.
        public var cwes: [Swift.String]?
        /// Provides details about where a code vulnerability is located in your Lambda function.
        public var filePath: SecurityHubClientTypes.CodeVulnerabilitiesFilePath?
        /// The Amazon Resource Name (ARN) of the Lambda layer in which the code vulnerability is located.
        public var sourceArn: Swift.String?

        public init(
            cwes: [Swift.String]? = nil,
            filePath: SecurityHubClientTypes.CodeVulnerabilitiesFilePath? = nil,
            sourceArn: Swift.String? = nil
        )
        {
            self.cwes = cwes
            self.filePath = filePath
            self.sourceArn = sourceArn
        }
    }

}

extension SecurityHubClientTypes {
    /// CVSS scores from the advisory related to the vulnerability.
    public struct Cvss {
        /// Adjustments to the CVSS metrics.
        public var adjustments: [SecurityHubClientTypes.Adjustment]?
        /// The base CVSS score.
        public var baseScore: Swift.Double?
        /// The base scoring vector for the CVSS score.
        public var baseVector: Swift.String?
        /// The origin of the original CVSS score and vector.
        public var source: Swift.String?
        /// The version of CVSS for the CVSS score.
        public var version: Swift.String?

        public init(
            adjustments: [SecurityHubClientTypes.Adjustment]? = nil,
            baseScore: Swift.Double? = nil,
            baseVector: Swift.String? = nil,
            source: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.adjustments = adjustments
            self.baseScore = baseScore
            self.baseVector = baseVector
            self.source = source
            self.version = version
        }
    }

}

extension SecurityHubClientTypes {

    public enum VulnerabilityExploitAvailable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [VulnerabilityExploitAvailable] {
            return [
                .no,
                .yes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum VulnerabilityFixAvailable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case partial
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [VulnerabilityFixAvailable] {
            return [
                .no,
                .partial,
                .yes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .partial: return "PARTIAL"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A vendor that generates a vulnerability report.
    public struct VulnerabilityVendor {
        /// The name of the vendor.
        /// This member is required.
        public var name: Swift.String?
        /// The URL of the vulnerability advisory.
        public var url: Swift.String?
        /// Indicates when the vulnerability advisory was created. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var vendorCreatedAt: Swift.String?
        /// The severity that the vendor assigned to the vulnerability.
        public var vendorSeverity: Swift.String?
        /// Indicates when the vulnerability advisory was last updated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var vendorUpdatedAt: Swift.String?

        public init(
            name: Swift.String? = nil,
            url: Swift.String? = nil,
            vendorCreatedAt: Swift.String? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: Swift.String? = nil
        )
        {
            self.name = name
            self.url = url
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
        }
    }

}

extension SecurityHubClientTypes {
    /// Information about a software package.
    public struct SoftwarePackage {
        /// The architecture used for the software package.
        public var architecture: Swift.String?
        /// The epoch of the software package.
        public var epoch: Swift.String?
        /// The file system path to the package manager inventory file.
        public var filePath: Swift.String?
        /// The version of the software package in which the vulnerability has been resolved.
        public var fixedInVersion: Swift.String?
        /// The name of the software package.
        public var name: Swift.String?
        /// The source of the package.
        public var packageManager: Swift.String?
        /// The release of the software package.
        public var release: Swift.String?
        /// Describes the actions a customer can take to resolve the vulnerability in the software package.
        public var remediation: Swift.String?
        /// The Amazon Resource Name (ARN) of the source layer.
        public var sourceLayerArn: Swift.String?
        /// The source layer hash of the vulnerable package.
        public var sourceLayerHash: Swift.String?
        /// The version of the software package.
        public var version: Swift.String?

        public init(
            architecture: Swift.String? = nil,
            epoch: Swift.String? = nil,
            filePath: Swift.String? = nil,
            fixedInVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            packageManager: Swift.String? = nil,
            release: Swift.String? = nil,
            remediation: Swift.String? = nil,
            sourceLayerArn: Swift.String? = nil,
            sourceLayerHash: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLayerArn = sourceLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}

extension SecurityHubClientTypes {
    /// A vulnerability associated with a finding.
    public struct Vulnerability {
        /// The vulnerabilities found in your Lambda function code. This field pertains to findings that Security Hub receives from Amazon Inspector.
        public var codeVulnerabilities: [SecurityHubClientTypes.VulnerabilityCodeVulnerabilities]?
        /// CVSS scores from the advisory related to the vulnerability.
        public var cvss: [SecurityHubClientTypes.Cvss]?
        /// The Exploit Prediction Scoring System (EPSS) score for a finding.
        public var epssScore: Swift.Double?
        /// Whether an exploit is available for a finding.
        public var exploitAvailable: SecurityHubClientTypes.VulnerabilityExploitAvailable?
        /// Specifies if all vulnerable packages in a finding have a value for FixedInVersion and Remediation. This field is evaluated for each vulnerability Id based on the number of vulnerable packages that have a value for both FixedInVersion and Remediation. Valid values are as follows:
        ///
        /// * YES if all vulnerable packages have a value for both FixedInVersion and Remediation
        ///
        /// * NO if no vulnerable packages have a value for FixedInVersion and Remediation
        ///
        /// * PARTIAL otherwise
        public var fixAvailable: SecurityHubClientTypes.VulnerabilityFixAvailable?
        /// The identifier of the vulnerability.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time of the last exploit associated with a finding discovered in your environment.
        public var lastKnownExploitAt: Swift.String?
        /// A list of URLs that provide additional information about the vulnerability.
        public var referenceUrls: [Swift.String]?
        /// List of vulnerabilities that are related to this vulnerability.
        public var relatedVulnerabilities: [Swift.String]?
        /// Information about the vendor that generates the vulnerability report.
        public var vendor: SecurityHubClientTypes.VulnerabilityVendor?
        /// List of software packages that have the vulnerability.
        public var vulnerablePackages: [SecurityHubClientTypes.SoftwarePackage]?

        public init(
            codeVulnerabilities: [SecurityHubClientTypes.VulnerabilityCodeVulnerabilities]? = nil,
            cvss: [SecurityHubClientTypes.Cvss]? = nil,
            epssScore: Swift.Double? = nil,
            exploitAvailable: SecurityHubClientTypes.VulnerabilityExploitAvailable? = nil,
            fixAvailable: SecurityHubClientTypes.VulnerabilityFixAvailable? = nil,
            id: Swift.String? = nil,
            lastKnownExploitAt: Swift.String? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            vendor: SecurityHubClientTypes.VulnerabilityVendor? = nil,
            vulnerablePackages: [SecurityHubClientTypes.SoftwarePackage]? = nil
        )
        {
            self.codeVulnerabilities = codeVulnerabilities
            self.cvss = cvss
            self.epssScore = epssScore
            self.exploitAvailable = exploitAvailable
            self.fixAvailable = fixAvailable
            self.id = id
            self.lastKnownExploitAt = lastKnownExploitAt
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.vendor = vendor
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the status of the investigation into a finding.
    public struct Workflow {
        /// The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to SUPPRESSED or RESOLVED does not prevent a new finding for the same issue. The allowed values are the following.
        ///
        /// * NEW - The initial state of a finding, before it is reviewed. Security Hub also resets the workflow status from NOTIFIED or RESOLVED to NEW in the following cases:
        ///
        /// * RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * ComplianceStatus changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.
        ///
        ///
        ///
        ///
        /// * NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.
        ///
        /// * SUPPRESSED - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.
        ///
        /// * RESOLVED - The finding was reviewed and remediated and is now considered resolved.
        public var status: SecurityHubClientTypes.WorkflowStatus?

        public init(
            status: SecurityHubClientTypes.WorkflowStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {

    @available(*, deprecated, message: "This filter is deprecated. Instead, use SeverityLabel or FindingProviderFieldsSeverityLabel.")
    public enum WorkflowState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assigned
        case deferred
        case inProgress
        case new
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowState] {
            return [
                .assigned,
                .deferred,
                .inProgress,
                .new,
                .resolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .deferred: return "DEFERRED"
            case .inProgress: return "IN_PROGRESS"
            case .new: return "NEW"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Provides a consistent format for Security Hub findings. AwsSecurityFinding format allows you to share findings between Amazon Web Services security services and third-party solutions. A finding is a potential security issue generated either by Amazon Web Services services or by the integrated third-party solutions and standards checks.
    public struct AwsSecurityFinding {
        /// Provides details about an action that affects or that was taken on a resource.
        public var action: SecurityHubClientTypes.Action?
        /// The Amazon Web Services account ID that a finding is generated in. Length Constraints: 12.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The name of the Amazon Web Services account from which a finding was generated. Length Constraints: Minimum length of 1. Maximum length of 50.
        public var awsAccountName: Swift.String?
        /// The name of the company for the product that generated the finding. Security Hub populates this attribute automatically for each finding. You cannot update this attribute with BatchImportFindings or BatchUpdateFindings. The exception to this is a custom integration. When you use the Security Hub console or API to filter findings by company name, you use this attribute. Length Constraints: Minimum length of 1. Maximum length of 128.
        public var companyName: Swift.String?
        /// This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.
        public var compliance: SecurityHubClientTypes.Compliance?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public var confidence: Swift.Int?
        /// Indicates when the security findings provider created the potential security issue that a finding captured. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        /// This member is required.
        public var createdAt: Swift.String?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public var criticality: Swift.Int?
        /// A finding's description. Description is a required property. Length Constraints: Minimum length of 1. Maximum length of 1024.
        /// This member is required.
        public var description: Swift.String?
        /// In a BatchImportFindings request, finding providers use FindingProviderFields to provide and update their own values for confidence, criticality, related findings, severity, and types.
        public var findingProviderFields: SecurityHubClientTypes.FindingProviderFields?
        /// Indicates when the security findings provider first observed the potential security issue that a finding captured. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var firstObservedAt: Swift.String?
        /// Provides metadata for the Amazon CodeGuru detector associated with a finding. This field pertains to findings that relate to Lambda functions. Amazon Inspector identifies policy violations and vulnerabilities in Lambda function code based on internal detectors developed in collaboration with Amazon CodeGuru. Security Hub receives those findings.
        public var generatorDetails: SecurityHubClientTypes.GeneratorDetails?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, or something else. Length Constraints: Minimum length of 1. Maximum length of 512.
        /// This member is required.
        public var generatorId: Swift.String?
        /// The security findings provider-specific identifier for a finding. Length Constraints: Minimum length of 1. Maximum length of 512.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates when the security findings provider most recently observed the potential security issue that a finding captured. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastObservedAt: Swift.String?
        /// A list of malware related to a finding. Array Members: Maximum number of 5 items.
        public var malware: [SecurityHubClientTypes.Malware]?
        /// The details of network-related information about a finding.
        public var network: SecurityHubClientTypes.Network?
        /// Provides information about a network path that is relevant to a finding. Each entry under NetworkPath represents a component of that path.
        public var networkPath: [SecurityHubClientTypes.NetworkPathComponent]?
        /// A user-defined note added to a finding.
        public var note: SecurityHubClientTypes.Note?
        /// Provides an overview of the patch compliance status for an instance against a selected compliance standard.
        public var patchSummary: SecurityHubClientTypes.PatchSummary?
        /// The details of process-related information about a finding.
        public var process: SecurityHubClientTypes.ProcessDetails?
        /// A timestamp that indicates when Security Hub received a finding and begins to process it. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var processedAt: Swift.String?
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration. Length Constraints: Minimum length of 12. Maximum length of 2048.
        /// This member is required.
        public var productArn: Swift.String?
        /// A data type where security findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 2048 characters.
        public var productFields: [Swift.String: Swift.String]?
        /// The name of the product that generated the finding. Security Hub populates this attribute automatically for each finding. You cannot update this attribute with BatchImportFindings or BatchUpdateFindings. The exception to this is a custom integration. When you use the Security Hub console or API to filter findings by product name, you use this attribute. Length Constraints: Minimum length of 1. Maximum length of 128.
        public var productName: Swift.String?
        /// The record state of a finding.
        public var recordState: SecurityHubClientTypes.RecordState?
        /// The Region from which the finding was generated. Security Hub populates this attribute automatically for each finding. You cannot update it using BatchImportFindings or BatchUpdateFindings. Length Constraints: Minimum length of 1. Maximum length of 16.
        public var region: Swift.String?
        /// A list of related findings. Array Members: Minimum number of 1 item. Maximum number of 10 items.
        public var relatedFindings: [SecurityHubClientTypes.RelatedFinding]?
        /// A data type that describes the remediation options for a finding.
        public var remediation: SecurityHubClientTypes.Remediation?
        /// A set of resource data types that describe the resources that the finding refers to. Array Members: Minimum number of 1 item. Maximum number of 32 items.
        /// This member is required.
        public var resources: [SecurityHubClientTypes.Resource]?
        /// Indicates whether the finding is a sample finding.
        public var sample: Swift.Bool?
        /// The schema version that a finding is formatted for. The value is 2018-10-08.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// A finding's severity.
        public var severity: SecurityHubClientTypes.Severity?
        /// A URL that links to a page about the current finding in the security findings provider's solution.
        public var sourceUrl: Swift.String?
        /// Threat intelligence details related to a finding. Array Members: Minimum number of 1 item. Maximum number of 5 items.
        public var threatIntelIndicators: [SecurityHubClientTypes.ThreatIntelIndicator]?
        /// Details about the threat detected in a security finding and the file paths that were affected by the threat. Array Members: Minimum number of 1 item. Maximum number of 32 items.
        public var threats: [SecurityHubClientTypes.Threat]?
        /// A finding's title. Title is a required property. Length Constraints: Minimum length of 1. Maximum length of 256.
        /// This member is required.
        public var title: Swift.String?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications Array Members: Maximum number of 50 items.
        public var types: [Swift.String]?
        /// Indicates when the security findings provider last updated the finding record. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        /// This member is required.
        public var updatedAt: Swift.String?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 1024 characters.
        public var userDefinedFields: [Swift.String: Swift.String]?
        /// Indicates the veracity of a finding.
        public var verificationState: SecurityHubClientTypes.VerificationState?
        /// Provides a list of vulnerabilities associated with the findings.
        public var vulnerabilities: [SecurityHubClientTypes.Vulnerability]?
        /// Provides information about the status of the investigation into a finding.
        public var workflow: SecurityHubClientTypes.Workflow?
        /// The workflow state of a finding.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use SeverityLabel or FindingProviderFieldsSeverityLabel.")
        public var workflowState: SecurityHubClientTypes.WorkflowState?

        public init(
            action: SecurityHubClientTypes.Action? = nil,
            awsAccountId: Swift.String? = nil,
            awsAccountName: Swift.String? = nil,
            companyName: Swift.String? = nil,
            compliance: SecurityHubClientTypes.Compliance? = nil,
            confidence: Swift.Int? = nil,
            createdAt: Swift.String? = nil,
            criticality: Swift.Int? = nil,
            description: Swift.String? = nil,
            findingProviderFields: SecurityHubClientTypes.FindingProviderFields? = nil,
            firstObservedAt: Swift.String? = nil,
            generatorDetails: SecurityHubClientTypes.GeneratorDetails? = nil,
            generatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            lastObservedAt: Swift.String? = nil,
            malware: [SecurityHubClientTypes.Malware]? = nil,
            network: SecurityHubClientTypes.Network? = nil,
            networkPath: [SecurityHubClientTypes.NetworkPathComponent]? = nil,
            note: SecurityHubClientTypes.Note? = nil,
            patchSummary: SecurityHubClientTypes.PatchSummary? = nil,
            process: SecurityHubClientTypes.ProcessDetails? = nil,
            processedAt: Swift.String? = nil,
            productArn: Swift.String? = nil,
            productFields: [Swift.String: Swift.String]? = nil,
            productName: Swift.String? = nil,
            recordState: SecurityHubClientTypes.RecordState? = nil,
            region: Swift.String? = nil,
            relatedFindings: [SecurityHubClientTypes.RelatedFinding]? = nil,
            remediation: SecurityHubClientTypes.Remediation? = nil,
            resources: [SecurityHubClientTypes.Resource]? = nil,
            sample: Swift.Bool? = nil,
            schemaVersion: Swift.String? = nil,
            severity: SecurityHubClientTypes.Severity? = nil,
            sourceUrl: Swift.String? = nil,
            threatIntelIndicators: [SecurityHubClientTypes.ThreatIntelIndicator]? = nil,
            threats: [SecurityHubClientTypes.Threat]? = nil,
            title: Swift.String? = nil,
            types: [Swift.String]? = nil,
            updatedAt: Swift.String? = nil,
            userDefinedFields: [Swift.String: Swift.String]? = nil,
            verificationState: SecurityHubClientTypes.VerificationState? = nil,
            vulnerabilities: [SecurityHubClientTypes.Vulnerability]? = nil,
            workflow: SecurityHubClientTypes.Workflow? = nil,
            workflowState: SecurityHubClientTypes.WorkflowState? = nil
        )
        {
            self.action = action
            self.awsAccountId = awsAccountId
            self.awsAccountName = awsAccountName
            self.companyName = companyName
            self.compliance = compliance
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.findingProviderFields = findingProviderFields
            self.firstObservedAt = firstObservedAt
            self.generatorDetails = generatorDetails
            self.generatorId = generatorId
            self.id = id
            self.lastObservedAt = lastObservedAt
            self.malware = malware
            self.network = network
            self.networkPath = networkPath
            self.note = note
            self.patchSummary = patchSummary
            self.process = process
            self.processedAt = processedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recordState = recordState
            self.region = region
            self.relatedFindings = relatedFindings
            self.remediation = remediation
            self.resources = resources
            self.sample = sample
            self.schemaVersion = schemaVersion
            self.severity = severity
            self.sourceUrl = sourceUrl
            self.threatIntelIndicators = threatIntelIndicators
            self.threats = threats
            self.title = title
            self.types = types
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.vulnerabilities = vulnerabilities
            self.workflow = workflow
            self.workflowState = workflowState
        }
    }

}

extension SecurityHubClientTypes {
    /// A keyword filter for querying findings.
    public struct KeywordFilter {
        /// A value for the keyword.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// The IP filter for querying findings.
    public struct IpFilter {
        /// A finding's CIDR value.
        public var cidr: Swift.String?

        public init(
            cidr: Swift.String? = nil
        )
        {
            self.cidr = cidr
        }
    }

}

extension SecurityHubClientTypes {
    /// Boolean filter for querying findings.
    public struct BooleanFilter {
        /// The value of the boolean.
        public var value: Swift.Bool?

        public init(
            value: Swift.Bool? = nil
        )
        {
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    /// A collection of filters that are applied to all active findings aggregated by Security Hub. You can filter by up to ten finding attributes. For each attribute, you can provide up to 20 filter values.
    public struct AwsSecurityFindingFilters {
        /// The Amazon Web Services account ID in which a finding is generated.
        public var awsAccountId: [SecurityHubClientTypes.StringFilter]?
        /// The name of the Amazon Web Services account in which a finding is generated.
        public var awsAccountName: [SecurityHubClientTypes.StringFilter]?
        /// The name of the findings provider (company) that owns the solution (product) that generates findings.
        public var companyName: [SecurityHubClientTypes.StringFilter]?
        /// The unique identifier of a standard in which a control is enabled. This field consists of the resource portion of the Amazon Resource Name (ARN) returned for a standard in the [DescribeStandards](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_DescribeStandards.html) API response.
        public var complianceAssociatedStandardsId: [SecurityHubClientTypes.StringFilter]?
        /// The unique identifier of a control across standards. Values for this field typically consist of an Amazon Web Servicesservice and a number, such as APIGateway.5.
        public var complianceSecurityControlId: [SecurityHubClientTypes.StringFilter]?
        /// The name of a security control parameter.
        public var complianceSecurityControlParametersName: [SecurityHubClientTypes.StringFilter]?
        /// The current value of a security control parameter.
        public var complianceSecurityControlParametersValue: [SecurityHubClientTypes.StringFilter]?
        /// Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.
        public var complianceStatus: [SecurityHubClientTypes.StringFilter]?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public var confidence: [SecurityHubClientTypes.NumberFilter]?
        /// A timestamp that indicates when the security findings provider created the potential security issue that a finding reflects. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var createdAt: [SecurityHubClientTypes.DateFilter]?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public var criticality: [SecurityHubClientTypes.NumberFilter]?
        /// A finding's description.
        public var description: [SecurityHubClientTypes.StringFilter]?
        /// The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public var findingProviderFieldsConfidence: [SecurityHubClientTypes.NumberFilter]?
        /// The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public var findingProviderFieldsCriticality: [SecurityHubClientTypes.NumberFilter]?
        /// The finding identifier of a related finding that is identified by the finding provider.
        public var findingProviderFieldsRelatedFindingsId: [SecurityHubClientTypes.StringFilter]?
        /// The ARN of the solution that generated a related finding that is identified by the finding provider.
        public var findingProviderFieldsRelatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]?
        /// The finding provider value for the severity label.
        public var findingProviderFieldsSeverityLabel: [SecurityHubClientTypes.StringFilter]?
        /// The finding provider's original value for the severity.
        public var findingProviderFieldsSeverityOriginal: [SecurityHubClientTypes.StringFilter]?
        /// One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public var findingProviderFieldsTypes: [SecurityHubClientTypes.StringFilter]?
        /// A timestamp that indicates when the security findings provider first observed the potential security issue that a finding captured. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var firstObservedAt: [SecurityHubClientTypes.DateFilter]?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.
        public var generatorId: [SecurityHubClientTypes.StringFilter]?
        /// The security findings provider-specific identifier for a finding.
        public var id: [SecurityHubClientTypes.StringFilter]?
        /// A keyword for a finding.
        @available(*, deprecated, message: "The Keyword property is deprecated.")
        public var keyword: [SecurityHubClientTypes.KeywordFilter]?
        /// A timestamp that indicates when the security findings provider most recently observed the potential security issue that a finding captured. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var lastObservedAt: [SecurityHubClientTypes.DateFilter]?
        /// The name of the malware that was observed.
        public var malwareName: [SecurityHubClientTypes.StringFilter]?
        /// The filesystem path of the malware that was observed.
        public var malwarePath: [SecurityHubClientTypes.StringFilter]?
        /// The state of the malware that was observed.
        public var malwareState: [SecurityHubClientTypes.StringFilter]?
        /// The type of the malware that was observed.
        public var malwareType: [SecurityHubClientTypes.StringFilter]?
        /// The destination domain of network-related information about a finding.
        public var networkDestinationDomain: [SecurityHubClientTypes.StringFilter]?
        /// The destination IPv4 address of network-related information about a finding.
        public var networkDestinationIpV4: [SecurityHubClientTypes.IpFilter]?
        /// The destination IPv6 address of network-related information about a finding.
        public var networkDestinationIpV6: [SecurityHubClientTypes.IpFilter]?
        /// The destination port of network-related information about a finding.
        public var networkDestinationPort: [SecurityHubClientTypes.NumberFilter]?
        /// Indicates the direction of network traffic associated with a finding.
        public var networkDirection: [SecurityHubClientTypes.StringFilter]?
        /// The protocol of network-related information about a finding.
        public var networkProtocol: [SecurityHubClientTypes.StringFilter]?
        /// The source domain of network-related information about a finding.
        public var networkSourceDomain: [SecurityHubClientTypes.StringFilter]?
        /// The source IPv4 address of network-related information about a finding.
        public var networkSourceIpV4: [SecurityHubClientTypes.IpFilter]?
        /// The source IPv6 address of network-related information about a finding.
        public var networkSourceIpV6: [SecurityHubClientTypes.IpFilter]?
        /// The source media access control (MAC) address of network-related information about a finding.
        public var networkSourceMac: [SecurityHubClientTypes.StringFilter]?
        /// The source port of network-related information about a finding.
        public var networkSourcePort: [SecurityHubClientTypes.NumberFilter]?
        /// The text of a note.
        public var noteText: [SecurityHubClientTypes.StringFilter]?
        /// The timestamp of when the note was updated.
        public var noteUpdatedAt: [SecurityHubClientTypes.DateFilter]?
        /// The principal that created a note.
        public var noteUpdatedBy: [SecurityHubClientTypes.StringFilter]?
        /// A timestamp that identifies when the process was launched. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var processLaunchedAt: [SecurityHubClientTypes.DateFilter]?
        /// The name of the process.
        public var processName: [SecurityHubClientTypes.StringFilter]?
        /// The parent process ID. This field accepts positive integers between O and 2147483647.
        public var processParentPid: [SecurityHubClientTypes.NumberFilter]?
        /// The path to the process executable.
        public var processPath: [SecurityHubClientTypes.StringFilter]?
        /// The process ID.
        public var processPid: [SecurityHubClientTypes.NumberFilter]?
        /// A timestamp that identifies when the process was terminated. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var processTerminatedAt: [SecurityHubClientTypes.DateFilter]?
        /// The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.
        public var productArn: [SecurityHubClientTypes.StringFilter]?
        /// A data type where security findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format.
        public var productFields: [SecurityHubClientTypes.MapFilter]?
        /// The name of the solution (product) that generates findings.
        public var productName: [SecurityHubClientTypes.StringFilter]?
        /// The recommendation of what to do about the issue described in a finding.
        public var recommendationText: [SecurityHubClientTypes.StringFilter]?
        /// The updated record state for the finding.
        public var recordState: [SecurityHubClientTypes.StringFilter]?
        /// The Region from which the finding was generated.
        public var region: [SecurityHubClientTypes.StringFilter]?
        /// The solution-generated identifier for a related finding.
        public var relatedFindingsId: [SecurityHubClientTypes.StringFilter]?
        /// The ARN of the solution that generated a related finding.
        public var relatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]?
        /// The ARN of the application that is related to a finding.
        public var resourceApplicationArn: [SecurityHubClientTypes.StringFilter]?
        /// The name of the application that is related to a finding.
        public var resourceApplicationName: [SecurityHubClientTypes.StringFilter]?
        /// The IAM profile ARN of the instance.
        public var resourceAwsEc2InstanceIamInstanceProfileArn: [SecurityHubClientTypes.StringFilter]?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public var resourceAwsEc2InstanceImageId: [SecurityHubClientTypes.StringFilter]?
        /// The IPv4 addresses associated with the instance.
        public var resourceAwsEc2InstanceIpV4Addresses: [SecurityHubClientTypes.IpFilter]?
        /// The IPv6 addresses associated with the instance.
        public var resourceAwsEc2InstanceIpV6Addresses: [SecurityHubClientTypes.IpFilter]?
        /// The key name associated with the instance.
        public var resourceAwsEc2InstanceKeyName: [SecurityHubClientTypes.StringFilter]?
        /// The date and time the instance was launched.
        public var resourceAwsEc2InstanceLaunchedAt: [SecurityHubClientTypes.DateFilter]?
        /// The identifier of the subnet that the instance was launched in.
        public var resourceAwsEc2InstanceSubnetId: [SecurityHubClientTypes.StringFilter]?
        /// The instance type of the instance.
        public var resourceAwsEc2InstanceType: [SecurityHubClientTypes.StringFilter]?
        /// The identifier of the VPC that the instance was launched in.
        public var resourceAwsEc2InstanceVpcId: [SecurityHubClientTypes.StringFilter]?
        /// The creation date/time of the IAM access key related to a finding.
        public var resourceAwsIamAccessKeyCreatedAt: [SecurityHubClientTypes.DateFilter]?
        /// The name of the principal that is associated with an IAM access key.
        public var resourceAwsIamAccessKeyPrincipalName: [SecurityHubClientTypes.StringFilter]?
        /// The status of the IAM access key related to a finding.
        public var resourceAwsIamAccessKeyStatus: [SecurityHubClientTypes.StringFilter]?
        /// The user associated with the IAM access key related to a finding.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use ResourceAwsIamAccessKeyPrincipalName.")
        public var resourceAwsIamAccessKeyUserName: [SecurityHubClientTypes.StringFilter]?
        /// The name of an IAM user.
        public var resourceAwsIamUserUserName: [SecurityHubClientTypes.StringFilter]?
        /// The canonical user ID of the owner of the S3 bucket.
        public var resourceAwsS3BucketOwnerId: [SecurityHubClientTypes.StringFilter]?
        /// The display name of the owner of the S3 bucket.
        public var resourceAwsS3BucketOwnerName: [SecurityHubClientTypes.StringFilter]?
        /// The identifier of the image related to a finding.
        public var resourceContainerImageId: [SecurityHubClientTypes.StringFilter]?
        /// The name of the image related to a finding.
        public var resourceContainerImageName: [SecurityHubClientTypes.StringFilter]?
        /// A timestamp that identifies when the container was started. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var resourceContainerLaunchedAt: [SecurityHubClientTypes.DateFilter]?
        /// The name of the container related to a finding.
        public var resourceContainerName: [SecurityHubClientTypes.StringFilter]?
        /// The details of a resource that doesn't have a specific subfield for the resource type defined.
        public var resourceDetailsOther: [SecurityHubClientTypes.MapFilter]?
        /// The canonical identifier for the given resource type.
        public var resourceId: [SecurityHubClientTypes.StringFilter]?
        /// The canonical Amazon Web Services partition name that the Region is assigned to.
        public var resourcePartition: [SecurityHubClientTypes.StringFilter]?
        /// The canonical Amazon Web Services external Region name where this resource is located.
        public var resourceRegion: [SecurityHubClientTypes.StringFilter]?
        /// A list of Amazon Web Services tags associated with a resource at the time the finding was processed.
        public var resourceTags: [SecurityHubClientTypes.MapFilter]?
        /// Specifies the type of the resource that details are provided for.
        public var resourceType: [SecurityHubClientTypes.StringFilter]?
        /// Indicates whether or not sample findings are included in the filter results.
        public var sample: [SecurityHubClientTypes.BooleanFilter]?
        /// The label of a finding's severity.
        public var severityLabel: [SecurityHubClientTypes.StringFilter]?
        /// The normalized severity of a finding.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use SeverityLabel or FindingProviderFieldsSeverityLabel.")
        public var severityNormalized: [SecurityHubClientTypes.NumberFilter]?
        /// The native severity as defined by the security findings provider's solution that generated the finding.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use FindingProviderSeverityOriginal.")
        public var severityProduct: [SecurityHubClientTypes.NumberFilter]?
        /// A URL that links to a page about the current finding in the security findings provider's solution.
        public var sourceUrl: [SecurityHubClientTypes.StringFilter]?
        /// The category of a threat intelligence indicator.
        public var threatIntelIndicatorCategory: [SecurityHubClientTypes.StringFilter]?
        /// A timestamp that identifies the last observation of a threat intelligence indicator.
        public var threatIntelIndicatorLastObservedAt: [SecurityHubClientTypes.DateFilter]?
        /// The source of the threat intelligence.
        public var threatIntelIndicatorSource: [SecurityHubClientTypes.StringFilter]?
        /// The URL for more details from the source of the threat intelligence.
        public var threatIntelIndicatorSourceUrl: [SecurityHubClientTypes.StringFilter]?
        /// The type of a threat intelligence indicator.
        public var threatIntelIndicatorType: [SecurityHubClientTypes.StringFilter]?
        /// The value of a threat intelligence indicator.
        public var threatIntelIndicatorValue: [SecurityHubClientTypes.StringFilter]?
        /// A finding's title.
        public var title: [SecurityHubClientTypes.StringFilter]?
        /// A finding type in the format of namespace/category/classifier that classifies a finding.
        public var type: [SecurityHubClientTypes.StringFilter]?
        /// A timestamp that indicates when the security findings provider last updated the finding record. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var updatedAt: [SecurityHubClientTypes.DateFilter]?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
        public var userDefinedFields: [SecurityHubClientTypes.MapFilter]?
        /// The veracity of a finding.
        public var verificationState: [SecurityHubClientTypes.StringFilter]?
        /// Indicates whether a software vulnerability in your environment has a known exploit. You can filter findings by this field only if you use Security Hub and Amazon Inspector.
        public var vulnerabilitiesExploitAvailable: [SecurityHubClientTypes.StringFilter]?
        /// Indicates whether a vulnerability is fixed in a newer version of the affected software packages. You can filter findings by this field only if you use Security Hub and Amazon Inspector.
        public var vulnerabilitiesFixAvailable: [SecurityHubClientTypes.StringFilter]?
        /// The workflow state of a finding. Note that this field is deprecated. To search for a finding based on its workflow status, use WorkflowStatus.
        public var workflowState: [SecurityHubClientTypes.StringFilter]?
        /// The status of the investigation into a finding. Allowed values are the following.
        ///
        /// * NEW - The initial state of a finding, before it is reviewed. Security Hub also resets the workflow status from NOTIFIED or RESOLVED to NEW in the following cases:
        ///
        /// * RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * Compliance.Status changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.
        ///
        ///
        ///
        ///
        /// * NOTIFIED - Indicates that the resource owner has been notified about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner. If one of the following occurs, the workflow status is changed automatically from NOTIFIED to NEW:
        ///
        /// * RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * Compliance.Status changes from PASSED to FAILED, WARNING, or NOT_AVAILABLE.
        ///
        ///
        ///
        ///
        /// * SUPPRESSED - Indicates that you reviewed the finding and do not believe that any action is needed. The workflow status of a SUPPRESSED finding does not change if RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * RESOLVED - The finding was reviewed and remediated and is now considered resolved. The finding remains RESOLVED unless one of the following occurs:
        ///
        /// * RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * Compliance.Status changes from PASSED to FAILED, WARNING, or NOT_AVAILABLE.
        ///
        ///
        /// In those cases, the workflow status is automatically reset to NEW. For findings from controls, if Compliance.Status is PASSED, then Security Hub automatically sets the workflow status to RESOLVED.
        public var workflowStatus: [SecurityHubClientTypes.StringFilter]?

        public init(
            awsAccountId: [SecurityHubClientTypes.StringFilter]? = nil,
            awsAccountName: [SecurityHubClientTypes.StringFilter]? = nil,
            companyName: [SecurityHubClientTypes.StringFilter]? = nil,
            complianceAssociatedStandardsId: [SecurityHubClientTypes.StringFilter]? = nil,
            complianceSecurityControlId: [SecurityHubClientTypes.StringFilter]? = nil,
            complianceSecurityControlParametersName: [SecurityHubClientTypes.StringFilter]? = nil,
            complianceSecurityControlParametersValue: [SecurityHubClientTypes.StringFilter]? = nil,
            complianceStatus: [SecurityHubClientTypes.StringFilter]? = nil,
            confidence: [SecurityHubClientTypes.NumberFilter]? = nil,
            createdAt: [SecurityHubClientTypes.DateFilter]? = nil,
            criticality: [SecurityHubClientTypes.NumberFilter]? = nil,
            description: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsConfidence: [SecurityHubClientTypes.NumberFilter]? = nil,
            findingProviderFieldsCriticality: [SecurityHubClientTypes.NumberFilter]? = nil,
            findingProviderFieldsRelatedFindingsId: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsRelatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsSeverityLabel: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsSeverityOriginal: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsTypes: [SecurityHubClientTypes.StringFilter]? = nil,
            firstObservedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            generatorId: [SecurityHubClientTypes.StringFilter]? = nil,
            id: [SecurityHubClientTypes.StringFilter]? = nil,
            keyword: [SecurityHubClientTypes.KeywordFilter]? = nil,
            lastObservedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            malwareName: [SecurityHubClientTypes.StringFilter]? = nil,
            malwarePath: [SecurityHubClientTypes.StringFilter]? = nil,
            malwareState: [SecurityHubClientTypes.StringFilter]? = nil,
            malwareType: [SecurityHubClientTypes.StringFilter]? = nil,
            networkDestinationDomain: [SecurityHubClientTypes.StringFilter]? = nil,
            networkDestinationIpV4: [SecurityHubClientTypes.IpFilter]? = nil,
            networkDestinationIpV6: [SecurityHubClientTypes.IpFilter]? = nil,
            networkDestinationPort: [SecurityHubClientTypes.NumberFilter]? = nil,
            networkDirection: [SecurityHubClientTypes.StringFilter]? = nil,
            networkProtocol: [SecurityHubClientTypes.StringFilter]? = nil,
            networkSourceDomain: [SecurityHubClientTypes.StringFilter]? = nil,
            networkSourceIpV4: [SecurityHubClientTypes.IpFilter]? = nil,
            networkSourceIpV6: [SecurityHubClientTypes.IpFilter]? = nil,
            networkSourceMac: [SecurityHubClientTypes.StringFilter]? = nil,
            networkSourcePort: [SecurityHubClientTypes.NumberFilter]? = nil,
            noteText: [SecurityHubClientTypes.StringFilter]? = nil,
            noteUpdatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            noteUpdatedBy: [SecurityHubClientTypes.StringFilter]? = nil,
            processLaunchedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            processName: [SecurityHubClientTypes.StringFilter]? = nil,
            processParentPid: [SecurityHubClientTypes.NumberFilter]? = nil,
            processPath: [SecurityHubClientTypes.StringFilter]? = nil,
            processPid: [SecurityHubClientTypes.NumberFilter]? = nil,
            processTerminatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            productArn: [SecurityHubClientTypes.StringFilter]? = nil,
            productFields: [SecurityHubClientTypes.MapFilter]? = nil,
            productName: [SecurityHubClientTypes.StringFilter]? = nil,
            recommendationText: [SecurityHubClientTypes.StringFilter]? = nil,
            recordState: [SecurityHubClientTypes.StringFilter]? = nil,
            region: [SecurityHubClientTypes.StringFilter]? = nil,
            relatedFindingsId: [SecurityHubClientTypes.StringFilter]? = nil,
            relatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceApplicationArn: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceApplicationName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceIamInstanceProfileArn: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceImageId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceIpV4Addresses: [SecurityHubClientTypes.IpFilter]? = nil,
            resourceAwsEc2InstanceIpV6Addresses: [SecurityHubClientTypes.IpFilter]? = nil,
            resourceAwsEc2InstanceKeyName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceLaunchedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            resourceAwsEc2InstanceSubnetId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceType: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceVpcId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsIamAccessKeyCreatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            resourceAwsIamAccessKeyPrincipalName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsIamAccessKeyStatus: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsIamAccessKeyUserName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsIamUserUserName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsS3BucketOwnerId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsS3BucketOwnerName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceContainerImageId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceContainerImageName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceContainerLaunchedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            resourceContainerName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceDetailsOther: [SecurityHubClientTypes.MapFilter]? = nil,
            resourceId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourcePartition: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceRegion: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceTags: [SecurityHubClientTypes.MapFilter]? = nil,
            resourceType: [SecurityHubClientTypes.StringFilter]? = nil,
            sample: [SecurityHubClientTypes.BooleanFilter]? = nil,
            severityLabel: [SecurityHubClientTypes.StringFilter]? = nil,
            severityNormalized: [SecurityHubClientTypes.NumberFilter]? = nil,
            severityProduct: [SecurityHubClientTypes.NumberFilter]? = nil,
            sourceUrl: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorCategory: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorLastObservedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            threatIntelIndicatorSource: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorSourceUrl: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorType: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorValue: [SecurityHubClientTypes.StringFilter]? = nil,
            title: [SecurityHubClientTypes.StringFilter]? = nil,
            type: [SecurityHubClientTypes.StringFilter]? = nil,
            updatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            userDefinedFields: [SecurityHubClientTypes.MapFilter]? = nil,
            verificationState: [SecurityHubClientTypes.StringFilter]? = nil,
            vulnerabilitiesExploitAvailable: [SecurityHubClientTypes.StringFilter]? = nil,
            vulnerabilitiesFixAvailable: [SecurityHubClientTypes.StringFilter]? = nil,
            workflowState: [SecurityHubClientTypes.StringFilter]? = nil,
            workflowStatus: [SecurityHubClientTypes.StringFilter]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.awsAccountName = awsAccountName
            self.companyName = companyName
            self.complianceAssociatedStandardsId = complianceAssociatedStandardsId
            self.complianceSecurityControlId = complianceSecurityControlId
            self.complianceSecurityControlParametersName = complianceSecurityControlParametersName
            self.complianceSecurityControlParametersValue = complianceSecurityControlParametersValue
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.findingProviderFieldsConfidence = findingProviderFieldsConfidence
            self.findingProviderFieldsCriticality = findingProviderFieldsCriticality
            self.findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsId
            self.findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArn
            self.findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabel
            self.findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginal
            self.findingProviderFieldsTypes = findingProviderFieldsTypes
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.keyword = keyword
            self.lastObservedAt = lastObservedAt
            self.malwareName = malwareName
            self.malwarePath = malwarePath
            self.malwareState = malwareState
            self.malwareType = malwareType
            self.networkDestinationDomain = networkDestinationDomain
            self.networkDestinationIpV4 = networkDestinationIpV4
            self.networkDestinationIpV6 = networkDestinationIpV6
            self.networkDestinationPort = networkDestinationPort
            self.networkDirection = networkDirection
            self.networkProtocol = networkProtocol
            self.networkSourceDomain = networkSourceDomain
            self.networkSourceIpV4 = networkSourceIpV4
            self.networkSourceIpV6 = networkSourceIpV6
            self.networkSourceMac = networkSourceMac
            self.networkSourcePort = networkSourcePort
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.processLaunchedAt = processLaunchedAt
            self.processName = processName
            self.processParentPid = processParentPid
            self.processPath = processPath
            self.processPid = processPid
            self.processTerminatedAt = processTerminatedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recommendationText = recommendationText
            self.recordState = recordState
            self.region = region
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceApplicationArn = resourceApplicationArn
            self.resourceApplicationName = resourceApplicationName
            self.resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn
            self.resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId
            self.resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses
            self.resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses
            self.resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName
            self.resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt
            self.resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId
            self.resourceAwsEc2InstanceType = resourceAwsEc2InstanceType
            self.resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId
            self.resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt
            self.resourceAwsIamAccessKeyPrincipalName = resourceAwsIamAccessKeyPrincipalName
            self.resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus
            self.resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserName
            self.resourceAwsIamUserUserName = resourceAwsIamUserUserName
            self.resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId
            self.resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName
            self.resourceContainerImageId = resourceContainerImageId
            self.resourceContainerImageName = resourceContainerImageName
            self.resourceContainerLaunchedAt = resourceContainerLaunchedAt
            self.resourceContainerName = resourceContainerName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.sample = sample
            self.severityLabel = severityLabel
            self.severityNormalized = severityNormalized
            self.severityProduct = severityProduct
            self.sourceUrl = sourceUrl
            self.threatIntelIndicatorCategory = threatIntelIndicatorCategory
            self.threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt
            self.threatIntelIndicatorSource = threatIntelIndicatorSource
            self.threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl
            self.threatIntelIndicatorType = threatIntelIndicatorType
            self.threatIntelIndicatorValue = threatIntelIndicatorValue
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.vulnerabilitiesExploitAvailable = vulnerabilitiesExploitAvailable
            self.vulnerabilitiesFixAvailable = vulnerabilitiesFixAvailable
            self.workflowState = workflowState
            self.workflowStatus = workflowStatus
        }
    }

}

extension SecurityHubClientTypes {
    /// Identifies which finding to get the finding history for.
    public struct AwsSecurityFindingIdentifier {
        /// The identifier of the finding that was specified by the finding provider.
        /// This member is required.
        public var id: Swift.String?
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.
        /// This member is required.
        public var productArn: Swift.String?

        public init(
            id: Swift.String? = nil,
            productArn: Swift.String? = nil
        )
        {
            self.id = id
            self.productArn = productArn
        }
    }

}

public struct BatchDeleteAutomationRulesInput {
    /// A list of Amazon Resource Names (ARNs) for the rules that are to be deleted.
    /// This member is required.
    public var automationRulesArns: [Swift.String]?

    public init(
        automationRulesArns: [Swift.String]? = nil
    )
    {
        self.automationRulesArns = automationRulesArns
    }
}

extension SecurityHubClientTypes {
    /// A list of objects containing RuleArn, ErrorCode, and ErrorMessage. This parameter tells you which automation rules the request didn't process and why.
    public struct UnprocessedAutomationRule {
        /// The error code associated with the unprocessed automation rule.
        public var errorCode: Swift.Int?
        /// An error message describing why a request didn't process a specific rule.
        public var errorMessage: Swift.String?
        /// The Amazon Resource Name (ARN) for the unprocessed automation rule.
        public var ruleArn: Swift.String?

        public init(
            errorCode: Swift.Int? = nil,
            errorMessage: Swift.String? = nil,
            ruleArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.ruleArn = ruleArn
        }
    }

}

public struct BatchDeleteAutomationRulesOutput {
    /// A list of properly processed rule ARNs.
    public var processedAutomationRules: [Swift.String]?
    /// A list of objects containing RuleArn, ErrorCode, and ErrorMessage. This parameter tells you which automation rules the request didn't delete and why.
    public var unprocessedAutomationRules: [SecurityHubClientTypes.UnprocessedAutomationRule]?

    public init(
        processedAutomationRules: [Swift.String]? = nil,
        unprocessedAutomationRules: [SecurityHubClientTypes.UnprocessedAutomationRule]? = nil
    )
    {
        self.processedAutomationRules = processedAutomationRules
        self.unprocessedAutomationRules = unprocessedAutomationRules
    }
}

public struct BatchDisableStandardsInput {
    /// The ARNs of the standards subscriptions to disable.
    /// This member is required.
    public var standardsSubscriptionArns: [Swift.String]?

    public init(
        standardsSubscriptionArns: [Swift.String]? = nil
    )
    {
        self.standardsSubscriptionArns = standardsSubscriptionArns
    }
}

extension SecurityHubClientTypes {

    public enum StandardsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case failed
        case incomplete
        case pending
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [StandardsStatus] {
            return [
                .deleting,
                .failed,
                .incomplete,
                .pending,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .incomplete: return "INCOMPLETE"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum StatusReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalError
        case noAvailableConfigurationRecorder
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusReasonCode] {
            return [
                .internalError,
                .noAvailableConfigurationRecorder
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .noAvailableConfigurationRecorder: return "NO_AVAILABLE_CONFIGURATION_RECORDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// The reason for the current status of a standard subscription.
    public struct StandardsStatusReason {
        /// The reason code that represents the reason for the current status of a standard subscription.
        /// This member is required.
        public var statusReasonCode: SecurityHubClientTypes.StatusReasonCode?

        public init(
            statusReasonCode: SecurityHubClientTypes.StatusReasonCode? = nil
        )
        {
            self.statusReasonCode = statusReasonCode
        }
    }

}

extension SecurityHubClientTypes {
    /// A resource that represents your subscription to a supported standard.
    public struct StandardsSubscription {
        /// The ARN of a standard.
        /// This member is required.
        public var standardsArn: Swift.String?
        /// A key-value pair of input for the standard.
        /// This member is required.
        public var standardsInput: [Swift.String: Swift.String]?
        /// The status of the standard subscription. The status values are as follows:
        ///
        /// * PENDING - Standard is in the process of being enabled.
        ///
        /// * READY - Standard is enabled.
        ///
        /// * INCOMPLETE - Standard could not be enabled completely. Some controls may not be available.
        ///
        /// * DELETING - Standard is in the process of being disabled.
        ///
        /// * FAILED - Standard could not be disabled.
        /// This member is required.
        public var standardsStatus: SecurityHubClientTypes.StandardsStatus?
        /// The reason for the current status.
        public var standardsStatusReason: SecurityHubClientTypes.StandardsStatusReason?
        /// The ARN of a resource that represents your subscription to a supported standard.
        /// This member is required.
        public var standardsSubscriptionArn: Swift.String?

        public init(
            standardsArn: Swift.String? = nil,
            standardsInput: [Swift.String: Swift.String]? = nil,
            standardsStatus: SecurityHubClientTypes.StandardsStatus? = nil,
            standardsStatusReason: SecurityHubClientTypes.StandardsStatusReason? = nil,
            standardsSubscriptionArn: Swift.String? = nil
        )
        {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
            self.standardsStatus = standardsStatus
            self.standardsStatusReason = standardsStatusReason
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }
    }

}

public struct BatchDisableStandardsOutput {
    /// The details of the standards subscriptions that were disabled.
    public var standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]?

    public init(
        standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]? = nil
    )
    {
        self.standardsSubscriptions = standardsSubscriptions
    }
}

extension SecurityHubClientTypes {
    /// The standard that you want to enable.
    public struct StandardsSubscriptionRequest {
        /// The ARN of the standard that you want to enable. To view the list of available standards and their ARNs, use the DescribeStandards operation.
        /// This member is required.
        public var standardsArn: Swift.String?
        /// A key-value pair of input for the standard.
        public var standardsInput: [Swift.String: Swift.String]?

        public init(
            standardsArn: Swift.String? = nil,
            standardsInput: [Swift.String: Swift.String]? = nil
        )
        {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
        }
    }

}

public struct BatchEnableStandardsInput {
    /// The list of standards checks to enable.
    /// This member is required.
    public var standardsSubscriptionRequests: [SecurityHubClientTypes.StandardsSubscriptionRequest]?

    public init(
        standardsSubscriptionRequests: [SecurityHubClientTypes.StandardsSubscriptionRequest]? = nil
    )
    {
        self.standardsSubscriptionRequests = standardsSubscriptionRequests
    }
}

public struct BatchEnableStandardsOutput {
    /// The details of the standards subscriptions that were enabled.
    public var standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]?

    public init(
        standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]? = nil
    )
    {
        self.standardsSubscriptions = standardsSubscriptions
    }
}

public struct BatchGetAutomationRulesInput {
    /// A list of rule ARNs to get details for.
    /// This member is required.
    public var automationRulesArns: [Swift.String]?

    public init(
        automationRulesArns: [Swift.String]? = nil
    )
    {
        self.automationRulesArns = automationRulesArns
    }
}

public struct BatchGetAutomationRulesOutput {
    /// A list of rule details for the provided rule ARNs.
    public var rules: [SecurityHubClientTypes.AutomationRulesConfig]?
    /// A list of objects containing RuleArn, ErrorCode, and ErrorMessage. This parameter tells you which automation rules the request didn't retrieve and why.
    public var unprocessedAutomationRules: [SecurityHubClientTypes.UnprocessedAutomationRule]?

    public init(
        rules: [SecurityHubClientTypes.AutomationRulesConfig]? = nil,
        unprocessedAutomationRules: [SecurityHubClientTypes.UnprocessedAutomationRule]? = nil
    )
    {
        self.rules = rules
        self.unprocessedAutomationRules = unprocessedAutomationRules
    }
}

extension SecurityHubClientTypes {
    /// The target account, organizational unit, or the root that is associated with an Security Hub configuration. The configuration can be a configuration policy or self-managed behavior.
    public enum Target {
        /// The Amazon Web Services account ID of the target account.
        case accountid(Swift.String)
        /// The organizational unit ID of the target organizational unit.
        case organizationalunitid(Swift.String)
        /// The ID of the organization root.
        case rootid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension SecurityHubClientTypes {
    /// Provides details about the association between an Security Hub configuration and a target account, organizational unit, or the root. An association can exist between a target and a configuration policy, or between a target and self-managed behavior.
    public struct ConfigurationPolicyAssociation {
        /// The target account, organizational unit, or the root.
        public var target: SecurityHubClientTypes.Target?

        public init(
            target: SecurityHubClientTypes.Target? = nil
        )
        {
            self.target = target
        }
    }

}

public struct BatchGetConfigurationPolicyAssociationsInput {
    /// Specifies one or more target account IDs, organizational unit (OU) IDs, or the root ID to retrieve associations for.
    /// This member is required.
    public var configurationPolicyAssociationIdentifiers: [SecurityHubClientTypes.ConfigurationPolicyAssociation]?

    public init(
        configurationPolicyAssociationIdentifiers: [SecurityHubClientTypes.ConfigurationPolicyAssociation]? = nil
    )
    {
        self.configurationPolicyAssociationIdentifiers = configurationPolicyAssociationIdentifiers
    }
}

extension SecurityHubClientTypes {

    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case organizationalUnit
        case root
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .account,
                .organizationalUnit,
                .root
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organizationalUnit: return "ORGANIZATIONAL_UNIT"
            case .root: return "ROOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// An object that contains the details of a configuration policy association that’s returned in a ListConfigurationPolicyAssociations request.
    public struct ConfigurationPolicyAssociationSummary {
        /// The current status of the association between the specified target and the configuration.
        public var associationStatus: SecurityHubClientTypes.ConfigurationPolicyAssociationStatus?
        /// The explanation for a FAILED value for AssociationStatus.
        public var associationStatusMessage: Swift.String?
        /// Indicates whether the association between the specified target and the configuration was directly applied by the Security Hub delegated administrator or inherited from a parent.
        public var associationType: SecurityHubClientTypes.AssociationType?
        /// The universally unique identifier (UUID) of the configuration policy.
        public var configurationPolicyId: Swift.String?
        /// The identifier of the target account, organizational unit, or the root.
        public var targetId: Swift.String?
        /// Specifies whether the target is an Amazon Web Services account, organizational unit, or the root.
        public var targetType: SecurityHubClientTypes.TargetType?
        /// The date and time, in UTC and ISO 8601 format, that the configuration policy association was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            associationStatus: SecurityHubClientTypes.ConfigurationPolicyAssociationStatus? = nil,
            associationStatusMessage: Swift.String? = nil,
            associationType: SecurityHubClientTypes.AssociationType? = nil,
            configurationPolicyId: Swift.String? = nil,
            targetId: Swift.String? = nil,
            targetType: SecurityHubClientTypes.TargetType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.associationStatus = associationStatus
            self.associationStatusMessage = associationStatusMessage
            self.associationType = associationType
            self.configurationPolicyId = configurationPolicyId
            self.targetId = targetId
            self.targetType = targetType
            self.updatedAt = updatedAt
        }
    }

}

extension SecurityHubClientTypes {
    /// An array of configuration policy associations, one for each configuration policy association identifier, that was specified in a BatchGetConfigurationPolicyAssociations request but couldn’t be processed due to an error.
    public struct UnprocessedConfigurationPolicyAssociation {
        /// Configuration policy association identifiers that were specified in a BatchGetConfigurationPolicyAssociations request but couldn’t be processed due to an error.
        public var configurationPolicyAssociationIdentifiers: SecurityHubClientTypes.ConfigurationPolicyAssociation?
        /// An HTTP status code that identifies why the configuration policy association failed.
        public var errorCode: Swift.String?
        /// A string that identifies why the configuration policy association failed.
        public var errorReason: Swift.String?

        public init(
            configurationPolicyAssociationIdentifiers: SecurityHubClientTypes.ConfigurationPolicyAssociation? = nil,
            errorCode: Swift.String? = nil,
            errorReason: Swift.String? = nil
        )
        {
            self.configurationPolicyAssociationIdentifiers = configurationPolicyAssociationIdentifiers
            self.errorCode = errorCode
            self.errorReason = errorReason
        }
    }

}

public struct BatchGetConfigurationPolicyAssociationsOutput {
    /// Describes associations for the target accounts, OUs, or the root.
    public var configurationPolicyAssociations: [SecurityHubClientTypes.ConfigurationPolicyAssociationSummary]?
    /// An array of configuration policy associations, one for each configuration policy association identifier, that was specified in the request but couldn’t be processed due to an error.
    public var unprocessedConfigurationPolicyAssociations: [SecurityHubClientTypes.UnprocessedConfigurationPolicyAssociation]?

    public init(
        configurationPolicyAssociations: [SecurityHubClientTypes.ConfigurationPolicyAssociationSummary]? = nil,
        unprocessedConfigurationPolicyAssociations: [SecurityHubClientTypes.UnprocessedConfigurationPolicyAssociation]? = nil
    )
    {
        self.configurationPolicyAssociations = configurationPolicyAssociations
        self.unprocessedConfigurationPolicyAssociations = unprocessedConfigurationPolicyAssociations
    }
}

public struct BatchGetSecurityControlsInput {
    /// A list of security controls (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters). The security control ID or Amazon Resource Name (ARN) is the same across standards.
    /// This member is required.
    public var securityControlIds: [Swift.String]?

    public init(
        securityControlIds: [Swift.String]? = nil
    )
    {
        self.securityControlIds = securityControlIds
    }
}

extension SecurityHubClientTypes {
    /// An object that includes the data type of a security control parameter and its current value.
    public enum ParameterValue {
        /// A control parameter that is an integer.
        case integer(Swift.Int)
        /// A control parameter that is a list of integers.
        case integerlist([Swift.Int])
        /// A control parameter that is a double.
        case double(Swift.Double)
        /// A control parameter that is a string.
        case string(Swift.String)
        /// A control parameter that is a list of strings.
        case stringlist([Swift.String])
        /// A control parameter that is a boolean.
        case boolean(Swift.Bool)
        /// A control parameter that is an enum.
        case `enum`(Swift.String)
        /// A control parameter that is a list of enums.
        case enumlist([Swift.String])
        case sdkUnknown(Swift.String)
    }

}

extension SecurityHubClientTypes {

    public enum ParameterValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterValueType] {
            return [
                .custom,
                .default
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// An object that provides the current value of a security control parameter and identifies whether it has been customized.
    public struct ParameterConfiguration {
        /// The current value of a control parameter.
        public var value: SecurityHubClientTypes.ParameterValue?
        /// Identifies whether a control parameter uses a custom user-defined value or subscribes to the default Security Hub behavior. When ValueType is set equal to DEFAULT, the default behavior can be a specific Security Hub default value, or the default behavior can be to ignore a specific parameter. When ValueType is set equal to DEFAULT, Security Hub ignores user-provided input for the Value field. When ValueType is set equal to CUSTOM, the Value field can't be empty.
        /// This member is required.
        public var valueType: SecurityHubClientTypes.ParameterValueType?

        public init(
            value: SecurityHubClientTypes.ParameterValue? = nil,
            valueType: SecurityHubClientTypes.ParameterValueType? = nil
        )
        {
            self.value = value
            self.valueType = valueType
        }
    }

}

extension SecurityHubClientTypes {

    public enum ControlStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum SeverityRating: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [SeverityRating] {
            return [
                .critical,
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum UpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ready
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateStatus] {
            return [
                .ready,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ready: return "READY"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A security control in Security Hub describes a security best practice related to a specific resource.
    public struct SecurityControl {
        /// The description of a security control across standards. This typically summarizes how Security Hub evaluates the control and the conditions under which it produces a failed finding. This parameter doesn't reference a specific standard.
        /// This member is required.
        public var description: Swift.String?
        /// The most recent reason for updating the customizable properties of a security control. This differs from the UpdateReason field of the [BatchUpdateStandardsControlAssociations](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html) API, which tracks the reason for updating the enablement status of a control. This field accepts alphanumeric characters in addition to white spaces, dashes, and underscores.
        public var lastUpdateReason: Swift.String?
        /// An object that identifies the name of a control parameter, its current value, and whether it has been customized.
        public var parameters: [Swift.String: SecurityHubClientTypes.ParameterConfiguration]?
        /// A link to Security Hub documentation that explains how to remediate a failed finding for a security control.
        /// This member is required.
        public var remediationUrl: Swift.String?
        /// The Amazon Resource Name (ARN) for a security control across standards, such as arn:aws:securityhub:eu-central-1:123456789012:security-control/S3.1. This parameter doesn't mention a specific standard.
        /// This member is required.
        public var securityControlArn: Swift.String?
        /// The unique identifier of a security control across standards. Values for this field typically consist of an Amazon Web Servicesservice name and a number, such as APIGateway.3.
        /// This member is required.
        public var securityControlId: Swift.String?
        /// The enablement status of a security control in a specific standard.
        /// This member is required.
        public var securityControlStatus: SecurityHubClientTypes.ControlStatus?
        /// The severity of a security control. For more information about how Security Hub determines control severity, see [Assigning severity to control findings](https://docs.aws.amazon.com/securityhub/latest/userguide/controls-findings-create-update.html#control-findings-severity) in the Security Hub User Guide.
        /// This member is required.
        public var severityRating: SecurityHubClientTypes.SeverityRating?
        /// The title of a security control.
        /// This member is required.
        public var title: Swift.String?
        /// Identifies whether customizable properties of a security control are reflected in Security Hub findings. A status of READY indicates that Security Hub uses the current control parameter values when running security checks of the control. A status of UPDATING indicates that all security checks might not use the current parameter values.
        public var updateStatus: SecurityHubClientTypes.UpdateStatus?

        public init(
            description: Swift.String? = nil,
            lastUpdateReason: Swift.String? = nil,
            parameters: [Swift.String: SecurityHubClientTypes.ParameterConfiguration]? = nil,
            remediationUrl: Swift.String? = nil,
            securityControlArn: Swift.String? = nil,
            securityControlId: Swift.String? = nil,
            securityControlStatus: SecurityHubClientTypes.ControlStatus? = nil,
            severityRating: SecurityHubClientTypes.SeverityRating? = nil,
            title: Swift.String? = nil,
            updateStatus: SecurityHubClientTypes.UpdateStatus? = nil
        )
        {
            self.description = description
            self.lastUpdateReason = lastUpdateReason
            self.parameters = parameters
            self.remediationUrl = remediationUrl
            self.securityControlArn = securityControlArn
            self.securityControlId = securityControlId
            self.securityControlStatus = securityControlStatus
            self.severityRating = severityRating
            self.title = title
            self.updateStatus = updateStatus
        }
    }

}

extension SecurityHubClientTypes {

    public enum UnprocessedErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case invalidInput
        case limitExceeded
        case notFound
        case sdkUnknown(Swift.String)

        public static var allCases: [UnprocessedErrorCode] {
            return [
                .accessDenied,
                .invalidInput,
                .limitExceeded,
                .notFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .invalidInput: return "INVALID_INPUT"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case .notFound: return "NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Provides details about a security control for which a response couldn't be returned.
    public struct UnprocessedSecurityControl {
        /// The error code for the unprocessed security control.
        /// This member is required.
        public var errorCode: SecurityHubClientTypes.UnprocessedErrorCode?
        /// The reason why the security control was unprocessed.
        public var errorReason: Swift.String?
        /// The control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) for which a response couldn't be returned.
        /// This member is required.
        public var securityControlId: Swift.String?

        public init(
            errorCode: SecurityHubClientTypes.UnprocessedErrorCode? = nil,
            errorReason: Swift.String? = nil,
            securityControlId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorReason = errorReason
            self.securityControlId = securityControlId
        }
    }

}

public struct BatchGetSecurityControlsOutput {
    /// An array that returns the identifier, Amazon Resource Name (ARN), and other details about a security control. The same information is returned whether the request includes SecurityControlId or SecurityControlArn.
    /// This member is required.
    public var securityControls: [SecurityHubClientTypes.SecurityControl]?
    /// A security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) for which details cannot be returned.
    public var unprocessedIds: [SecurityHubClientTypes.UnprocessedSecurityControl]?

    public init(
        securityControls: [SecurityHubClientTypes.SecurityControl]? = nil,
        unprocessedIds: [SecurityHubClientTypes.UnprocessedSecurityControl]? = nil
    )
    {
        self.securityControls = securityControls
        self.unprocessedIds = unprocessedIds
    }
}

extension SecurityHubClientTypes {
    /// An array with one or more objects that includes a security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) and the Amazon Resource Name (ARN) of a standard. The security control ID or ARN is the same across standards.
    public struct StandardsControlAssociationId {
        /// The unique identifier (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) of a security control across standards.
        /// This member is required.
        public var securityControlId: Swift.String?
        /// The ARN of a standard.
        /// This member is required.
        public var standardsArn: Swift.String?

        public init(
            securityControlId: Swift.String? = nil,
            standardsArn: Swift.String? = nil
        )
        {
            self.securityControlId = securityControlId
            self.standardsArn = standardsArn
        }
    }

}

public struct BatchGetStandardsControlAssociationsInput {
    /// An array with one or more objects that includes a security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) and the Amazon Resource Name (ARN) of a standard. This field is used to query the enablement status of a control in a specified standard. The security control ID or ARN is the same across standards.
    /// This member is required.
    public var standardsControlAssociationIds: [SecurityHubClientTypes.StandardsControlAssociationId]?

    public init(
        standardsControlAssociationIds: [SecurityHubClientTypes.StandardsControlAssociationId]? = nil
    )
    {
        self.standardsControlAssociationIds = standardsControlAssociationIds
    }
}

extension SecurityHubClientTypes {
    /// Provides details about a control's enablement status in a specified standard.
    public struct StandardsControlAssociationDetail {
        /// Specifies whether a control is enabled or disabled in a specified standard.
        /// This member is required.
        public var associationStatus: SecurityHubClientTypes.AssociationStatus?
        /// The requirement that underlies a control in the compliance framework related to the standard.
        public var relatedRequirements: [Swift.String]?
        /// The ARN of a security control across standards, such as arn:aws:securityhub:eu-central-1:123456789012:security-control/S3.1. This parameter doesn't mention a specific standard.
        /// This member is required.
        public var securityControlArn: Swift.String?
        /// The unique identifier of a security control across standards. Values for this field typically consist of an Amazon Web Servicesservice name and a number, such as APIGateway.3.
        /// This member is required.
        public var securityControlId: Swift.String?
        /// The Amazon Resource Name (ARN) of a security standard.
        /// This member is required.
        public var standardsArn: Swift.String?
        /// Provides the input parameter that Security Hub uses to call the [UpdateStandardsControl](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_UpdateStandardsControl.html) API. This API can be used to enable or disable a control in a specified standard.
        public var standardsControlArns: [Swift.String]?
        /// The description of a control. This typically summarizes how Security Hub evaluates the control and the conditions under which it produces a failed finding. This parameter may reference a specific standard.
        public var standardsControlDescription: Swift.String?
        /// The title of a control. This field may reference a specific standard.
        public var standardsControlTitle: Swift.String?
        /// The time at which the enablement status of the control in the specified standard was last updated.
        public var updatedAt: Foundation.Date?
        /// The reason for updating the enablement status of a control in a specified standard.
        public var updatedReason: Swift.String?

        public init(
            associationStatus: SecurityHubClientTypes.AssociationStatus? = nil,
            relatedRequirements: [Swift.String]? = nil,
            securityControlArn: Swift.String? = nil,
            securityControlId: Swift.String? = nil,
            standardsArn: Swift.String? = nil,
            standardsControlArns: [Swift.String]? = nil,
            standardsControlDescription: Swift.String? = nil,
            standardsControlTitle: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedReason: Swift.String? = nil
        )
        {
            self.associationStatus = associationStatus
            self.relatedRequirements = relatedRequirements
            self.securityControlArn = securityControlArn
            self.securityControlId = securityControlId
            self.standardsArn = standardsArn
            self.standardsControlArns = standardsControlArns
            self.standardsControlDescription = standardsControlDescription
            self.standardsControlTitle = standardsControlTitle
            self.updatedAt = updatedAt
            self.updatedReason = updatedReason
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides details about which control's enablement status couldn't be retrieved in a specified standard when calling [BatchUpdateStandardsControlAssociations](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html). This parameter also provides details about why the request was unprocessed.
    public struct UnprocessedStandardsControlAssociation {
        /// The error code for the unprocessed standard and control association.
        /// This member is required.
        public var errorCode: SecurityHubClientTypes.UnprocessedErrorCode?
        /// The reason why the standard and control association was unprocessed.
        public var errorReason: Swift.String?
        /// An array with one or more objects that includes a security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) and the Amazon Resource Name (ARN) of a standard. This parameter shows the specific controls for which the enablement status couldn't be retrieved in specified standards when calling [BatchUpdateStandardsControlAssociations](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html).
        /// This member is required.
        public var standardsControlAssociationId: SecurityHubClientTypes.StandardsControlAssociationId?

        public init(
            errorCode: SecurityHubClientTypes.UnprocessedErrorCode? = nil,
            errorReason: Swift.String? = nil,
            standardsControlAssociationId: SecurityHubClientTypes.StandardsControlAssociationId? = nil
        )
        {
            self.errorCode = errorCode
            self.errorReason = errorReason
            self.standardsControlAssociationId = standardsControlAssociationId
        }
    }

}

public struct BatchGetStandardsControlAssociationsOutput {
    /// Provides the enablement status of a security control in a specified standard and other details for the control in relation to the specified standard.
    /// This member is required.
    public var standardsControlAssociationDetails: [SecurityHubClientTypes.StandardsControlAssociationDetail]?
    /// A security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) whose enablement status in a specified standard cannot be returned.
    public var unprocessedAssociations: [SecurityHubClientTypes.UnprocessedStandardsControlAssociation]?

    public init(
        standardsControlAssociationDetails: [SecurityHubClientTypes.StandardsControlAssociationDetail]? = nil,
        unprocessedAssociations: [SecurityHubClientTypes.UnprocessedStandardsControlAssociation]? = nil
    )
    {
        self.standardsControlAssociationDetails = standardsControlAssociationDetails
        self.unprocessedAssociations = unprocessedAssociations
    }
}

public struct BatchImportFindingsInput {
    /// A list of findings to import. To successfully import a finding, it must follow the [Amazon Web Services Security Finding Format](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format.html). Maximum of 100 findings per request.
    /// This member is required.
    public var findings: [SecurityHubClientTypes.AwsSecurityFinding]?

    public init(
        findings: [SecurityHubClientTypes.AwsSecurityFinding]? = nil
    )
    {
        self.findings = findings
    }
}

extension SecurityHubClientTypes {
    /// The list of the findings that cannot be imported. For each finding, the list provides the error.
    public struct ImportFindingsError {
        /// The code of the error returned by the BatchImportFindings operation.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message of the error returned by the BatchImportFindings operation.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The identifier of the finding that could not be updated.
        /// This member is required.
        public var id: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }

}

public struct BatchImportFindingsOutput {
    /// The number of findings that failed to import.
    /// This member is required.
    public var failedCount: Swift.Int?
    /// The list of findings that failed to import.
    public var failedFindings: [SecurityHubClientTypes.ImportFindingsError]?
    /// The number of findings that were successfully imported.
    /// This member is required.
    public var successCount: Swift.Int?

    public init(
        failedCount: Swift.Int? = nil,
        failedFindings: [SecurityHubClientTypes.ImportFindingsError]? = nil,
        successCount: Swift.Int? = nil
    )
    {
        self.failedCount = failedCount
        self.failedFindings = failedFindings
        self.successCount = successCount
    }
}

extension SecurityHubClientTypes {
    /// Specifies the parameters to update in an existing automation rule.
    public struct UpdateAutomationRulesRequestItem {
        /// One or more actions to update finding fields if a finding matches the conditions specified in Criteria.
        public var actions: [SecurityHubClientTypes.AutomationRulesAction]?
        /// A set of ASFF finding field attributes and corresponding expected values that Security Hub uses to filter findings. If a rule is enabled and a finding matches the conditions specified in this parameter, Security Hub applies the rule action to the finding.
        public var criteria: SecurityHubClientTypes.AutomationRulesFindingFilters?
        /// A description of the rule.
        public var description: Swift.String?
        /// Specifies whether a rule is the last to be applied with respect to a finding that matches the rule criteria. This is useful when a finding matches the criteria for multiple rules, and each rule has different actions. If a rule is terminal, Security Hub applies the rule action to a finding that matches the rule criteria and doesn't evaluate other rules for the finding. By default, a rule isn't terminal.
        public var isTerminal: Swift.Bool?
        /// The Amazon Resource Name (ARN) for the rule.
        /// This member is required.
        public var ruleArn: Swift.String?
        /// The name of the rule.
        public var ruleName: Swift.String?
        /// An integer ranging from 1 to 1000 that represents the order in which the rule action is applied to findings. Security Hub applies rules with lower values for this parameter first.
        public var ruleOrder: Swift.Int?
        /// Whether the rule is active after it is created. If this parameter is equal to ENABLED, Security Hub starts applying the rule to findings and finding updates after the rule is created. To change the value of this parameter after creating a rule, use [BatchUpdateAutomationRules](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateAutomationRules.html).
        public var ruleStatus: SecurityHubClientTypes.RuleStatus?

        public init(
            actions: [SecurityHubClientTypes.AutomationRulesAction]? = nil,
            criteria: SecurityHubClientTypes.AutomationRulesFindingFilters? = nil,
            description: Swift.String? = nil,
            isTerminal: Swift.Bool? = nil,
            ruleArn: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            ruleOrder: Swift.Int? = nil,
            ruleStatus: SecurityHubClientTypes.RuleStatus? = nil
        )
        {
            self.actions = actions
            self.criteria = criteria
            self.description = description
            self.isTerminal = isTerminal
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.ruleOrder = ruleOrder
            self.ruleStatus = ruleStatus
        }
    }

}

public struct BatchUpdateAutomationRulesInput {
    /// An array of ARNs for the rules that are to be updated. Optionally, you can also include RuleStatus and RuleOrder.
    /// This member is required.
    public var updateAutomationRulesRequestItems: [SecurityHubClientTypes.UpdateAutomationRulesRequestItem]?

    public init(
        updateAutomationRulesRequestItems: [SecurityHubClientTypes.UpdateAutomationRulesRequestItem]? = nil
    )
    {
        self.updateAutomationRulesRequestItems = updateAutomationRulesRequestItems
    }
}

public struct BatchUpdateAutomationRulesOutput {
    /// A list of properly processed rule ARNs.
    public var processedAutomationRules: [Swift.String]?
    /// A list of objects containing RuleArn, ErrorCode, and ErrorMessage. This parameter tells you which automation rules the request didn't update and why.
    public var unprocessedAutomationRules: [SecurityHubClientTypes.UnprocessedAutomationRule]?

    public init(
        processedAutomationRules: [Swift.String]? = nil,
        unprocessedAutomationRules: [SecurityHubClientTypes.UnprocessedAutomationRule]? = nil
    )
    {
        self.processedAutomationRules = processedAutomationRules
        self.unprocessedAutomationRules = unprocessedAutomationRules
    }
}

public struct BatchUpdateFindingsInput {
    /// The updated value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
    public var confidence: Swift.Int?
    /// The updated value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
    public var criticality: Swift.Int?
    /// The list of findings to update. BatchUpdateFindings can be used to update up to 100 findings at a time. For each finding, the list provides the finding identifier and the ARN of the finding provider.
    /// This member is required.
    public var findingIdentifiers: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]?
    /// The updated note.
    public var note: SecurityHubClientTypes.NoteUpdate?
    /// A list of findings that are related to the updated findings.
    public var relatedFindings: [SecurityHubClientTypes.RelatedFinding]?
    /// Used to update the finding severity.
    public var severity: SecurityHubClientTypes.SeverityUpdate?
    /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are as follows.
    ///
    /// * Software and Configuration Checks
    ///
    /// * TTPs
    ///
    /// * Effects
    ///
    /// * Unusual Behaviors
    ///
    /// * Sensitive Data Identifications
    public var types: [Swift.String]?
    /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
    public var userDefinedFields: [Swift.String: Swift.String]?
    /// Indicates the veracity of a finding. The available values for VerificationState are as follows.
    ///
    /// * UNKNOWN – The default disposition of a security finding
    ///
    /// * TRUE_POSITIVE – The security finding is confirmed
    ///
    /// * FALSE_POSITIVE – The security finding was determined to be a false alarm
    ///
    /// * BENIGN_POSITIVE – A special case of TRUE_POSITIVE where the finding doesn't pose any threat, is expected, or both
    public var verificationState: SecurityHubClientTypes.VerificationState?
    /// Used to update the workflow status of a finding. The workflow status indicates the progress of the investigation into the finding.
    public var workflow: SecurityHubClientTypes.WorkflowUpdate?

    public init(
        confidence: Swift.Int? = nil,
        criticality: Swift.Int? = nil,
        findingIdentifiers: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]? = nil,
        note: SecurityHubClientTypes.NoteUpdate? = nil,
        relatedFindings: [SecurityHubClientTypes.RelatedFinding]? = nil,
        severity: SecurityHubClientTypes.SeverityUpdate? = nil,
        types: [Swift.String]? = nil,
        userDefinedFields: [Swift.String: Swift.String]? = nil,
        verificationState: SecurityHubClientTypes.VerificationState? = nil,
        workflow: SecurityHubClientTypes.WorkflowUpdate? = nil
    )
    {
        self.confidence = confidence
        self.criticality = criticality
        self.findingIdentifiers = findingIdentifiers
        self.note = note
        self.relatedFindings = relatedFindings
        self.severity = severity
        self.types = types
        self.userDefinedFields = userDefinedFields
        self.verificationState = verificationState
        self.workflow = workflow
    }
}

extension SecurityHubClientTypes {
    /// A finding from a BatchUpdateFindings request that Security Hub was unable to update.
    public struct BatchUpdateFindingsUnprocessedFinding {
        /// The code associated with the error. Possible values are:
        ///
        /// * ConcurrentUpdateError - Another request attempted to update the finding while this request was being processed. This error may also occur if you call [BatchUpdateFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateFindings.html) and [BatchImportFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchImportFindings.html) at the same time.
        ///
        /// * DuplicatedFindingIdentifier - The request included two or more findings with the same FindingIdentifier.
        ///
        /// * FindingNotFound - The FindingIdentifier included in the request did not match an existing finding.
        ///
        /// * FindingSizeExceeded - The finding size was greater than the permissible value of 240 KB.
        ///
        /// * InternalFailure - An internal service failure occurred when updating the finding.
        ///
        /// * InvalidInput - The finding update contained an invalid value that did not satisfy the [Amazon Web Services Security Finding Format](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format.html) syntax.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message associated with the error. Possible values are:
        ///
        /// * Concurrent finding updates detected
        ///
        /// * Finding Identifier is duplicated
        ///
        /// * Finding Not Found
        ///
        /// * Finding size exceeded 240 KB
        ///
        /// * Internal service failure
        ///
        /// * Invalid Input
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The identifier of the finding that was not updated.
        /// This member is required.
        public var findingIdentifier: SecurityHubClientTypes.AwsSecurityFindingIdentifier?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            findingIdentifier: SecurityHubClientTypes.AwsSecurityFindingIdentifier? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingIdentifier = findingIdentifier
        }
    }

}

public struct BatchUpdateFindingsOutput {
    /// The list of findings that were updated successfully.
    /// This member is required.
    public var processedFindings: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]?
    /// The list of findings that were not updated.
    /// This member is required.
    public var unprocessedFindings: [SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding]?

    public init(
        processedFindings: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]? = nil,
        unprocessedFindings: [SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding]? = nil
    )
    {
        self.processedFindings = processedFindings
        self.unprocessedFindings = unprocessedFindings
    }
}

extension SecurityHubClientTypes {
    /// An array of requested updates to the enablement status of controls in specified standards. The objects in the array include a security control ID, the Amazon Resource Name (ARN) of the standard, the requested enablement status, and the reason for updating the enablement status.
    public struct StandardsControlAssociationUpdate {
        /// The desired enablement status of the control in the standard.
        /// This member is required.
        public var associationStatus: SecurityHubClientTypes.AssociationStatus?
        /// The unique identifier for the security control whose enablement status you want to update.
        /// This member is required.
        public var securityControlId: Swift.String?
        /// The Amazon Resource Name (ARN) of the standard in which you want to update the control's enablement status.
        /// This member is required.
        public var standardsArn: Swift.String?
        /// The reason for updating the control's enablement status in the standard.
        public var updatedReason: Swift.String?

        public init(
            associationStatus: SecurityHubClientTypes.AssociationStatus? = nil,
            securityControlId: Swift.String? = nil,
            standardsArn: Swift.String? = nil,
            updatedReason: Swift.String? = nil
        )
        {
            self.associationStatus = associationStatus
            self.securityControlId = securityControlId
            self.standardsArn = standardsArn
            self.updatedReason = updatedReason
        }
    }

}

public struct BatchUpdateStandardsControlAssociationsInput {
    /// Updates the enablement status of a security control in a specified standard.
    /// This member is required.
    public var standardsControlAssociationUpdates: [SecurityHubClientTypes.StandardsControlAssociationUpdate]?

    public init(
        standardsControlAssociationUpdates: [SecurityHubClientTypes.StandardsControlAssociationUpdate]? = nil
    )
    {
        self.standardsControlAssociationUpdates = standardsControlAssociationUpdates
    }
}

extension SecurityHubClientTypes {
    /// Provides details about which control's enablement status could not be updated in a specified standard when calling the [BatchUpdateStandardsControlAssociations](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html) API. This parameter also provides details about why the request was unprocessed.
    public struct UnprocessedStandardsControlAssociationUpdate {
        /// The error code for the unprocessed update of the control's enablement status in the specified standard.
        /// This member is required.
        public var errorCode: SecurityHubClientTypes.UnprocessedErrorCode?
        /// The reason why a control's enablement status in the specified standard couldn't be updated.
        public var errorReason: Swift.String?
        /// An array of control and standard associations for which an update failed when calling [BatchUpdateStandardsControlAssociations](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html).
        /// This member is required.
        public var standardsControlAssociationUpdate: SecurityHubClientTypes.StandardsControlAssociationUpdate?

        public init(
            errorCode: SecurityHubClientTypes.UnprocessedErrorCode? = nil,
            errorReason: Swift.String? = nil,
            standardsControlAssociationUpdate: SecurityHubClientTypes.StandardsControlAssociationUpdate? = nil
        )
        {
            self.errorCode = errorCode
            self.errorReason = errorReason
            self.standardsControlAssociationUpdate = standardsControlAssociationUpdate
        }
    }

}

public struct BatchUpdateStandardsControlAssociationsOutput {
    /// A security control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) whose enablement status in a specified standard couldn't be updated.
    public var unprocessedAssociationUpdates: [SecurityHubClientTypes.UnprocessedStandardsControlAssociationUpdate]?

    public init(
        unprocessedAssociationUpdates: [SecurityHubClientTypes.UnprocessedStandardsControlAssociationUpdate]? = nil
    )
    {
        self.unprocessedAssociationUpdates = unprocessedAssociationUpdates
    }
}

extension SecurityHubClientTypes {
    /// The options for customizing a security control parameter with a boolean. For a boolean parameter, the options are true and false.
    public struct BooleanConfigurationOptions {
        /// The Security Hub default value for a boolean parameter.
        public var defaultValue: Swift.Bool?

        public init(
            defaultValue: Swift.Bool? = nil
        )
        {
            self.defaultValue = defaultValue
        }
    }

}

extension SecurityHubClientTypes {
    /// The options for customizing a security control parameter that is a double.
    public struct DoubleConfigurationOptions {
        /// The Security Hub default value for a control parameter that is a double.
        public var defaultValue: Swift.Double?
        /// The maximum valid value for a control parameter that is a double.
        public var max: Swift.Double?
        /// The minimum valid value for a control parameter that is a double.
        public var min: Swift.Double?

        public init(
            defaultValue: Swift.Double? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil
        )
        {
            self.defaultValue = defaultValue
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The options for customizing a security control parameter that is an enum.
    public struct EnumConfigurationOptions {
        /// The valid values for a control parameter that is an enum.
        public var allowedValues: [Swift.String]?
        /// The Security Hub default value for a control parameter that is an enum.
        public var defaultValue: Swift.String?

        public init(
            allowedValues: [Swift.String]? = nil,
            defaultValue: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }
    }

}

extension SecurityHubClientTypes {
    /// The options for customizing a security control parameter that is a list of enums.
    public struct EnumListConfigurationOptions {
        /// The valid values for a control parameter that is a list of enums.
        public var allowedValues: [Swift.String]?
        /// The Security Hub default value for a control parameter that is a list of enums.
        public var defaultValue: [Swift.String]?
        /// The maximum number of list items that an enum list control parameter can accept.
        public var maxItems: Swift.Int?

        public init(
            allowedValues: [Swift.String]? = nil,
            defaultValue: [Swift.String]? = nil,
            maxItems: Swift.Int? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
            self.maxItems = maxItems
        }
    }

}

extension SecurityHubClientTypes {
    /// The options for customizing a security control parameter that is an integer.
    public struct IntegerConfigurationOptions {
        /// The Security Hub default value for a control parameter that is an integer.
        public var defaultValue: Swift.Int?
        /// The maximum valid value for a control parameter that is an integer.
        public var max: Swift.Int?
        /// The minimum valid value for a control parameter that is an integer.
        public var min: Swift.Int?

        public init(
            defaultValue: Swift.Int? = nil,
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.defaultValue = defaultValue
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The options for customizing a security control parameter that is a list of integers.
    public struct IntegerListConfigurationOptions {
        /// The Security Hub default value for a control parameter that is a list of integers.
        public var defaultValue: [Swift.Int]?
        /// The maximum valid value for a control parameter that is a list of integers.
        public var max: Swift.Int?
        /// The maximum number of list items that an interger list control parameter can accept.
        public var maxItems: Swift.Int?
        /// The minimum valid value for a control parameter that is a list of integers.
        public var min: Swift.Int?

        public init(
            defaultValue: [Swift.Int]? = nil,
            max: Swift.Int? = nil,
            maxItems: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.defaultValue = defaultValue
            self.max = max
            self.maxItems = maxItems
            self.min = min
        }
    }

}

extension SecurityHubClientTypes {
    /// The options for customizing a security control parameter that is a string.
    public struct StringConfigurationOptions {
        /// The Security Hub default value for a control parameter that is a string.
        public var defaultValue: Swift.String?
        /// The description of the RE2 regular expression.
        public var expressionDescription: Swift.String?
        /// An RE2 regular expression that Security Hub uses to validate a user-provided control parameter string.
        public var re2Expression: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            expressionDescription: Swift.String? = nil,
            re2Expression: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.expressionDescription = expressionDescription
            self.re2Expression = re2Expression
        }
    }

}

extension SecurityHubClientTypes {
    /// The options for customizing a security control parameter that is a list of strings.
    public struct StringListConfigurationOptions {
        /// The Security Hub default value for a control parameter that is a list of strings.
        public var defaultValue: [Swift.String]?
        /// The description of the RE2 regular expression.
        public var expressionDescription: Swift.String?
        /// The maximum number of list items that a string list control parameter can accept.
        public var maxItems: Swift.Int?
        /// An RE2 regular expression that Security Hub uses to validate a user-provided list of strings for a control parameter.
        public var re2Expression: Swift.String?

        public init(
            defaultValue: [Swift.String]? = nil,
            expressionDescription: Swift.String? = nil,
            maxItems: Swift.Int? = nil,
            re2Expression: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.expressionDescription = expressionDescription
            self.maxItems = maxItems
            self.re2Expression = re2Expression
        }
    }

}

extension SecurityHubClientTypes {
    /// The options for customizing a security control parameter.
    public enum ConfigurationOptions {
        /// The options for customizing a security control parameter that is an integer.
        case integer(SecurityHubClientTypes.IntegerConfigurationOptions)
        /// The options for customizing a security control parameter that is a list of integers.
        case integerlist(SecurityHubClientTypes.IntegerListConfigurationOptions)
        /// The options for customizing a security control parameter that is a double.
        case double(SecurityHubClientTypes.DoubleConfigurationOptions)
        /// The options for customizing a security control parameter that is a string data type.
        case string(SecurityHubClientTypes.StringConfigurationOptions)
        /// The options for customizing a security control parameter that is a list of strings.
        case stringlist(SecurityHubClientTypes.StringListConfigurationOptions)
        /// The options for customizing a security control parameter that is a boolean. For a boolean parameter, the options are true and false.
        case boolean(SecurityHubClientTypes.BooleanConfigurationOptions)
        /// The options for customizing a security control parameter that is an enum.
        case `enum`(SecurityHubClientTypes.EnumConfigurationOptions)
        /// The options for customizing a security control parameter that is a list of enums.
        case enumlist(SecurityHubClientTypes.EnumListConfigurationOptions)
        case sdkUnknown(Swift.String)
    }

}

extension SecurityHubClientTypes {
    /// An object that contains the details of an Security Hub configuration policy that’s returned in a ListConfigurationPolicies request.
    public struct ConfigurationPolicySummary {
        /// The Amazon Resource Name (ARN) of the configuration policy.
        public var arn: Swift.String?
        /// The description of the configuration policy.
        public var description: Swift.String?
        /// The universally unique identifier (UUID) of the configuration policy.
        public var id: Swift.String?
        /// The name of the configuration policy. Alphanumeric characters and the following ASCII characters are permitted: -, ., !, *, /.
        public var name: Swift.String?
        /// Indicates whether the service that the configuration policy applies to is enabled in the policy.
        public var serviceEnabled: Swift.Bool?
        /// The date and time, in UTC and ISO 8601 format, that the configuration policy was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            serviceEnabled: Swift.Bool? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.serviceEnabled = serviceEnabled
            self.updatedAt = updatedAt
        }
    }

}

extension SecurityHubClientTypes {

    public enum ControlFindingGenerator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case securityControl
        case standardControl
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlFindingGenerator] {
            return [
                .securityControl,
                .standardControl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .securityControl: return "SECURITY_CONTROL"
            case .standardControl: return "STANDARD_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The resource specified in the request conflicts with an existing resource.
public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct CreateActionTargetInput {
    /// The description for the custom action target.
    /// This member is required.
    public var description: Swift.String?
    /// The ID for the custom action target. Can contain up to 20 alphanumeric characters.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the custom action target. Can contain up to 20 characters.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

public struct CreateActionTargetOutput {
    /// The Amazon Resource Name (ARN) for the custom action target.
    /// This member is required.
    public var actionTargetArn: Swift.String?

    public init(
        actionTargetArn: Swift.String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
    }
}

public struct CreateAutomationRuleInput {
    /// One or more actions to update finding fields if a finding matches the conditions specified in Criteria.
    /// This member is required.
    public var actions: [SecurityHubClientTypes.AutomationRulesAction]?
    /// A set of ASFF finding field attributes and corresponding expected values that Security Hub uses to filter findings. If a rule is enabled and a finding matches the conditions specified in this parameter, Security Hub applies the rule action to the finding.
    /// This member is required.
    public var criteria: SecurityHubClientTypes.AutomationRulesFindingFilters?
    /// A description of the rule.
    /// This member is required.
    public var description: Swift.String?
    /// Specifies whether a rule is the last to be applied with respect to a finding that matches the rule criteria. This is useful when a finding matches the criteria for multiple rules, and each rule has different actions. If a rule is terminal, Security Hub applies the rule action to a finding that matches the rule criteria and doesn't evaluate other rules for the finding. By default, a rule isn't terminal.
    public var isTerminal: Swift.Bool?
    /// The name of the rule.
    /// This member is required.
    public var ruleName: Swift.String?
    /// An integer ranging from 1 to 1000 that represents the order in which the rule action is applied to findings. Security Hub applies rules with lower values for this parameter first.
    /// This member is required.
    public var ruleOrder: Swift.Int?
    /// Whether the rule is active after it is created. If this parameter is equal to ENABLED, Security Hub starts applying the rule to findings and finding updates after the rule is created. To change the value of this parameter after creating a rule, use [BatchUpdateAutomationRules](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateAutomationRules.html).
    public var ruleStatus: SecurityHubClientTypes.RuleStatus?
    /// User-defined tags associated with an automation rule.
    public var tags: [Swift.String: Swift.String]?

    public init(
        actions: [SecurityHubClientTypes.AutomationRulesAction]? = nil,
        criteria: SecurityHubClientTypes.AutomationRulesFindingFilters? = nil,
        description: Swift.String? = nil,
        isTerminal: Swift.Bool? = nil,
        ruleName: Swift.String? = nil,
        ruleOrder: Swift.Int? = nil,
        ruleStatus: SecurityHubClientTypes.RuleStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.actions = actions
        self.criteria = criteria
        self.description = description
        self.isTerminal = isTerminal
        self.ruleName = ruleName
        self.ruleOrder = ruleOrder
        self.ruleStatus = ruleStatus
        self.tags = tags
    }
}

public struct CreateAutomationRuleOutput {
    /// The Amazon Resource Name (ARN) of the automation rule that you created.
    public var ruleArn: Swift.String?

    public init(
        ruleArn: Swift.String? = nil
    )
    {
        self.ruleArn = ruleArn
    }
}

extension SecurityHubClientTypes {
    /// A list of security controls and control parameter values that are included in a configuration policy.
    public struct SecurityControlCustomParameter {
        /// An object that specifies parameter values for a control in a configuration policy.
        public var parameters: [Swift.String: SecurityHubClientTypes.ParameterConfiguration]?
        /// The ID of the security control.
        public var securityControlId: Swift.String?

        public init(
            parameters: [Swift.String: SecurityHubClientTypes.ParameterConfiguration]? = nil,
            securityControlId: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.securityControlId = securityControlId
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that defines which security controls are enabled in an Security Hub configuration policy. The enablement status of a control is aligned across all of the enabled standards in an account.
    public struct SecurityControlsConfiguration {
        /// A list of security controls that are disabled in the configuration policy. Security Hub enables all other controls (including newly released controls) other than the listed controls.
        public var disabledSecurityControlIdentifiers: [Swift.String]?
        /// A list of security controls that are enabled in the configuration policy. Security Hub disables all other controls (including newly released controls) other than the listed controls.
        public var enabledSecurityControlIdentifiers: [Swift.String]?
        /// A list of security controls and control parameter values that are included in a configuration policy.
        public var securityControlCustomParameters: [SecurityHubClientTypes.SecurityControlCustomParameter]?

        public init(
            disabledSecurityControlIdentifiers: [Swift.String]? = nil,
            enabledSecurityControlIdentifiers: [Swift.String]? = nil,
            securityControlCustomParameters: [SecurityHubClientTypes.SecurityControlCustomParameter]? = nil
        )
        {
            self.disabledSecurityControlIdentifiers = disabledSecurityControlIdentifiers
            self.enabledSecurityControlIdentifiers = enabledSecurityControlIdentifiers
            self.securityControlCustomParameters = securityControlCustomParameters
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that defines how Security Hub is configured. The configuration policy includes whether Security Hub is enabled or disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls. If you provide a list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including newly released controls). If you provide a list of security controls that are disabled in the configuration policy, Security Hub enables all other controls (including newly released controls).
    public struct SecurityHubPolicy {
        /// A list that defines which security standards are enabled in the configuration policy.
        public var enabledStandardIdentifiers: [Swift.String]?
        /// An object that defines which security controls are enabled in the configuration policy. The enablement status of a control is aligned across all of the enabled standards in an account.
        public var securityControlsConfiguration: SecurityHubClientTypes.SecurityControlsConfiguration?
        /// Indicates whether Security Hub is enabled in the policy.
        public var serviceEnabled: Swift.Bool?

        public init(
            enabledStandardIdentifiers: [Swift.String]? = nil,
            securityControlsConfiguration: SecurityHubClientTypes.SecurityControlsConfiguration? = nil,
            serviceEnabled: Swift.Bool? = nil
        )
        {
            self.enabledStandardIdentifiers = enabledStandardIdentifiers
            self.securityControlsConfiguration = securityControlsConfiguration
            self.serviceEnabled = serviceEnabled
        }
    }

}

extension SecurityHubClientTypes {
    /// An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls. If you provide a list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including newly released controls). If you provide a list of security controls that are disabled in the configuration policy, Security Hub enables all other controls (including newly released controls).
    public enum Policy {
        /// The Amazon Web Servicesservice that the configuration policy applies to.
        case securityhub(SecurityHubClientTypes.SecurityHubPolicy)
        case sdkUnknown(Swift.String)
    }

}

public struct CreateConfigurationPolicyInput {
    /// An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls. If you provide a list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including newly released controls). If you provide a list of security controls that are disabled in the configuration policy, Security Hub enables all other controls (including newly released controls).
    /// This member is required.
    public var configurationPolicy: SecurityHubClientTypes.Policy?
    /// The description of the configuration policy.
    public var description: Swift.String?
    /// The name of the configuration policy. Alphanumeric characters and the following ASCII characters are permitted: -, ., !, *, /.
    /// This member is required.
    public var name: Swift.String?
    /// User-defined tags associated with a configuration policy. For more information, see [Tagging Security Hub resources](https://docs.aws.amazon.com/securityhub/latest/userguide/tagging-resources.html) in the Security Hub user guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        configurationPolicy: SecurityHubClientTypes.Policy? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.configurationPolicy = configurationPolicy
        self.description = description
        self.name = name
        self.tags = tags
    }
}

public struct CreateConfigurationPolicyOutput {
    /// The Amazon Resource Name (ARN) of the configuration policy.
    public var arn: Swift.String?
    /// An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls. If the request included a list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including newly released controls). If the request included a list of security controls that are disabled in the configuration policy, Security Hub enables all other controls (including newly released controls).
    public var configurationPolicy: SecurityHubClientTypes.Policy?
    /// The date and time, in UTC and ISO 8601 format, that the configuration policy was created.
    public var createdAt: Foundation.Date?
    /// The description of the configuration policy.
    public var description: Swift.String?
    /// The universally unique identifier (UUID) of the configuration policy.
    public var id: Swift.String?
    /// The name of the configuration policy.
    public var name: Swift.String?
    /// The date and time, in UTC and ISO 8601 format, that the configuration policy was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        configurationPolicy: SecurityHubClientTypes.Policy? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.configurationPolicy = configurationPolicy
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
    }
}

public struct CreateFindingAggregatorInput {
    /// Indicates whether to aggregate findings from all of the available Regions in the current partition. Also determines whether to automatically aggregate findings from new Regions as Security Hub supports them and you opt into them. The selected option also determines how to use the Regions provided in the Regions list. The options are as follows:
    ///
    /// * ALL_REGIONS - Aggregates findings from all of the Regions where Security Hub is enabled. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.
    ///
    /// * ALL_REGIONS_EXCEPT_SPECIFIED - Aggregates findings from all of the Regions where Security Hub is enabled, except for the Regions listed in the Regions parameter. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.
    ///
    /// * SPECIFIED_REGIONS - Aggregates findings only from the Regions listed in the Regions parameter. Security Hub does not automatically aggregate findings from new Regions.
    ///
    /// * NO_REGIONS - Aggregates no data because no Regions are selected as linked Regions.
    /// This member is required.
    public var regionLinkingMode: Swift.String?
    /// If RegionLinkingMode is ALL_REGIONS_EXCEPT_SPECIFIED, then this is a space-separated list of Regions that do not aggregate findings to the aggregation Region. If RegionLinkingMode is SPECIFIED_REGIONS, then this is a space-separated list of Regions that do aggregate findings to the aggregation Region. An InvalidInputException error results if you populate this field while RegionLinkingMode is NO_REGIONS.
    public var regions: [Swift.String]?

    public init(
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

public struct CreateFindingAggregatorOutput {
    /// The aggregation Region.
    public var findingAggregationRegion: Swift.String?
    /// The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and stop finding aggregation.
    public var findingAggregatorArn: Swift.String?
    /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
    public var regionLinkingMode: Swift.String?
    /// The list of excluded Regions or included Regions.
    public var regions: [Swift.String]?

    public init(
        findingAggregationRegion: Swift.String? = nil,
        findingAggregatorArn: Swift.String? = nil,
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.findingAggregationRegion = findingAggregationRegion
        self.findingAggregatorArn = findingAggregatorArn
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

public struct CreateInsightInput {
    /// One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.
    /// This member is required.
    public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    /// The attribute used to group the findings for the insight. The grouping attribute identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
    /// This member is required.
    public var groupByAttribute: Swift.String?
    /// The name of the custom insight to create.
    /// This member is required.
    public var name: Swift.String?

    public init(
        filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
        groupByAttribute: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.filters = filters
        self.groupByAttribute = groupByAttribute
        self.name = name
    }
}

public struct CreateInsightOutput {
    /// The ARN of the insight created.
    /// This member is required.
    public var insightArn: Swift.String?

    public init(
        insightArn: Swift.String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

public struct CreateMembersInput {
    /// The list of accounts to associate with the Security Hub administrator account. For each account, the list includes the account ID and optionally the email address.
    /// This member is required.
    public var accountDetails: [SecurityHubClientTypes.AccountDetails]?

    public init(
        accountDetails: [SecurityHubClientTypes.AccountDetails]? = nil
    )
    {
        self.accountDetails = accountDetails
    }
}

extension SecurityHubClientTypes {
    /// Details about the account that was not processed.
    public struct Result {
        /// An Amazon Web Services account ID of the account that was not processed.
        public var accountId: Swift.String?
        /// The reason that the account was not processed.
        public var processingResult: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            processingResult: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.processingResult = processingResult
        }
    }

}

public struct CreateMembersOutput {
    /// The list of Amazon Web Services accounts that were not processed. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init(
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

extension SecurityHubClientTypes {

    public enum SecurityControlProperty: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case parameters
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityControlProperty] {
            return [
                .parameters
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .parameters: return "Parameters"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeclineInvitationsInput {
    /// The list of prospective member account IDs for which to decline an invitation.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

public struct DeclineInvitationsOutput {
    /// The list of Amazon Web Services accounts that were not processed. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init(
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

public struct DeleteActionTargetInput {
    /// The Amazon Resource Name (ARN) of the custom action target to delete.
    /// This member is required.
    public var actionTargetArn: Swift.String?

    public init(
        actionTargetArn: Swift.String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
    }
}

public struct DeleteActionTargetOutput {
    /// The ARN of the custom action target that was deleted.
    /// This member is required.
    public var actionTargetArn: Swift.String?

    public init(
        actionTargetArn: Swift.String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
    }
}

public struct DeleteConfigurationPolicyInput {
    /// The Amazon Resource Name (ARN) or universally unique identifier (UUID) of the configuration policy.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DeleteConfigurationPolicyOutput {

    public init() { }
}

public struct DeleteFindingAggregatorInput {
    /// The ARN of the finding aggregator to delete. To obtain the ARN, use ListFindingAggregators.
    /// This member is required.
    public var findingAggregatorArn: Swift.String?

    public init(
        findingAggregatorArn: Swift.String? = nil
    )
    {
        self.findingAggregatorArn = findingAggregatorArn
    }
}

public struct DeleteFindingAggregatorOutput {

    public init() { }
}

public struct DeleteInsightInput {
    /// The ARN of the insight to delete.
    /// This member is required.
    public var insightArn: Swift.String?

    public init(
        insightArn: Swift.String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

public struct DeleteInsightOutput {
    /// The ARN of the insight that was deleted.
    /// This member is required.
    public var insightArn: Swift.String?

    public init(
        insightArn: Swift.String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

public struct DeleteInvitationsInput {
    /// The list of member account IDs that received the invitations you want to delete.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

public struct DeleteInvitationsOutput {
    /// The list of Amazon Web Services accounts for which the invitations were not deleted. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init(
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

public struct DeleteMembersInput {
    /// The list of account IDs for the member accounts to delete.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

public struct DeleteMembersOutput {
    /// The list of Amazon Web Services accounts that were not deleted. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init(
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

public struct DescribeActionTargetsInput {
    /// A list of custom action target ARNs for the custom action targets to retrieve.
    public var actionTargetArns: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the DescribeActionTargets operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init(
        actionTargetArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionTargetArns = actionTargetArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeActionTargetsOutput {
    /// A list of ActionTarget objects. Each object includes the ActionTargetArn, Description, and Name of a custom action target available in Security Hub.
    /// This member is required.
    public var actionTargets: [SecurityHubClientTypes.ActionTarget]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        actionTargets: [SecurityHubClientTypes.ActionTarget]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionTargets = actionTargets
        self.nextToken = nextToken
    }
}

public struct DescribeHubInput {
    /// The ARN of the Hub resource to retrieve.
    public var hubArn: Swift.String?

    public init(
        hubArn: Swift.String? = nil
    )
    {
        self.hubArn = hubArn
    }
}

public struct DescribeHubOutput {
    /// Whether to automatically enable new controls when they are added to standards that are enabled. If set to true, then new controls for enabled standards are enabled automatically. If set to false, then new controls are not enabled.
    public var autoEnableControls: Swift.Bool?
    /// Specifies whether the calling account has consolidated control findings turned on. If the value for this field is set to SECURITY_CONTROL, Security Hub generates a single finding for a control check even when the check applies to multiple enabled standards. If the value for this field is set to STANDARD_CONTROL, Security Hub generates separate findings for a control check when the check applies to multiple enabled standards. The value for this field in a member account matches the value in the administrator account. For accounts that aren't part of an organization, the default value of this field is SECURITY_CONTROL if you enabled Security Hub on or after February 23, 2023.
    public var controlFindingGenerator: SecurityHubClientTypes.ControlFindingGenerator?
    /// The ARN of the Hub resource that was retrieved.
    public var hubArn: Swift.String?
    /// The date and time when Security Hub was enabled in the account.
    public var subscribedAt: Swift.String?

    public init(
        autoEnableControls: Swift.Bool? = nil,
        controlFindingGenerator: SecurityHubClientTypes.ControlFindingGenerator? = nil,
        hubArn: Swift.String? = nil,
        subscribedAt: Swift.String? = nil
    )
    {
        self.autoEnableControls = autoEnableControls
        self.controlFindingGenerator = controlFindingGenerator
        self.hubArn = hubArn
        self.subscribedAt = subscribedAt
    }
}

public struct DescribeOrganizationConfigurationInput {

    public init() { }
}

extension SecurityHubClientTypes {

    public enum OrganizationConfigurationConfigurationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case central
        case local
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationConfigurationConfigurationType] {
            return [
                .central,
                .local
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .central: return "CENTRAL"
            case .local: return "LOCAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {

    public enum OrganizationConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationConfigurationStatus] {
            return [
                .enabled,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the way an organization is configured in Security Hub.
    public struct OrganizationConfiguration {
        /// Indicates whether the organization uses local or central configuration. If you use local configuration, the Security Hub delegated administrator can set AutoEnable to true and AutoEnableStandards to DEFAULT. This automatically enables Security Hub and default security standards in new organization accounts. These new account settings must be set separately in each Amazon Web Services Region, and settings may be different in each Region. If you use central configuration, the delegated administrator can create configuration policies. Configuration policies can be used to configure Security Hub, security standards, and security controls in multiple accounts and Regions. If you want new organization accounts to use a specific configuration, you can create a configuration policy and associate it with the root or specific organizational units (OUs). New accounts will inherit the policy from the root or their assigned OU.
        public var configurationType: SecurityHubClientTypes.OrganizationConfigurationConfigurationType?
        /// Describes whether central configuration could be enabled as the ConfigurationType for the organization. If your ConfigurationType is local configuration, then the value of Status is always ENABLED.
        public var status: SecurityHubClientTypes.OrganizationConfigurationStatus?
        /// Provides an explanation if the value of Status is equal to FAILED when ConfigurationType is equal to CENTRAL.
        public var statusMessage: Swift.String?

        public init(
            configurationType: SecurityHubClientTypes.OrganizationConfigurationConfigurationType? = nil,
            status: SecurityHubClientTypes.OrganizationConfigurationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.configurationType = configurationType
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

public struct DescribeOrganizationConfigurationOutput {
    /// Whether to automatically enable Security Hub in new member accounts when they join the organization. If set to true, then Security Hub is automatically enabled in new accounts. If set to false, then Security Hub isn't enabled in new accounts automatically. The default value is false. If the ConfigurationType of your organization is set to CENTRAL, then this field is set to false and can't be changed in the home Region and linked Regions. However, in that case, the delegated administrator can create a configuration policy in which Security Hub is enabled and associate the policy with new organization accounts.
    public var autoEnable: Swift.Bool?
    /// Whether to automatically enable Security Hub [default standards](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-enable-disable.html) in new member accounts when they join the organization. If equal to DEFAULT, then Security Hub default standards are automatically enabled for new member accounts. If equal to NONE, then default standards are not automatically enabled for new member accounts. The default value of this parameter is equal to DEFAULT. If the ConfigurationType of your organization is set to CENTRAL, then this field is set to NONE and can't be changed in the home Region and linked Regions. However, in that case, the delegated administrator can create a configuration policy in which specific security standards are enabled and associate the policy with new organization accounts.
    public var autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards?
    /// Whether the maximum number of allowed member accounts are already associated with the Security Hub administrator account.
    public var memberAccountLimitReached: Swift.Bool?
    /// Provides information about the way an organization is configured in Security Hub.
    public var organizationConfiguration: SecurityHubClientTypes.OrganizationConfiguration?

    public init(
        autoEnable: Swift.Bool? = nil,
        autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards? = nil,
        memberAccountLimitReached: Swift.Bool? = nil,
        organizationConfiguration: SecurityHubClientTypes.OrganizationConfiguration? = nil
    )
    {
        self.autoEnable = autoEnable
        self.autoEnableStandards = autoEnableStandards
        self.memberAccountLimitReached = memberAccountLimitReached
        self.organizationConfiguration = organizationConfiguration
    }
}

public struct DescribeProductsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the DescribeProducts operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// The ARN of the integration to return.
    public var productArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        productArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productArn = productArn
    }
}

extension SecurityHubClientTypes {

    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case receiveFindingsFromSecurityHub
        case sendFindingsToSecurityHub
        case updateFindingsInSecurityHub
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .receiveFindingsFromSecurityHub,
                .sendFindingsToSecurityHub,
                .updateFindingsInSecurityHub
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .receiveFindingsFromSecurityHub: return "RECEIVE_FINDINGS_FROM_SECURITY_HUB"
            case .sendFindingsToSecurityHub: return "SEND_FINDINGS_TO_SECURITY_HUB"
            case .updateFindingsInSecurityHub: return "UPDATE_FINDINGS_IN_SECURITY_HUB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Contains details about a product.
    public struct Product {
        /// The URL to the service or product documentation about the integration with Security Hub, including how to activate the integration.
        public var activationUrl: Swift.String?
        /// The categories assigned to the product.
        public var categories: [Swift.String]?
        /// The name of the company that provides the product.
        public var companyName: Swift.String?
        /// A description of the product.
        public var description: Swift.String?
        /// The types of integration that the product supports. Available values are the following.
        ///
        /// * SEND_FINDINGS_TO_SECURITY_HUB - The integration sends findings to Security Hub.
        ///
        /// * RECEIVE_FINDINGS_FROM_SECURITY_HUB - The integration receives findings from Security Hub.
        ///
        /// * UPDATE_FINDINGS_IN_SECURITY_HUB - The integration does not send new findings to Security Hub, but does make updates to the findings that it receives from Security Hub.
        public var integrationTypes: [SecurityHubClientTypes.IntegrationType]?
        /// For integrations with Amazon Web Services services, the Amazon Web Services Console URL from which to activate the service. For integrations with third-party products, the Amazon Web Services Marketplace URL from which to subscribe to or purchase the product.
        public var marketplaceUrl: Swift.String?
        /// The ARN assigned to the product.
        /// This member is required.
        public var productArn: Swift.String?
        /// The name of the product.
        public var productName: Swift.String?
        /// The resource policy associated with the product.
        public var productSubscriptionResourcePolicy: Swift.String?

        public init(
            activationUrl: Swift.String? = nil,
            categories: [Swift.String]? = nil,
            companyName: Swift.String? = nil,
            description: Swift.String? = nil,
            integrationTypes: [SecurityHubClientTypes.IntegrationType]? = nil,
            marketplaceUrl: Swift.String? = nil,
            productArn: Swift.String? = nil,
            productName: Swift.String? = nil,
            productSubscriptionResourcePolicy: Swift.String? = nil
        )
        {
            self.activationUrl = activationUrl
            self.categories = categories
            self.companyName = companyName
            self.description = description
            self.integrationTypes = integrationTypes
            self.marketplaceUrl = marketplaceUrl
            self.productArn = productArn
            self.productName = productName
            self.productSubscriptionResourcePolicy = productSubscriptionResourcePolicy
        }
    }

}

public struct DescribeProductsOutput {
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?
    /// A list of products, including details for each product.
    /// This member is required.
    public var products: [SecurityHubClientTypes.Product]?

    public init(
        nextToken: Swift.String? = nil,
        products: [SecurityHubClientTypes.Product]? = nil
    )
    {
        self.nextToken = nextToken
        self.products = products
    }
}

public struct DescribeStandardsInput {
    /// The maximum number of standards to return.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the DescribeStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the management of a security standard.
    public struct StandardsManagedBy {
        /// An identifier for the company that manages a specific security standard. For existing standards, the value is equal to Amazon Web Services.
        public var company: Swift.String?
        /// An identifier for the product that manages a specific security standard. For existing standards, the value is equal to the Amazon Web Services service that manages the standard.
        public var product: Swift.String?

        public init(
            company: Swift.String? = nil,
            product: Swift.String? = nil
        )
        {
            self.company = company
            self.product = product
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides information about a specific security standard.
    public struct Standard {
        /// A description of the standard.
        public var description: Swift.String?
        /// Whether the standard is enabled by default. When Security Hub is enabled from the console, if a standard is enabled by default, the check box for that standard is selected by default. When Security Hub is enabled using the EnableSecurityHub API operation, the standard is enabled by default unless EnableDefaultStandards is set to false.
        public var enabledByDefault: Swift.Bool?
        /// The name of the standard.
        public var name: Swift.String?
        /// The ARN of a standard.
        public var standardsArn: Swift.String?
        /// Provides details about the management of a standard.
        public var standardsManagedBy: SecurityHubClientTypes.StandardsManagedBy?

        public init(
            description: Swift.String? = nil,
            enabledByDefault: Swift.Bool? = nil,
            name: Swift.String? = nil,
            standardsArn: Swift.String? = nil,
            standardsManagedBy: SecurityHubClientTypes.StandardsManagedBy? = nil
        )
        {
            self.description = description
            self.enabledByDefault = enabledByDefault
            self.name = name
            self.standardsArn = standardsArn
            self.standardsManagedBy = standardsManagedBy
        }
    }

}

public struct DescribeStandardsOutput {
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?
    /// A list of available standards.
    public var standards: [SecurityHubClientTypes.Standard]?

    public init(
        nextToken: Swift.String? = nil,
        standards: [SecurityHubClientTypes.Standard]? = nil
    )
    {
        self.nextToken = nextToken
        self.standards = standards
    }
}

public struct DescribeStandardsControlsInput {
    /// The maximum number of security standard controls to return.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the DescribeStandardsControls operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// The ARN of a resource that represents your subscription to a supported standard. To get the subscription ARNs of the standards you have enabled, use the GetEnabledStandards operation.
    /// This member is required.
    public var standardsSubscriptionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        standardsSubscriptionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.standardsSubscriptionArn = standardsSubscriptionArn
    }
}

extension SecurityHubClientTypes {
    /// Details for an individual security standard control.
    public struct StandardsControl {
        /// The identifier of the security standard control.
        public var controlId: Swift.String?
        /// The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.
        public var controlStatus: SecurityHubClientTypes.ControlStatus?
        /// The date and time that the status of the security standard control was most recently updated.
        public var controlStatusUpdatedAt: Foundation.Date?
        /// The longer description of the security standard control. Provides information about what the control is checking for.
        public var description: Swift.String?
        /// The reason provided for the most recent change in status for the control.
        public var disabledReason: Swift.String?
        /// The list of requirements that are related to this control.
        public var relatedRequirements: [Swift.String]?
        /// A link to remediation information for the control in the Security Hub user documentation.
        public var remediationUrl: Swift.String?
        /// The severity of findings generated from this security standard control. The finding severity is based on an assessment of how easy it would be to compromise Amazon Web Services resources if the issue is detected.
        public var severityRating: SecurityHubClientTypes.SeverityRating?
        /// The ARN of the security standard control.
        public var standardsControlArn: Swift.String?
        /// The title of the security standard control.
        public var title: Swift.String?

        public init(
            controlId: Swift.String? = nil,
            controlStatus: SecurityHubClientTypes.ControlStatus? = nil,
            controlStatusUpdatedAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            disabledReason: Swift.String? = nil,
            relatedRequirements: [Swift.String]? = nil,
            remediationUrl: Swift.String? = nil,
            severityRating: SecurityHubClientTypes.SeverityRating? = nil,
            standardsControlArn: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.controlId = controlId
            self.controlStatus = controlStatus
            self.controlStatusUpdatedAt = controlStatusUpdatedAt
            self.description = description
            self.disabledReason = disabledReason
            self.relatedRequirements = relatedRequirements
            self.remediationUrl = remediationUrl
            self.severityRating = severityRating
            self.standardsControlArn = standardsControlArn
            self.title = title
        }
    }

}

public struct DescribeStandardsControlsOutput {
    /// A list of security standards controls.
    public var controls: [SecurityHubClientTypes.StandardsControl]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        controls: [SecurityHubClientTypes.StandardsControl]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controls = controls
        self.nextToken = nextToken
    }
}

public struct DisableImportFindingsForProductInput {
    /// The ARN of the integrated product to disable the integration for.
    /// This member is required.
    public var productSubscriptionArn: Swift.String?

    public init(
        productSubscriptionArn: Swift.String? = nil
    )
    {
        self.productSubscriptionArn = productSubscriptionArn
    }
}

public struct DisableImportFindingsForProductOutput {

    public init() { }
}

public struct DisableOrganizationAdminAccountInput {
    /// The Amazon Web Services account identifier of the Security Hub administrator account.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

public struct DisableOrganizationAdminAccountOutput {

    public init() { }
}

public struct DisableSecurityHubInput {

    public init() { }
}

public struct DisableSecurityHubOutput {

    public init() { }
}

public struct DisassociateFromAdministratorAccountInput {

    public init() { }
}

public struct DisassociateFromAdministratorAccountOutput {

    public init() { }
}

public struct DisassociateFromMasterAccountInput {

    public init() { }
}

public struct DisassociateFromMasterAccountOutput {

    public init() { }
}

public struct DisassociateMembersInput {
    /// The account IDs of the member accounts to disassociate from the administrator account.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

public struct DisassociateMembersOutput {

    public init() { }
}

public struct EnableImportFindingsForProductInput {
    /// The ARN of the product to enable the integration for.
    /// This member is required.
    public var productArn: Swift.String?

    public init(
        productArn: Swift.String? = nil
    )
    {
        self.productArn = productArn
    }
}

public struct EnableImportFindingsForProductOutput {
    /// The ARN of your subscription to the product to enable integrations for.
    public var productSubscriptionArn: Swift.String?

    public init(
        productSubscriptionArn: Swift.String? = nil
    )
    {
        self.productSubscriptionArn = productSubscriptionArn
    }
}

public struct EnableOrganizationAdminAccountInput {
    /// The Amazon Web Services account identifier of the account to designate as the Security Hub administrator account.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

public struct EnableOrganizationAdminAccountOutput {

    public init() { }
}

public struct EnableSecurityHubInput {
    /// This field, used when enabling Security Hub, specifies whether the calling account has consolidated control findings turned on. If the value for this field is set to SECURITY_CONTROL, Security Hub generates a single finding for a control check even when the check applies to multiple enabled standards. If the value for this field is set to STANDARD_CONTROL, Security Hub generates separate findings for a control check when the check applies to multiple enabled standards. The value for this field in a member account matches the value in the administrator account. For accounts that aren't part of an organization, the default value of this field is SECURITY_CONTROL if you enabled Security Hub on or after February 23, 2023.
    public var controlFindingGenerator: SecurityHubClientTypes.ControlFindingGenerator?
    /// Whether to enable the security standards that Security Hub has designated as automatically enabled. If you do not provide a value for EnableDefaultStandards, it is set to true. To not enable the automatically enabled standards, set EnableDefaultStandards to false.
    public var enableDefaultStandards: Swift.Bool?
    /// The tags to add to the hub resource when you enable Security Hub.
    public var tags: [Swift.String: Swift.String]?

    public init(
        controlFindingGenerator: SecurityHubClientTypes.ControlFindingGenerator? = nil,
        enableDefaultStandards: Swift.Bool? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.controlFindingGenerator = controlFindingGenerator
        self.enableDefaultStandards = enableDefaultStandards
        self.tags = tags
    }
}

public struct EnableSecurityHubOutput {

    public init() { }
}

extension SecurityHubClientTypes {
    /// A finding aggregator. A finding aggregator contains the configuration for finding aggregation.
    public struct FindingAggregator {
        /// The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and delete the finding aggregator.
        public var findingAggregatorArn: Swift.String?

        public init(
            findingAggregatorArn: Swift.String? = nil
        )
        {
            self.findingAggregatorArn = findingAggregatorArn
        }
    }

}

extension SecurityHubClientTypes {
    /// An array of objects that provides details about a change to a finding, including the Amazon Web Services Security Finding Format (ASFF) field that changed, the value of the field before the change, and the value of the field after the change.
    public struct FindingHistoryUpdate {
        /// The value of the ASFF field after the finding change event. To preserve storage and readability, Security Hub omits this value if [FindingHistoryRecord](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_FindingHistoryRecord.html) exceeds database limits.
        public var newValue: Swift.String?
        /// The value of the ASFF field before the finding change event.
        public var oldValue: Swift.String?
        /// The ASFF field that changed during the finding change event.
        public var updatedField: Swift.String?

        public init(
            newValue: Swift.String? = nil,
            oldValue: Swift.String? = nil,
            updatedField: Swift.String? = nil
        )
        {
            self.newValue = newValue
            self.oldValue = oldValue
            self.updatedField = updatedField
        }
    }

}

extension SecurityHubClientTypes {

    public enum FindingHistoryUpdateSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case batchImportFindings
        case batchUpdateFindings
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingHistoryUpdateSourceType] {
            return [
                .batchImportFindings,
                .batchUpdateFindings
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .batchImportFindings: return "BATCH_IMPORT_FINDINGS"
            case .batchUpdateFindings: return "BATCH_UPDATE_FINDINGS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// Identifies the source of the finding change event.
    public struct FindingHistoryUpdateSource {
        /// The identity of the source that initiated the finding change event. For example, the Amazon Resource Name (ARN) of a partner that calls BatchImportFindings or of a customer that calls BatchUpdateFindings.
        public var identity: Swift.String?
        /// Describes the type of finding change event, such as a call to [BatchImportFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchImportFindings.html) (by an integrated Amazon Web Servicesservice or third party partner integration) or [BatchUpdateFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateFindings.html) (by a Security Hub customer).
        public var type: SecurityHubClientTypes.FindingHistoryUpdateSourceType?

        public init(
            identity: Swift.String? = nil,
            type: SecurityHubClientTypes.FindingHistoryUpdateSourceType? = nil
        )
        {
            self.identity = identity
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    /// A list of events that changed the specified finding during the specified time period. Each record represents a single finding change event.
    public struct FindingHistoryRecord {
        /// Identifies whether the event marks the creation of a new finding. A value of True means that the finding is newly created. A value of False means that the finding isn’t newly created.
        public var findingCreated: Swift.Bool?
        /// Identifies which finding to get the finding history for.
        public var findingIdentifier: SecurityHubClientTypes.AwsSecurityFindingIdentifier?
        /// A token for pagination purposes. Provide this token in the subsequent request to [GetFindingsHistory](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_GetFindingsHistory.html) to get up to an additional 100 results of history for the same finding that you specified in your initial request.
        public var nextToken: Swift.String?
        /// Identifies the source of the event that changed the finding. For example, an integrated Amazon Web Servicesservice or third-party partner integration may call [BatchImportFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchImportFindings.html), or an Security Hub customer may call [BatchUpdateFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateFindings.html).
        public var updateSource: SecurityHubClientTypes.FindingHistoryUpdateSource?
        /// A timestamp that indicates when Security Hub processed the updated finding record. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
        ///
        /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
        ///
        /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
        ///
        /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
        ///
        /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
        public var updateTime: Foundation.Date?
        /// An array of objects that provides details about the finding change event, including the Amazon Web Services Security Finding Format (ASFF) field that changed, the value of the field before the change, and the value of the field after the change.
        public var updates: [SecurityHubClientTypes.FindingHistoryUpdate]?

        public init(
            findingCreated: Swift.Bool? = nil,
            findingIdentifier: SecurityHubClientTypes.AwsSecurityFindingIdentifier? = nil,
            nextToken: Swift.String? = nil,
            updateSource: SecurityHubClientTypes.FindingHistoryUpdateSource? = nil,
            updateTime: Foundation.Date? = nil,
            updates: [SecurityHubClientTypes.FindingHistoryUpdate]? = nil
        )
        {
            self.findingCreated = findingCreated
            self.findingIdentifier = findingIdentifier
            self.nextToken = nextToken
            self.updateSource = updateSource
            self.updateTime = updateTime
            self.updates = updates
        }
    }

}

public struct GetAdministratorAccountInput {

    public init() { }
}

extension SecurityHubClientTypes {
    /// Details about an invitation.
    public struct Invitation {
        /// The account ID of the Security Hub administrator account that the invitation was sent from.
        public var accountId: Swift.String?
        /// The ID of the invitation sent to the member account.
        public var invitationId: Swift.String?
        /// The timestamp of when the invitation was sent.
        public var invitedAt: Foundation.Date?
        /// The current status of the association between the member and administrator accounts.
        public var memberStatus: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: Foundation.Date? = nil,
            memberStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.memberStatus = memberStatus
        }
    }

}

public struct GetAdministratorAccountOutput {
    /// Details about an invitation.
    public var administrator: SecurityHubClientTypes.Invitation?

    public init(
        administrator: SecurityHubClientTypes.Invitation? = nil
    )
    {
        self.administrator = administrator
    }
}

public struct GetConfigurationPolicyInput {
    /// The Amazon Resource Name (ARN) or universally unique identifier (UUID) of the configuration policy.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetConfigurationPolicyOutput {
    /// The ARN of the configuration policy.
    public var arn: Swift.String?
    /// An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls. If the policy includes a list of security controls that are enabled, Security Hub disables all other controls (including newly released controls). If the policy includes a list of security controls that are disabled, Security Hub enables all other controls (including newly released controls).
    public var configurationPolicy: SecurityHubClientTypes.Policy?
    /// The date and time, in UTC and ISO 8601 format, that the configuration policy was created.
    public var createdAt: Foundation.Date?
    /// The description of the configuration policy.
    public var description: Swift.String?
    /// The UUID of the configuration policy.
    public var id: Swift.String?
    /// The name of the configuration policy.
    public var name: Swift.String?
    /// The date and time, in UTC and ISO 8601 format, that the configuration policy was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        configurationPolicy: SecurityHubClientTypes.Policy? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.configurationPolicy = configurationPolicy
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
    }
}

public struct GetConfigurationPolicyAssociationInput {
    /// The target account ID, organizational unit ID, or the root ID to retrieve the association for.
    /// This member is required.
    public var target: SecurityHubClientTypes.Target?

    public init(
        target: SecurityHubClientTypes.Target? = nil
    )
    {
        self.target = target
    }
}

public struct GetConfigurationPolicyAssociationOutput {
    /// The current status of the association between the specified target and the configuration.
    public var associationStatus: SecurityHubClientTypes.ConfigurationPolicyAssociationStatus?
    /// The explanation for a FAILED value for AssociationStatus.
    public var associationStatusMessage: Swift.String?
    /// Indicates whether the association between the specified target and the configuration was directly applied by the Security Hub delegated administrator or inherited from a parent.
    public var associationType: SecurityHubClientTypes.AssociationType?
    /// The universally unique identifier (UUID) of a configuration policy. For self-managed behavior, the value is SELF_MANAGED_SECURITY_HUB.
    public var configurationPolicyId: Swift.String?
    /// The target account ID, organizational unit ID, or the root ID for which the association is retrieved.
    public var targetId: Swift.String?
    /// Specifies whether the target is an Amazon Web Services account, organizational unit, or the organization root.
    public var targetType: SecurityHubClientTypes.TargetType?
    /// The date and time, in UTC and ISO 8601 format, that the configuration policy association was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        associationStatus: SecurityHubClientTypes.ConfigurationPolicyAssociationStatus? = nil,
        associationStatusMessage: Swift.String? = nil,
        associationType: SecurityHubClientTypes.AssociationType? = nil,
        configurationPolicyId: Swift.String? = nil,
        targetId: Swift.String? = nil,
        targetType: SecurityHubClientTypes.TargetType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.associationStatus = associationStatus
        self.associationStatusMessage = associationStatusMessage
        self.associationType = associationType
        self.configurationPolicyId = configurationPolicyId
        self.targetId = targetId
        self.targetType = targetType
        self.updatedAt = updatedAt
    }
}

public struct GetEnabledStandardsInput {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the GetEnabledStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// The list of the standards subscription ARNs for the standards to retrieve.
    public var standardsSubscriptionArns: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        standardsSubscriptionArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.standardsSubscriptionArns = standardsSubscriptionArns
    }
}

public struct GetEnabledStandardsOutput {
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?
    /// The list of StandardsSubscriptions objects that include information about the enabled standards.
    public var standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]?

    public init(
        nextToken: Swift.String? = nil,
        standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.standardsSubscriptions = standardsSubscriptions
    }
}

public struct GetFindingAggregatorInput {
    /// The ARN of the finding aggregator to return details for. To obtain the ARN, use ListFindingAggregators.
    /// This member is required.
    public var findingAggregatorArn: Swift.String?

    public init(
        findingAggregatorArn: Swift.String? = nil
    )
    {
        self.findingAggregatorArn = findingAggregatorArn
    }
}

public struct GetFindingAggregatorOutput {
    /// The aggregation Region.
    public var findingAggregationRegion: Swift.String?
    /// The ARN of the finding aggregator.
    public var findingAggregatorArn: Swift.String?
    /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
    public var regionLinkingMode: Swift.String?
    /// The list of excluded Regions or included Regions.
    public var regions: [Swift.String]?

    public init(
        findingAggregationRegion: Swift.String? = nil,
        findingAggregatorArn: Swift.String? = nil,
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.findingAggregationRegion = findingAggregationRegion
        self.findingAggregatorArn = findingAggregatorArn
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

public struct GetFindingHistoryInput {
    /// An ISO 8601-formatted timestamp that indicates the end time of the requested finding history. If you provide values for both StartTime and EndTime, Security Hub returns finding history for the specified time period. If you provide a value for StartTime but not for EndTime, Security Hub returns finding history from the StartTime to the time at which the API is called. If you provide a value for EndTime but not for StartTime, Security Hub returns finding history from the [CreatedAt](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_AwsSecurityFindingFilters.html#securityhub-Type-AwsSecurityFindingFilters-CreatedAt) timestamp of the finding to the EndTime. If you provide neither StartTime nor EndTime, Security Hub returns finding history from the CreatedAt timestamp of the finding to the time at which the API is called. In all of these scenarios, the response is limited to 100 results, and the maximum time period is limited to 90 days. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
    ///
    /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
    ///
    /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
    ///
    /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
    ///
    /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
    ///
    /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
    public var endTime: Foundation.Date?
    /// Identifies which finding to get the finding history for.
    /// This member is required.
    public var findingIdentifier: SecurityHubClientTypes.AwsSecurityFindingIdentifier?
    /// The maximum number of results to be returned. If you don’t provide it, Security Hub returns up to 100 results of finding history.
    public var maxResults: Swift.Int?
    /// A token for pagination purposes. Provide NULL as the initial value. In subsequent requests, provide the token included in the response to get up to an additional 100 results of finding history. If you don’t provide NextToken, Security Hub returns up to 100 results of finding history for each request.
    public var nextToken: Swift.String?
    /// A timestamp that indicates the start time of the requested finding history. If you provide values for both StartTime and EndTime, Security Hub returns finding history for the specified time period. If you provide a value for StartTime but not for EndTime, Security Hub returns finding history from the StartTime to the time at which the API is called. If you provide a value for EndTime but not for StartTime, Security Hub returns finding history from the [CreatedAt](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_AwsSecurityFindingFilters.html#securityhub-Type-AwsSecurityFindingFilters-CreatedAt) timestamp of the finding to the EndTime. If you provide neither StartTime nor EndTime, Security Hub returns finding history from the CreatedAt timestamp of the finding to the time at which the API is called. In all of these scenarios, the response is limited to 100 results, and the maximum time period is limited to 90 days. This field accepts only the specified formats. Timestamps can end with Z or ("+" / "-") time-hour [":" time-minute]. The time-secfrac after seconds is limited to a maximum of 9 digits. The offset is bounded by +/-18:00. Here are valid timestamp formats with examples:
    ///
    /// * YYYY-MM-DDTHH:MM:SSZ (for example, 2019-01-31T23:00:00Z)
    ///
    /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ (for example, 2019-01-31T23:00:00.123456789Z)
    ///
    /// * YYYY-MM-DDTHH:MM:SS+HH:MM (for example, 2024-01-04T15:25:10+17:59)
    ///
    /// * YYYY-MM-DDTHH:MM:SS-HHMM (for example, 2024-01-04T15:25:10-1759)
    ///
    /// * YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM (for example, 2024-01-04T15:25:10.123456789+17:59)
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        findingIdentifier: SecurityHubClientTypes.AwsSecurityFindingIdentifier? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.findingIdentifier = findingIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

public struct GetFindingHistoryOutput {
    /// A token for pagination purposes. Provide this token in the subsequent request to GetFindingsHistory to get up to an additional 100 results of history for the same finding that you specified in your initial request.
    public var nextToken: Swift.String?
    /// A list of events that altered the specified finding during the specified time period.
    public var records: [SecurityHubClientTypes.FindingHistoryRecord]?

    public init(
        nextToken: Swift.String? = nil,
        records: [SecurityHubClientTypes.FindingHistoryRecord]? = nil
    )
    {
        self.nextToken = nextToken
        self.records = records
    }
}

extension SecurityHubClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "asc"
            case .descending: return "desc"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// A collection of finding attributes used to sort findings.
    public struct SortCriterion {
        /// The finding attribute used to sort findings.
        public var field: Swift.String?
        /// The order used to sort findings.
        public var sortOrder: SecurityHubClientTypes.SortOrder?

        public init(
            field: Swift.String? = nil,
            sortOrder: SecurityHubClientTypes.SortOrder? = nil
        )
        {
            self.field = field
            self.sortOrder = sortOrder
        }
    }

}

public struct GetFindingsInput {
    /// The finding attributes used to define a condition to filter the returned findings. You can filter by up to 10 finding attributes. For each attribute, you can provide up to 20 filter values. Note that in the available filter fields, WorkflowState is deprecated. To search for a finding based on its workflow status, use WorkflowStatus.
    public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    /// The maximum number of findings to return.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the GetFindings operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// The finding attributes used to sort the list of returned findings.
    public var sortCriteria: [SecurityHubClientTypes.SortCriterion]?

    public init(
        filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [SecurityHubClientTypes.SortCriterion]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

public struct GetFindingsOutput {
    /// The findings that matched the filters specified in the request.
    /// This member is required.
    public var findings: [SecurityHubClientTypes.AwsSecurityFinding]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        findings: [SecurityHubClientTypes.AwsSecurityFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

public struct GetInsightResultsInput {
    /// The ARN of the insight for which to return results.
    /// This member is required.
    public var insightArn: Swift.String?

    public init(
        insightArn: Swift.String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

extension SecurityHubClientTypes {
    /// The insight result values returned by the GetInsightResults operation.
    public struct InsightResultValue {
        /// The number of findings returned for each GroupByAttributeValue.
        /// This member is required.
        public var count: Swift.Int?
        /// The value of the attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        /// This member is required.
        public var groupByAttributeValue: Swift.String?

        public init(
            count: Swift.Int? = nil,
            groupByAttributeValue: Swift.String? = nil
        )
        {
            self.count = count
            self.groupByAttributeValue = groupByAttributeValue
        }
    }

}

extension SecurityHubClientTypes {
    /// The insight results returned by the GetInsightResults operation.
    public struct InsightResults {
        /// The attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        /// This member is required.
        public var groupByAttribute: Swift.String?
        /// The ARN of the insight whose results are returned by the GetInsightResults operation.
        /// This member is required.
        public var insightArn: Swift.String?
        /// The list of insight result values returned by the GetInsightResults operation.
        /// This member is required.
        public var resultValues: [SecurityHubClientTypes.InsightResultValue]?

        public init(
            groupByAttribute: Swift.String? = nil,
            insightArn: Swift.String? = nil,
            resultValues: [SecurityHubClientTypes.InsightResultValue]? = nil
        )
        {
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.resultValues = resultValues
        }
    }

}

public struct GetInsightResultsOutput {
    /// The insight results returned by the operation.
    /// This member is required.
    public var insightResults: SecurityHubClientTypes.InsightResults?

    public init(
        insightResults: SecurityHubClientTypes.InsightResults? = nil
    )
    {
        self.insightResults = insightResults
    }
}

public struct GetInsightsInput {
    /// The ARNs of the insights to describe. If you do not provide any insight ARNs, then GetInsights returns all of your custom insights. It does not return any managed insights.
    public var insightArns: [Swift.String]?
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the GetInsights operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init(
        insightArns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insightArns = insightArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a Security Hub insight.
    public struct Insight {
        /// One or more attributes used to filter the findings included in the insight. You can filter by up to ten finding attributes. For each attribute, you can provide up to 20 filter values. The insight only includes findings that match the criteria defined in the filters.
        /// This member is required.
        public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
        /// The grouping attribute for the insight's findings. Indicates how to group the matching findings, and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
        /// This member is required.
        public var groupByAttribute: Swift.String?
        /// The ARN of a Security Hub insight.
        /// This member is required.
        public var insightArn: Swift.String?
        /// The name of a Security Hub insight.
        /// This member is required.
        public var name: Swift.String?

        public init(
            filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
            groupByAttribute: Swift.String? = nil,
            insightArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }
    }

}

public struct GetInsightsOutput {
    /// The insights returned by the operation.
    /// This member is required.
    public var insights: [SecurityHubClientTypes.Insight]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        insights: [SecurityHubClientTypes.Insight]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insights = insights
        self.nextToken = nextToken
    }
}

public struct GetInvitationsCountInput {

    public init() { }
}

public struct GetInvitationsCountOutput {
    /// The number of all membership invitations sent to this Security Hub member account, not including the currently accepted invitation.
    public var invitationsCount: Swift.Int?

    public init(
        invitationsCount: Swift.Int? = nil
    )
    {
        self.invitationsCount = invitationsCount
    }
}

public struct GetMasterAccountInput {

    public init() { }
}

public struct GetMasterAccountOutput {
    /// A list of details about the Security Hub administrator account for the current member account.
    public var master: SecurityHubClientTypes.Invitation?

    public init(
        master: SecurityHubClientTypes.Invitation? = nil
    )
    {
        self.master = master
    }
}

public struct GetMembersInput {
    /// The list of account IDs for the Security Hub member accounts to return the details for.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

extension SecurityHubClientTypes {
    /// The details about a member account.
    public struct Member {
        /// The Amazon Web Services account ID of the member account.
        public var accountId: Swift.String?
        /// The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.
        public var administratorId: Swift.String?
        /// The email address of the member account.
        public var email: Swift.String?
        /// A timestamp for the date and time when the invitation was sent to the member account.
        public var invitedAt: Foundation.Date?
        /// This is replaced by AdministratorID. The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.
        @available(*, deprecated, message: "This field is deprecated, use AdministratorId instead.")
        public var masterId: Swift.String?
        /// The status of the relationship between the member account and its administrator account. The status can have one of the following values:
        ///
        /// * Created - Indicates that the administrator account added the member account, but has not yet invited the member account.
        ///
        /// * Invited - Indicates that the administrator account invited the member account. The member account has not yet responded to the invitation.
        ///
        /// * Enabled - Indicates that the member account is currently active. For manually invited member accounts, indicates that the member account accepted the invitation.
        ///
        /// * Removed - Indicates that the administrator account disassociated the member account.
        ///
        /// * Resigned - Indicates that the member account disassociated themselves from the administrator account.
        ///
        /// * Deleted - Indicates that the administrator account deleted the member account.
        ///
        /// * AccountSuspended - Indicates that an organization account was suspended from Amazon Web Services at the same time that the administrator account tried to enable the organization account as a member account.
        public var memberStatus: Swift.String?
        /// The timestamp for the date and time when the member account was updated.
        public var updatedAt: Foundation.Date?

        public init(
            accountId: Swift.String? = nil,
            administratorId: Swift.String? = nil,
            email: Swift.String? = nil,
            invitedAt: Foundation.Date? = nil,
            masterId: Swift.String? = nil,
            memberStatus: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.accountId = accountId
            self.administratorId = administratorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.memberStatus = memberStatus
            self.updatedAt = updatedAt
        }
    }

}

public struct GetMembersOutput {
    /// The list of details about the Security Hub member accounts.
    public var members: [SecurityHubClientTypes.Member]?
    /// The list of Amazon Web Services accounts that could not be processed. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init(
        members: [SecurityHubClientTypes.Member]? = nil,
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

public struct GetSecurityControlDefinitionInput {
    /// The ID of the security control to retrieve the definition for. This field doesn’t accept an Amazon Resource Name (ARN).
    /// This member is required.
    public var securityControlId: Swift.String?

    public init(
        securityControlId: Swift.String? = nil
    )
    {
        self.securityControlId = securityControlId
    }
}

extension SecurityHubClientTypes {

    public enum RegionAvailabilityStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [RegionAvailabilityStatus] {
            return [
                .available,
                .unavailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityHubClientTypes {
    /// An object that describes a security control parameter and the options for customizing it.
    public struct ParameterDefinition {
        /// The options for customizing a control parameter. Customization options vary based on the data type of the parameter.
        /// This member is required.
        public var configurationOptions: SecurityHubClientTypes.ConfigurationOptions?
        /// Description of a control parameter.
        /// This member is required.
        public var description: Swift.String?

        public init(
            configurationOptions: SecurityHubClientTypes.ConfigurationOptions? = nil,
            description: Swift.String? = nil
        )
        {
            self.configurationOptions = configurationOptions
            self.description = description
        }
    }

}

extension SecurityHubClientTypes {
    /// Provides metadata for a security control, including its unique standard-agnostic identifier, title, description, severity, availability in Amazon Web Services Regions, and a link to remediation steps.
    public struct SecurityControlDefinition {
        /// Specifies whether a security control is available in the current Amazon Web Services Region.
        /// This member is required.
        public var currentRegionAvailability: SecurityHubClientTypes.RegionAvailabilityStatus?
        /// Security control properties that you can customize. Currently, only parameter customization is supported for select controls. An empty array is returned for controls that don’t support custom properties.
        public var customizableProperties: [SecurityHubClientTypes.SecurityControlProperty]?
        /// The description of a security control across standards. This typically summarizes how Security Hub evaluates the control and the conditions under which it produces a failed finding. This parameter doesn't reference a specific standard.
        /// This member is required.
        public var description: Swift.String?
        /// An object that provides a security control parameter name, description, and the options for customizing it. This object is excluded for a control that doesn't support custom parameters.
        public var parameterDefinitions: [Swift.String: SecurityHubClientTypes.ParameterDefinition]?
        /// A link to Security Hub documentation that explains how to remediate a failed finding for a security control.
        /// This member is required.
        public var remediationUrl: Swift.String?
        /// The unique identifier of a security control across standards. Values for this field typically consist of an Amazon Web Servicesservice name and a number (for example, APIGateway.3). This parameter differs from SecurityControlArn, which is a unique Amazon Resource Name (ARN) assigned to a control. The ARN references the security control ID (for example, arn:aws:securityhub:eu-central-1:123456789012:security-control/APIGateway.3).
        /// This member is required.
        public var securityControlId: Swift.String?
        /// The severity of a security control. For more information about how Security Hub determines control severity, see [Assigning severity to control findings](https://docs.aws.amazon.com/securityhub/latest/userguide/controls-findings-create-update.html#control-findings-severity) in the Security Hub User Guide.
        /// This member is required.
        public var severityRating: SecurityHubClientTypes.SeverityRating?
        /// The title of a security control.
        /// This member is required.
        public var title: Swift.String?

        public init(
            currentRegionAvailability: SecurityHubClientTypes.RegionAvailabilityStatus? = nil,
            customizableProperties: [SecurityHubClientTypes.SecurityControlProperty]? = nil,
            description: Swift.String? = nil,
            parameterDefinitions: [Swift.String: SecurityHubClientTypes.ParameterDefinition]? = nil,
            remediationUrl: Swift.String? = nil,
            securityControlId: Swift.String? = nil,
            severityRating: SecurityHubClientTypes.SeverityRating? = nil,
            title: Swift.String? = nil
        )
        {
            self.currentRegionAvailability = currentRegionAvailability
            self.customizableProperties = customizableProperties
            self.description = description
            self.parameterDefinitions = parameterDefinitions
            self.remediationUrl = remediationUrl
            self.securityControlId = securityControlId
            self.severityRating = severityRating
            self.title = title
        }
    }

}

public struct GetSecurityControlDefinitionOutput {
    /// Provides metadata for a security control, including its unique standard-agnostic identifier, title, description, severity, availability in Amazon Web Services Regions, and a link to remediation steps.
    /// This member is required.
    public var securityControlDefinition: SecurityHubClientTypes.SecurityControlDefinition?

    public init(
        securityControlDefinition: SecurityHubClientTypes.SecurityControlDefinition? = nil
    )
    {
        self.securityControlDefinition = securityControlDefinition
    }
}

public struct InviteMembersInput {
    /// The list of account IDs of the Amazon Web Services accounts to invite to Security Hub as members.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

public struct InviteMembersOutput {
    /// The list of Amazon Web Services accounts that could not be processed. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init(
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

public struct ListAutomationRulesInput {
    /// The maximum number of rules to return in the response. This currently ranges from 1 to 100.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating the response. This is the NextToken from a previously truncated response. On your first call to the ListAutomationRules API, set the value of this parameter to NULL.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAutomationRulesOutput {
    /// Metadata for rules in the calling account. The response includes rules with a RuleStatus of ENABLED and DISABLED.
    public var automationRulesMetadata: [SecurityHubClientTypes.AutomationRulesMetadata]?
    /// A pagination token for the response.
    public var nextToken: Swift.String?

    public init(
        automationRulesMetadata: [SecurityHubClientTypes.AutomationRulesMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.automationRulesMetadata = automationRulesMetadata
        self.nextToken = nextToken
    }
}

public struct ListConfigurationPoliciesInput {
    /// The maximum number of results that's returned by ListConfigurationPolicies in each page of the response. When this parameter is used, ListConfigurationPolicies returns the specified number of results in a single page and a NextToken response element. You can see the remaining results of the initial request by sending another ListConfigurationPolicies request with the returned NextToken value. A valid range for MaxResults is between 1 and 100.
    public var maxResults: Swift.Int?
    /// The NextToken value that's returned from a previous paginated ListConfigurationPolicies request where MaxResults was used but the results exceeded the value of that parameter. Pagination continues from the MaxResults was used but the results exceeded the value of that parameter. Pagination continues from the end of the previous response that returned the NextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConfigurationPoliciesOutput {
    /// Provides metadata for each of your configuration policies.
    public var configurationPolicySummaries: [SecurityHubClientTypes.ConfigurationPolicySummary]?
    /// The NextToken value to include in the next ListConfigurationPolicies request. When the results of a ListConfigurationPolicies request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        configurationPolicySummaries: [SecurityHubClientTypes.ConfigurationPolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationPolicySummaries = configurationPolicySummaries
        self.nextToken = nextToken
    }
}

public struct ListConfigurationPolicyAssociationsInput {
    /// Options for filtering the ListConfigurationPolicyAssociations response. You can filter by the Amazon Resource Name (ARN) or universally unique identifier (UUID) of a configuration, AssociationType, or AssociationStatus.
    public var filters: SecurityHubClientTypes.AssociationFilters?
    /// The maximum number of results that's returned by ListConfigurationPolicies in each page of the response. When this parameter is used, ListConfigurationPolicyAssociations returns the specified number of results in a single page and a NextToken response element. You can see the remaining results of the initial request by sending another ListConfigurationPolicyAssociations request with the returned NextToken value. A valid range for MaxResults is between 1 and 100.
    public var maxResults: Swift.Int?
    /// The NextToken value that's returned from a previous paginated ListConfigurationPolicyAssociations request where MaxResults was used but the results exceeded the value of that parameter. Pagination continues from the end of the previous response that returned the NextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        filters: SecurityHubClientTypes.AssociationFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConfigurationPolicyAssociationsOutput {
    /// An object that contains the details of each configuration policy association that’s returned in a ListConfigurationPolicyAssociations request.
    public var configurationPolicyAssociationSummaries: [SecurityHubClientTypes.ConfigurationPolicyAssociationSummary]?
    /// The NextToken value to include in the next ListConfigurationPolicyAssociations request. When the results of a ListConfigurationPolicyAssociations request exceed MaxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        configurationPolicyAssociationSummaries: [SecurityHubClientTypes.ConfigurationPolicyAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationPolicyAssociationSummaries = configurationPolicyAssociationSummaries
        self.nextToken = nextToken
    }
}

public struct ListEnabledProductsForImportInput {
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the ListEnabledProductsForImport operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEnabledProductsForImportOutput {
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?
    /// The list of ARNs for the resources that represent your subscriptions to products.
    public var productSubscriptions: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        productSubscriptions: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.productSubscriptions = productSubscriptions
    }
}

public struct ListFindingAggregatorsInput {
    /// The maximum number of results to return. This operation currently only returns a single result.
    public var maxResults: Swift.Int?
    /// The token returned with the previous set of results. Identifies the next set of results to return.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFindingAggregatorsOutput {
    /// The list of finding aggregators. This operation currently only returns a single result.
    public var findingAggregators: [SecurityHubClientTypes.FindingAggregator]?
    /// If there are more results, this is the token to provide in the next call to ListFindingAggregators. This operation currently only returns a single result.
    public var nextToken: Swift.String?

    public init(
        findingAggregators: [SecurityHubClientTypes.FindingAggregator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingAggregators = findingAggregators
        self.nextToken = nextToken
    }
}

public struct ListInvitationsInput {
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the ListInvitations operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInvitationsOutput {
    /// The details of the invitations returned by the operation.
    public var invitations: [SecurityHubClientTypes.Invitation]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        invitations: [SecurityHubClientTypes.Invitation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

public struct ListMembersInput {
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the ListMembers operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// Specifies which member accounts to include in the response based on their relationship status with the administrator account. The default value is TRUE. If OnlyAssociated is set to TRUE, the response includes member accounts whose relationship status with the administrator account is set to ENABLED. If OnlyAssociated is set to FALSE, the response includes all existing member accounts.
    public var onlyAssociated: Swift.Bool?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        onlyAssociated: Swift.Bool? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

public struct ListMembersOutput {
    /// Member details returned by the operation.
    public var members: [SecurityHubClientTypes.Member]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        members: [SecurityHubClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

public struct ListOrganizationAdminAccountsInput {
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int?
    /// The token that is required for pagination. On your first call to the ListOrganizationAdminAccounts operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListOrganizationAdminAccountsOutput {
    /// The list of Security Hub administrator accounts.
    public var adminAccounts: [SecurityHubClientTypes.AdminAccount]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        adminAccounts: [SecurityHubClientTypes.AdminAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

public struct ListSecurityControlDefinitionsInput {
    /// An optional parameter that limits the total results of the API response to the specified number. If this parameter isn't provided in the request, the results include the first 25 security controls that apply to the specified standard. The results also include a NextToken parameter that you can use in a subsequent API call to get the next 25 controls. This repeats until all controls for the standard are returned.
    public var maxResults: Swift.Int?
    /// Optional pagination parameter.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the standard that you want to view controls for.
    public var standardsArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        standardsArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.standardsArn = standardsArn
    }
}

public struct ListSecurityControlDefinitionsOutput {
    /// A pagination parameter that's included in the response only if it was included in the request.
    public var nextToken: Swift.String?
    /// An array of controls that apply to the specified standard.
    /// This member is required.
    public var securityControlDefinitions: [SecurityHubClientTypes.SecurityControlDefinition]?

    public init(
        nextToken: Swift.String? = nil,
        securityControlDefinitions: [SecurityHubClientTypes.SecurityControlDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityControlDefinitions = securityControlDefinitions
    }
}

public struct ListStandardsControlAssociationsInput {
    /// An optional parameter that limits the total results of the API response to the specified number. If this parameter isn't provided in the request, the results include the first 25 standard and control associations. The results also include a NextToken parameter that you can use in a subsequent API call to get the next 25 associations. This repeats until all associations for the specified control are returned. The number of results is limited by the number of supported Security Hub standards that you've enabled in the calling account.
    public var maxResults: Swift.Int?
    /// Optional pagination parameter.
    public var nextToken: Swift.String?
    /// The identifier of the control (identified with SecurityControlId, SecurityControlArn, or a mix of both parameters) that you want to determine the enablement status of in each enabled standard.
    /// This member is required.
    public var securityControlId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        securityControlId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.securityControlId = securityControlId
    }
}

extension SecurityHubClientTypes {
    /// An array that provides the enablement status and other details for each control that applies to each enabled standard.
    public struct StandardsControlAssociationSummary {
        /// The enablement status of a control in a specific standard.
        /// This member is required.
        public var associationStatus: SecurityHubClientTypes.AssociationStatus?
        /// The requirement that underlies this control in the compliance framework related to the standard.
        public var relatedRequirements: [Swift.String]?
        /// The ARN of a control, such as arn:aws:securityhub:eu-central-1:123456789012:security-control/S3.1. This parameter doesn't mention a specific standard.
        /// This member is required.
        public var securityControlArn: Swift.String?
        /// A unique standard-agnostic identifier for a control. Values for this field typically consist of an Amazon Web Servicesservice and a number, such as APIGateway.5. This field doesn't reference a specific standard.
        /// This member is required.
        public var securityControlId: Swift.String?
        /// The Amazon Resource Name (ARN) of a standard.
        /// This member is required.
        public var standardsArn: Swift.String?
        /// The description of a control. This typically summarizes how Security Hub evaluates the control and the conditions under which it produces a failed finding. The parameter may reference a specific standard.
        public var standardsControlDescription: Swift.String?
        /// The title of a control.
        public var standardsControlTitle: Swift.String?
        /// The last time that a control's enablement status in a specified standard was updated.
        public var updatedAt: Foundation.Date?
        /// The reason for updating a control's enablement status in a specified standard.
        public var updatedReason: Swift.String?

        public init(
            associationStatus: SecurityHubClientTypes.AssociationStatus? = nil,
            relatedRequirements: [Swift.String]? = nil,
            securityControlArn: Swift.String? = nil,
            securityControlId: Swift.String? = nil,
            standardsArn: Swift.String? = nil,
            standardsControlDescription: Swift.String? = nil,
            standardsControlTitle: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedReason: Swift.String? = nil
        )
        {
            self.associationStatus = associationStatus
            self.relatedRequirements = relatedRequirements
            self.securityControlArn = securityControlArn
            self.securityControlId = securityControlId
            self.standardsArn = standardsArn
            self.standardsControlDescription = standardsControlDescription
            self.standardsControlTitle = standardsControlTitle
            self.updatedAt = updatedAt
            self.updatedReason = updatedReason
        }
    }

}

public struct ListStandardsControlAssociationsOutput {
    /// A pagination parameter that's included in the response only if it was included in the request.
    public var nextToken: Swift.String?
    /// An array that provides the enablement status and other details for each security control that applies to each enabled standard.
    /// This member is required.
    public var standardsControlAssociationSummaries: [SecurityHubClientTypes.StandardsControlAssociationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        standardsControlAssociationSummaries: [SecurityHubClientTypes.StandardsControlAssociationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.standardsControlAssociationSummaries = standardsControlAssociationSummaries
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the resource to retrieve tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The tags associated with a resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

/// The request was rejected because it conflicts with the resource's availability. For example, you tried to update a security control that's currently in the UPDATING state.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct StartConfigurationPolicyAssociationInput {
    /// The Amazon Resource Name (ARN) of a configuration policy, the universally unique identifier (UUID) of a configuration policy, or a value of SELF_MANAGED_SECURITY_HUB for a self-managed configuration.
    /// This member is required.
    public var configurationPolicyIdentifier: Swift.String?
    /// The identifier of the target account, organizational unit, or the root to associate with the specified configuration.
    /// This member is required.
    public var target: SecurityHubClientTypes.Target?

    public init(
        configurationPolicyIdentifier: Swift.String? = nil,
        target: SecurityHubClientTypes.Target? = nil
    )
    {
        self.configurationPolicyIdentifier = configurationPolicyIdentifier
        self.target = target
    }
}

public struct StartConfigurationPolicyAssociationOutput {
    /// The current status of the association between the specified target and the configuration.
    public var associationStatus: SecurityHubClientTypes.ConfigurationPolicyAssociationStatus?
    /// An explanation for a FAILED value for AssociationStatus.
    public var associationStatusMessage: Swift.String?
    /// Indicates whether the association between the specified target and the configuration was directly applied by the Security Hub delegated administrator or inherited from a parent.
    public var associationType: SecurityHubClientTypes.AssociationType?
    /// The UUID of the configuration policy.
    public var configurationPolicyId: Swift.String?
    /// The identifier of the target account, organizational unit, or the organization root with which the configuration is associated.
    public var targetId: Swift.String?
    /// Indicates whether the target is an Amazon Web Services account, organizational unit, or the organization root.
    public var targetType: SecurityHubClientTypes.TargetType?
    /// The date and time, in UTC and ISO 8601 format, that the configuration policy association was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        associationStatus: SecurityHubClientTypes.ConfigurationPolicyAssociationStatus? = nil,
        associationStatusMessage: Swift.String? = nil,
        associationType: SecurityHubClientTypes.AssociationType? = nil,
        configurationPolicyId: Swift.String? = nil,
        targetId: Swift.String? = nil,
        targetType: SecurityHubClientTypes.TargetType? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.associationStatus = associationStatus
        self.associationStatusMessage = associationStatusMessage
        self.associationType = associationType
        self.configurationPolicyId = configurationPolicyId
        self.targetId = targetId
        self.targetType = targetType
        self.updatedAt = updatedAt
    }
}

public struct StartConfigurationPolicyDisassociationInput {
    /// The Amazon Resource Name (ARN) of a configuration policy, the universally unique identifier (UUID) of a configuration policy, or a value of SELF_MANAGED_SECURITY_HUB for a self-managed configuration.
    /// This member is required.
    public var configurationPolicyIdentifier: Swift.String?
    /// The identifier of the target account, organizational unit, or the root to disassociate from the specified configuration.
    public var target: SecurityHubClientTypes.Target?

    public init(
        configurationPolicyIdentifier: Swift.String? = nil,
        target: SecurityHubClientTypes.Target? = nil
    )
    {
        self.configurationPolicyIdentifier = configurationPolicyIdentifier
        self.target = target
    }
}

public struct StartConfigurationPolicyDisassociationOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The ARN of the resource to apply the tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. You can add up to 50 tags at a time. The tag keys can be no longer than 128 characters. The tag values can be no longer than 256 characters.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the resource to remove the tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys associated with the tags to remove from the resource. You can remove up to 50 tags at a time.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateActionTargetInput {
    /// The ARN of the custom action target to update.
    /// This member is required.
    public var actionTargetArn: Swift.String?
    /// The updated description for the custom action target.
    public var description: Swift.String?
    /// The updated name of the custom action target.
    public var name: Swift.String?

    public init(
        actionTargetArn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
        self.description = description
        self.name = name
    }
}

public struct UpdateActionTargetOutput {

    public init() { }
}

public struct UpdateConfigurationPolicyInput {
    /// An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls. If you provide a list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including newly released controls). If you provide a list of security controls that are disabled in the configuration policy, Security Hub enables all other controls (including newly released controls). When updating a configuration policy, provide a complete list of standards that you want to enable and a complete list of controls that you want to enable or disable. The updated configuration replaces the current configuration.
    public var configurationPolicy: SecurityHubClientTypes.Policy?
    /// The description of the configuration policy.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) or universally unique identifier (UUID) of the configuration policy.
    /// This member is required.
    public var identifier: Swift.String?
    /// The name of the configuration policy. Alphanumeric characters and the following ASCII characters are permitted: -, ., !, *, /.
    public var name: Swift.String?
    /// The reason for updating the configuration policy.
    public var updatedReason: Swift.String?

    public init(
        configurationPolicy: SecurityHubClientTypes.Policy? = nil,
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedReason: Swift.String? = nil
    )
    {
        self.configurationPolicy = configurationPolicy
        self.description = description
        self.identifier = identifier
        self.name = name
        self.updatedReason = updatedReason
    }
}

public struct UpdateConfigurationPolicyOutput {
    /// The ARN of the configuration policy.
    public var arn: Swift.String?
    /// An object that defines how Security Hub is configured. It includes whether Security Hub is enabled or disabled, a list of enabled security standards, a list of enabled or disabled security controls, and a list of custom parameter values for specified controls. If the request included a list of security controls that are enabled in the configuration policy, Security Hub disables all other controls (including newly released controls). If the request included a list of security controls that are disabled in the configuration policy, Security Hub enables all other controls (including newly released controls).
    public var configurationPolicy: SecurityHubClientTypes.Policy?
    /// The date and time, in UTC and ISO 8601 format, that the configuration policy was created.
    public var createdAt: Foundation.Date?
    /// The description of the configuration policy.
    public var description: Swift.String?
    /// The UUID of the configuration policy.
    public var id: Swift.String?
    /// The name of the configuration policy.
    public var name: Swift.String?
    /// The date and time, in UTC and ISO 8601 format, that the configuration policy was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        configurationPolicy: SecurityHubClientTypes.Policy? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.configurationPolicy = configurationPolicy
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
    }
}

public struct UpdateFindingAggregatorInput {
    /// The ARN of the finding aggregator. To obtain the ARN, use ListFindingAggregators.
    /// This member is required.
    public var findingAggregatorArn: Swift.String?
    /// Indicates whether to aggregate findings from all of the available Regions in the current partition. Also determines whether to automatically aggregate findings from new Regions as Security Hub supports them and you opt into them. The selected option also determines how to use the Regions provided in the Regions list. The options are as follows:
    ///
    /// * ALL_REGIONS - Aggregates findings from all of the Regions where Security Hub is enabled. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.
    ///
    /// * ALL_REGIONS_EXCEPT_SPECIFIED - Aggregates findings from all of the Regions where Security Hub is enabled, except for the Regions listed in the Regions parameter. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.
    ///
    /// * SPECIFIED_REGIONS - Aggregates findings only from the Regions listed in the Regions parameter. Security Hub does not automatically aggregate findings from new Regions.
    ///
    /// * NO_REGIONS - Aggregates no data because no Regions are selected as linked Regions.
    /// This member is required.
    public var regionLinkingMode: Swift.String?
    /// If RegionLinkingMode is ALL_REGIONS_EXCEPT_SPECIFIED, then this is a space-separated list of Regions that do not aggregate findings to the aggregation Region. If RegionLinkingMode is SPECIFIED_REGIONS, then this is a space-separated list of Regions that do aggregate findings to the aggregation Region. An InvalidInputException error results if you populate this field while RegionLinkingMode is NO_REGIONS.
    public var regions: [Swift.String]?

    public init(
        findingAggregatorArn: Swift.String? = nil,
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.findingAggregatorArn = findingAggregatorArn
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

public struct UpdateFindingAggregatorOutput {
    /// The aggregation Region.
    public var findingAggregationRegion: Swift.String?
    /// The ARN of the finding aggregator.
    public var findingAggregatorArn: Swift.String?
    /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
    public var regionLinkingMode: Swift.String?
    /// The list of excluded Regions or included Regions.
    public var regions: [Swift.String]?

    public init(
        findingAggregationRegion: Swift.String? = nil,
        findingAggregatorArn: Swift.String? = nil,
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.findingAggregationRegion = findingAggregationRegion
        self.findingAggregatorArn = findingAggregatorArn
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

public struct UpdateFindingsInput {
    /// A collection of attributes that specify which findings you want to update.
    /// This member is required.
    public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    /// The updated note for the finding.
    public var note: SecurityHubClientTypes.NoteUpdate?
    /// The updated record state for the finding.
    public var recordState: SecurityHubClientTypes.RecordState?

    public init(
        filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
        note: SecurityHubClientTypes.NoteUpdate? = nil,
        recordState: SecurityHubClientTypes.RecordState? = nil
    )
    {
        self.filters = filters
        self.note = note
        self.recordState = recordState
    }
}

public struct UpdateFindingsOutput {

    public init() { }
}

public struct UpdateInsightInput {
    /// The updated filters that define this insight.
    public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    /// The updated GroupBy attribute that defines this insight.
    public var groupByAttribute: Swift.String?
    /// The ARN of the insight that you want to update.
    /// This member is required.
    public var insightArn: Swift.String?
    /// The updated name for the insight.
    public var name: Swift.String?

    public init(
        filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
        groupByAttribute: Swift.String? = nil,
        insightArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.filters = filters
        self.groupByAttribute = groupByAttribute
        self.insightArn = insightArn
        self.name = name
    }
}

public struct UpdateInsightOutput {

    public init() { }
}

public struct UpdateOrganizationConfigurationInput {
    /// Whether to automatically enable Security Hub in new member accounts when they join the organization. If set to true, then Security Hub is automatically enabled in new accounts. If set to false, then Security Hub isn't enabled in new accounts automatically. The default value is false. If the ConfigurationType of your organization is set to CENTRAL, then this field is set to false and can't be changed in the home Region and linked Regions. However, in that case, the delegated administrator can create a configuration policy in which Security Hub is enabled and associate the policy with new organization accounts.
    /// This member is required.
    public var autoEnable: Swift.Bool?
    /// Whether to automatically enable Security Hub [default standards](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-enable-disable.html) in new member accounts when they join the organization. The default value of this parameter is equal to DEFAULT. If equal to DEFAULT, then Security Hub default standards are automatically enabled for new member accounts. If equal to NONE, then default standards are not automatically enabled for new member accounts. If the ConfigurationType of your organization is set to CENTRAL, then this field is set to NONE and can't be changed in the home Region and linked Regions. However, in that case, the delegated administrator can create a configuration policy in which specific security standards are enabled and associate the policy with new organization accounts.
    public var autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards?
    /// Provides information about the way an organization is configured in Security Hub.
    public var organizationConfiguration: SecurityHubClientTypes.OrganizationConfiguration?

    public init(
        autoEnable: Swift.Bool? = nil,
        autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards? = nil,
        organizationConfiguration: SecurityHubClientTypes.OrganizationConfiguration? = nil
    )
    {
        self.autoEnable = autoEnable
        self.autoEnableStandards = autoEnableStandards
        self.organizationConfiguration = organizationConfiguration
    }
}

public struct UpdateOrganizationConfigurationOutput {

    public init() { }
}

public struct UpdateSecurityControlInput {
    /// The most recent reason for updating the properties of the security control. This field accepts alphanumeric characters in addition to white spaces, dashes, and underscores.
    public var lastUpdateReason: Swift.String?
    /// An object that specifies which security control parameters to update.
    /// This member is required.
    public var parameters: [Swift.String: SecurityHubClientTypes.ParameterConfiguration]?
    /// The Amazon Resource Name (ARN) or ID of the control to update.
    /// This member is required.
    public var securityControlId: Swift.String?

    public init(
        lastUpdateReason: Swift.String? = nil,
        parameters: [Swift.String: SecurityHubClientTypes.ParameterConfiguration]? = nil,
        securityControlId: Swift.String? = nil
    )
    {
        self.lastUpdateReason = lastUpdateReason
        self.parameters = parameters
        self.securityControlId = securityControlId
    }
}

public struct UpdateSecurityControlOutput {

    public init() { }
}

public struct UpdateSecurityHubConfigurationInput {
    /// Whether to automatically enable new controls when they are added to standards that are enabled. By default, this is set to true, and new controls are enabled automatically. To not automatically enable new controls, set this to false.
    public var autoEnableControls: Swift.Bool?
    /// Updates whether the calling account has consolidated control findings turned on. If the value for this field is set to SECURITY_CONTROL, Security Hub generates a single finding for a control check even when the check applies to multiple enabled standards. If the value for this field is set to STANDARD_CONTROL, Security Hub generates separate findings for a control check when the check applies to multiple enabled standards. For accounts that are part of an organization, this value can only be updated in the administrator account.
    public var controlFindingGenerator: SecurityHubClientTypes.ControlFindingGenerator?

    public init(
        autoEnableControls: Swift.Bool? = nil,
        controlFindingGenerator: SecurityHubClientTypes.ControlFindingGenerator? = nil
    )
    {
        self.autoEnableControls = autoEnableControls
        self.controlFindingGenerator = controlFindingGenerator
    }
}

public struct UpdateSecurityHubConfigurationOutput {

    public init() { }
}

public struct UpdateStandardsControlInput {
    /// The updated status of the security standard control.
    public var controlStatus: SecurityHubClientTypes.ControlStatus?
    /// A description of the reason why you are disabling a security standard control. If you are disabling a control, then this is required.
    public var disabledReason: Swift.String?
    /// The ARN of the security standard control to enable or disable.
    /// This member is required.
    public var standardsControlArn: Swift.String?

    public init(
        controlStatus: SecurityHubClientTypes.ControlStatus? = nil,
        disabledReason: Swift.String? = nil,
        standardsControlArn: Swift.String? = nil
    )
    {
        self.controlStatus = controlStatus
        self.disabledReason = disabledReason
        self.standardsControlArn = standardsControlArn
    }
}

public struct UpdateStandardsControlOutput {

    public init() { }
}

extension AcceptAdministratorInvitationInput {

    static func urlPathProvider(_ value: AcceptAdministratorInvitationInput) -> Swift.String? {
        return "/administrator"
    }
}

extension AcceptInvitationInput {

    static func urlPathProvider(_ value: AcceptInvitationInput) -> Swift.String? {
        return "/master"
    }
}

extension BatchDeleteAutomationRulesInput {

    static func urlPathProvider(_ value: BatchDeleteAutomationRulesInput) -> Swift.String? {
        return "/automationrules/delete"
    }
}

extension BatchDisableStandardsInput {

    static func urlPathProvider(_ value: BatchDisableStandardsInput) -> Swift.String? {
        return "/standards/deregister"
    }
}

extension BatchEnableStandardsInput {

    static func urlPathProvider(_ value: BatchEnableStandardsInput) -> Swift.String? {
        return "/standards/register"
    }
}

extension BatchGetAutomationRulesInput {

    static func urlPathProvider(_ value: BatchGetAutomationRulesInput) -> Swift.String? {
        return "/automationrules/get"
    }
}

extension BatchGetConfigurationPolicyAssociationsInput {

    static func urlPathProvider(_ value: BatchGetConfigurationPolicyAssociationsInput) -> Swift.String? {
        return "/configurationPolicyAssociation/batchget"
    }
}

extension BatchGetSecurityControlsInput {

    static func urlPathProvider(_ value: BatchGetSecurityControlsInput) -> Swift.String? {
        return "/securityControls/batchGet"
    }
}

extension BatchGetStandardsControlAssociationsInput {

    static func urlPathProvider(_ value: BatchGetStandardsControlAssociationsInput) -> Swift.String? {
        return "/associations/batchGet"
    }
}

extension BatchImportFindingsInput {

    static func urlPathProvider(_ value: BatchImportFindingsInput) -> Swift.String? {
        return "/findings/import"
    }
}

extension BatchUpdateAutomationRulesInput {

    static func urlPathProvider(_ value: BatchUpdateAutomationRulesInput) -> Swift.String? {
        return "/automationrules/update"
    }
}

extension BatchUpdateFindingsInput {

    static func urlPathProvider(_ value: BatchUpdateFindingsInput) -> Swift.String? {
        return "/findings/batchupdate"
    }
}

extension BatchUpdateStandardsControlAssociationsInput {

    static func urlPathProvider(_ value: BatchUpdateStandardsControlAssociationsInput) -> Swift.String? {
        return "/associations"
    }
}

extension CreateActionTargetInput {

    static func urlPathProvider(_ value: CreateActionTargetInput) -> Swift.String? {
        return "/actionTargets"
    }
}

extension CreateAutomationRuleInput {

    static func urlPathProvider(_ value: CreateAutomationRuleInput) -> Swift.String? {
        return "/automationrules/create"
    }
}

extension CreateConfigurationPolicyInput {

    static func urlPathProvider(_ value: CreateConfigurationPolicyInput) -> Swift.String? {
        return "/configurationPolicy/create"
    }
}

extension CreateFindingAggregatorInput {

    static func urlPathProvider(_ value: CreateFindingAggregatorInput) -> Swift.String? {
        return "/findingAggregator/create"
    }
}

extension CreateInsightInput {

    static func urlPathProvider(_ value: CreateInsightInput) -> Swift.String? {
        return "/insights"
    }
}

extension CreateMembersInput {

    static func urlPathProvider(_ value: CreateMembersInput) -> Swift.String? {
        return "/members"
    }
}

extension DeclineInvitationsInput {

    static func urlPathProvider(_ value: DeclineInvitationsInput) -> Swift.String? {
        return "/invitations/decline"
    }
}

extension DeleteActionTargetInput {

    static func urlPathProvider(_ value: DeleteActionTargetInput) -> Swift.String? {
        guard let actionTargetArn = value.actionTargetArn else {
            return nil
        }
        return "/actionTargets/\(actionTargetArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteConfigurationPolicyInput {

    static func urlPathProvider(_ value: DeleteConfigurationPolicyInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/configurationPolicy/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteFindingAggregatorInput {

    static func urlPathProvider(_ value: DeleteFindingAggregatorInput) -> Swift.String? {
        guard let findingAggregatorArn = value.findingAggregatorArn else {
            return nil
        }
        return "/findingAggregator/delete/\(findingAggregatorArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteInsightInput {

    static func urlPathProvider(_ value: DeleteInsightInput) -> Swift.String? {
        guard let insightArn = value.insightArn else {
            return nil
        }
        return "/insights/\(insightArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DeleteInvitationsInput {

    static func urlPathProvider(_ value: DeleteInvitationsInput) -> Swift.String? {
        return "/invitations/delete"
    }
}

extension DeleteMembersInput {

    static func urlPathProvider(_ value: DeleteMembersInput) -> Swift.String? {
        return "/members/delete"
    }
}

extension DescribeActionTargetsInput {

    static func urlPathProvider(_ value: DescribeActionTargetsInput) -> Swift.String? {
        return "/actionTargets/get"
    }
}

extension DescribeHubInput {

    static func urlPathProvider(_ value: DescribeHubInput) -> Swift.String? {
        return "/accounts"
    }
}

extension DescribeHubInput {

    static func queryItemProvider(_ value: DescribeHubInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let hubArn = value.hubArn {
            let hubArnQueryItem = Smithy.URIQueryItem(name: "HubArn".urlPercentEncoding(), value: Swift.String(hubArn).urlPercentEncoding())
            items.append(hubArnQueryItem)
        }
        return items
    }
}

extension DescribeOrganizationConfigurationInput {

    static func urlPathProvider(_ value: DescribeOrganizationConfigurationInput) -> Swift.String? {
        return "/organization/configuration"
    }
}

extension DescribeProductsInput {

    static func urlPathProvider(_ value: DescribeProductsInput) -> Swift.String? {
        return "/products"
    }
}

extension DescribeProductsInput {

    static func queryItemProvider(_ value: DescribeProductsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let productArn = value.productArn {
            let productArnQueryItem = Smithy.URIQueryItem(name: "ProductArn".urlPercentEncoding(), value: Swift.String(productArn).urlPercentEncoding())
            items.append(productArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension DescribeStandardsInput {

    static func urlPathProvider(_ value: DescribeStandardsInput) -> Swift.String? {
        return "/standards"
    }
}

extension DescribeStandardsInput {

    static func queryItemProvider(_ value: DescribeStandardsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension DescribeStandardsControlsInput {

    static func urlPathProvider(_ value: DescribeStandardsControlsInput) -> Swift.String? {
        guard let standardsSubscriptionArn = value.standardsSubscriptionArn else {
            return nil
        }
        return "/standards/controls/\(standardsSubscriptionArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DescribeStandardsControlsInput {

    static func queryItemProvider(_ value: DescribeStandardsControlsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension DisableImportFindingsForProductInput {

    static func urlPathProvider(_ value: DisableImportFindingsForProductInput) -> Swift.String? {
        guard let productSubscriptionArn = value.productSubscriptionArn else {
            return nil
        }
        return "/productSubscriptions/\(productSubscriptionArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension DisableOrganizationAdminAccountInput {

    static func urlPathProvider(_ value: DisableOrganizationAdminAccountInput) -> Swift.String? {
        return "/organization/admin/disable"
    }
}

extension DisableSecurityHubInput {

    static func urlPathProvider(_ value: DisableSecurityHubInput) -> Swift.String? {
        return "/accounts"
    }
}

extension DisassociateFromAdministratorAccountInput {

    static func urlPathProvider(_ value: DisassociateFromAdministratorAccountInput) -> Swift.String? {
        return "/administrator/disassociate"
    }
}

extension DisassociateFromMasterAccountInput {

    static func urlPathProvider(_ value: DisassociateFromMasterAccountInput) -> Swift.String? {
        return "/master/disassociate"
    }
}

extension DisassociateMembersInput {

    static func urlPathProvider(_ value: DisassociateMembersInput) -> Swift.String? {
        return "/members/disassociate"
    }
}

extension EnableImportFindingsForProductInput {

    static func urlPathProvider(_ value: EnableImportFindingsForProductInput) -> Swift.String? {
        return "/productSubscriptions"
    }
}

extension EnableOrganizationAdminAccountInput {

    static func urlPathProvider(_ value: EnableOrganizationAdminAccountInput) -> Swift.String? {
        return "/organization/admin/enable"
    }
}

extension EnableSecurityHubInput {

    static func urlPathProvider(_ value: EnableSecurityHubInput) -> Swift.String? {
        return "/accounts"
    }
}

extension GetAdministratorAccountInput {

    static func urlPathProvider(_ value: GetAdministratorAccountInput) -> Swift.String? {
        return "/administrator"
    }
}

extension GetConfigurationPolicyInput {

    static func urlPathProvider(_ value: GetConfigurationPolicyInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/configurationPolicy/get/\(identifier.urlPercentEncoding())"
    }
}

extension GetConfigurationPolicyAssociationInput {

    static func urlPathProvider(_ value: GetConfigurationPolicyAssociationInput) -> Swift.String? {
        return "/configurationPolicyAssociation/get"
    }
}

extension GetEnabledStandardsInput {

    static func urlPathProvider(_ value: GetEnabledStandardsInput) -> Swift.String? {
        return "/standards/get"
    }
}

extension GetFindingAggregatorInput {

    static func urlPathProvider(_ value: GetFindingAggregatorInput) -> Swift.String? {
        guard let findingAggregatorArn = value.findingAggregatorArn else {
            return nil
        }
        return "/findingAggregator/get/\(findingAggregatorArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetFindingHistoryInput {

    static func urlPathProvider(_ value: GetFindingHistoryInput) -> Swift.String? {
        return "/findingHistory/get"
    }
}

extension GetFindingsInput {

    static func urlPathProvider(_ value: GetFindingsInput) -> Swift.String? {
        return "/findings"
    }
}

extension GetInsightResultsInput {

    static func urlPathProvider(_ value: GetInsightResultsInput) -> Swift.String? {
        guard let insightArn = value.insightArn else {
            return nil
        }
        return "/insights/results/\(insightArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension GetInsightsInput {

    static func urlPathProvider(_ value: GetInsightsInput) -> Swift.String? {
        return "/insights/get"
    }
}

extension GetInvitationsCountInput {

    static func urlPathProvider(_ value: GetInvitationsCountInput) -> Swift.String? {
        return "/invitations/count"
    }
}

extension GetMasterAccountInput {

    static func urlPathProvider(_ value: GetMasterAccountInput) -> Swift.String? {
        return "/master"
    }
}

extension GetMembersInput {

    static func urlPathProvider(_ value: GetMembersInput) -> Swift.String? {
        return "/members/get"
    }
}

extension GetSecurityControlDefinitionInput {

    static func urlPathProvider(_ value: GetSecurityControlDefinitionInput) -> Swift.String? {
        return "/securityControl/definition"
    }
}

extension GetSecurityControlDefinitionInput {

    static func queryItemProvider(_ value: GetSecurityControlDefinitionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let securityControlId = value.securityControlId else {
            let message = "Creating a URL Query Item failed. securityControlId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let securityControlIdQueryItem = Smithy.URIQueryItem(name: "SecurityControlId".urlPercentEncoding(), value: Swift.String(securityControlId).urlPercentEncoding())
        items.append(securityControlIdQueryItem)
        return items
    }
}

extension InviteMembersInput {

    static func urlPathProvider(_ value: InviteMembersInput) -> Swift.String? {
        return "/members/invite"
    }
}

extension ListAutomationRulesInput {

    static func urlPathProvider(_ value: ListAutomationRulesInput) -> Swift.String? {
        return "/automationrules/list"
    }
}

extension ListAutomationRulesInput {

    static func queryItemProvider(_ value: ListAutomationRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationPoliciesInput {

    static func urlPathProvider(_ value: ListConfigurationPoliciesInput) -> Swift.String? {
        return "/configurationPolicy/list"
    }
}

extension ListConfigurationPoliciesInput {

    static func queryItemProvider(_ value: ListConfigurationPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationPolicyAssociationsInput {

    static func urlPathProvider(_ value: ListConfigurationPolicyAssociationsInput) -> Swift.String? {
        return "/configurationPolicyAssociation/list"
    }
}

extension ListEnabledProductsForImportInput {

    static func urlPathProvider(_ value: ListEnabledProductsForImportInput) -> Swift.String? {
        return "/productSubscriptions"
    }
}

extension ListEnabledProductsForImportInput {

    static func queryItemProvider(_ value: ListEnabledProductsForImportInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFindingAggregatorsInput {

    static func urlPathProvider(_ value: ListFindingAggregatorsInput) -> Swift.String? {
        return "/findingAggregator/list"
    }
}

extension ListFindingAggregatorsInput {

    static func queryItemProvider(_ value: ListFindingAggregatorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInvitationsInput {

    static func urlPathProvider(_ value: ListInvitationsInput) -> Swift.String? {
        return "/invitations"
    }
}

extension ListInvitationsInput {

    static func queryItemProvider(_ value: ListInvitationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMembersInput {

    static func urlPathProvider(_ value: ListMembersInput) -> Swift.String? {
        return "/members"
    }
}

extension ListMembersInput {

    static func queryItemProvider(_ value: ListMembersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let onlyAssociated = value.onlyAssociated {
            let onlyAssociatedQueryItem = Smithy.URIQueryItem(name: "OnlyAssociated".urlPercentEncoding(), value: Swift.String(onlyAssociated).urlPercentEncoding())
            items.append(onlyAssociatedQueryItem)
        }
        return items
    }
}

extension ListOrganizationAdminAccountsInput {

    static func urlPathProvider(_ value: ListOrganizationAdminAccountsInput) -> Swift.String? {
        return "/organization/admin"
    }
}

extension ListOrganizationAdminAccountsInput {

    static func queryItemProvider(_ value: ListOrganizationAdminAccountsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSecurityControlDefinitionsInput {

    static func urlPathProvider(_ value: ListSecurityControlDefinitionsInput) -> Swift.String? {
        return "/securityControls/definitions"
    }
}

extension ListSecurityControlDefinitionsInput {

    static func queryItemProvider(_ value: ListSecurityControlDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let standardsArn = value.standardsArn {
            let standardsArnQueryItem = Smithy.URIQueryItem(name: "StandardsArn".urlPercentEncoding(), value: Swift.String(standardsArn).urlPercentEncoding())
            items.append(standardsArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStandardsControlAssociationsInput {

    static func urlPathProvider(_ value: ListStandardsControlAssociationsInput) -> Swift.String? {
        return "/associations"
    }
}

extension ListStandardsControlAssociationsInput {

    static func queryItemProvider(_ value: ListStandardsControlAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let securityControlId = value.securityControlId else {
            let message = "Creating a URL Query Item failed. securityControlId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let securityControlIdQueryItem = Smithy.URIQueryItem(name: "SecurityControlId".urlPercentEncoding(), value: Swift.String(securityControlId).urlPercentEncoding())
        items.append(securityControlIdQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartConfigurationPolicyAssociationInput {

    static func urlPathProvider(_ value: StartConfigurationPolicyAssociationInput) -> Swift.String? {
        return "/configurationPolicyAssociation/associate"
    }
}

extension StartConfigurationPolicyDisassociationInput {

    static func urlPathProvider(_ value: StartConfigurationPolicyDisassociationInput) -> Swift.String? {
        return "/configurationPolicyAssociation/disassociate"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateActionTargetInput {

    static func urlPathProvider(_ value: UpdateActionTargetInput) -> Swift.String? {
        guard let actionTargetArn = value.actionTargetArn else {
            return nil
        }
        return "/actionTargets/\(actionTargetArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UpdateConfigurationPolicyInput {

    static func urlPathProvider(_ value: UpdateConfigurationPolicyInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/configurationPolicy/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateFindingAggregatorInput {

    static func urlPathProvider(_ value: UpdateFindingAggregatorInput) -> Swift.String? {
        return "/findingAggregator/update"
    }
}

extension UpdateFindingsInput {

    static func urlPathProvider(_ value: UpdateFindingsInput) -> Swift.String? {
        return "/findings"
    }
}

extension UpdateInsightInput {

    static func urlPathProvider(_ value: UpdateInsightInput) -> Swift.String? {
        guard let insightArn = value.insightArn else {
            return nil
        }
        return "/insights/\(insightArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension UpdateOrganizationConfigurationInput {

    static func urlPathProvider(_ value: UpdateOrganizationConfigurationInput) -> Swift.String? {
        return "/organization/configuration"
    }
}

extension UpdateSecurityControlInput {

    static func urlPathProvider(_ value: UpdateSecurityControlInput) -> Swift.String? {
        return "/securityControl/update"
    }
}

extension UpdateSecurityHubConfigurationInput {

    static func urlPathProvider(_ value: UpdateSecurityHubConfigurationInput) -> Swift.String? {
        return "/accounts"
    }
}

extension UpdateStandardsControlInput {

    static func urlPathProvider(_ value: UpdateStandardsControlInput) -> Swift.String? {
        guard let standardsControlArn = value.standardsControlArn else {
            return nil
        }
        return "/standards/control/\(standardsControlArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension AcceptAdministratorInvitationInput {

    static func write(value: AcceptAdministratorInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdministratorId"].write(value.administratorId)
        try writer["InvitationId"].write(value.invitationId)
    }
}

extension AcceptInvitationInput {

    static func write(value: AcceptInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvitationId"].write(value.invitationId)
        try writer["MasterId"].write(value.masterId)
    }
}

extension BatchDeleteAutomationRulesInput {

    static func write(value: BatchDeleteAutomationRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomationRulesArns"].writeList(value.automationRulesArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDisableStandardsInput {

    static func write(value: BatchDisableStandardsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StandardsSubscriptionArns"].writeList(value.standardsSubscriptionArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchEnableStandardsInput {

    static func write(value: BatchEnableStandardsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StandardsSubscriptionRequests"].writeList(value.standardsSubscriptionRequests, memberWritingClosure: SecurityHubClientTypes.StandardsSubscriptionRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetAutomationRulesInput {

    static func write(value: BatchGetAutomationRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomationRulesArns"].writeList(value.automationRulesArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetConfigurationPolicyAssociationsInput {

    static func write(value: BatchGetConfigurationPolicyAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationPolicyAssociationIdentifiers"].writeList(value.configurationPolicyAssociationIdentifiers, memberWritingClosure: SecurityHubClientTypes.ConfigurationPolicyAssociation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetSecurityControlsInput {

    static func write(value: BatchGetSecurityControlsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityControlIds"].writeList(value.securityControlIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetStandardsControlAssociationsInput {

    static func write(value: BatchGetStandardsControlAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StandardsControlAssociationIds"].writeList(value.standardsControlAssociationIds, memberWritingClosure: SecurityHubClientTypes.StandardsControlAssociationId.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchImportFindingsInput {

    static func write(value: BatchImportFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Findings"].writeList(value.findings, memberWritingClosure: SecurityHubClientTypes.AwsSecurityFinding.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateAutomationRulesInput {

    static func write(value: BatchUpdateAutomationRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UpdateAutomationRulesRequestItems"].writeList(value.updateAutomationRulesRequestItems, memberWritingClosure: SecurityHubClientTypes.UpdateAutomationRulesRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateFindingsInput {

    static func write(value: BatchUpdateFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Confidence"].write(value.confidence)
        try writer["Criticality"].write(value.criticality)
        try writer["FindingIdentifiers"].writeList(value.findingIdentifiers, memberWritingClosure: SecurityHubClientTypes.AwsSecurityFindingIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Note"].write(value.note, with: SecurityHubClientTypes.NoteUpdate.write(value:to:))
        try writer["RelatedFindings"].writeList(value.relatedFindings, memberWritingClosure: SecurityHubClientTypes.RelatedFinding.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Severity"].write(value.severity, with: SecurityHubClientTypes.SeverityUpdate.write(value:to:))
        try writer["Types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserDefinedFields"].writeMap(value.userDefinedFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VerificationState"].write(value.verificationState)
        try writer["Workflow"].write(value.workflow, with: SecurityHubClientTypes.WorkflowUpdate.write(value:to:))
    }
}

extension BatchUpdateStandardsControlAssociationsInput {

    static func write(value: BatchUpdateStandardsControlAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StandardsControlAssociationUpdates"].writeList(value.standardsControlAssociationUpdates, memberWritingClosure: SecurityHubClientTypes.StandardsControlAssociationUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateActionTargetInput {

    static func write(value: CreateActionTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
    }
}

extension CreateAutomationRuleInput {

    static func write(value: CreateAutomationRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: SecurityHubClientTypes.AutomationRulesAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Criteria"].write(value.criteria, with: SecurityHubClientTypes.AutomationRulesFindingFilters.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["IsTerminal"].write(value.isTerminal)
        try writer["RuleName"].write(value.ruleName)
        try writer["RuleOrder"].write(value.ruleOrder)
        try writer["RuleStatus"].write(value.ruleStatus)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateConfigurationPolicyInput {

    static func write(value: CreateConfigurationPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationPolicy"].write(value.configurationPolicy, with: SecurityHubClientTypes.Policy.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFindingAggregatorInput {

    static func write(value: CreateFindingAggregatorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegionLinkingMode"].write(value.regionLinkingMode)
        try writer["Regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateInsightInput {

    static func write(value: CreateInsightInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: SecurityHubClientTypes.AwsSecurityFindingFilters.write(value:to:))
        try writer["GroupByAttribute"].write(value.groupByAttribute)
        try writer["Name"].write(value.name)
    }
}

extension CreateMembersInput {

    static func write(value: CreateMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountDetails"].writeList(value.accountDetails, memberWritingClosure: SecurityHubClientTypes.AccountDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeclineInvitationsInput {

    static func write(value: DeclineInvitationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteInvitationsInput {

    static func write(value: DeleteInvitationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteMembersInput {

    static func write(value: DeleteMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeActionTargetsInput {

    static func write(value: DescribeActionTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionTargetArns"].writeList(value.actionTargetArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DisableOrganizationAdminAccountInput {

    static func write(value: DisableOrganizationAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdminAccountId"].write(value.adminAccountId)
    }
}

extension DisassociateMembersInput {

    static func write(value: DisassociateMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension EnableImportFindingsForProductInput {

    static func write(value: EnableImportFindingsForProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProductArn"].write(value.productArn)
    }
}

extension EnableOrganizationAdminAccountInput {

    static func write(value: EnableOrganizationAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdminAccountId"].write(value.adminAccountId)
    }
}

extension EnableSecurityHubInput {

    static func write(value: EnableSecurityHubInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ControlFindingGenerator"].write(value.controlFindingGenerator)
        try writer["EnableDefaultStandards"].write(value.enableDefaultStandards)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GetConfigurationPolicyAssociationInput {

    static func write(value: GetConfigurationPolicyAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Target"].write(value.target, with: SecurityHubClientTypes.Target.write(value:to:))
    }
}

extension GetEnabledStandardsInput {

    static func write(value: GetEnabledStandardsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StandardsSubscriptionArns"].writeList(value.standardsSubscriptionArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetFindingHistoryInput {

    static func write(value: GetFindingHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["FindingIdentifier"].write(value.findingIdentifier, with: SecurityHubClientTypes.AwsSecurityFindingIdentifier.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
    }
}

extension GetFindingsInput {

    static func write(value: GetFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: SecurityHubClientTypes.AwsSecurityFindingFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortCriteria"].writeList(value.sortCriteria, memberWritingClosure: SecurityHubClientTypes.SortCriterion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetInsightsInput {

    static func write(value: GetInsightsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightArns"].writeList(value.insightArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension GetMembersInput {

    static func write(value: GetMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension InviteMembersInput {

    static func write(value: InviteMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListConfigurationPolicyAssociationsInput {

    static func write(value: ListConfigurationPolicyAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: SecurityHubClientTypes.AssociationFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension StartConfigurationPolicyAssociationInput {

    static func write(value: StartConfigurationPolicyAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationPolicyIdentifier"].write(value.configurationPolicyIdentifier)
        try writer["Target"].write(value.target, with: SecurityHubClientTypes.Target.write(value:to:))
    }
}

extension StartConfigurationPolicyDisassociationInput {

    static func write(value: StartConfigurationPolicyDisassociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationPolicyIdentifier"].write(value.configurationPolicyIdentifier)
        try writer["Target"].write(value.target, with: SecurityHubClientTypes.Target.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateActionTargetInput {

    static func write(value: UpdateActionTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
    }
}

extension UpdateConfigurationPolicyInput {

    static func write(value: UpdateConfigurationPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationPolicy"].write(value.configurationPolicy, with: SecurityHubClientTypes.Policy.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["UpdatedReason"].write(value.updatedReason)
    }
}

extension UpdateFindingAggregatorInput {

    static func write(value: UpdateFindingAggregatorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FindingAggregatorArn"].write(value.findingAggregatorArn)
        try writer["RegionLinkingMode"].write(value.regionLinkingMode)
        try writer["Regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateFindingsInput {

    static func write(value: UpdateFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: SecurityHubClientTypes.AwsSecurityFindingFilters.write(value:to:))
        try writer["Note"].write(value.note, with: SecurityHubClientTypes.NoteUpdate.write(value:to:))
        try writer["RecordState"].write(value.recordState)
    }
}

extension UpdateInsightInput {

    static func write(value: UpdateInsightInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: SecurityHubClientTypes.AwsSecurityFindingFilters.write(value:to:))
        try writer["GroupByAttribute"].write(value.groupByAttribute)
        try writer["Name"].write(value.name)
    }
}

extension UpdateOrganizationConfigurationInput {

    static func write(value: UpdateOrganizationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoEnable"].write(value.autoEnable)
        try writer["AutoEnableStandards"].write(value.autoEnableStandards)
        try writer["OrganizationConfiguration"].write(value.organizationConfiguration, with: SecurityHubClientTypes.OrganizationConfiguration.write(value:to:))
    }
}

extension UpdateSecurityControlInput {

    static func write(value: UpdateSecurityControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LastUpdateReason"].write(value.lastUpdateReason)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SecurityHubClientTypes.ParameterConfiguration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SecurityControlId"].write(value.securityControlId)
    }
}

extension UpdateSecurityHubConfigurationInput {

    static func write(value: UpdateSecurityHubConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoEnableControls"].write(value.autoEnableControls)
        try writer["ControlFindingGenerator"].write(value.controlFindingGenerator)
    }
}

extension UpdateStandardsControlInput {

    static func write(value: UpdateStandardsControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ControlStatus"].write(value.controlStatus)
        try writer["DisabledReason"].write(value.disabledReason)
    }
}

extension AcceptAdministratorInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptAdministratorInvitationOutput {
        return AcceptAdministratorInvitationOutput()
    }
}

extension AcceptInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptInvitationOutput {
        return AcceptInvitationOutput()
    }
}

extension BatchDeleteAutomationRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteAutomationRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteAutomationRulesOutput()
        value.processedAutomationRules = try reader["ProcessedAutomationRules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedAutomationRules = try reader["UnprocessedAutomationRules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.UnprocessedAutomationRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDisableStandardsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisableStandardsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisableStandardsOutput()
        value.standardsSubscriptions = try reader["StandardsSubscriptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StandardsSubscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchEnableStandardsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchEnableStandardsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchEnableStandardsOutput()
        value.standardsSubscriptions = try reader["StandardsSubscriptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StandardsSubscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetAutomationRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetAutomationRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetAutomationRulesOutput()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AutomationRulesConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedAutomationRules = try reader["UnprocessedAutomationRules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.UnprocessedAutomationRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetConfigurationPolicyAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetConfigurationPolicyAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetConfigurationPolicyAssociationsOutput()
        value.configurationPolicyAssociations = try reader["ConfigurationPolicyAssociations"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.ConfigurationPolicyAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedConfigurationPolicyAssociations = try reader["UnprocessedConfigurationPolicyAssociations"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.UnprocessedConfigurationPolicyAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetSecurityControlsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetSecurityControlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetSecurityControlsOutput()
        value.securityControls = try reader["SecurityControls"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.SecurityControl.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.unprocessedIds = try reader["UnprocessedIds"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.UnprocessedSecurityControl.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetStandardsControlAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetStandardsControlAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetStandardsControlAssociationsOutput()
        value.standardsControlAssociationDetails = try reader["StandardsControlAssociationDetails"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StandardsControlAssociationDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.unprocessedAssociations = try reader["UnprocessedAssociations"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.UnprocessedStandardsControlAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchImportFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchImportFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchImportFindingsOutput()
        value.failedCount = try reader["FailedCount"].readIfPresent() ?? 0
        value.failedFindings = try reader["FailedFindings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.ImportFindingsError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successCount = try reader["SuccessCount"].readIfPresent() ?? 0
        return value
    }
}

extension BatchUpdateAutomationRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateAutomationRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateAutomationRulesOutput()
        value.processedAutomationRules = try reader["ProcessedAutomationRules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedAutomationRules = try reader["UnprocessedAutomationRules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.UnprocessedAutomationRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdateFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateFindingsOutput()
        value.processedFindings = try reader["ProcessedFindings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsSecurityFindingIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.unprocessedFindings = try reader["UnprocessedFindings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchUpdateStandardsControlAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateStandardsControlAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateStandardsControlAssociationsOutput()
        value.unprocessedAssociationUpdates = try reader["UnprocessedAssociationUpdates"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.UnprocessedStandardsControlAssociationUpdate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateActionTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateActionTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateActionTargetOutput()
        value.actionTargetArn = try reader["ActionTargetArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAutomationRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAutomationRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAutomationRuleOutput()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        return value
    }
}

extension CreateConfigurationPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConfigurationPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfigurationPolicyOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.configurationPolicy = try reader["ConfigurationPolicy"].readIfPresent(with: SecurityHubClientTypes.Policy.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension CreateFindingAggregatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFindingAggregatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFindingAggregatorOutput()
        value.findingAggregationRegion = try reader["FindingAggregationRegion"].readIfPresent()
        value.findingAggregatorArn = try reader["FindingAggregatorArn"].readIfPresent()
        value.regionLinkingMode = try reader["RegionLinkingMode"].readIfPresent()
        value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateInsightOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInsightOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInsightOutput()
        value.insightArn = try reader["InsightArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMembersOutput()
        value.unprocessedAccounts = try reader["UnprocessedAccounts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Result.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeclineInvitationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeclineInvitationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeclineInvitationsOutput()
        value.unprocessedAccounts = try reader["UnprocessedAccounts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Result.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteActionTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteActionTargetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteActionTargetOutput()
        value.actionTargetArn = try reader["ActionTargetArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteConfigurationPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfigurationPolicyOutput {
        return DeleteConfigurationPolicyOutput()
    }
}

extension DeleteFindingAggregatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFindingAggregatorOutput {
        return DeleteFindingAggregatorOutput()
    }
}

extension DeleteInsightOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInsightOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInsightOutput()
        value.insightArn = try reader["InsightArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteInvitationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInvitationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInvitationsOutput()
        value.unprocessedAccounts = try reader["UnprocessedAccounts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Result.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMembersOutput()
        value.unprocessedAccounts = try reader["UnprocessedAccounts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Result.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeActionTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeActionTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeActionTargetsOutput()
        value.actionTargets = try reader["ActionTargets"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.ActionTarget.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeHubOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeHubOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeHubOutput()
        value.autoEnableControls = try reader["AutoEnableControls"].readIfPresent()
        value.controlFindingGenerator = try reader["ControlFindingGenerator"].readIfPresent()
        value.hubArn = try reader["HubArn"].readIfPresent()
        value.subscribedAt = try reader["SubscribedAt"].readIfPresent()
        return value
    }
}

extension DescribeOrganizationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationConfigurationOutput()
        value.autoEnable = try reader["AutoEnable"].readIfPresent()
        value.autoEnableStandards = try reader["AutoEnableStandards"].readIfPresent()
        value.memberAccountLimitReached = try reader["MemberAccountLimitReached"].readIfPresent()
        value.organizationConfiguration = try reader["OrganizationConfiguration"].readIfPresent(with: SecurityHubClientTypes.OrganizationConfiguration.read(from:))
        return value
    }
}

extension DescribeProductsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProductsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProductsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.products = try reader["Products"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Product.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeStandardsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStandardsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStandardsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.standards = try reader["Standards"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Standard.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeStandardsControlsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStandardsControlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStandardsControlsOutput()
        value.controls = try reader["Controls"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StandardsControl.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DisableImportFindingsForProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableImportFindingsForProductOutput {
        return DisableImportFindingsForProductOutput()
    }
}

extension DisableOrganizationAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableOrganizationAdminAccountOutput {
        return DisableOrganizationAdminAccountOutput()
    }
}

extension DisableSecurityHubOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableSecurityHubOutput {
        return DisableSecurityHubOutput()
    }
}

extension DisassociateFromAdministratorAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateFromAdministratorAccountOutput {
        return DisassociateFromAdministratorAccountOutput()
    }
}

extension DisassociateFromMasterAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateFromMasterAccountOutput {
        return DisassociateFromMasterAccountOutput()
    }
}

extension DisassociateMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMembersOutput {
        return DisassociateMembersOutput()
    }
}

extension EnableImportFindingsForProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableImportFindingsForProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableImportFindingsForProductOutput()
        value.productSubscriptionArn = try reader["ProductSubscriptionArn"].readIfPresent()
        return value
    }
}

extension EnableOrganizationAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableOrganizationAdminAccountOutput {
        return EnableOrganizationAdminAccountOutput()
    }
}

extension EnableSecurityHubOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableSecurityHubOutput {
        return EnableSecurityHubOutput()
    }
}

extension GetAdministratorAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAdministratorAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAdministratorAccountOutput()
        value.administrator = try reader["Administrator"].readIfPresent(with: SecurityHubClientTypes.Invitation.read(from:))
        return value
    }
}

extension GetConfigurationPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConfigurationPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConfigurationPolicyOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.configurationPolicy = try reader["ConfigurationPolicy"].readIfPresent(with: SecurityHubClientTypes.Policy.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetConfigurationPolicyAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConfigurationPolicyAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConfigurationPolicyAssociationOutput()
        value.associationStatus = try reader["AssociationStatus"].readIfPresent()
        value.associationStatusMessage = try reader["AssociationStatusMessage"].readIfPresent()
        value.associationType = try reader["AssociationType"].readIfPresent()
        value.configurationPolicyId = try reader["ConfigurationPolicyId"].readIfPresent()
        value.targetId = try reader["TargetId"].readIfPresent()
        value.targetType = try reader["TargetType"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetEnabledStandardsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnabledStandardsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnabledStandardsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.standardsSubscriptions = try reader["StandardsSubscriptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StandardsSubscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetFindingAggregatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFindingAggregatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFindingAggregatorOutput()
        value.findingAggregationRegion = try reader["FindingAggregationRegion"].readIfPresent()
        value.findingAggregatorArn = try reader["FindingAggregatorArn"].readIfPresent()
        value.regionLinkingMode = try reader["RegionLinkingMode"].readIfPresent()
        value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetFindingHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFindingHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFindingHistoryOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.records = try reader["Records"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.FindingHistoryRecord.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFindingsOutput()
        value.findings = try reader["Findings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsSecurityFinding.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetInsightResultsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInsightResultsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInsightResultsOutput()
        value.insightResults = try reader["InsightResults"].readIfPresent(with: SecurityHubClientTypes.InsightResults.read(from:))
        return value
    }
}

extension GetInsightsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInsightsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInsightsOutput()
        value.insights = try reader["Insights"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Insight.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension GetInvitationsCountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInvitationsCountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInvitationsCountOutput()
        value.invitationsCount = try reader["InvitationsCount"].readIfPresent()
        return value
    }
}

extension GetMasterAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMasterAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMasterAccountOutput()
        value.master = try reader["Master"].readIfPresent(with: SecurityHubClientTypes.Invitation.read(from:))
        return value
    }
}

extension GetMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMembersOutput()
        value.members = try reader["Members"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Member.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unprocessedAccounts = try reader["UnprocessedAccounts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Result.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSecurityControlDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSecurityControlDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSecurityControlDefinitionOutput()
        value.securityControlDefinition = try reader["SecurityControlDefinition"].readIfPresent(with: SecurityHubClientTypes.SecurityControlDefinition.read(from:))
        return value
    }
}

extension InviteMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InviteMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InviteMembersOutput()
        value.unprocessedAccounts = try reader["UnprocessedAccounts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Result.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAutomationRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutomationRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutomationRulesOutput()
        value.automationRulesMetadata = try reader["AutomationRulesMetadata"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AutomationRulesMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConfigurationPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfigurationPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfigurationPoliciesOutput()
        value.configurationPolicySummaries = try reader["ConfigurationPolicySummaries"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.ConfigurationPolicySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConfigurationPolicyAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfigurationPolicyAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfigurationPolicyAssociationsOutput()
        value.configurationPolicyAssociationSummaries = try reader["ConfigurationPolicyAssociationSummaries"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.ConfigurationPolicyAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEnabledProductsForImportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnabledProductsForImportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnabledProductsForImportOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.productSubscriptions = try reader["ProductSubscriptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListFindingAggregatorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFindingAggregatorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFindingAggregatorsOutput()
        value.findingAggregators = try reader["FindingAggregators"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.FindingAggregator.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInvitationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInvitationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInvitationsOutput()
        value.invitations = try reader["Invitations"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Invitation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMembersOutput()
        value.members = try reader["Members"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Member.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOrganizationAdminAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOrganizationAdminAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrganizationAdminAccountsOutput()
        value.adminAccounts = try reader["AdminAccounts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AdminAccount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSecurityControlDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSecurityControlDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSecurityControlDefinitionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.securityControlDefinitions = try reader["SecurityControlDefinitions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.SecurityControlDefinition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStandardsControlAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStandardsControlAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStandardsControlAssociationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.standardsControlAssociationSummaries = try reader["StandardsControlAssociationSummaries"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StandardsControlAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartConfigurationPolicyAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartConfigurationPolicyAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartConfigurationPolicyAssociationOutput()
        value.associationStatus = try reader["AssociationStatus"].readIfPresent()
        value.associationStatusMessage = try reader["AssociationStatusMessage"].readIfPresent()
        value.associationType = try reader["AssociationType"].readIfPresent()
        value.configurationPolicyId = try reader["ConfigurationPolicyId"].readIfPresent()
        value.targetId = try reader["TargetId"].readIfPresent()
        value.targetType = try reader["TargetType"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension StartConfigurationPolicyDisassociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartConfigurationPolicyDisassociationOutput {
        return StartConfigurationPolicyDisassociationOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateActionTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateActionTargetOutput {
        return UpdateActionTargetOutput()
    }
}

extension UpdateConfigurationPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConfigurationPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConfigurationPolicyOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.configurationPolicy = try reader["ConfigurationPolicy"].readIfPresent(with: SecurityHubClientTypes.Policy.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension UpdateFindingAggregatorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFindingAggregatorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFindingAggregatorOutput()
        value.findingAggregationRegion = try reader["FindingAggregationRegion"].readIfPresent()
        value.findingAggregatorArn = try reader["FindingAggregatorArn"].readIfPresent()
        value.regionLinkingMode = try reader["RegionLinkingMode"].readIfPresent()
        value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFindingsOutput {
        return UpdateFindingsOutput()
    }
}

extension UpdateInsightOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInsightOutput {
        return UpdateInsightOutput()
    }
}

extension UpdateOrganizationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOrganizationConfigurationOutput {
        return UpdateOrganizationConfigurationOutput()
    }
}

extension UpdateSecurityControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSecurityControlOutput {
        return UpdateSecurityControlOutput()
    }
}

extension UpdateSecurityHubConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSecurityHubConfigurationOutput {
        return UpdateSecurityHubConfigurationOutput()
    }
}

extension UpdateStandardsControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStandardsControlOutput {
        return UpdateStandardsControlOutput()
    }
}

enum AcceptAdministratorInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AcceptInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteAutomationRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisableStandardsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchEnableStandardsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetAutomationRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetConfigurationPolicyAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetSecurityControlsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetStandardsControlAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchImportFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateAutomationRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateStandardsControlAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateActionTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAutomationRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConfigurationPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFindingAggregatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInsightOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeclineInvitationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteActionTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfigurationPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFindingAggregatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInsightOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInvitationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeActionTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeHubOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProductsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStandardsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStandardsControlsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableImportFindingsForProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableOrganizationAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableSecurityHubOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateFromAdministratorAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateFromMasterAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableImportFindingsForProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableOrganizationAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableSecurityHubOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAdministratorAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConfigurationPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConfigurationPolicyAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnabledStandardsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFindingAggregatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFindingHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInsightResultsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInsightsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInvitationsCountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMasterAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSecurityControlDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InviteMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutomationRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfigurationPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfigurationPolicyAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnabledProductsForImportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFindingAggregatorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInvitationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOrganizationAdminAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSecurityControlDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStandardsControlAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartConfigurationPolicyAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartConfigurationPolicyDisassociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateActionTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConfigurationPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFindingAggregatorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInsightOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOrganizationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSecurityControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSecurityHubConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStandardsControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalException": return try InternalException.makeError(baseError: baseError)
            case "InvalidAccessException": return try InvalidAccessException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalException {
        let reader = baseError.errorBodyReader
        var value = InternalException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAccessException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidAccessException {
        let reader = baseError.errorBodyReader
        var value = InvalidAccessException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceConflictException {
        let reader = baseError.errorBodyReader
        var value = ResourceConflictException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SecurityHubClientTypes.UnprocessedAutomationRule {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.UnprocessedAutomationRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.UnprocessedAutomationRule()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StandardsSubscription {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StandardsSubscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StandardsSubscription()
        value.standardsSubscriptionArn = try reader["StandardsSubscriptionArn"].readIfPresent() ?? ""
        value.standardsArn = try reader["StandardsArn"].readIfPresent() ?? ""
        value.standardsInput = try reader["StandardsInput"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.standardsStatus = try reader["StandardsStatus"].readIfPresent() ?? .sdkUnknown("")
        value.standardsStatusReason = try reader["StandardsStatusReason"].readIfPresent(with: SecurityHubClientTypes.StandardsStatusReason.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.StandardsStatusReason {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StandardsStatusReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StandardsStatusReason()
        value.statusReasonCode = try reader["StatusReasonCode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SecurityHubClientTypes.AutomationRulesConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AutomationRulesConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AutomationRulesConfig()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.ruleStatus = try reader["RuleStatus"].readIfPresent()
        value.ruleOrder = try reader["RuleOrder"].readIfPresent()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.isTerminal = try reader["IsTerminal"].readIfPresent()
        value.criteria = try reader["Criteria"].readIfPresent(with: SecurityHubClientTypes.AutomationRulesFindingFilters.read(from:))
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AutomationRulesAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AutomationRulesAction {

    static func write(value: SecurityHubClientTypes.AutomationRulesAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FindingFieldsUpdate"].write(value.findingFieldsUpdate, with: SecurityHubClientTypes.AutomationRulesFindingFieldsUpdate.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AutomationRulesAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AutomationRulesAction()
        value.type = try reader["Type"].readIfPresent()
        value.findingFieldsUpdate = try reader["FindingFieldsUpdate"].readIfPresent(with: SecurityHubClientTypes.AutomationRulesFindingFieldsUpdate.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AutomationRulesFindingFieldsUpdate {

    static func write(value: SecurityHubClientTypes.AutomationRulesFindingFieldsUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Confidence"].write(value.confidence)
        try writer["Criticality"].write(value.criticality)
        try writer["Note"].write(value.note, with: SecurityHubClientTypes.NoteUpdate.write(value:to:))
        try writer["RelatedFindings"].writeList(value.relatedFindings, memberWritingClosure: SecurityHubClientTypes.RelatedFinding.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Severity"].write(value.severity, with: SecurityHubClientTypes.SeverityUpdate.write(value:to:))
        try writer["Types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserDefinedFields"].writeMap(value.userDefinedFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VerificationState"].write(value.verificationState)
        try writer["Workflow"].write(value.workflow, with: SecurityHubClientTypes.WorkflowUpdate.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AutomationRulesFindingFieldsUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AutomationRulesFindingFieldsUpdate()
        value.note = try reader["Note"].readIfPresent(with: SecurityHubClientTypes.NoteUpdate.read(from:))
        value.severity = try reader["Severity"].readIfPresent(with: SecurityHubClientTypes.SeverityUpdate.read(from:))
        value.verificationState = try reader["VerificationState"].readIfPresent()
        value.confidence = try reader["Confidence"].readIfPresent()
        value.criticality = try reader["Criticality"].readIfPresent()
        value.types = try reader["Types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.userDefinedFields = try reader["UserDefinedFields"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.workflow = try reader["Workflow"].readIfPresent(with: SecurityHubClientTypes.WorkflowUpdate.read(from:))
        value.relatedFindings = try reader["RelatedFindings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RelatedFinding.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.RelatedFinding {

    static func write(value: SecurityHubClientTypes.RelatedFinding?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["ProductArn"].write(value.productArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RelatedFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RelatedFinding()
        value.productArn = try reader["ProductArn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityHubClientTypes.WorkflowUpdate {

    static func write(value: SecurityHubClientTypes.WorkflowUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.WorkflowUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.WorkflowUpdate()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.SeverityUpdate {

    static func write(value: SecurityHubClientTypes.SeverityUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Label"].write(value.label)
        try writer["Normalized"].write(value.normalized)
        try writer["Product"].write(value.product)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SeverityUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SeverityUpdate()
        value.normalized = try reader["Normalized"].readIfPresent()
        value.product = try reader["Product"].readIfPresent()
        value.label = try reader["Label"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.NoteUpdate {

    static func write(value: SecurityHubClientTypes.NoteUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Text"].write(value.text)
        try writer["UpdatedBy"].write(value.updatedBy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.NoteUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.NoteUpdate()
        value.text = try reader["Text"].readIfPresent() ?? ""
        value.updatedBy = try reader["UpdatedBy"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityHubClientTypes.AutomationRulesFindingFilters {

    static func write(value: SecurityHubClientTypes.AutomationRulesFindingFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsAccountId"].writeList(value.awsAccountId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AwsAccountName"].writeList(value.awsAccountName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CompanyName"].writeList(value.companyName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceAssociatedStandardsId"].writeList(value.complianceAssociatedStandardsId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceSecurityControlId"].writeList(value.complianceSecurityControlId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceStatus"].writeList(value.complianceStatus, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Confidence"].writeList(value.confidence, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreatedAt"].writeList(value.createdAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Criticality"].writeList(value.criticality, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].writeList(value.description, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FirstObservedAt"].writeList(value.firstObservedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GeneratorId"].writeList(value.generatorId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Id"].writeList(value.id, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LastObservedAt"].writeList(value.lastObservedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NoteText"].writeList(value.noteText, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NoteUpdatedAt"].writeList(value.noteUpdatedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NoteUpdatedBy"].writeList(value.noteUpdatedBy, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProductArn"].writeList(value.productArn, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProductName"].writeList(value.productName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecordState"].writeList(value.recordState, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RelatedFindingsId"].writeList(value.relatedFindingsId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RelatedFindingsProductArn"].writeList(value.relatedFindingsProductArn, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceApplicationArn"].writeList(value.resourceApplicationArn, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceApplicationName"].writeList(value.resourceApplicationName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceDetailsOther"].writeList(value.resourceDetailsOther, memberWritingClosure: SecurityHubClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceId"].writeList(value.resourceId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourcePartition"].writeList(value.resourcePartition, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceRegion"].writeList(value.resourceRegion, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: SecurityHubClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].writeList(value.resourceType, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SeverityLabel"].writeList(value.severityLabel, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceUrl"].writeList(value.sourceUrl, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Title"].writeList(value.title, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].writeList(value.type, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UpdatedAt"].writeList(value.updatedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserDefinedFields"].writeList(value.userDefinedFields, memberWritingClosure: SecurityHubClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VerificationState"].writeList(value.verificationState, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkflowStatus"].writeList(value.workflowStatus, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AutomationRulesFindingFilters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AutomationRulesFindingFilters()
        value.productArn = try reader["ProductArn"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsAccountId = try reader["AwsAccountId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.generatorId = try reader["GeneratorId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.firstObservedAt = try reader["FirstObservedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastObservedAt = try reader["LastObservedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.confidence = try reader["Confidence"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.criticality = try reader["Criticality"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.title = try reader["Title"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["Description"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceUrl = try reader["SourceUrl"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.productName = try reader["ProductName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.companyName = try reader["CompanyName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.severityLabel = try reader["SeverityLabel"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceId = try reader["ResourceId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourcePartition = try reader["ResourcePartition"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceRegion = try reader["ResourceRegion"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.MapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceDetailsOther = try reader["ResourceDetailsOther"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.MapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.complianceStatus = try reader["ComplianceStatus"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.complianceSecurityControlId = try reader["ComplianceSecurityControlId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.complianceAssociatedStandardsId = try reader["ComplianceAssociatedStandardsId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.verificationState = try reader["VerificationState"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workflowStatus = try reader["WorkflowStatus"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recordState = try reader["RecordState"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedFindingsProductArn = try reader["RelatedFindingsProductArn"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedFindingsId = try reader["RelatedFindingsId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.noteText = try reader["NoteText"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.noteUpdatedAt = try reader["NoteUpdatedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.noteUpdatedBy = try reader["NoteUpdatedBy"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.userDefinedFields = try reader["UserDefinedFields"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.MapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceApplicationArn = try reader["ResourceApplicationArn"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceApplicationName = try reader["ResourceApplicationName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsAccountName = try reader["AwsAccountName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.StringFilter {

    static func write(value: SecurityHubClientTypes.StringFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Comparison"].write(value.comparison)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StringFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StringFilter()
        value.value = try reader["Value"].readIfPresent()
        value.comparison = try reader["Comparison"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.MapFilter {

    static func write(value: SecurityHubClientTypes.MapFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Comparison"].write(value.comparison)
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.MapFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.MapFilter()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.comparison = try reader["Comparison"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.DateFilter {

    static func write(value: SecurityHubClientTypes.DateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: SecurityHubClientTypes.DateRange.write(value:to:))
        try writer["End"].write(value.end)
        try writer["Start"].write(value.start)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.DateFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.DateFilter()
        value.start = try reader["Start"].readIfPresent()
        value.end = try reader["End"].readIfPresent()
        value.dateRange = try reader["DateRange"].readIfPresent(with: SecurityHubClientTypes.DateRange.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.DateRange {

    static func write(value: SecurityHubClientTypes.DateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Unit"].write(value.unit)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.DateRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.DateRange()
        value.value = try reader["Value"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.NumberFilter {

    static func write(value: SecurityHubClientTypes.NumberFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Eq"].write(value.eq)
        try writer["Gt"].write(value.gt)
        try writer["Gte"].write(value.gte)
        try writer["Lt"].write(value.lt)
        try writer["Lte"].write(value.lte)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.NumberFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.NumberFilter()
        value.gte = try reader["Gte"].readIfPresent()
        value.lte = try reader["Lte"].readIfPresent()
        value.eq = try reader["Eq"].readIfPresent()
        value.gt = try reader["Gt"].readIfPresent()
        value.lt = try reader["Lt"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ConfigurationPolicyAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ConfigurationPolicyAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ConfigurationPolicyAssociationSummary()
        value.configurationPolicyId = try reader["ConfigurationPolicyId"].readIfPresent()
        value.targetId = try reader["TargetId"].readIfPresent()
        value.targetType = try reader["TargetType"].readIfPresent()
        value.associationType = try reader["AssociationType"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.associationStatus = try reader["AssociationStatus"].readIfPresent()
        value.associationStatusMessage = try reader["AssociationStatusMessage"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.UnprocessedConfigurationPolicyAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.UnprocessedConfigurationPolicyAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.UnprocessedConfigurationPolicyAssociation()
        value.configurationPolicyAssociationIdentifiers = try reader["ConfigurationPolicyAssociationIdentifiers"].readIfPresent(with: SecurityHubClientTypes.ConfigurationPolicyAssociation.read(from:))
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorReason = try reader["ErrorReason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ConfigurationPolicyAssociation {

    static func write(value: SecurityHubClientTypes.ConfigurationPolicyAssociation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Target"].write(value.target, with: SecurityHubClientTypes.Target.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ConfigurationPolicyAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ConfigurationPolicyAssociation()
        value.target = try reader["Target"].readIfPresent(with: SecurityHubClientTypes.Target.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.Target {

    static func write(value: SecurityHubClientTypes.Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .accountid(accountid):
                try writer["AccountId"].write(accountid)
            case let .organizationalunitid(organizationalunitid):
                try writer["OrganizationalUnitId"].write(organizationalunitid)
            case let .rootid(rootid):
                try writer["RootId"].write(rootid)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Target {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "AccountId":
                return .accountid(try reader["AccountId"].read())
            case "OrganizationalUnitId":
                return .organizationalunitid(try reader["OrganizationalUnitId"].read())
            case "RootId":
                return .rootid(try reader["RootId"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SecurityHubClientTypes.SecurityControl {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SecurityControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SecurityControl()
        value.securityControlId = try reader["SecurityControlId"].readIfPresent() ?? ""
        value.securityControlArn = try reader["SecurityControlArn"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.remediationUrl = try reader["RemediationUrl"].readIfPresent() ?? ""
        value.severityRating = try reader["SeverityRating"].readIfPresent() ?? .sdkUnknown("")
        value.securityControlStatus = try reader["SecurityControlStatus"].readIfPresent() ?? .sdkUnknown("")
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SecurityHubClientTypes.ParameterConfiguration.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdateReason = try reader["LastUpdateReason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ParameterConfiguration {

    static func write(value: SecurityHubClientTypes.ParameterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value, with: SecurityHubClientTypes.ParameterValue.write(value:to:))
        try writer["ValueType"].write(value.valueType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ParameterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ParameterConfiguration()
        value.valueType = try reader["ValueType"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent(with: SecurityHubClientTypes.ParameterValue.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.ParameterValue {

    static func write(value: SecurityHubClientTypes.ParameterValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .boolean(boolean):
                try writer["Boolean"].write(boolean)
            case let .double(double):
                try writer["Double"].write(double)
            case let .`enum`(`enum`):
                try writer["Enum"].write(`enum`)
            case let .enumlist(enumlist):
                try writer["EnumList"].writeList(enumlist, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .integer(integer):
                try writer["Integer"].write(integer)
            case let .integerlist(integerlist):
                try writer["IntegerList"].writeList(integerlist, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .string(string):
                try writer["String"].write(string)
            case let .stringlist(stringlist):
                try writer["StringList"].writeList(stringlist, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ParameterValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Integer":
                return .integer(try reader["Integer"].read())
            case "IntegerList":
                return .integerlist(try reader["IntegerList"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false))
            case "Double":
                return .double(try reader["Double"].read())
            case "String":
                return .string(try reader["String"].read())
            case "StringList":
                return .stringlist(try reader["StringList"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            case "Boolean":
                return .boolean(try reader["Boolean"].read())
            case "Enum":
                return .`enum`(try reader["Enum"].read())
            case "EnumList":
                return .enumlist(try reader["EnumList"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SecurityHubClientTypes.UnprocessedSecurityControl {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.UnprocessedSecurityControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.UnprocessedSecurityControl()
        value.securityControlId = try reader["SecurityControlId"].readIfPresent() ?? ""
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorReason = try reader["ErrorReason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StandardsControlAssociationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StandardsControlAssociationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StandardsControlAssociationDetail()
        value.standardsArn = try reader["StandardsArn"].readIfPresent() ?? ""
        value.securityControlId = try reader["SecurityControlId"].readIfPresent() ?? ""
        value.securityControlArn = try reader["SecurityControlArn"].readIfPresent() ?? ""
        value.associationStatus = try reader["AssociationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.relatedRequirements = try reader["RelatedRequirements"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedReason = try reader["UpdatedReason"].readIfPresent()
        value.standardsControlTitle = try reader["StandardsControlTitle"].readIfPresent()
        value.standardsControlDescription = try reader["StandardsControlDescription"].readIfPresent()
        value.standardsControlArns = try reader["StandardsControlArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.UnprocessedStandardsControlAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.UnprocessedStandardsControlAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.UnprocessedStandardsControlAssociation()
        value.standardsControlAssociationId = try reader["StandardsControlAssociationId"].readIfPresent(with: SecurityHubClientTypes.StandardsControlAssociationId.read(from:))
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorReason = try reader["ErrorReason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StandardsControlAssociationId {

    static func write(value: SecurityHubClientTypes.StandardsControlAssociationId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityControlId"].write(value.securityControlId)
        try writer["StandardsArn"].write(value.standardsArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StandardsControlAssociationId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StandardsControlAssociationId()
        value.securityControlId = try reader["SecurityControlId"].readIfPresent() ?? ""
        value.standardsArn = try reader["StandardsArn"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityHubClientTypes.ImportFindingsError {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ImportFindingsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ImportFindingsError()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.errorMessage = try reader["ErrorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityHubClientTypes.AwsSecurityFindingIdentifier {

    static func write(value: SecurityHubClientTypes.AwsSecurityFindingIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["ProductArn"].write(value.productArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSecurityFindingIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSecurityFindingIdentifier()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.productArn = try reader["ProductArn"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding()
        value.findingIdentifier = try reader["FindingIdentifier"].readIfPresent(with: SecurityHubClientTypes.AwsSecurityFindingIdentifier.read(from:))
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.errorMessage = try reader["ErrorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityHubClientTypes.UnprocessedStandardsControlAssociationUpdate {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.UnprocessedStandardsControlAssociationUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.UnprocessedStandardsControlAssociationUpdate()
        value.standardsControlAssociationUpdate = try reader["StandardsControlAssociationUpdate"].readIfPresent(with: SecurityHubClientTypes.StandardsControlAssociationUpdate.read(from:))
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorReason = try reader["ErrorReason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StandardsControlAssociationUpdate {

    static func write(value: SecurityHubClientTypes.StandardsControlAssociationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationStatus"].write(value.associationStatus)
        try writer["SecurityControlId"].write(value.securityControlId)
        try writer["StandardsArn"].write(value.standardsArn)
        try writer["UpdatedReason"].write(value.updatedReason)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StandardsControlAssociationUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StandardsControlAssociationUpdate()
        value.standardsArn = try reader["StandardsArn"].readIfPresent() ?? ""
        value.securityControlId = try reader["SecurityControlId"].readIfPresent() ?? ""
        value.associationStatus = try reader["AssociationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.updatedReason = try reader["UpdatedReason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Policy {

    static func write(value: SecurityHubClientTypes.Policy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .securityhub(securityhub):
                try writer["SecurityHub"].write(securityhub, with: SecurityHubClientTypes.SecurityHubPolicy.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Policy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "SecurityHub":
                return .securityhub(try reader["SecurityHub"].read(with: SecurityHubClientTypes.SecurityHubPolicy.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SecurityHubClientTypes.SecurityHubPolicy {

    static func write(value: SecurityHubClientTypes.SecurityHubPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnabledStandardIdentifiers"].writeList(value.enabledStandardIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityControlsConfiguration"].write(value.securityControlsConfiguration, with: SecurityHubClientTypes.SecurityControlsConfiguration.write(value:to:))
        try writer["ServiceEnabled"].write(value.serviceEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SecurityHubPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SecurityHubPolicy()
        value.serviceEnabled = try reader["ServiceEnabled"].readIfPresent()
        value.enabledStandardIdentifiers = try reader["EnabledStandardIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityControlsConfiguration = try reader["SecurityControlsConfiguration"].readIfPresent(with: SecurityHubClientTypes.SecurityControlsConfiguration.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.SecurityControlsConfiguration {

    static func write(value: SecurityHubClientTypes.SecurityControlsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisabledSecurityControlIdentifiers"].writeList(value.disabledSecurityControlIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnabledSecurityControlIdentifiers"].writeList(value.enabledSecurityControlIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityControlCustomParameters"].writeList(value.securityControlCustomParameters, memberWritingClosure: SecurityHubClientTypes.SecurityControlCustomParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SecurityControlsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SecurityControlsConfiguration()
        value.enabledSecurityControlIdentifiers = try reader["EnabledSecurityControlIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.disabledSecurityControlIdentifiers = try reader["DisabledSecurityControlIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityControlCustomParameters = try reader["SecurityControlCustomParameters"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.SecurityControlCustomParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.SecurityControlCustomParameter {

    static func write(value: SecurityHubClientTypes.SecurityControlCustomParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SecurityHubClientTypes.ParameterConfiguration.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SecurityControlId"].write(value.securityControlId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SecurityControlCustomParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SecurityControlCustomParameter()
        value.securityControlId = try reader["SecurityControlId"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SecurityHubClientTypes.ParameterConfiguration.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.Result {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Result {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Result()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.processingResult = try reader["ProcessingResult"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ActionTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ActionTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ActionTarget()
        value.actionTargetArn = try reader["ActionTargetArn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityHubClientTypes.OrganizationConfiguration {

    static func write(value: SecurityHubClientTypes.OrganizationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationType"].write(value.configurationType)
        try writer["Status"].write(value.status)
        try writer["StatusMessage"].write(value.statusMessage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.OrganizationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.OrganizationConfiguration()
        value.configurationType = try reader["ConfigurationType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Product {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Product {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Product()
        value.productArn = try reader["ProductArn"].readIfPresent() ?? ""
        value.productName = try reader["ProductName"].readIfPresent()
        value.companyName = try reader["CompanyName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.integrationTypes = try reader["IntegrationTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SecurityHubClientTypes.IntegrationType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marketplaceUrl = try reader["MarketplaceUrl"].readIfPresent()
        value.activationUrl = try reader["ActivationUrl"].readIfPresent()
        value.productSubscriptionResourcePolicy = try reader["ProductSubscriptionResourcePolicy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Standard {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Standard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Standard()
        value.standardsArn = try reader["StandardsArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.enabledByDefault = try reader["EnabledByDefault"].readIfPresent()
        value.standardsManagedBy = try reader["StandardsManagedBy"].readIfPresent(with: SecurityHubClientTypes.StandardsManagedBy.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.StandardsManagedBy {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StandardsManagedBy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StandardsManagedBy()
        value.company = try reader["Company"].readIfPresent()
        value.product = try reader["Product"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StandardsControl {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StandardsControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StandardsControl()
        value.standardsControlArn = try reader["StandardsControlArn"].readIfPresent()
        value.controlStatus = try reader["ControlStatus"].readIfPresent()
        value.disabledReason = try reader["DisabledReason"].readIfPresent()
        value.controlStatusUpdatedAt = try reader["ControlStatusUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.controlId = try reader["ControlId"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.remediationUrl = try reader["RemediationUrl"].readIfPresent()
        value.severityRating = try reader["SeverityRating"].readIfPresent()
        value.relatedRequirements = try reader["RelatedRequirements"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.Invitation {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Invitation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Invitation()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.invitationId = try reader["InvitationId"].readIfPresent()
        value.invitedAt = try reader["InvitedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.memberStatus = try reader["MemberStatus"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.FindingHistoryRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FindingHistoryRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FindingHistoryRecord()
        value.findingIdentifier = try reader["FindingIdentifier"].readIfPresent(with: SecurityHubClientTypes.AwsSecurityFindingIdentifier.read(from:))
        value.updateTime = try reader["UpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.findingCreated = try reader["FindingCreated"].readIfPresent()
        value.updateSource = try reader["UpdateSource"].readIfPresent(with: SecurityHubClientTypes.FindingHistoryUpdateSource.read(from:))
        value.updates = try reader["Updates"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.FindingHistoryUpdate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.FindingHistoryUpdate {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FindingHistoryUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FindingHistoryUpdate()
        value.updatedField = try reader["UpdatedField"].readIfPresent()
        value.oldValue = try reader["OldValue"].readIfPresent()
        value.newValue = try reader["NewValue"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.FindingHistoryUpdateSource {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FindingHistoryUpdateSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FindingHistoryUpdateSource()
        value.type = try reader["Type"].readIfPresent()
        value.identity = try reader["Identity"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsSecurityFinding {

    static func write(value: SecurityHubClientTypes.AwsSecurityFinding?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: SecurityHubClientTypes.Action.write(value:to:))
        try writer["AwsAccountId"].write(value.awsAccountId)
        try writer["AwsAccountName"].write(value.awsAccountName)
        try writer["CompanyName"].write(value.companyName)
        try writer["Compliance"].write(value.compliance, with: SecurityHubClientTypes.Compliance.write(value:to:))
        try writer["Confidence"].write(value.confidence)
        try writer["CreatedAt"].write(value.createdAt)
        try writer["Criticality"].write(value.criticality)
        try writer["Description"].write(value.description)
        try writer["FindingProviderFields"].write(value.findingProviderFields, with: SecurityHubClientTypes.FindingProviderFields.write(value:to:))
        try writer["FirstObservedAt"].write(value.firstObservedAt)
        try writer["GeneratorDetails"].write(value.generatorDetails, with: SecurityHubClientTypes.GeneratorDetails.write(value:to:))
        try writer["GeneratorId"].write(value.generatorId)
        try writer["Id"].write(value.id)
        try writer["LastObservedAt"].write(value.lastObservedAt)
        try writer["Malware"].writeList(value.malware, memberWritingClosure: SecurityHubClientTypes.Malware.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Network"].write(value.network, with: SecurityHubClientTypes.Network.write(value:to:))
        try writer["NetworkPath"].writeList(value.networkPath, memberWritingClosure: SecurityHubClientTypes.NetworkPathComponent.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Note"].write(value.note, with: SecurityHubClientTypes.Note.write(value:to:))
        try writer["PatchSummary"].write(value.patchSummary, with: SecurityHubClientTypes.PatchSummary.write(value:to:))
        try writer["Process"].write(value.process, with: SecurityHubClientTypes.ProcessDetails.write(value:to:))
        try writer["ProcessedAt"].write(value.processedAt)
        try writer["ProductArn"].write(value.productArn)
        try writer["ProductFields"].writeMap(value.productFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ProductName"].write(value.productName)
        try writer["RecordState"].write(value.recordState)
        try writer["Region"].write(value.region)
        try writer["RelatedFindings"].writeList(value.relatedFindings, memberWritingClosure: SecurityHubClientTypes.RelatedFinding.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Remediation"].write(value.remediation, with: SecurityHubClientTypes.Remediation.write(value:to:))
        try writer["Resources"].writeList(value.resources, memberWritingClosure: SecurityHubClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sample"].write(value.sample)
        try writer["SchemaVersion"].write(value.schemaVersion)
        try writer["Severity"].write(value.severity, with: SecurityHubClientTypes.Severity.write(value:to:))
        try writer["SourceUrl"].write(value.sourceUrl)
        try writer["ThreatIntelIndicators"].writeList(value.threatIntelIndicators, memberWritingClosure: SecurityHubClientTypes.ThreatIntelIndicator.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Threats"].writeList(value.threats, memberWritingClosure: SecurityHubClientTypes.Threat.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Title"].write(value.title)
        try writer["Types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UpdatedAt"].write(value.updatedAt)
        try writer["UserDefinedFields"].writeMap(value.userDefinedFields, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["VerificationState"].write(value.verificationState)
        try writer["Vulnerabilities"].writeList(value.vulnerabilities, memberWritingClosure: SecurityHubClientTypes.Vulnerability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Workflow"].write(value.workflow, with: SecurityHubClientTypes.Workflow.write(value:to:))
        try writer["WorkflowState"].write(value.workflowState)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSecurityFinding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSecurityFinding()
        value.schemaVersion = try reader["SchemaVersion"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.productArn = try reader["ProductArn"].readIfPresent() ?? ""
        value.productName = try reader["ProductName"].readIfPresent()
        value.companyName = try reader["CompanyName"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.generatorId = try reader["GeneratorId"].readIfPresent() ?? ""
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent() ?? ""
        value.types = try reader["Types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.firstObservedAt = try reader["FirstObservedAt"].readIfPresent()
        value.lastObservedAt = try reader["LastObservedAt"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent() ?? ""
        value.updatedAt = try reader["UpdatedAt"].readIfPresent() ?? ""
        value.severity = try reader["Severity"].readIfPresent(with: SecurityHubClientTypes.Severity.read(from:))
        value.confidence = try reader["Confidence"].readIfPresent()
        value.criticality = try reader["Criticality"].readIfPresent()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.remediation = try reader["Remediation"].readIfPresent(with: SecurityHubClientTypes.Remediation.read(from:))
        value.sourceUrl = try reader["SourceUrl"].readIfPresent()
        value.productFields = try reader["ProductFields"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.userDefinedFields = try reader["UserDefinedFields"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.malware = try reader["Malware"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Malware.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.network = try reader["Network"].readIfPresent(with: SecurityHubClientTypes.Network.read(from:))
        value.networkPath = try reader["NetworkPath"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NetworkPathComponent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.process = try reader["Process"].readIfPresent(with: SecurityHubClientTypes.ProcessDetails.read(from:))
        value.threats = try reader["Threats"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Threat.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.threatIntelIndicators = try reader["ThreatIntelIndicators"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.ThreatIntelIndicator.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.compliance = try reader["Compliance"].readIfPresent(with: SecurityHubClientTypes.Compliance.read(from:))
        value.verificationState = try reader["VerificationState"].readIfPresent()
        value.workflowState = try reader["WorkflowState"].readIfPresent()
        value.workflow = try reader["Workflow"].readIfPresent(with: SecurityHubClientTypes.Workflow.read(from:))
        value.recordState = try reader["RecordState"].readIfPresent()
        value.relatedFindings = try reader["RelatedFindings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RelatedFinding.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.note = try reader["Note"].readIfPresent(with: SecurityHubClientTypes.Note.read(from:))
        value.vulnerabilities = try reader["Vulnerabilities"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Vulnerability.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.patchSummary = try reader["PatchSummary"].readIfPresent(with: SecurityHubClientTypes.PatchSummary.read(from:))
        value.action = try reader["Action"].readIfPresent(with: SecurityHubClientTypes.Action.read(from:))
        value.findingProviderFields = try reader["FindingProviderFields"].readIfPresent(with: SecurityHubClientTypes.FindingProviderFields.read(from:))
        value.sample = try reader["Sample"].readIfPresent()
        value.generatorDetails = try reader["GeneratorDetails"].readIfPresent(with: SecurityHubClientTypes.GeneratorDetails.read(from:))
        value.processedAt = try reader["ProcessedAt"].readIfPresent()
        value.awsAccountName = try reader["AwsAccountName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.GeneratorDetails {

    static func write(value: SecurityHubClientTypes.GeneratorDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Labels"].writeList(value.labels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.GeneratorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.GeneratorDetails()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.labels = try reader["Labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.FindingProviderFields {

    static func write(value: SecurityHubClientTypes.FindingProviderFields?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Confidence"].write(value.confidence)
        try writer["Criticality"].write(value.criticality)
        try writer["RelatedFindings"].writeList(value.relatedFindings, memberWritingClosure: SecurityHubClientTypes.RelatedFinding.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Severity"].write(value.severity, with: SecurityHubClientTypes.FindingProviderSeverity.write(value:to:))
        try writer["Types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FindingProviderFields {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FindingProviderFields()
        value.confidence = try reader["Confidence"].readIfPresent()
        value.criticality = try reader["Criticality"].readIfPresent()
        value.relatedFindings = try reader["RelatedFindings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RelatedFinding.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.severity = try reader["Severity"].readIfPresent(with: SecurityHubClientTypes.FindingProviderSeverity.read(from:))
        value.types = try reader["Types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.FindingProviderSeverity {

    static func write(value: SecurityHubClientTypes.FindingProviderSeverity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Label"].write(value.label)
        try writer["Original"].write(value.original)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FindingProviderSeverity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FindingProviderSeverity()
        value.label = try reader["Label"].readIfPresent()
        value.original = try reader["Original"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Action {

    static func write(value: SecurityHubClientTypes.Action?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionType"].write(value.actionType)
        try writer["AwsApiCallAction"].write(value.awsApiCallAction, with: SecurityHubClientTypes.AwsApiCallAction.write(value:to:))
        try writer["DnsRequestAction"].write(value.dnsRequestAction, with: SecurityHubClientTypes.DnsRequestAction.write(value:to:))
        try writer["NetworkConnectionAction"].write(value.networkConnectionAction, with: SecurityHubClientTypes.NetworkConnectionAction.write(value:to:))
        try writer["PortProbeAction"].write(value.portProbeAction, with: SecurityHubClientTypes.PortProbeAction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Action()
        value.actionType = try reader["ActionType"].readIfPresent()
        value.networkConnectionAction = try reader["NetworkConnectionAction"].readIfPresent(with: SecurityHubClientTypes.NetworkConnectionAction.read(from:))
        value.awsApiCallAction = try reader["AwsApiCallAction"].readIfPresent(with: SecurityHubClientTypes.AwsApiCallAction.read(from:))
        value.dnsRequestAction = try reader["DnsRequestAction"].readIfPresent(with: SecurityHubClientTypes.DnsRequestAction.read(from:))
        value.portProbeAction = try reader["PortProbeAction"].readIfPresent(with: SecurityHubClientTypes.PortProbeAction.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.PortProbeAction {

    static func write(value: SecurityHubClientTypes.PortProbeAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Blocked"].write(value.blocked)
        try writer["PortProbeDetails"].writeList(value.portProbeDetails, memberWritingClosure: SecurityHubClientTypes.PortProbeDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.PortProbeAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.PortProbeAction()
        value.portProbeDetails = try reader["PortProbeDetails"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.PortProbeDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.blocked = try reader["Blocked"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.PortProbeDetail {

    static func write(value: SecurityHubClientTypes.PortProbeDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LocalIpDetails"].write(value.localIpDetails, with: SecurityHubClientTypes.ActionLocalIpDetails.write(value:to:))
        try writer["LocalPortDetails"].write(value.localPortDetails, with: SecurityHubClientTypes.ActionLocalPortDetails.write(value:to:))
        try writer["RemoteIpDetails"].write(value.remoteIpDetails, with: SecurityHubClientTypes.ActionRemoteIpDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.PortProbeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.PortProbeDetail()
        value.localPortDetails = try reader["LocalPortDetails"].readIfPresent(with: SecurityHubClientTypes.ActionLocalPortDetails.read(from:))
        value.localIpDetails = try reader["LocalIpDetails"].readIfPresent(with: SecurityHubClientTypes.ActionLocalIpDetails.read(from:))
        value.remoteIpDetails = try reader["RemoteIpDetails"].readIfPresent(with: SecurityHubClientTypes.ActionRemoteIpDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.ActionRemoteIpDetails {

    static func write(value: SecurityHubClientTypes.ActionRemoteIpDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["City"].write(value.city, with: SecurityHubClientTypes.City.write(value:to:))
        try writer["Country"].write(value.country, with: SecurityHubClientTypes.Country.write(value:to:))
        try writer["GeoLocation"].write(value.geoLocation, with: SecurityHubClientTypes.GeoLocation.write(value:to:))
        try writer["IpAddressV4"].write(value.ipAddressV4)
        try writer["Organization"].write(value.organization, with: SecurityHubClientTypes.IpOrganizationDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ActionRemoteIpDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ActionRemoteIpDetails()
        value.ipAddressV4 = try reader["IpAddressV4"].readIfPresent()
        value.organization = try reader["Organization"].readIfPresent(with: SecurityHubClientTypes.IpOrganizationDetails.read(from:))
        value.country = try reader["Country"].readIfPresent(with: SecurityHubClientTypes.Country.read(from:))
        value.city = try reader["City"].readIfPresent(with: SecurityHubClientTypes.City.read(from:))
        value.geoLocation = try reader["GeoLocation"].readIfPresent(with: SecurityHubClientTypes.GeoLocation.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.GeoLocation {

    static func write(value: SecurityHubClientTypes.GeoLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Lat"].write(value.lat)
        try writer["Lon"].write(value.lon)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.GeoLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.GeoLocation()
        value.lon = try reader["Lon"].readIfPresent()
        value.lat = try reader["Lat"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.City {

    static func write(value: SecurityHubClientTypes.City?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CityName"].write(value.cityName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.City {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.City()
        value.cityName = try reader["CityName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Country {

    static func write(value: SecurityHubClientTypes.Country?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CountryCode"].write(value.countryCode)
        try writer["CountryName"].write(value.countryName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Country {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Country()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.countryName = try reader["CountryName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.IpOrganizationDetails {

    static func write(value: SecurityHubClientTypes.IpOrganizationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Asn"].write(value.asn)
        try writer["AsnOrg"].write(value.asnOrg)
        try writer["Isp"].write(value.isp)
        try writer["Org"].write(value.org)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.IpOrganizationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.IpOrganizationDetails()
        value.asn = try reader["Asn"].readIfPresent()
        value.asnOrg = try reader["AsnOrg"].readIfPresent()
        value.isp = try reader["Isp"].readIfPresent()
        value.org = try reader["Org"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ActionLocalIpDetails {

    static func write(value: SecurityHubClientTypes.ActionLocalIpDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IpAddressV4"].write(value.ipAddressV4)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ActionLocalIpDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ActionLocalIpDetails()
        value.ipAddressV4 = try reader["IpAddressV4"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ActionLocalPortDetails {

    static func write(value: SecurityHubClientTypes.ActionLocalPortDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Port"].write(value.port)
        try writer["PortName"].write(value.portName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ActionLocalPortDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ActionLocalPortDetails()
        value.port = try reader["Port"].readIfPresent()
        value.portName = try reader["PortName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.DnsRequestAction {

    static func write(value: SecurityHubClientTypes.DnsRequestAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Blocked"].write(value.blocked)
        try writer["Domain"].write(value.domain)
        try writer["Protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.DnsRequestAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.DnsRequestAction()
        value.domain = try reader["Domain"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.blocked = try reader["Blocked"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsApiCallAction {

    static func write(value: SecurityHubClientTypes.AwsApiCallAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AffectedResources"].writeMap(value.affectedResources, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Api"].write(value.api)
        try writer["CallerType"].write(value.callerType)
        try writer["DomainDetails"].write(value.domainDetails, with: SecurityHubClientTypes.AwsApiCallActionDomainDetails.write(value:to:))
        try writer["FirstSeen"].write(value.firstSeen)
        try writer["LastSeen"].write(value.lastSeen)
        try writer["RemoteIpDetails"].write(value.remoteIpDetails, with: SecurityHubClientTypes.ActionRemoteIpDetails.write(value:to:))
        try writer["ServiceName"].write(value.serviceName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiCallAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiCallAction()
        value.api = try reader["Api"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.callerType = try reader["CallerType"].readIfPresent()
        value.remoteIpDetails = try reader["RemoteIpDetails"].readIfPresent(with: SecurityHubClientTypes.ActionRemoteIpDetails.read(from:))
        value.domainDetails = try reader["DomainDetails"].readIfPresent(with: SecurityHubClientTypes.AwsApiCallActionDomainDetails.read(from:))
        value.affectedResources = try reader["AffectedResources"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.firstSeen = try reader["FirstSeen"].readIfPresent()
        value.lastSeen = try reader["LastSeen"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsApiCallActionDomainDetails {

    static func write(value: SecurityHubClientTypes.AwsApiCallActionDomainDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiCallActionDomainDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiCallActionDomainDetails()
        value.domain = try reader["Domain"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.NetworkConnectionAction {

    static func write(value: SecurityHubClientTypes.NetworkConnectionAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Blocked"].write(value.blocked)
        try writer["ConnectionDirection"].write(value.connectionDirection)
        try writer["LocalPortDetails"].write(value.localPortDetails, with: SecurityHubClientTypes.ActionLocalPortDetails.write(value:to:))
        try writer["Protocol"].write(value.`protocol`)
        try writer["RemoteIpDetails"].write(value.remoteIpDetails, with: SecurityHubClientTypes.ActionRemoteIpDetails.write(value:to:))
        try writer["RemotePortDetails"].write(value.remotePortDetails, with: SecurityHubClientTypes.ActionRemotePortDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.NetworkConnectionAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.NetworkConnectionAction()
        value.connectionDirection = try reader["ConnectionDirection"].readIfPresent()
        value.remoteIpDetails = try reader["RemoteIpDetails"].readIfPresent(with: SecurityHubClientTypes.ActionRemoteIpDetails.read(from:))
        value.remotePortDetails = try reader["RemotePortDetails"].readIfPresent(with: SecurityHubClientTypes.ActionRemotePortDetails.read(from:))
        value.localPortDetails = try reader["LocalPortDetails"].readIfPresent(with: SecurityHubClientTypes.ActionLocalPortDetails.read(from:))
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.blocked = try reader["Blocked"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ActionRemotePortDetails {

    static func write(value: SecurityHubClientTypes.ActionRemotePortDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Port"].write(value.port)
        try writer["PortName"].write(value.portName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ActionRemotePortDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ActionRemotePortDetails()
        value.port = try reader["Port"].readIfPresent()
        value.portName = try reader["PortName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.PatchSummary {

    static func write(value: SecurityHubClientTypes.PatchSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailedCount"].write(value.failedCount)
        try writer["Id"].write(value.id)
        try writer["InstalledCount"].write(value.installedCount)
        try writer["InstalledOtherCount"].write(value.installedOtherCount)
        try writer["InstalledPendingReboot"].write(value.installedPendingReboot)
        try writer["InstalledRejectedCount"].write(value.installedRejectedCount)
        try writer["MissingCount"].write(value.missingCount)
        try writer["Operation"].write(value.operation)
        try writer["OperationEndTime"].write(value.operationEndTime)
        try writer["OperationStartTime"].write(value.operationStartTime)
        try writer["RebootOption"].write(value.rebootOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.PatchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.PatchSummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.installedCount = try reader["InstalledCount"].readIfPresent()
        value.missingCount = try reader["MissingCount"].readIfPresent()
        value.failedCount = try reader["FailedCount"].readIfPresent()
        value.installedOtherCount = try reader["InstalledOtherCount"].readIfPresent()
        value.installedRejectedCount = try reader["InstalledRejectedCount"].readIfPresent()
        value.installedPendingReboot = try reader["InstalledPendingReboot"].readIfPresent()
        value.operationStartTime = try reader["OperationStartTime"].readIfPresent()
        value.operationEndTime = try reader["OperationEndTime"].readIfPresent()
        value.rebootOption = try reader["RebootOption"].readIfPresent()
        value.operation = try reader["Operation"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Vulnerability {

    static func write(value: SecurityHubClientTypes.Vulnerability?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeVulnerabilities"].writeList(value.codeVulnerabilities, memberWritingClosure: SecurityHubClientTypes.VulnerabilityCodeVulnerabilities.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Cvss"].writeList(value.cvss, memberWritingClosure: SecurityHubClientTypes.Cvss.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EpssScore"].write(value.epssScore)
        try writer["ExploitAvailable"].write(value.exploitAvailable)
        try writer["FixAvailable"].write(value.fixAvailable)
        try writer["Id"].write(value.id)
        try writer["LastKnownExploitAt"].write(value.lastKnownExploitAt)
        try writer["ReferenceUrls"].writeList(value.referenceUrls, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RelatedVulnerabilities"].writeList(value.relatedVulnerabilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Vendor"].write(value.vendor, with: SecurityHubClientTypes.VulnerabilityVendor.write(value:to:))
        try writer["VulnerablePackages"].writeList(value.vulnerablePackages, memberWritingClosure: SecurityHubClientTypes.SoftwarePackage.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Vulnerability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Vulnerability()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.vulnerablePackages = try reader["VulnerablePackages"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.SoftwarePackage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cvss = try reader["Cvss"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Cvss.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedVulnerabilities = try reader["RelatedVulnerabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vendor = try reader["Vendor"].readIfPresent(with: SecurityHubClientTypes.VulnerabilityVendor.read(from:))
        value.referenceUrls = try reader["ReferenceUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.fixAvailable = try reader["FixAvailable"].readIfPresent()
        value.epssScore = try reader["EpssScore"].readIfPresent()
        value.exploitAvailable = try reader["ExploitAvailable"].readIfPresent()
        value.lastKnownExploitAt = try reader["LastKnownExploitAt"].readIfPresent()
        value.codeVulnerabilities = try reader["CodeVulnerabilities"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.VulnerabilityCodeVulnerabilities.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.VulnerabilityCodeVulnerabilities {

    static func write(value: SecurityHubClientTypes.VulnerabilityCodeVulnerabilities?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cwes"].writeList(value.cwes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FilePath"].write(value.filePath, with: SecurityHubClientTypes.CodeVulnerabilitiesFilePath.write(value:to:))
        try writer["SourceArn"].write(value.sourceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.VulnerabilityCodeVulnerabilities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.VulnerabilityCodeVulnerabilities()
        value.cwes = try reader["Cwes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.filePath = try reader["FilePath"].readIfPresent(with: SecurityHubClientTypes.CodeVulnerabilitiesFilePath.read(from:))
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.CodeVulnerabilitiesFilePath {

    static func write(value: SecurityHubClientTypes.CodeVulnerabilitiesFilePath?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndLine"].write(value.endLine)
        try writer["FileName"].write(value.fileName)
        try writer["FilePath"].write(value.filePath)
        try writer["StartLine"].write(value.startLine)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.CodeVulnerabilitiesFilePath {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.CodeVulnerabilitiesFilePath()
        value.endLine = try reader["EndLine"].readIfPresent()
        value.fileName = try reader["FileName"].readIfPresent()
        value.filePath = try reader["FilePath"].readIfPresent()
        value.startLine = try reader["StartLine"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.VulnerabilityVendor {

    static func write(value: SecurityHubClientTypes.VulnerabilityVendor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Url"].write(value.url)
        try writer["VendorCreatedAt"].write(value.vendorCreatedAt)
        try writer["VendorSeverity"].write(value.vendorSeverity)
        try writer["VendorUpdatedAt"].write(value.vendorUpdatedAt)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.VulnerabilityVendor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.VulnerabilityVendor()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.url = try reader["Url"].readIfPresent()
        value.vendorSeverity = try reader["VendorSeverity"].readIfPresent()
        value.vendorCreatedAt = try reader["VendorCreatedAt"].readIfPresent()
        value.vendorUpdatedAt = try reader["VendorUpdatedAt"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Cvss {

    static func write(value: SecurityHubClientTypes.Cvss?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Adjustments"].writeList(value.adjustments, memberWritingClosure: SecurityHubClientTypes.Adjustment.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BaseScore"].write(value.baseScore)
        try writer["BaseVector"].write(value.baseVector)
        try writer["Source"].write(value.source)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Cvss {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Cvss()
        value.version = try reader["Version"].readIfPresent()
        value.baseScore = try reader["BaseScore"].readIfPresent()
        value.baseVector = try reader["BaseVector"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.adjustments = try reader["Adjustments"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Adjustment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.Adjustment {

    static func write(value: SecurityHubClientTypes.Adjustment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Metric"].write(value.metric)
        try writer["Reason"].write(value.reason)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Adjustment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Adjustment()
        value.metric = try reader["Metric"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.SoftwarePackage {

    static func write(value: SecurityHubClientTypes.SoftwarePackage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Architecture"].write(value.architecture)
        try writer["Epoch"].write(value.epoch)
        try writer["FilePath"].write(value.filePath)
        try writer["FixedInVersion"].write(value.fixedInVersion)
        try writer["Name"].write(value.name)
        try writer["PackageManager"].write(value.packageManager)
        try writer["Release"].write(value.release)
        try writer["Remediation"].write(value.remediation)
        try writer["SourceLayerArn"].write(value.sourceLayerArn)
        try writer["SourceLayerHash"].write(value.sourceLayerHash)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SoftwarePackage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SoftwarePackage()
        value.name = try reader["Name"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.epoch = try reader["Epoch"].readIfPresent()
        value.release = try reader["Release"].readIfPresent()
        value.architecture = try reader["Architecture"].readIfPresent()
        value.packageManager = try reader["PackageManager"].readIfPresent()
        value.filePath = try reader["FilePath"].readIfPresent()
        value.fixedInVersion = try reader["FixedInVersion"].readIfPresent()
        value.remediation = try reader["Remediation"].readIfPresent()
        value.sourceLayerHash = try reader["SourceLayerHash"].readIfPresent()
        value.sourceLayerArn = try reader["SourceLayerArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Note {

    static func write(value: SecurityHubClientTypes.Note?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Text"].write(value.text)
        try writer["UpdatedAt"].write(value.updatedAt)
        try writer["UpdatedBy"].write(value.updatedBy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Note {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Note()
        value.text = try reader["Text"].readIfPresent() ?? ""
        value.updatedBy = try reader["UpdatedBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["UpdatedAt"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityHubClientTypes.Workflow {

    static func write(value: SecurityHubClientTypes.Workflow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Workflow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Workflow()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Compliance {

    static func write(value: SecurityHubClientTypes.Compliance?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociatedStandards"].writeList(value.associatedStandards, memberWritingClosure: SecurityHubClientTypes.AssociatedStandard.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RelatedRequirements"].writeList(value.relatedRequirements, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityControlId"].write(value.securityControlId)
        try writer["SecurityControlParameters"].writeList(value.securityControlParameters, memberWritingClosure: SecurityHubClientTypes.SecurityControlParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Status"].write(value.status)
        try writer["StatusReasons"].writeList(value.statusReasons, memberWritingClosure: SecurityHubClientTypes.StatusReason.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Compliance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Compliance()
        value.status = try reader["Status"].readIfPresent()
        value.relatedRequirements = try reader["RelatedRequirements"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.statusReasons = try reader["StatusReasons"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StatusReason.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityControlId = try reader["SecurityControlId"].readIfPresent()
        value.associatedStandards = try reader["AssociatedStandards"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AssociatedStandard.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityControlParameters = try reader["SecurityControlParameters"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.SecurityControlParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.SecurityControlParameter {

    static func write(value: SecurityHubClientTypes.SecurityControlParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].writeList(value.value, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SecurityControlParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SecurityControlParameter()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AssociatedStandard {

    static func write(value: SecurityHubClientTypes.AssociatedStandard?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StandardsId"].write(value.standardsId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AssociatedStandard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AssociatedStandard()
        value.standardsId = try reader["StandardsId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StatusReason {

    static func write(value: SecurityHubClientTypes.StatusReason?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["ReasonCode"].write(value.reasonCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StatusReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StatusReason()
        value.reasonCode = try reader["ReasonCode"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Resource {

    static func write(value: SecurityHubClientTypes.Resource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["ApplicationName"].write(value.applicationName)
        try writer["DataClassification"].write(value.dataClassification, with: SecurityHubClientTypes.DataClassificationDetails.write(value:to:))
        try writer["Details"].write(value.details, with: SecurityHubClientTypes.ResourceDetails.write(value:to:))
        try writer["Id"].write(value.id)
        try writer["Partition"].write(value.partition)
        try writer["Region"].write(value.region)
        try writer["ResourceRole"].write(value.resourceRole)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Resource()
        value.type = try reader["Type"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.partition = try reader["Partition"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.resourceRole = try reader["ResourceRole"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.dataClassification = try reader["DataClassification"].readIfPresent(with: SecurityHubClientTypes.DataClassificationDetails.read(from:))
        value.details = try reader["Details"].readIfPresent(with: SecurityHubClientTypes.ResourceDetails.read(from:))
        value.applicationName = try reader["ApplicationName"].readIfPresent()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ResourceDetails {

    static func write(value: SecurityHubClientTypes.ResourceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsAmazonMqBroker"].write(value.awsAmazonMqBroker, with: SecurityHubClientTypes.AwsAmazonMqBrokerDetails.write(value:to:))
        try writer["AwsApiGatewayRestApi"].write(value.awsApiGatewayRestApi, with: SecurityHubClientTypes.AwsApiGatewayRestApiDetails.write(value:to:))
        try writer["AwsApiGatewayStage"].write(value.awsApiGatewayStage, with: SecurityHubClientTypes.AwsApiGatewayStageDetails.write(value:to:))
        try writer["AwsApiGatewayV2Api"].write(value.awsApiGatewayV2Api, with: SecurityHubClientTypes.AwsApiGatewayV2ApiDetails.write(value:to:))
        try writer["AwsApiGatewayV2Stage"].write(value.awsApiGatewayV2Stage, with: SecurityHubClientTypes.AwsApiGatewayV2StageDetails.write(value:to:))
        try writer["AwsAppSyncGraphQlApi"].write(value.awsAppSyncGraphQlApi, with: SecurityHubClientTypes.AwsAppSyncGraphQlApiDetails.write(value:to:))
        try writer["AwsAthenaWorkGroup"].write(value.awsAthenaWorkGroup, with: SecurityHubClientTypes.AwsAthenaWorkGroupDetails.write(value:to:))
        try writer["AwsAutoScalingAutoScalingGroup"].write(value.awsAutoScalingAutoScalingGroup, with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails.write(value:to:))
        try writer["AwsAutoScalingLaunchConfiguration"].write(value.awsAutoScalingLaunchConfiguration, with: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails.write(value:to:))
        try writer["AwsBackupBackupPlan"].write(value.awsBackupBackupPlan, with: SecurityHubClientTypes.AwsBackupBackupPlanDetails.write(value:to:))
        try writer["AwsBackupBackupVault"].write(value.awsBackupBackupVault, with: SecurityHubClientTypes.AwsBackupBackupVaultDetails.write(value:to:))
        try writer["AwsBackupRecoveryPoint"].write(value.awsBackupRecoveryPoint, with: SecurityHubClientTypes.AwsBackupRecoveryPointDetails.write(value:to:))
        try writer["AwsCertificateManagerCertificate"].write(value.awsCertificateManagerCertificate, with: SecurityHubClientTypes.AwsCertificateManagerCertificateDetails.write(value:to:))
        try writer["AwsCloudFormationStack"].write(value.awsCloudFormationStack, with: SecurityHubClientTypes.AwsCloudFormationStackDetails.write(value:to:))
        try writer["AwsCloudFrontDistribution"].write(value.awsCloudFrontDistribution, with: SecurityHubClientTypes.AwsCloudFrontDistributionDetails.write(value:to:))
        try writer["AwsCloudTrailTrail"].write(value.awsCloudTrailTrail, with: SecurityHubClientTypes.AwsCloudTrailTrailDetails.write(value:to:))
        try writer["AwsCloudWatchAlarm"].write(value.awsCloudWatchAlarm, with: SecurityHubClientTypes.AwsCloudWatchAlarmDetails.write(value:to:))
        try writer["AwsCodeBuildProject"].write(value.awsCodeBuildProject, with: SecurityHubClientTypes.AwsCodeBuildProjectDetails.write(value:to:))
        try writer["AwsDmsEndpoint"].write(value.awsDmsEndpoint, with: SecurityHubClientTypes.AwsDmsEndpointDetails.write(value:to:))
        try writer["AwsDmsReplicationInstance"].write(value.awsDmsReplicationInstance, with: SecurityHubClientTypes.AwsDmsReplicationInstanceDetails.write(value:to:))
        try writer["AwsDmsReplicationTask"].write(value.awsDmsReplicationTask, with: SecurityHubClientTypes.AwsDmsReplicationTaskDetails.write(value:to:))
        try writer["AwsDynamoDbTable"].write(value.awsDynamoDbTable, with: SecurityHubClientTypes.AwsDynamoDbTableDetails.write(value:to:))
        try writer["AwsEc2ClientVpnEndpoint"].write(value.awsEc2ClientVpnEndpoint, with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointDetails.write(value:to:))
        try writer["AwsEc2Eip"].write(value.awsEc2Eip, with: SecurityHubClientTypes.AwsEc2EipDetails.write(value:to:))
        try writer["AwsEc2Instance"].write(value.awsEc2Instance, with: SecurityHubClientTypes.AwsEc2InstanceDetails.write(value:to:))
        try writer["AwsEc2LaunchTemplate"].write(value.awsEc2LaunchTemplate, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDetails.write(value:to:))
        try writer["AwsEc2NetworkAcl"].write(value.awsEc2NetworkAcl, with: SecurityHubClientTypes.AwsEc2NetworkAclDetails.write(value:to:))
        try writer["AwsEc2NetworkInterface"].write(value.awsEc2NetworkInterface, with: SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails.write(value:to:))
        try writer["AwsEc2RouteTable"].write(value.awsEc2RouteTable, with: SecurityHubClientTypes.AwsEc2RouteTableDetails.write(value:to:))
        try writer["AwsEc2SecurityGroup"].write(value.awsEc2SecurityGroup, with: SecurityHubClientTypes.AwsEc2SecurityGroupDetails.write(value:to:))
        try writer["AwsEc2Subnet"].write(value.awsEc2Subnet, with: SecurityHubClientTypes.AwsEc2SubnetDetails.write(value:to:))
        try writer["AwsEc2TransitGateway"].write(value.awsEc2TransitGateway, with: SecurityHubClientTypes.AwsEc2TransitGatewayDetails.write(value:to:))
        try writer["AwsEc2Volume"].write(value.awsEc2Volume, with: SecurityHubClientTypes.AwsEc2VolumeDetails.write(value:to:))
        try writer["AwsEc2Vpc"].write(value.awsEc2Vpc, with: SecurityHubClientTypes.AwsEc2VpcDetails.write(value:to:))
        try writer["AwsEc2VpcEndpointService"].write(value.awsEc2VpcEndpointService, with: SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails.write(value:to:))
        try writer["AwsEc2VpcPeeringConnection"].write(value.awsEc2VpcPeeringConnection, with: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails.write(value:to:))
        try writer["AwsEc2VpnConnection"].write(value.awsEc2VpnConnection, with: SecurityHubClientTypes.AwsEc2VpnConnectionDetails.write(value:to:))
        try writer["AwsEcrContainerImage"].write(value.awsEcrContainerImage, with: SecurityHubClientTypes.AwsEcrContainerImageDetails.write(value:to:))
        try writer["AwsEcrRepository"].write(value.awsEcrRepository, with: SecurityHubClientTypes.AwsEcrRepositoryDetails.write(value:to:))
        try writer["AwsEcsCluster"].write(value.awsEcsCluster, with: SecurityHubClientTypes.AwsEcsClusterDetails.write(value:to:))
        try writer["AwsEcsContainer"].write(value.awsEcsContainer, with: SecurityHubClientTypes.AwsEcsContainerDetails.write(value:to:))
        try writer["AwsEcsService"].write(value.awsEcsService, with: SecurityHubClientTypes.AwsEcsServiceDetails.write(value:to:))
        try writer["AwsEcsTask"].write(value.awsEcsTask, with: SecurityHubClientTypes.AwsEcsTaskDetails.write(value:to:))
        try writer["AwsEcsTaskDefinition"].write(value.awsEcsTaskDefinition, with: SecurityHubClientTypes.AwsEcsTaskDefinitionDetails.write(value:to:))
        try writer["AwsEfsAccessPoint"].write(value.awsEfsAccessPoint, with: SecurityHubClientTypes.AwsEfsAccessPointDetails.write(value:to:))
        try writer["AwsEksCluster"].write(value.awsEksCluster, with: SecurityHubClientTypes.AwsEksClusterDetails.write(value:to:))
        try writer["AwsElasticBeanstalkEnvironment"].write(value.awsElasticBeanstalkEnvironment, with: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails.write(value:to:))
        try writer["AwsElasticsearchDomain"].write(value.awsElasticsearchDomain, with: SecurityHubClientTypes.AwsElasticsearchDomainDetails.write(value:to:))
        try writer["AwsElbLoadBalancer"].write(value.awsElbLoadBalancer, with: SecurityHubClientTypes.AwsElbLoadBalancerDetails.write(value:to:))
        try writer["AwsElbv2LoadBalancer"].write(value.awsElbv2LoadBalancer, with: SecurityHubClientTypes.AwsElbv2LoadBalancerDetails.write(value:to:))
        try writer["AwsEventSchemasRegistry"].write(value.awsEventSchemasRegistry, with: SecurityHubClientTypes.AwsEventSchemasRegistryDetails.write(value:to:))
        try writer["AwsEventsEndpoint"].write(value.awsEventsEndpoint, with: SecurityHubClientTypes.AwsEventsEndpointDetails.write(value:to:))
        try writer["AwsEventsEventbus"].write(value.awsEventsEventbus, with: SecurityHubClientTypes.AwsEventsEventbusDetails.write(value:to:))
        try writer["AwsGuardDutyDetector"].write(value.awsGuardDutyDetector, with: SecurityHubClientTypes.AwsGuardDutyDetectorDetails.write(value:to:))
        try writer["AwsIamAccessKey"].write(value.awsIamAccessKey, with: SecurityHubClientTypes.AwsIamAccessKeyDetails.write(value:to:))
        try writer["AwsIamGroup"].write(value.awsIamGroup, with: SecurityHubClientTypes.AwsIamGroupDetails.write(value:to:))
        try writer["AwsIamPolicy"].write(value.awsIamPolicy, with: SecurityHubClientTypes.AwsIamPolicyDetails.write(value:to:))
        try writer["AwsIamRole"].write(value.awsIamRole, with: SecurityHubClientTypes.AwsIamRoleDetails.write(value:to:))
        try writer["AwsIamUser"].write(value.awsIamUser, with: SecurityHubClientTypes.AwsIamUserDetails.write(value:to:))
        try writer["AwsKinesisStream"].write(value.awsKinesisStream, with: SecurityHubClientTypes.AwsKinesisStreamDetails.write(value:to:))
        try writer["AwsKmsKey"].write(value.awsKmsKey, with: SecurityHubClientTypes.AwsKmsKeyDetails.write(value:to:))
        try writer["AwsLambdaFunction"].write(value.awsLambdaFunction, with: SecurityHubClientTypes.AwsLambdaFunctionDetails.write(value:to:))
        try writer["AwsLambdaLayerVersion"].write(value.awsLambdaLayerVersion, with: SecurityHubClientTypes.AwsLambdaLayerVersionDetails.write(value:to:))
        try writer["AwsMskCluster"].write(value.awsMskCluster, with: SecurityHubClientTypes.AwsMskClusterDetails.write(value:to:))
        try writer["AwsNetworkFirewallFirewall"].write(value.awsNetworkFirewallFirewall, with: SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails.write(value:to:))
        try writer["AwsNetworkFirewallFirewallPolicy"].write(value.awsNetworkFirewallFirewallPolicy, with: SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails.write(value:to:))
        try writer["AwsNetworkFirewallRuleGroup"].write(value.awsNetworkFirewallRuleGroup, with: SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails.write(value:to:))
        try writer["AwsOpenSearchServiceDomain"].write(value.awsOpenSearchServiceDomain, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails.write(value:to:))
        try writer["AwsRdsDbCluster"].write(value.awsRdsDbCluster, with: SecurityHubClientTypes.AwsRdsDbClusterDetails.write(value:to:))
        try writer["AwsRdsDbClusterSnapshot"].write(value.awsRdsDbClusterSnapshot, with: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails.write(value:to:))
        try writer["AwsRdsDbInstance"].write(value.awsRdsDbInstance, with: SecurityHubClientTypes.AwsRdsDbInstanceDetails.write(value:to:))
        try writer["AwsRdsDbSecurityGroup"].write(value.awsRdsDbSecurityGroup, with: SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails.write(value:to:))
        try writer["AwsRdsDbSnapshot"].write(value.awsRdsDbSnapshot, with: SecurityHubClientTypes.AwsRdsDbSnapshotDetails.write(value:to:))
        try writer["AwsRdsEventSubscription"].write(value.awsRdsEventSubscription, with: SecurityHubClientTypes.AwsRdsEventSubscriptionDetails.write(value:to:))
        try writer["AwsRedshiftCluster"].write(value.awsRedshiftCluster, with: SecurityHubClientTypes.AwsRedshiftClusterDetails.write(value:to:))
        try writer["AwsRoute53HostedZone"].write(value.awsRoute53HostedZone, with: SecurityHubClientTypes.AwsRoute53HostedZoneDetails.write(value:to:))
        try writer["AwsS3AccessPoint"].write(value.awsS3AccessPoint, with: SecurityHubClientTypes.AwsS3AccessPointDetails.write(value:to:))
        try writer["AwsS3AccountPublicAccessBlock"].write(value.awsS3AccountPublicAccessBlock, with: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails.write(value:to:))
        try writer["AwsS3Bucket"].write(value.awsS3Bucket, with: SecurityHubClientTypes.AwsS3BucketDetails.write(value:to:))
        try writer["AwsS3Object"].write(value.awsS3Object, with: SecurityHubClientTypes.AwsS3ObjectDetails.write(value:to:))
        try writer["AwsSageMakerNotebookInstance"].write(value.awsSageMakerNotebookInstance, with: SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails.write(value:to:))
        try writer["AwsSecretsManagerSecret"].write(value.awsSecretsManagerSecret, with: SecurityHubClientTypes.AwsSecretsManagerSecretDetails.write(value:to:))
        try writer["AwsSnsTopic"].write(value.awsSnsTopic, with: SecurityHubClientTypes.AwsSnsTopicDetails.write(value:to:))
        try writer["AwsSqsQueue"].write(value.awsSqsQueue, with: SecurityHubClientTypes.AwsSqsQueueDetails.write(value:to:))
        try writer["AwsSsmPatchCompliance"].write(value.awsSsmPatchCompliance, with: SecurityHubClientTypes.AwsSsmPatchComplianceDetails.write(value:to:))
        try writer["AwsStepFunctionStateMachine"].write(value.awsStepFunctionStateMachine, with: SecurityHubClientTypes.AwsStepFunctionStateMachineDetails.write(value:to:))
        try writer["AwsWafRateBasedRule"].write(value.awsWafRateBasedRule, with: SecurityHubClientTypes.AwsWafRateBasedRuleDetails.write(value:to:))
        try writer["AwsWafRegionalRateBasedRule"].write(value.awsWafRegionalRateBasedRule, with: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails.write(value:to:))
        try writer["AwsWafRegionalRule"].write(value.awsWafRegionalRule, with: SecurityHubClientTypes.AwsWafRegionalRuleDetails.write(value:to:))
        try writer["AwsWafRegionalRuleGroup"].write(value.awsWafRegionalRuleGroup, with: SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails.write(value:to:))
        try writer["AwsWafRegionalWebAcl"].write(value.awsWafRegionalWebAcl, with: SecurityHubClientTypes.AwsWafRegionalWebAclDetails.write(value:to:))
        try writer["AwsWafRule"].write(value.awsWafRule, with: SecurityHubClientTypes.AwsWafRuleDetails.write(value:to:))
        try writer["AwsWafRuleGroup"].write(value.awsWafRuleGroup, with: SecurityHubClientTypes.AwsWafRuleGroupDetails.write(value:to:))
        try writer["AwsWafWebAcl"].write(value.awsWafWebAcl, with: SecurityHubClientTypes.AwsWafWebAclDetails.write(value:to:))
        try writer["AwsWafv2RuleGroup"].write(value.awsWafv2RuleGroup, with: SecurityHubClientTypes.AwsWafv2RuleGroupDetails.write(value:to:))
        try writer["AwsWafv2WebAcl"].write(value.awsWafv2WebAcl, with: SecurityHubClientTypes.AwsWafv2WebAclDetails.write(value:to:))
        try writer["AwsXrayEncryptionConfig"].write(value.awsXrayEncryptionConfig, with: SecurityHubClientTypes.AwsXrayEncryptionConfigDetails.write(value:to:))
        try writer["Container"].write(value.container, with: SecurityHubClientTypes.ContainerDetails.write(value:to:))
        try writer["Other"].writeMap(value.other, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ResourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ResourceDetails()
        value.awsAutoScalingAutoScalingGroup = try reader["AwsAutoScalingAutoScalingGroup"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails.read(from:))
        value.awsCodeBuildProject = try reader["AwsCodeBuildProject"].readIfPresent(with: SecurityHubClientTypes.AwsCodeBuildProjectDetails.read(from:))
        value.awsCloudFrontDistribution = try reader["AwsCloudFrontDistribution"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionDetails.read(from:))
        value.awsEc2Instance = try reader["AwsEc2Instance"].readIfPresent(with: SecurityHubClientTypes.AwsEc2InstanceDetails.read(from:))
        value.awsEc2NetworkInterface = try reader["AwsEc2NetworkInterface"].readIfPresent(with: SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails.read(from:))
        value.awsEc2SecurityGroup = try reader["AwsEc2SecurityGroup"].readIfPresent(with: SecurityHubClientTypes.AwsEc2SecurityGroupDetails.read(from:))
        value.awsEc2Volume = try reader["AwsEc2Volume"].readIfPresent(with: SecurityHubClientTypes.AwsEc2VolumeDetails.read(from:))
        value.awsEc2Vpc = try reader["AwsEc2Vpc"].readIfPresent(with: SecurityHubClientTypes.AwsEc2VpcDetails.read(from:))
        value.awsEc2Eip = try reader["AwsEc2Eip"].readIfPresent(with: SecurityHubClientTypes.AwsEc2EipDetails.read(from:))
        value.awsEc2Subnet = try reader["AwsEc2Subnet"].readIfPresent(with: SecurityHubClientTypes.AwsEc2SubnetDetails.read(from:))
        value.awsEc2NetworkAcl = try reader["AwsEc2NetworkAcl"].readIfPresent(with: SecurityHubClientTypes.AwsEc2NetworkAclDetails.read(from:))
        value.awsElbv2LoadBalancer = try reader["AwsElbv2LoadBalancer"].readIfPresent(with: SecurityHubClientTypes.AwsElbv2LoadBalancerDetails.read(from:))
        value.awsElasticBeanstalkEnvironment = try reader["AwsElasticBeanstalkEnvironment"].readIfPresent(with: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails.read(from:))
        value.awsElasticsearchDomain = try reader["AwsElasticsearchDomain"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainDetails.read(from:))
        value.awsS3Bucket = try reader["AwsS3Bucket"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketDetails.read(from:))
        value.awsS3AccountPublicAccessBlock = try reader["AwsS3AccountPublicAccessBlock"].readIfPresent(with: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails.read(from:))
        value.awsS3Object = try reader["AwsS3Object"].readIfPresent(with: SecurityHubClientTypes.AwsS3ObjectDetails.read(from:))
        value.awsSecretsManagerSecret = try reader["AwsSecretsManagerSecret"].readIfPresent(with: SecurityHubClientTypes.AwsSecretsManagerSecretDetails.read(from:))
        value.awsIamAccessKey = try reader["AwsIamAccessKey"].readIfPresent(with: SecurityHubClientTypes.AwsIamAccessKeyDetails.read(from:))
        value.awsIamUser = try reader["AwsIamUser"].readIfPresent(with: SecurityHubClientTypes.AwsIamUserDetails.read(from:))
        value.awsIamPolicy = try reader["AwsIamPolicy"].readIfPresent(with: SecurityHubClientTypes.AwsIamPolicyDetails.read(from:))
        value.awsApiGatewayV2Stage = try reader["AwsApiGatewayV2Stage"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayV2StageDetails.read(from:))
        value.awsApiGatewayV2Api = try reader["AwsApiGatewayV2Api"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayV2ApiDetails.read(from:))
        value.awsDynamoDbTable = try reader["AwsDynamoDbTable"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableDetails.read(from:))
        value.awsApiGatewayStage = try reader["AwsApiGatewayStage"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayStageDetails.read(from:))
        value.awsApiGatewayRestApi = try reader["AwsApiGatewayRestApi"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayRestApiDetails.read(from:))
        value.awsCloudTrailTrail = try reader["AwsCloudTrailTrail"].readIfPresent(with: SecurityHubClientTypes.AwsCloudTrailTrailDetails.read(from:))
        value.awsSsmPatchCompliance = try reader["AwsSsmPatchCompliance"].readIfPresent(with: SecurityHubClientTypes.AwsSsmPatchComplianceDetails.read(from:))
        value.awsCertificateManagerCertificate = try reader["AwsCertificateManagerCertificate"].readIfPresent(with: SecurityHubClientTypes.AwsCertificateManagerCertificateDetails.read(from:))
        value.awsRedshiftCluster = try reader["AwsRedshiftCluster"].readIfPresent(with: SecurityHubClientTypes.AwsRedshiftClusterDetails.read(from:))
        value.awsElbLoadBalancer = try reader["AwsElbLoadBalancer"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerDetails.read(from:))
        value.awsIamGroup = try reader["AwsIamGroup"].readIfPresent(with: SecurityHubClientTypes.AwsIamGroupDetails.read(from:))
        value.awsIamRole = try reader["AwsIamRole"].readIfPresent(with: SecurityHubClientTypes.AwsIamRoleDetails.read(from:))
        value.awsKmsKey = try reader["AwsKmsKey"].readIfPresent(with: SecurityHubClientTypes.AwsKmsKeyDetails.read(from:))
        value.awsLambdaFunction = try reader["AwsLambdaFunction"].readIfPresent(with: SecurityHubClientTypes.AwsLambdaFunctionDetails.read(from:))
        value.awsLambdaLayerVersion = try reader["AwsLambdaLayerVersion"].readIfPresent(with: SecurityHubClientTypes.AwsLambdaLayerVersionDetails.read(from:))
        value.awsRdsDbInstance = try reader["AwsRdsDbInstance"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbInstanceDetails.read(from:))
        value.awsSnsTopic = try reader["AwsSnsTopic"].readIfPresent(with: SecurityHubClientTypes.AwsSnsTopicDetails.read(from:))
        value.awsSqsQueue = try reader["AwsSqsQueue"].readIfPresent(with: SecurityHubClientTypes.AwsSqsQueueDetails.read(from:))
        value.awsWafWebAcl = try reader["AwsWafWebAcl"].readIfPresent(with: SecurityHubClientTypes.AwsWafWebAclDetails.read(from:))
        value.awsRdsDbSnapshot = try reader["AwsRdsDbSnapshot"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbSnapshotDetails.read(from:))
        value.awsRdsDbClusterSnapshot = try reader["AwsRdsDbClusterSnapshot"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails.read(from:))
        value.awsRdsDbCluster = try reader["AwsRdsDbCluster"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbClusterDetails.read(from:))
        value.awsEcsCluster = try reader["AwsEcsCluster"].readIfPresent(with: SecurityHubClientTypes.AwsEcsClusterDetails.read(from:))
        value.awsEcsContainer = try reader["AwsEcsContainer"].readIfPresent(with: SecurityHubClientTypes.AwsEcsContainerDetails.read(from:))
        value.awsEcsTaskDefinition = try reader["AwsEcsTaskDefinition"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionDetails.read(from:))
        value.container = try reader["Container"].readIfPresent(with: SecurityHubClientTypes.ContainerDetails.read(from:))
        value.other = try reader["Other"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.awsRdsEventSubscription = try reader["AwsRdsEventSubscription"].readIfPresent(with: SecurityHubClientTypes.AwsRdsEventSubscriptionDetails.read(from:))
        value.awsEcsService = try reader["AwsEcsService"].readIfPresent(with: SecurityHubClientTypes.AwsEcsServiceDetails.read(from:))
        value.awsAutoScalingLaunchConfiguration = try reader["AwsAutoScalingLaunchConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails.read(from:))
        value.awsEc2VpnConnection = try reader["AwsEc2VpnConnection"].readIfPresent(with: SecurityHubClientTypes.AwsEc2VpnConnectionDetails.read(from:))
        value.awsEcrContainerImage = try reader["AwsEcrContainerImage"].readIfPresent(with: SecurityHubClientTypes.AwsEcrContainerImageDetails.read(from:))
        value.awsOpenSearchServiceDomain = try reader["AwsOpenSearchServiceDomain"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails.read(from:))
        value.awsEc2VpcEndpointService = try reader["AwsEc2VpcEndpointService"].readIfPresent(with: SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails.read(from:))
        value.awsXrayEncryptionConfig = try reader["AwsXrayEncryptionConfig"].readIfPresent(with: SecurityHubClientTypes.AwsXrayEncryptionConfigDetails.read(from:))
        value.awsWafRateBasedRule = try reader["AwsWafRateBasedRule"].readIfPresent(with: SecurityHubClientTypes.AwsWafRateBasedRuleDetails.read(from:))
        value.awsWafRegionalRateBasedRule = try reader["AwsWafRegionalRateBasedRule"].readIfPresent(with: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails.read(from:))
        value.awsEcrRepository = try reader["AwsEcrRepository"].readIfPresent(with: SecurityHubClientTypes.AwsEcrRepositoryDetails.read(from:))
        value.awsEksCluster = try reader["AwsEksCluster"].readIfPresent(with: SecurityHubClientTypes.AwsEksClusterDetails.read(from:))
        value.awsNetworkFirewallFirewallPolicy = try reader["AwsNetworkFirewallFirewallPolicy"].readIfPresent(with: SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails.read(from:))
        value.awsNetworkFirewallFirewall = try reader["AwsNetworkFirewallFirewall"].readIfPresent(with: SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails.read(from:))
        value.awsNetworkFirewallRuleGroup = try reader["AwsNetworkFirewallRuleGroup"].readIfPresent(with: SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails.read(from:))
        value.awsRdsDbSecurityGroup = try reader["AwsRdsDbSecurityGroup"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails.read(from:))
        value.awsKinesisStream = try reader["AwsKinesisStream"].readIfPresent(with: SecurityHubClientTypes.AwsKinesisStreamDetails.read(from:))
        value.awsEc2TransitGateway = try reader["AwsEc2TransitGateway"].readIfPresent(with: SecurityHubClientTypes.AwsEc2TransitGatewayDetails.read(from:))
        value.awsEfsAccessPoint = try reader["AwsEfsAccessPoint"].readIfPresent(with: SecurityHubClientTypes.AwsEfsAccessPointDetails.read(from:))
        value.awsCloudFormationStack = try reader["AwsCloudFormationStack"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFormationStackDetails.read(from:))
        value.awsCloudWatchAlarm = try reader["AwsCloudWatchAlarm"].readIfPresent(with: SecurityHubClientTypes.AwsCloudWatchAlarmDetails.read(from:))
        value.awsEc2VpcPeeringConnection = try reader["AwsEc2VpcPeeringConnection"].readIfPresent(with: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails.read(from:))
        value.awsWafRegionalRuleGroup = try reader["AwsWafRegionalRuleGroup"].readIfPresent(with: SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails.read(from:))
        value.awsWafRegionalRule = try reader["AwsWafRegionalRule"].readIfPresent(with: SecurityHubClientTypes.AwsWafRegionalRuleDetails.read(from:))
        value.awsWafRegionalWebAcl = try reader["AwsWafRegionalWebAcl"].readIfPresent(with: SecurityHubClientTypes.AwsWafRegionalWebAclDetails.read(from:))
        value.awsWafRule = try reader["AwsWafRule"].readIfPresent(with: SecurityHubClientTypes.AwsWafRuleDetails.read(from:))
        value.awsWafRuleGroup = try reader["AwsWafRuleGroup"].readIfPresent(with: SecurityHubClientTypes.AwsWafRuleGroupDetails.read(from:))
        value.awsEcsTask = try reader["AwsEcsTask"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDetails.read(from:))
        value.awsBackupBackupVault = try reader["AwsBackupBackupVault"].readIfPresent(with: SecurityHubClientTypes.AwsBackupBackupVaultDetails.read(from:))
        value.awsBackupBackupPlan = try reader["AwsBackupBackupPlan"].readIfPresent(with: SecurityHubClientTypes.AwsBackupBackupPlanDetails.read(from:))
        value.awsBackupRecoveryPoint = try reader["AwsBackupRecoveryPoint"].readIfPresent(with: SecurityHubClientTypes.AwsBackupRecoveryPointDetails.read(from:))
        value.awsEc2LaunchTemplate = try reader["AwsEc2LaunchTemplate"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDetails.read(from:))
        value.awsSageMakerNotebookInstance = try reader["AwsSageMakerNotebookInstance"].readIfPresent(with: SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails.read(from:))
        value.awsWafv2WebAcl = try reader["AwsWafv2WebAcl"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2WebAclDetails.read(from:))
        value.awsWafv2RuleGroup = try reader["AwsWafv2RuleGroup"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2RuleGroupDetails.read(from:))
        value.awsEc2RouteTable = try reader["AwsEc2RouteTable"].readIfPresent(with: SecurityHubClientTypes.AwsEc2RouteTableDetails.read(from:))
        value.awsAmazonMqBroker = try reader["AwsAmazonMqBroker"].readIfPresent(with: SecurityHubClientTypes.AwsAmazonMqBrokerDetails.read(from:))
        value.awsAppSyncGraphQlApi = try reader["AwsAppSyncGraphQlApi"].readIfPresent(with: SecurityHubClientTypes.AwsAppSyncGraphQlApiDetails.read(from:))
        value.awsEventSchemasRegistry = try reader["AwsEventSchemasRegistry"].readIfPresent(with: SecurityHubClientTypes.AwsEventSchemasRegistryDetails.read(from:))
        value.awsGuardDutyDetector = try reader["AwsGuardDutyDetector"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDetails.read(from:))
        value.awsStepFunctionStateMachine = try reader["AwsStepFunctionStateMachine"].readIfPresent(with: SecurityHubClientTypes.AwsStepFunctionStateMachineDetails.read(from:))
        value.awsAthenaWorkGroup = try reader["AwsAthenaWorkGroup"].readIfPresent(with: SecurityHubClientTypes.AwsAthenaWorkGroupDetails.read(from:))
        value.awsEventsEventbus = try reader["AwsEventsEventbus"].readIfPresent(with: SecurityHubClientTypes.AwsEventsEventbusDetails.read(from:))
        value.awsDmsEndpoint = try reader["AwsDmsEndpoint"].readIfPresent(with: SecurityHubClientTypes.AwsDmsEndpointDetails.read(from:))
        value.awsEventsEndpoint = try reader["AwsEventsEndpoint"].readIfPresent(with: SecurityHubClientTypes.AwsEventsEndpointDetails.read(from:))
        value.awsDmsReplicationTask = try reader["AwsDmsReplicationTask"].readIfPresent(with: SecurityHubClientTypes.AwsDmsReplicationTaskDetails.read(from:))
        value.awsDmsReplicationInstance = try reader["AwsDmsReplicationInstance"].readIfPresent(with: SecurityHubClientTypes.AwsDmsReplicationInstanceDetails.read(from:))
        value.awsRoute53HostedZone = try reader["AwsRoute53HostedZone"].readIfPresent(with: SecurityHubClientTypes.AwsRoute53HostedZoneDetails.read(from:))
        value.awsMskCluster = try reader["AwsMskCluster"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterDetails.read(from:))
        value.awsS3AccessPoint = try reader["AwsS3AccessPoint"].readIfPresent(with: SecurityHubClientTypes.AwsS3AccessPointDetails.read(from:))
        value.awsEc2ClientVpnEndpoint = try reader["AwsEc2ClientVpnEndpoint"].readIfPresent(with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2ClientVpnEndpointDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2ClientVpnEndpointDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationOptions"].writeList(value.authenticationOptions, memberWritingClosure: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientCidrBlock"].write(value.clientCidrBlock)
        try writer["ClientConnectOptions"].write(value.clientConnectOptions, with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsDetails.write(value:to:))
        try writer["ClientLoginBannerOptions"].write(value.clientLoginBannerOptions, with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails.write(value:to:))
        try writer["ClientVpnEndpointId"].write(value.clientVpnEndpointId)
        try writer["ConnectionLogOptions"].write(value.connectionLogOptions, with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointConnectionLogOptionsDetails.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DnsServer"].writeList(value.dnsServer, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityGroupIdSet"].writeList(value.securityGroupIdSet, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SelfServicePortalUrl"].write(value.selfServicePortalUrl)
        try writer["ServerCertificateArn"].write(value.serverCertificateArn)
        try writer["SessionTimeoutHours"].write(value.sessionTimeoutHours)
        try writer["SplitTunnel"].write(value.splitTunnel)
        try writer["TransportProtocol"].write(value.transportProtocol)
        try writer["VpcId"].write(value.vpcId)
        try writer["VpnPort"].write(value.vpnPort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2ClientVpnEndpointDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2ClientVpnEndpointDetails()
        value.clientVpnEndpointId = try reader["ClientVpnEndpointId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.clientCidrBlock = try reader["ClientCidrBlock"].readIfPresent()
        value.dnsServer = try reader["DnsServer"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.splitTunnel = try reader["SplitTunnel"].readIfPresent()
        value.transportProtocol = try reader["TransportProtocol"].readIfPresent()
        value.vpnPort = try reader["VpnPort"].readIfPresent()
        value.serverCertificateArn = try reader["ServerCertificateArn"].readIfPresent()
        value.authenticationOptions = try reader["AuthenticationOptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionLogOptions = try reader["ConnectionLogOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointConnectionLogOptionsDetails.read(from:))
        value.securityGroupIdSet = try reader["SecurityGroupIdSet"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.selfServicePortalUrl = try reader["SelfServicePortalUrl"].readIfPresent()
        value.clientConnectOptions = try reader["ClientConnectOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsDetails.read(from:))
        value.sessionTimeoutHours = try reader["SessionTimeoutHours"].readIfPresent()
        value.clientLoginBannerOptions = try reader["ClientLoginBannerOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BannerText"].write(value.bannerText)
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.bannerText = try reader["BannerText"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["LambdaFunctionArn"].write(value.lambdaFunctionArn)
        try writer["Status"].write(value.status, with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.lambdaFunctionArn = try reader["LambdaFunctionArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
        try writer["Message"].write(value.message)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2ClientVpnEndpointConnectionLogOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2ClientVpnEndpointConnectionLogOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudwatchLogGroup"].write(value.cloudwatchLogGroup)
        try writer["CloudwatchLogStream"].write(value.cloudwatchLogStream)
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2ClientVpnEndpointConnectionLogOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2ClientVpnEndpointConnectionLogOptionsDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.cloudwatchLogGroup = try reader["CloudwatchLogGroup"].readIfPresent()
        value.cloudwatchLogStream = try reader["CloudwatchLogStream"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActiveDirectory"].write(value.activeDirectory, with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails.write(value:to:))
        try writer["FederatedAuthentication"].write(value.federatedAuthentication, with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails.write(value:to:))
        try writer["MutualAuthentication"].write(value.mutualAuthentication, with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsDetails()
        value.type = try reader["Type"].readIfPresent()
        value.activeDirectory = try reader["ActiveDirectory"].readIfPresent(with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails.read(from:))
        value.mutualAuthentication = try reader["MutualAuthentication"].readIfPresent(with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails.read(from:))
        value.federatedAuthentication = try reader["FederatedAuthentication"].readIfPresent(with: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SamlProviderArn"].write(value.samlProviderArn)
        try writer["SelfServiceSamlProviderArn"].write(value.selfServiceSamlProviderArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails()
        value.samlProviderArn = try reader["SamlProviderArn"].readIfPresent()
        value.selfServiceSamlProviderArn = try reader["SelfServiceSamlProviderArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRootCertificateChain"].write(value.clientRootCertificateChain)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails()
        value.clientRootCertificateChain = try reader["ClientRootCertificateChain"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DirectoryId"].write(value.directoryId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails()
        value.directoryId = try reader["DirectoryId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3AccessPointDetails {

    static func write(value: SecurityHubClientTypes.AwsS3AccessPointDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessPointArn"].write(value.accessPointArn)
        try writer["Alias"].write(value.alias)
        try writer["Bucket"].write(value.bucket)
        try writer["BucketAccountId"].write(value.bucketAccountId)
        try writer["Name"].write(value.name)
        try writer["NetworkOrigin"].write(value.networkOrigin)
        try writer["PublicAccessBlockConfiguration"].write(value.publicAccessBlockConfiguration, with: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails.write(value:to:))
        try writer["VpcConfiguration"].write(value.vpcConfiguration, with: SecurityHubClientTypes.AwsS3AccessPointVpcConfigurationDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3AccessPointDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3AccessPointDetails()
        value.accessPointArn = try reader["AccessPointArn"].readIfPresent()
        value.alias = try reader["Alias"].readIfPresent()
        value.bucket = try reader["Bucket"].readIfPresent()
        value.bucketAccountId = try reader["BucketAccountId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.networkOrigin = try reader["NetworkOrigin"].readIfPresent()
        value.publicAccessBlockConfiguration = try reader["PublicAccessBlockConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails.read(from:))
        value.vpcConfiguration = try reader["VpcConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3AccessPointVpcConfigurationDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsS3AccessPointVpcConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsS3AccessPointVpcConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3AccessPointVpcConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3AccessPointVpcConfigurationDetails()
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails {

    static func write(value: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlockPublicAcls"].write(value.blockPublicAcls)
        try writer["BlockPublicPolicy"].write(value.blockPublicPolicy)
        try writer["IgnorePublicAcls"].write(value.ignorePublicAcls)
        try writer["RestrictPublicBuckets"].write(value.restrictPublicBuckets)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails()
        value.blockPublicAcls = try reader["BlockPublicAcls"].readIfPresent()
        value.blockPublicPolicy = try reader["BlockPublicPolicy"].readIfPresent()
        value.ignorePublicAcls = try reader["IgnorePublicAcls"].readIfPresent()
        value.restrictPublicBuckets = try reader["RestrictPublicBuckets"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterInfo"].write(value.clusterInfo, with: SecurityHubClientTypes.AwsMskClusterClusterInfoDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterDetails()
        value.clusterInfo = try reader["ClusterInfo"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientAuthentication"].write(value.clientAuthentication, with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationDetails.write(value:to:))
        try writer["ClusterName"].write(value.clusterName)
        try writer["CurrentVersion"].write(value.currentVersion)
        try writer["EncryptionInfo"].write(value.encryptionInfo, with: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoDetails.write(value:to:))
        try writer["EnhancedMonitoring"].write(value.enhancedMonitoring)
        try writer["NumberOfBrokerNodes"].write(value.numberOfBrokerNodes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoDetails()
        value.encryptionInfo = try reader["EncryptionInfo"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoDetails.read(from:))
        value.currentVersion = try reader["CurrentVersion"].readIfPresent()
        value.numberOfBrokerNodes = try reader["NumberOfBrokerNodes"].readIfPresent()
        value.clusterName = try reader["ClusterName"].readIfPresent()
        value.clientAuthentication = try reader["ClientAuthentication"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationDetails.read(from:))
        value.enhancedMonitoring = try reader["EnhancedMonitoring"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Sasl"].write(value.sasl, with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslDetails.write(value:to:))
        try writer["Tls"].write(value.tls, with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationTlsDetails.write(value:to:))
        try writer["Unauthenticated"].write(value.unauthenticated, with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationDetails()
        value.sasl = try reader["Sasl"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslDetails.read(from:))
        value.unauthenticated = try reader["Unauthenticated"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails.read(from:))
        value.tls = try reader["Tls"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationTlsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationTlsDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationTlsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateAuthorityArnList"].writeList(value.certificateAuthorityArnList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationTlsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationTlsDetails()
        value.certificateAuthorityArnList = try reader["CertificateAuthorityArnList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Iam"].write(value.iam, with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails.write(value:to:))
        try writer["Scram"].write(value.scram, with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslDetails()
        value.iam = try reader["Iam"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails.read(from:))
        value.scram = try reader["Scram"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionAtRest"].write(value.encryptionAtRest, with: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails.write(value:to:))
        try writer["EncryptionInTransit"].write(value.encryptionInTransit, with: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoDetails()
        value.encryptionInTransit = try reader["EncryptionInTransit"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails.read(from:))
        value.encryptionAtRest = try reader["EncryptionAtRest"].readIfPresent(with: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataVolumeKMSKeyId"].write(value.dataVolumeKMSKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails()
        value.dataVolumeKMSKeyId = try reader["DataVolumeKMSKeyId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails {

    static func write(value: SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientBroker"].write(value.clientBroker)
        try writer["InCluster"].write(value.inCluster)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails()
        value.inCluster = try reader["InCluster"].readIfPresent()
        value.clientBroker = try reader["ClientBroker"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRoute53HostedZoneDetails {

    static func write(value: SecurityHubClientTypes.AwsRoute53HostedZoneDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HostedZone"].write(value.hostedZone, with: SecurityHubClientTypes.AwsRoute53HostedZoneObjectDetails.write(value:to:))
        try writer["NameServers"].writeList(value.nameServers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryLoggingConfig"].write(value.queryLoggingConfig, with: SecurityHubClientTypes.AwsRoute53QueryLoggingConfigDetails.write(value:to:))
        try writer["Vpcs"].writeList(value.vpcs, memberWritingClosure: SecurityHubClientTypes.AwsRoute53HostedZoneVpcDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRoute53HostedZoneDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRoute53HostedZoneDetails()
        value.hostedZone = try reader["HostedZone"].readIfPresent(with: SecurityHubClientTypes.AwsRoute53HostedZoneObjectDetails.read(from:))
        value.vpcs = try reader["Vpcs"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRoute53HostedZoneVpcDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nameServers = try reader["NameServers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.queryLoggingConfig = try reader["QueryLoggingConfig"].readIfPresent(with: SecurityHubClientTypes.AwsRoute53QueryLoggingConfigDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsRoute53QueryLoggingConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsRoute53QueryLoggingConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsLogGroupArn"].write(value.cloudWatchLogsLogGroupArn, with: SecurityHubClientTypes.CloudWatchLogsLogGroupArnConfigDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRoute53QueryLoggingConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRoute53QueryLoggingConfigDetails()
        value.cloudWatchLogsLogGroupArn = try reader["CloudWatchLogsLogGroupArn"].readIfPresent(with: SecurityHubClientTypes.CloudWatchLogsLogGroupArnConfigDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.CloudWatchLogsLogGroupArnConfigDetails {

    static func write(value: SecurityHubClientTypes.CloudWatchLogsLogGroupArnConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsLogGroupArn"].write(value.cloudWatchLogsLogGroupArn)
        try writer["HostedZoneId"].write(value.hostedZoneId)
        try writer["Id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.CloudWatchLogsLogGroupArnConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.CloudWatchLogsLogGroupArnConfigDetails()
        value.cloudWatchLogsLogGroupArn = try reader["CloudWatchLogsLogGroupArn"].readIfPresent()
        value.hostedZoneId = try reader["HostedZoneId"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRoute53HostedZoneVpcDetails {

    static func write(value: SecurityHubClientTypes.AwsRoute53HostedZoneVpcDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRoute53HostedZoneVpcDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRoute53HostedZoneVpcDetails()
        value.id = try reader["Id"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRoute53HostedZoneObjectDetails {

    static func write(value: SecurityHubClientTypes.AwsRoute53HostedZoneObjectDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Config"].write(value.config, with: SecurityHubClientTypes.AwsRoute53HostedZoneConfigDetails.write(value:to:))
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRoute53HostedZoneObjectDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRoute53HostedZoneObjectDetails()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.config = try reader["Config"].readIfPresent(with: SecurityHubClientTypes.AwsRoute53HostedZoneConfigDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsRoute53HostedZoneConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsRoute53HostedZoneConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Comment"].write(value.comment)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRoute53HostedZoneConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRoute53HostedZoneConfigDetails()
        value.comment = try reader["Comment"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDmsReplicationInstanceDetails {

    static func write(value: SecurityHubClientTypes.AwsDmsReplicationInstanceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedStorage"].write(value.allocatedStorage)
        try writer["AutoMinorVersionUpgrade"].write(value.autoMinorVersionUpgrade)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MultiAZ"].write(value.multiAZ)
        try writer["PreferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["PubliclyAccessible"].write(value.publiclyAccessible)
        try writer["ReplicationInstanceClass"].write(value.replicationInstanceClass)
        try writer["ReplicationInstanceIdentifier"].write(value.replicationInstanceIdentifier)
        try writer["ReplicationSubnetGroup"].write(value.replicationSubnetGroup, with: SecurityHubClientTypes.AwsDmsReplicationInstanceReplicationSubnetGroupDetails.write(value:to:))
        try writer["VpcSecurityGroups"].writeList(value.vpcSecurityGroups, memberWritingClosure: SecurityHubClientTypes.AwsDmsReplicationInstanceVpcSecurityGroupsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDmsReplicationInstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDmsReplicationInstanceDetails()
        value.allocatedStorage = try reader["AllocatedStorage"].readIfPresent()
        value.autoMinorVersionUpgrade = try reader["AutoMinorVersionUpgrade"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.multiAZ = try reader["MultiAZ"].readIfPresent()
        value.preferredMaintenanceWindow = try reader["PreferredMaintenanceWindow"].readIfPresent()
        value.publiclyAccessible = try reader["PubliclyAccessible"].readIfPresent()
        value.replicationInstanceClass = try reader["ReplicationInstanceClass"].readIfPresent()
        value.replicationInstanceIdentifier = try reader["ReplicationInstanceIdentifier"].readIfPresent()
        value.replicationSubnetGroup = try reader["ReplicationSubnetGroup"].readIfPresent(with: SecurityHubClientTypes.AwsDmsReplicationInstanceReplicationSubnetGroupDetails.read(from:))
        value.vpcSecurityGroups = try reader["VpcSecurityGroups"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsDmsReplicationInstanceVpcSecurityGroupsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsDmsReplicationInstanceVpcSecurityGroupsDetails {

    static func write(value: SecurityHubClientTypes.AwsDmsReplicationInstanceVpcSecurityGroupsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcSecurityGroupId"].write(value.vpcSecurityGroupId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDmsReplicationInstanceVpcSecurityGroupsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDmsReplicationInstanceVpcSecurityGroupsDetails()
        value.vpcSecurityGroupId = try reader["VpcSecurityGroupId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDmsReplicationInstanceReplicationSubnetGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsDmsReplicationInstanceReplicationSubnetGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReplicationSubnetGroupIdentifier"].write(value.replicationSubnetGroupIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDmsReplicationInstanceReplicationSubnetGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDmsReplicationInstanceReplicationSubnetGroupDetails()
        value.replicationSubnetGroupIdentifier = try reader["ReplicationSubnetGroupIdentifier"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDmsReplicationTaskDetails {

    static func write(value: SecurityHubClientTypes.AwsDmsReplicationTaskDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CdcStartPosition"].write(value.cdcStartPosition)
        try writer["CdcStartTime"].write(value.cdcStartTime)
        try writer["CdcStopPosition"].write(value.cdcStopPosition)
        try writer["Id"].write(value.id)
        try writer["MigrationType"].write(value.migrationType)
        try writer["ReplicationInstanceArn"].write(value.replicationInstanceArn)
        try writer["ReplicationTaskIdentifier"].write(value.replicationTaskIdentifier)
        try writer["ReplicationTaskSettings"].write(value.replicationTaskSettings)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["SourceEndpointArn"].write(value.sourceEndpointArn)
        try writer["TableMappings"].write(value.tableMappings)
        try writer["TargetEndpointArn"].write(value.targetEndpointArn)
        try writer["TaskData"].write(value.taskData)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDmsReplicationTaskDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDmsReplicationTaskDetails()
        value.cdcStartPosition = try reader["CdcStartPosition"].readIfPresent()
        value.cdcStartTime = try reader["CdcStartTime"].readIfPresent()
        value.cdcStopPosition = try reader["CdcStopPosition"].readIfPresent()
        value.migrationType = try reader["MigrationType"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.resourceIdentifier = try reader["ResourceIdentifier"].readIfPresent()
        value.replicationInstanceArn = try reader["ReplicationInstanceArn"].readIfPresent()
        value.replicationTaskIdentifier = try reader["ReplicationTaskIdentifier"].readIfPresent()
        value.replicationTaskSettings = try reader["ReplicationTaskSettings"].readIfPresent()
        value.sourceEndpointArn = try reader["SourceEndpointArn"].readIfPresent()
        value.tableMappings = try reader["TableMappings"].readIfPresent()
        value.targetEndpointArn = try reader["TargetEndpointArn"].readIfPresent()
        value.taskData = try reader["TaskData"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEventsEndpointDetails {

    static func write(value: SecurityHubClientTypes.AwsEventsEndpointDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Description"].write(value.description)
        try writer["EndpointId"].write(value.endpointId)
        try writer["EndpointUrl"].write(value.endpointUrl)
        try writer["EventBuses"].writeList(value.eventBuses, memberWritingClosure: SecurityHubClientTypes.AwsEventsEndpointEventBusesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["ReplicationConfig"].write(value.replicationConfig, with: SecurityHubClientTypes.AwsEventsEndpointReplicationConfigDetails.write(value:to:))
        try writer["RoleArn"].write(value.roleArn)
        try writer["RoutingConfig"].write(value.routingConfig, with: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigDetails.write(value:to:))
        try writer["State"].write(value.state)
        try writer["StateReason"].write(value.stateReason)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEventsEndpointDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEventsEndpointDetails()
        value.arn = try reader["Arn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.endpointId = try reader["EndpointId"].readIfPresent()
        value.endpointUrl = try reader["EndpointUrl"].readIfPresent()
        value.eventBuses = try reader["EventBuses"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEventsEndpointEventBusesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.replicationConfig = try reader["ReplicationConfig"].readIfPresent(with: SecurityHubClientTypes.AwsEventsEndpointReplicationConfigDetails.read(from:))
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.routingConfig = try reader["RoutingConfig"].readIfPresent(with: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigDetails.read(from:))
        value.state = try reader["State"].readIfPresent()
        value.stateReason = try reader["StateReason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEventsEndpointRoutingConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailoverConfig"].write(value.failoverConfig, with: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEventsEndpointRoutingConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEventsEndpointRoutingConfigDetails()
        value.failoverConfig = try reader["FailoverConfig"].readIfPresent(with: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Primary"].write(value.primary, with: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails.write(value:to:))
        try writer["Secondary"].write(value.secondary, with: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigDetails()
        value.primary = try reader["Primary"].readIfPresent(with: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails.read(from:))
        value.secondary = try reader["Secondary"].readIfPresent(with: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails {

    static func write(value: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Route"].write(value.route)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails()
        value.route = try reader["Route"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails {

    static func write(value: SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HealthCheck"].write(value.healthCheck)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails()
        value.healthCheck = try reader["HealthCheck"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEventsEndpointReplicationConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsEventsEndpointReplicationConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEventsEndpointReplicationConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEventsEndpointReplicationConfigDetails()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEventsEndpointEventBusesDetails {

    static func write(value: SecurityHubClientTypes.AwsEventsEndpointEventBusesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventBusArn"].write(value.eventBusArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEventsEndpointEventBusesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEventsEndpointEventBusesDetails()
        value.eventBusArn = try reader["EventBusArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDmsEndpointDetails {

    static func write(value: SecurityHubClientTypes.AwsDmsEndpointDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["EndpointArn"].write(value.endpointArn)
        try writer["EndpointIdentifier"].write(value.endpointIdentifier)
        try writer["EndpointType"].write(value.endpointType)
        try writer["EngineName"].write(value.engineName)
        try writer["ExternalId"].write(value.externalId)
        try writer["ExtraConnectionAttributes"].write(value.extraConnectionAttributes)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["Port"].write(value.port)
        try writer["ServerName"].write(value.serverName)
        try writer["SslMode"].write(value.sslMode)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDmsEndpointDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDmsEndpointDetails()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.endpointArn = try reader["EndpointArn"].readIfPresent()
        value.endpointIdentifier = try reader["EndpointIdentifier"].readIfPresent()
        value.endpointType = try reader["EndpointType"].readIfPresent()
        value.engineName = try reader["EngineName"].readIfPresent()
        value.externalId = try reader["ExternalId"].readIfPresent()
        value.extraConnectionAttributes = try reader["ExtraConnectionAttributes"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.serverName = try reader["ServerName"].readIfPresent()
        value.sslMode = try reader["SslMode"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEventsEventbusDetails {

    static func write(value: SecurityHubClientTypes.AwsEventsEventbusDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Name"].write(value.name)
        try writer["Policy"].write(value.policy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEventsEventbusDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEventsEventbusDetails()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAthenaWorkGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsAthenaWorkGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationDetails.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAthenaWorkGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAthenaWorkGroupDetails()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.configuration = try reader["Configuration"].readIfPresent(with: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResultConfiguration"].write(value.resultConfiguration, with: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationDetails()
        value.resultConfiguration = try reader["ResultConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionConfiguration"].write(value.encryptionConfiguration, with: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationDetails()
        value.encryptionConfiguration = try reader["EncryptionConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionOption"].write(value.encryptionOption)
        try writer["KmsKey"].write(value.kmsKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails()
        value.encryptionOption = try reader["EncryptionOption"].readIfPresent()
        value.kmsKey = try reader["KmsKey"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsStepFunctionStateMachineDetails {

    static func write(value: SecurityHubClientTypes.AwsStepFunctionStateMachineDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Label"].write(value.label)
        try writer["LoggingConfiguration"].write(value.loggingConfiguration, with: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDetails.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RoleArn"].write(value.roleArn)
        try writer["StateMachineArn"].write(value.stateMachineArn)
        try writer["Status"].write(value.status)
        try writer["TracingConfiguration"].write(value.tracingConfiguration, with: SecurityHubClientTypes.AwsStepFunctionStateMachineTracingConfigurationDetails.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsStepFunctionStateMachineDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsStepFunctionStateMachineDetails()
        value.label = try reader["Label"].readIfPresent()
        value.loggingConfiguration = try reader["LoggingConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDetails.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.stateMachineArn = try reader["StateMachineArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tracingConfiguration = try reader["TracingConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsStepFunctionStateMachineTracingConfigurationDetails.read(from:))
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsStepFunctionStateMachineTracingConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsStepFunctionStateMachineTracingConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsStepFunctionStateMachineTracingConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsStepFunctionStateMachineTracingConfigurationDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destinations"].writeList(value.destinations, memberWritingClosure: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IncludeExecutionData"].write(value.includeExecutionData)
        try writer["Level"].write(value.level)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDetails()
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.includeExecutionData = try reader["IncludeExecutionData"].readIfPresent()
        value.level = try reader["Level"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails {

    static func write(value: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsLogGroup"].write(value.cloudWatchLogsLogGroup, with: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails()
        value.cloudWatchLogsLogGroup = try reader["CloudWatchLogsLogGroup"].readIfPresent(with: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogGroupArn"].write(value.logGroupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails()
        value.logGroupArn = try reader["LogGroupArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataSources"].write(value.dataSources, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDetails.write(value:to:))
        try writer["Features"].writeList(value.features, memberWritingClosure: SecurityHubClientTypes.AwsGuardDutyDetectorFeaturesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FindingPublishingFrequency"].write(value.findingPublishingFrequency)
        try writer["ServiceRole"].write(value.serviceRole)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDetails()
        value.dataSources = try reader["DataSources"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDetails.read(from:))
        value.features = try reader["Features"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsGuardDutyDetectorFeaturesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingPublishingFrequency = try reader["FindingPublishingFrequency"].readIfPresent()
        value.serviceRole = try reader["ServiceRole"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorFeaturesDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorFeaturesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorFeaturesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorFeaturesDetails()
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudTrail"].write(value.cloudTrail, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesCloudTrailDetails.write(value:to:))
        try writer["DnsLogs"].write(value.dnsLogs, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDnsLogsDetails.write(value:to:))
        try writer["FlowLogs"].write(value.flowLogs, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesFlowLogsDetails.write(value:to:))
        try writer["Kubernetes"].write(value.kubernetes, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesDetails.write(value:to:))
        try writer["MalwareProtection"].write(value.malwareProtection, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails.write(value:to:))
        try writer["S3Logs"].write(value.s3Logs, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesS3LogsDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDetails()
        value.cloudTrail = try reader["CloudTrail"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesCloudTrailDetails.read(from:))
        value.dnsLogs = try reader["DnsLogs"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDnsLogsDetails.read(from:))
        value.flowLogs = try reader["FlowLogs"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesFlowLogsDetails.read(from:))
        value.kubernetes = try reader["Kubernetes"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesDetails.read(from:))
        value.malwareProtection = try reader["MalwareProtection"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails.read(from:))
        value.s3Logs = try reader["S3Logs"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesS3LogsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesS3LogsDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesS3LogsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesS3LogsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesS3LogsDetails()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ScanEc2InstanceWithFindings"].write(value.scanEc2InstanceWithFindings, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails.write(value:to:))
        try writer["ServiceRole"].write(value.serviceRole)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails()
        value.scanEc2InstanceWithFindings = try reader["ScanEc2InstanceWithFindings"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails.read(from:))
        value.serviceRole = try reader["ServiceRole"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EbsVolumes"].write(value.ebsVolumes, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails()
        value.ebsVolumes = try reader["EbsVolumes"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Reason"].write(value.reason)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails()
        value.reason = try reader["Reason"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditLogs"].write(value.auditLogs, with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesDetails()
        value.auditLogs = try reader["AuditLogs"].readIfPresent(with: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesFlowLogsDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesFlowLogsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesFlowLogsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesFlowLogsDetails()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDnsLogsDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDnsLogsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDnsLogsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesDnsLogsDetails()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesCloudTrailDetails {

    static func write(value: SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesCloudTrailDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesCloudTrailDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsGuardDutyDetectorDataSourcesCloudTrailDetails()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEventSchemasRegistryDetails {

    static func write(value: SecurityHubClientTypes.AwsEventSchemasRegistryDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["RegistryArn"].write(value.registryArn)
        try writer["RegistryName"].write(value.registryName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEventSchemasRegistryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEventSchemasRegistryDetails()
        value.description = try reader["Description"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        value.registryName = try reader["RegistryName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAppSyncGraphQlApiDetails {

    static func write(value: SecurityHubClientTypes.AwsAppSyncGraphQlApiDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalAuthenticationProviders"].writeList(value.additionalAuthenticationProviders, memberWritingClosure: SecurityHubClientTypes.AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ApiId"].write(value.apiId)
        try writer["Arn"].write(value.arn)
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["Id"].write(value.id)
        try writer["LambdaAuthorizerConfig"].write(value.lambdaAuthorizerConfig, with: SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails.write(value:to:))
        try writer["LogConfig"].write(value.logConfig, with: SecurityHubClientTypes.AwsAppSyncGraphQlApiLogConfigDetails.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["OpenIdConnectConfig"].write(value.openIdConnectConfig, with: SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails.write(value:to:))
        try writer["UserPoolConfig"].write(value.userPoolConfig, with: SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails.write(value:to:))
        try writer["WafWebAclArn"].write(value.wafWebAclArn)
        try writer["XrayEnabled"].write(value.xrayEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAppSyncGraphQlApiDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAppSyncGraphQlApiDetails()
        value.apiId = try reader["ApiId"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.openIdConnectConfig = try reader["OpenIdConnectConfig"].readIfPresent(with: SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.lambdaAuthorizerConfig = try reader["LambdaAuthorizerConfig"].readIfPresent(with: SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails.read(from:))
        value.xrayEnabled = try reader["XrayEnabled"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.userPoolConfig = try reader["UserPoolConfig"].readIfPresent(with: SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails.read(from:))
        value.authenticationType = try reader["AuthenticationType"].readIfPresent()
        value.logConfig = try reader["LogConfig"].readIfPresent(with: SecurityHubClientTypes.AwsAppSyncGraphQlApiLogConfigDetails.read(from:))
        value.additionalAuthenticationProviders = try reader["AdditionalAuthenticationProviders"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.wafWebAclArn = try reader["WafWebAclArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails {

    static func write(value: SecurityHubClientTypes.AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationType"].write(value.authenticationType)
        try writer["LambdaAuthorizerConfig"].write(value.lambdaAuthorizerConfig, with: SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails.write(value:to:))
        try writer["OpenIdConnectConfig"].write(value.openIdConnectConfig, with: SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails.write(value:to:))
        try writer["UserPoolConfig"].write(value.userPoolConfig, with: SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails()
        value.authenticationType = try reader["AuthenticationType"].readIfPresent()
        value.lambdaAuthorizerConfig = try reader["LambdaAuthorizerConfig"].readIfPresent(with: SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails.read(from:))
        value.openIdConnectConfig = try reader["OpenIdConnectConfig"].readIfPresent(with: SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails.read(from:))
        value.userPoolConfig = try reader["UserPoolConfig"].readIfPresent(with: SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppIdClientRegex"].write(value.appIdClientRegex)
        try writer["AwsRegion"].write(value.awsRegion)
        try writer["DefaultAction"].write(value.defaultAction)
        try writer["UserPoolId"].write(value.userPoolId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAppSyncGraphQlApiUserPoolConfigDetails()
        value.appIdClientRegex = try reader["AppIdClientRegex"].readIfPresent()
        value.awsRegion = try reader["AwsRegion"].readIfPresent()
        value.defaultAction = try reader["DefaultAction"].readIfPresent()
        value.userPoolId = try reader["UserPoolId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthTtL"].write(value.authTtL)
        try writer["ClientId"].write(value.clientId)
        try writer["IatTtL"].write(value.iatTtL)
        try writer["Issuer"].write(value.issuer)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAppSyncGraphQlApiOpenIdConnectConfigDetails()
        value.authTtL = try reader["AuthTtL"].readIfPresent()
        value.clientId = try reader["ClientId"].readIfPresent()
        value.iatTtL = try reader["IatTtL"].readIfPresent()
        value.issuer = try reader["Issuer"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizerResultTtlInSeconds"].write(value.authorizerResultTtlInSeconds)
        try writer["AuthorizerUri"].write(value.authorizerUri)
        try writer["IdentityValidationExpression"].write(value.identityValidationExpression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails()
        value.authorizerResultTtlInSeconds = try reader["AuthorizerResultTtlInSeconds"].readIfPresent()
        value.authorizerUri = try reader["AuthorizerUri"].readIfPresent()
        value.identityValidationExpression = try reader["IdentityValidationExpression"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAppSyncGraphQlApiLogConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsAppSyncGraphQlApiLogConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsRoleArn"].write(value.cloudWatchLogsRoleArn)
        try writer["ExcludeVerboseContent"].write(value.excludeVerboseContent)
        try writer["FieldLogLevel"].write(value.fieldLogLevel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAppSyncGraphQlApiLogConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAppSyncGraphQlApiLogConfigDetails()
        value.cloudWatchLogsRoleArn = try reader["CloudWatchLogsRoleArn"].readIfPresent()
        value.excludeVerboseContent = try reader["ExcludeVerboseContent"].readIfPresent()
        value.fieldLogLevel = try reader["FieldLogLevel"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAmazonMqBrokerDetails {

    static func write(value: SecurityHubClientTypes.AwsAmazonMqBrokerDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationStrategy"].write(value.authenticationStrategy)
        try writer["AutoMinorVersionUpgrade"].write(value.autoMinorVersionUpgrade)
        try writer["BrokerArn"].write(value.brokerArn)
        try writer["BrokerId"].write(value.brokerId)
        try writer["BrokerName"].write(value.brokerName)
        try writer["DeploymentMode"].write(value.deploymentMode)
        try writer["EncryptionOptions"].write(value.encryptionOptions, with: SecurityHubClientTypes.AwsAmazonMqBrokerEncryptionOptionsDetails.write(value:to:))
        try writer["EngineType"].write(value.engineType)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["HostInstanceType"].write(value.hostInstanceType)
        try writer["LdapServerMetadata"].write(value.ldapServerMetadata, with: SecurityHubClientTypes.AwsAmazonMqBrokerLdapServerMetadataDetails.write(value:to:))
        try writer["Logs"].write(value.logs, with: SecurityHubClientTypes.AwsAmazonMqBrokerLogsDetails.write(value:to:))
        try writer["MaintenanceWindowStartTime"].write(value.maintenanceWindowStartTime, with: SecurityHubClientTypes.AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails.write(value:to:))
        try writer["PubliclyAccessible"].write(value.publiclyAccessible)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StorageType"].write(value.storageType)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Users"].writeList(value.users, memberWritingClosure: SecurityHubClientTypes.AwsAmazonMqBrokerUsersDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAmazonMqBrokerDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAmazonMqBrokerDetails()
        value.authenticationStrategy = try reader["AuthenticationStrategy"].readIfPresent()
        value.autoMinorVersionUpgrade = try reader["AutoMinorVersionUpgrade"].readIfPresent()
        value.brokerArn = try reader["BrokerArn"].readIfPresent()
        value.brokerName = try reader["BrokerName"].readIfPresent()
        value.deploymentMode = try reader["DeploymentMode"].readIfPresent()
        value.encryptionOptions = try reader["EncryptionOptions"].readIfPresent(with: SecurityHubClientTypes.AwsAmazonMqBrokerEncryptionOptionsDetails.read(from:))
        value.engineType = try reader["EngineType"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.hostInstanceType = try reader["HostInstanceType"].readIfPresent()
        value.brokerId = try reader["BrokerId"].readIfPresent()
        value.ldapServerMetadata = try reader["LdapServerMetadata"].readIfPresent(with: SecurityHubClientTypes.AwsAmazonMqBrokerLdapServerMetadataDetails.read(from:))
        value.logs = try reader["Logs"].readIfPresent(with: SecurityHubClientTypes.AwsAmazonMqBrokerLogsDetails.read(from:))
        value.maintenanceWindowStartTime = try reader["MaintenanceWindowStartTime"].readIfPresent(with: SecurityHubClientTypes.AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails.read(from:))
        value.publiclyAccessible = try reader["PubliclyAccessible"].readIfPresent()
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.storageType = try reader["StorageType"].readIfPresent()
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsAmazonMqBrokerUsersDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsAmazonMqBrokerUsersDetails {

    static func write(value: SecurityHubClientTypes.AwsAmazonMqBrokerUsersDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PendingChange"].write(value.pendingChange)
        try writer["Username"].write(value.username)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAmazonMqBrokerUsersDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAmazonMqBrokerUsersDetails()
        value.pendingChange = try reader["PendingChange"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails {

    static func write(value: SecurityHubClientTypes.AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfWeek"].write(value.dayOfWeek)
        try writer["TimeOfDay"].write(value.timeOfDay)
        try writer["TimeZone"].write(value.timeZone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails()
        value.dayOfWeek = try reader["DayOfWeek"].readIfPresent()
        value.timeOfDay = try reader["TimeOfDay"].readIfPresent()
        value.timeZone = try reader["TimeZone"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAmazonMqBrokerLogsDetails {

    static func write(value: SecurityHubClientTypes.AwsAmazonMqBrokerLogsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Audit"].write(value.audit)
        try writer["AuditLogGroup"].write(value.auditLogGroup)
        try writer["General"].write(value.general)
        try writer["GeneralLogGroup"].write(value.generalLogGroup)
        try writer["Pending"].write(value.pending, with: SecurityHubClientTypes.AwsAmazonMqBrokerLogsPendingDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAmazonMqBrokerLogsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAmazonMqBrokerLogsDetails()
        value.audit = try reader["Audit"].readIfPresent()
        value.general = try reader["General"].readIfPresent()
        value.auditLogGroup = try reader["AuditLogGroup"].readIfPresent()
        value.generalLogGroup = try reader["GeneralLogGroup"].readIfPresent()
        value.pending = try reader["Pending"].readIfPresent(with: SecurityHubClientTypes.AwsAmazonMqBrokerLogsPendingDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsAmazonMqBrokerLogsPendingDetails {

    static func write(value: SecurityHubClientTypes.AwsAmazonMqBrokerLogsPendingDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Audit"].write(value.audit)
        try writer["General"].write(value.general)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAmazonMqBrokerLogsPendingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAmazonMqBrokerLogsPendingDetails()
        value.audit = try reader["Audit"].readIfPresent()
        value.general = try reader["General"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAmazonMqBrokerLdapServerMetadataDetails {

    static func write(value: SecurityHubClientTypes.AwsAmazonMqBrokerLdapServerMetadataDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hosts"].writeList(value.hosts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoleBase"].write(value.roleBase)
        try writer["RoleName"].write(value.roleName)
        try writer["RoleSearchMatching"].write(value.roleSearchMatching)
        try writer["RoleSearchSubtree"].write(value.roleSearchSubtree)
        try writer["ServiceAccountUsername"].write(value.serviceAccountUsername)
        try writer["UserBase"].write(value.userBase)
        try writer["UserRoleName"].write(value.userRoleName)
        try writer["UserSearchMatching"].write(value.userSearchMatching)
        try writer["UserSearchSubtree"].write(value.userSearchSubtree)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAmazonMqBrokerLdapServerMetadataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAmazonMqBrokerLdapServerMetadataDetails()
        value.hosts = try reader["Hosts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleBase = try reader["RoleBase"].readIfPresent()
        value.roleName = try reader["RoleName"].readIfPresent()
        value.roleSearchMatching = try reader["RoleSearchMatching"].readIfPresent()
        value.roleSearchSubtree = try reader["RoleSearchSubtree"].readIfPresent()
        value.serviceAccountUsername = try reader["ServiceAccountUsername"].readIfPresent()
        value.userBase = try reader["UserBase"].readIfPresent()
        value.userRoleName = try reader["UserRoleName"].readIfPresent()
        value.userSearchMatching = try reader["UserSearchMatching"].readIfPresent()
        value.userSearchSubtree = try reader["UserSearchSubtree"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAmazonMqBrokerEncryptionOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsAmazonMqBrokerEncryptionOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["UseAwsOwnedKey"].write(value.useAwsOwnedKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAmazonMqBrokerEncryptionOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAmazonMqBrokerEncryptionOptionsDetails()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.useAwsOwnedKey = try reader["UseAwsOwnedKey"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2RouteTableDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2RouteTableDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationSet"].writeList(value.associationSet, memberWritingClosure: SecurityHubClientTypes.AssociationSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OwnerId"].write(value.ownerId)
        try writer["PropagatingVgwSet"].writeList(value.propagatingVgwSet, memberWritingClosure: SecurityHubClientTypes.PropagatingVgwSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RouteSet"].writeList(value.routeSet, memberWritingClosure: SecurityHubClientTypes.RouteSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RouteTableId"].write(value.routeTableId)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2RouteTableDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2RouteTableDetails()
        value.associationSet = try reader["AssociationSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AssociationSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.propagatingVgwSet = try reader["PropagatingVgwSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.PropagatingVgwSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeTableId = try reader["RouteTableId"].readIfPresent()
        value.routeSet = try reader["RouteSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RouteSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.RouteSetDetails {

    static func write(value: SecurityHubClientTypes.RouteSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CarrierGatewayId"].write(value.carrierGatewayId)
        try writer["CoreNetworkArn"].write(value.coreNetworkArn)
        try writer["DestinationCidrBlock"].write(value.destinationCidrBlock)
        try writer["DestinationIpv6CidrBlock"].write(value.destinationIpv6CidrBlock)
        try writer["DestinationPrefixListId"].write(value.destinationPrefixListId)
        try writer["EgressOnlyInternetGatewayId"].write(value.egressOnlyInternetGatewayId)
        try writer["GatewayId"].write(value.gatewayId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["InstanceOwnerId"].write(value.instanceOwnerId)
        try writer["LocalGatewayId"].write(value.localGatewayId)
        try writer["NatGatewayId"].write(value.natGatewayId)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["Origin"].write(value.origin)
        try writer["State"].write(value.state)
        try writer["TransitGatewayId"].write(value.transitGatewayId)
        try writer["VpcPeeringConnectionId"].write(value.vpcPeeringConnectionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RouteSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RouteSetDetails()
        value.carrierGatewayId = try reader["CarrierGatewayId"].readIfPresent()
        value.coreNetworkArn = try reader["CoreNetworkArn"].readIfPresent()
        value.destinationCidrBlock = try reader["DestinationCidrBlock"].readIfPresent()
        value.destinationIpv6CidrBlock = try reader["DestinationIpv6CidrBlock"].readIfPresent()
        value.destinationPrefixListId = try reader["DestinationPrefixListId"].readIfPresent()
        value.egressOnlyInternetGatewayId = try reader["EgressOnlyInternetGatewayId"].readIfPresent()
        value.gatewayId = try reader["GatewayId"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.instanceOwnerId = try reader["InstanceOwnerId"].readIfPresent()
        value.localGatewayId = try reader["LocalGatewayId"].readIfPresent()
        value.natGatewayId = try reader["NatGatewayId"].readIfPresent()
        value.networkInterfaceId = try reader["NetworkInterfaceId"].readIfPresent()
        value.origin = try reader["Origin"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.transitGatewayId = try reader["TransitGatewayId"].readIfPresent()
        value.vpcPeeringConnectionId = try reader["VpcPeeringConnectionId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.PropagatingVgwSetDetails {

    static func write(value: SecurityHubClientTypes.PropagatingVgwSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GatewayId"].write(value.gatewayId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.PropagatingVgwSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.PropagatingVgwSetDetails()
        value.gatewayId = try reader["GatewayId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AssociationSetDetails {

    static func write(value: SecurityHubClientTypes.AssociationSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationState"].write(value.associationState, with: SecurityHubClientTypes.AssociationStateDetails.write(value:to:))
        try writer["GatewayId"].write(value.gatewayId)
        try writer["Main"].write(value.main)
        try writer["RouteTableAssociationId"].write(value.routeTableAssociationId)
        try writer["RouteTableId"].write(value.routeTableId)
        try writer["SubnetId"].write(value.subnetId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AssociationSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AssociationSetDetails()
        value.associationState = try reader["AssociationState"].readIfPresent(with: SecurityHubClientTypes.AssociationStateDetails.read(from:))
        value.gatewayId = try reader["GatewayId"].readIfPresent()
        value.main = try reader["Main"].readIfPresent()
        value.routeTableAssociationId = try reader["RouteTableAssociationId"].readIfPresent()
        value.routeTableId = try reader["RouteTableId"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AssociationStateDetails {

    static func write(value: SecurityHubClientTypes.AssociationStateDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
        try writer["StatusMessage"].write(value.statusMessage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AssociationStateDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AssociationStateDetails()
        value.state = try reader["State"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2RuleGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2RuleGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Capacity"].write(value.capacity)
        try writer["Description"].write(value.description)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: SecurityHubClientTypes.AwsWafv2RulesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Scope"].write(value.scope)
        try writer["VisibilityConfig"].write(value.visibilityConfig, with: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2RuleGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2RuleGroupDetails()
        value.capacity = try reader["Capacity"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafv2RulesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scope = try reader["Scope"].readIfPresent()
        value.visibilityConfig = try reader["VisibilityConfig"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchMetricsEnabled"].write(value.cloudWatchMetricsEnabled)
        try writer["MetricName"].write(value.metricName)
        try writer["SampledRequestsEnabled"].write(value.sampledRequestsEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails()
        value.cloudWatchMetricsEnabled = try reader["CloudWatchMetricsEnabled"].readIfPresent()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.sampledRequestsEnabled = try reader["SampledRequestsEnabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2RulesDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2RulesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: SecurityHubClientTypes.AwsWafv2RulesActionDetails.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["OverrideAction"].write(value.overrideAction)
        try writer["Priority"].write(value.priority)
        try writer["VisibilityConfig"].write(value.visibilityConfig, with: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2RulesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2RulesDetails()
        value.action = try reader["Action"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2RulesActionDetails.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.overrideAction = try reader["OverrideAction"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent()
        value.visibilityConfig = try reader["VisibilityConfig"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2RulesActionDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2RulesActionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Allow"].write(value.allow, with: SecurityHubClientTypes.AwsWafv2ActionAllowDetails.write(value:to:))
        try writer["Block"].write(value.block, with: SecurityHubClientTypes.AwsWafv2ActionBlockDetails.write(value:to:))
        try writer["Captcha"].write(value.captcha, with: SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails.write(value:to:))
        try writer["Count"].write(value.count, with: SecurityHubClientTypes.AwsWafv2RulesActionCountDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2RulesActionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2RulesActionDetails()
        value.allow = try reader["Allow"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2ActionAllowDetails.read(from:))
        value.block = try reader["Block"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2ActionBlockDetails.read(from:))
        value.captcha = try reader["Captcha"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails.read(from:))
        value.count = try reader["Count"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2RulesActionCountDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2RulesActionCountDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2RulesActionCountDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomRequestHandling"].write(value.customRequestHandling, with: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2RulesActionCountDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2RulesActionCountDetails()
        value.customRequestHandling = try reader["CustomRequestHandling"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsertHeaders"].writeList(value.insertHeaders, memberWritingClosure: SecurityHubClientTypes.AwsWafv2CustomHttpHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails()
        value.insertHeaders = try reader["InsertHeaders"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafv2CustomHttpHeader.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2CustomHttpHeader {

    static func write(value: SecurityHubClientTypes.AwsWafv2CustomHttpHeader?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2CustomHttpHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2CustomHttpHeader()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomRequestHandling"].write(value.customRequestHandling, with: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails()
        value.customRequestHandling = try reader["CustomRequestHandling"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2ActionBlockDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2ActionBlockDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomResponse"].write(value.customResponse, with: SecurityHubClientTypes.AwsWafv2CustomResponseDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2ActionBlockDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2ActionBlockDetails()
        value.customResponse = try reader["CustomResponse"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2CustomResponseDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2CustomResponseDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2CustomResponseDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomResponseBodyKey"].write(value.customResponseBodyKey)
        try writer["ResponseCode"].write(value.responseCode)
        try writer["ResponseHeaders"].writeList(value.responseHeaders, memberWritingClosure: SecurityHubClientTypes.AwsWafv2CustomHttpHeader.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2CustomResponseDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2CustomResponseDetails()
        value.customResponseBodyKey = try reader["CustomResponseBodyKey"].readIfPresent()
        value.responseCode = try reader["ResponseCode"].readIfPresent()
        value.responseHeaders = try reader["ResponseHeaders"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafv2CustomHttpHeader.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2ActionAllowDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2ActionAllowDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomRequestHandling"].write(value.customRequestHandling, with: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2ActionAllowDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2ActionAllowDetails()
        value.customRequestHandling = try reader["CustomRequestHandling"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2WebAclDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2WebAclDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Capacity"].write(value.capacity)
        try writer["CaptchaConfig"].write(value.captchaConfig, with: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails.write(value:to:))
        try writer["DefaultAction"].write(value.defaultAction, with: SecurityHubClientTypes.AwsWafv2WebAclActionDetails.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["Id"].write(value.id)
        try writer["ManagedbyFirewallManager"].write(value.managedbyFirewallManager)
        try writer["Name"].write(value.name)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: SecurityHubClientTypes.AwsWafv2RulesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VisibilityConfig"].write(value.visibilityConfig, with: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2WebAclDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2WebAclDetails()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.managedbyFirewallManager = try reader["ManagedbyFirewallManager"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.capacity = try reader["Capacity"].readIfPresent()
        value.captchaConfig = try reader["CaptchaConfig"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails.read(from:))
        value.defaultAction = try reader["DefaultAction"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2WebAclActionDetails.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafv2RulesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.visibilityConfig = try reader["VisibilityConfig"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2WebAclActionDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2WebAclActionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Allow"].write(value.allow, with: SecurityHubClientTypes.AwsWafv2ActionAllowDetails.write(value:to:))
        try writer["Block"].write(value.block, with: SecurityHubClientTypes.AwsWafv2ActionBlockDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2WebAclActionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2WebAclActionDetails()
        value.allow = try reader["Allow"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2ActionAllowDetails.read(from:))
        value.block = try reader["Block"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2ActionBlockDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImmunityTimeProperty"].write(value.immunityTimeProperty, with: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails()
        value.immunityTimeProperty = try reader["ImmunityTimeProperty"].readIfPresent(with: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails {

    static func write(value: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImmunityTime"].write(value.immunityTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails()
        value.immunityTime = try reader["ImmunityTime"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails {

    static func write(value: SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorTypes"].writeList(value.acceleratorTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AdditionalCodeRepositories"].writeList(value.additionalCodeRepositories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DefaultCodeRepository"].write(value.defaultCodeRepository)
        try writer["DirectInternetAccess"].write(value.directInternetAccess)
        try writer["FailureReason"].write(value.failureReason)
        try writer["InstanceMetadataServiceConfiguration"].write(value.instanceMetadataServiceConfiguration, with: SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails.write(value:to:))
        try writer["InstanceType"].write(value.instanceType)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["NotebookInstanceArn"].write(value.notebookInstanceArn)
        try writer["NotebookInstanceLifecycleConfigName"].write(value.notebookInstanceLifecycleConfigName)
        try writer["NotebookInstanceName"].write(value.notebookInstanceName)
        try writer["NotebookInstanceStatus"].write(value.notebookInstanceStatus)
        try writer["PlatformIdentifier"].write(value.platformIdentifier)
        try writer["RoleArn"].write(value.roleArn)
        try writer["RootAccess"].write(value.rootAccess)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetId"].write(value.subnetId)
        try writer["Url"].write(value.url)
        try writer["VolumeSizeInGB"].write(value.volumeSizeInGB)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails()
        value.acceleratorTypes = try reader["AcceleratorTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.additionalCodeRepositories = try reader["AdditionalCodeRepositories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.defaultCodeRepository = try reader["DefaultCodeRepository"].readIfPresent()
        value.directInternetAccess = try reader["DirectInternetAccess"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.instanceMetadataServiceConfiguration = try reader["InstanceMetadataServiceConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails.read(from:))
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.networkInterfaceId = try reader["NetworkInterfaceId"].readIfPresent()
        value.notebookInstanceArn = try reader["NotebookInstanceArn"].readIfPresent()
        value.notebookInstanceLifecycleConfigName = try reader["NotebookInstanceLifecycleConfigName"].readIfPresent()
        value.notebookInstanceName = try reader["NotebookInstanceName"].readIfPresent()
        value.notebookInstanceStatus = try reader["NotebookInstanceStatus"].readIfPresent()
        value.platformIdentifier = try reader["PlatformIdentifier"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.rootAccess = try reader["RootAccess"].readIfPresent()
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        value.volumeSizeInGB = try reader["VolumeSizeInGB"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MinimumInstanceMetadataServiceVersion"].write(value.minimumInstanceMetadataServiceVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails()
        value.minimumInstanceMetadataServiceVersion = try reader["MinimumInstanceMetadataServiceVersion"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultVersionNumber"].write(value.defaultVersionNumber)
        try writer["Id"].write(value.id)
        try writer["LatestVersionNumber"].write(value.latestVersionNumber)
        try writer["LaunchTemplateData"].write(value.launchTemplateData, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails.write(value:to:))
        try writer["LaunchTemplateName"].write(value.launchTemplateName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDetails()
        value.launchTemplateName = try reader["LaunchTemplateName"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.launchTemplateData = try reader["LaunchTemplateData"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails.read(from:))
        value.defaultVersionNumber = try reader["DefaultVersionNumber"].readIfPresent()
        value.latestVersionNumber = try reader["LatestVersionNumber"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlockDeviceMappingSet"].writeList(value.blockDeviceMappingSet, memberWritingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CapacityReservationSpecification"].write(value.capacityReservationSpecification, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails.write(value:to:))
        try writer["CpuOptions"].write(value.cpuOptions, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails.write(value:to:))
        try writer["CreditSpecification"].write(value.creditSpecification, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails.write(value:to:))
        try writer["DisableApiStop"].write(value.disableApiStop)
        try writer["DisableApiTermination"].write(value.disableApiTermination)
        try writer["EbsOptimized"].write(value.ebsOptimized)
        try writer["ElasticGpuSpecificationSet"].writeList(value.elasticGpuSpecificationSet, memberWritingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ElasticInferenceAcceleratorSet"].writeList(value.elasticInferenceAcceleratorSet, memberWritingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnclaveOptions"].write(value.enclaveOptions, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails.write(value:to:))
        try writer["HibernationOptions"].write(value.hibernationOptions, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails.write(value:to:))
        try writer["IamInstanceProfile"].write(value.iamInstanceProfile, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails.write(value:to:))
        try writer["ImageId"].write(value.imageId)
        try writer["InstanceInitiatedShutdownBehavior"].write(value.instanceInitiatedShutdownBehavior)
        try writer["InstanceMarketOptions"].write(value.instanceMarketOptions, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails.write(value:to:))
        try writer["InstanceRequirements"].write(value.instanceRequirements, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails.write(value:to:))
        try writer["InstanceType"].write(value.instanceType)
        try writer["KernelId"].write(value.kernelId)
        try writer["KeyName"].write(value.keyName)
        try writer["LicenseSet"].writeList(value.licenseSet, memberWritingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaintenanceOptions"].write(value.maintenanceOptions, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails.write(value:to:))
        try writer["MetadataOptions"].write(value.metadataOptions, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails.write(value:to:))
        try writer["Monitoring"].write(value.monitoring, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails.write(value:to:))
        try writer["NetworkInterfaceSet"].writeList(value.networkInterfaceSet, memberWritingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Placement"].write(value.placement, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails.write(value:to:))
        try writer["PrivateDnsNameOptions"].write(value.privateDnsNameOptions, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails.write(value:to:))
        try writer["RamDiskId"].write(value.ramDiskId)
        try writer["SecurityGroupIdSet"].writeList(value.securityGroupIdSet, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityGroupSet"].writeList(value.securityGroupSet, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserData"].write(value.userData)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails()
        value.blockDeviceMappingSet = try reader["BlockDeviceMappingSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.capacityReservationSpecification = try reader["CapacityReservationSpecification"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails.read(from:))
        value.cpuOptions = try reader["CpuOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails.read(from:))
        value.creditSpecification = try reader["CreditSpecification"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails.read(from:))
        value.disableApiStop = try reader["DisableApiStop"].readIfPresent()
        value.disableApiTermination = try reader["DisableApiTermination"].readIfPresent()
        value.ebsOptimized = try reader["EbsOptimized"].readIfPresent()
        value.elasticGpuSpecificationSet = try reader["ElasticGpuSpecificationSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.elasticInferenceAcceleratorSet = try reader["ElasticInferenceAcceleratorSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.enclaveOptions = try reader["EnclaveOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails.read(from:))
        value.hibernationOptions = try reader["HibernationOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails.read(from:))
        value.iamInstanceProfile = try reader["IamInstanceProfile"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails.read(from:))
        value.imageId = try reader["ImageId"].readIfPresent()
        value.instanceInitiatedShutdownBehavior = try reader["InstanceInitiatedShutdownBehavior"].readIfPresent()
        value.instanceMarketOptions = try reader["InstanceMarketOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails.read(from:))
        value.instanceRequirements = try reader["InstanceRequirements"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails.read(from:))
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.kernelId = try reader["KernelId"].readIfPresent()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.licenseSet = try reader["LicenseSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maintenanceOptions = try reader["MaintenanceOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails.read(from:))
        value.metadataOptions = try reader["MetadataOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails.read(from:))
        value.monitoring = try reader["Monitoring"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails.read(from:))
        value.networkInterfaceSet = try reader["NetworkInterfaceSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.placement = try reader["Placement"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails.read(from:))
        value.privateDnsNameOptions = try reader["PrivateDnsNameOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails.read(from:))
        value.ramDiskId = try reader["RamDiskId"].readIfPresent()
        value.securityGroupIdSet = try reader["SecurityGroupIdSet"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupSet = try reader["SecurityGroupSet"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.userData = try reader["UserData"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableResourceNameDnsAAAARecord"].write(value.enableResourceNameDnsAAAARecord)
        try writer["EnableResourceNameDnsARecord"].write(value.enableResourceNameDnsARecord)
        try writer["HostnameType"].write(value.hostnameType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails()
        value.enableResourceNameDnsAAAARecord = try reader["EnableResourceNameDnsAAAARecord"].readIfPresent()
        value.enableResourceNameDnsARecord = try reader["EnableResourceNameDnsARecord"].readIfPresent()
        value.hostnameType = try reader["HostnameType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Affinity"].write(value.affinity)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["GroupName"].write(value.groupName)
        try writer["HostId"].write(value.hostId)
        try writer["HostResourceGroupArn"].write(value.hostResourceGroupArn)
        try writer["PartitionNumber"].write(value.partitionNumber)
        try writer["SpreadDomain"].write(value.spreadDomain)
        try writer["Tenancy"].write(value.tenancy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails()
        value.affinity = try reader["Affinity"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.hostId = try reader["HostId"].readIfPresent()
        value.hostResourceGroupArn = try reader["HostResourceGroupArn"].readIfPresent()
        value.partitionNumber = try reader["PartitionNumber"].readIfPresent()
        value.spreadDomain = try reader["SpreadDomain"].readIfPresent()
        value.tenancy = try reader["Tenancy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociateCarrierIpAddress"].write(value.associateCarrierIpAddress)
        try writer["AssociatePublicIpAddress"].write(value.associatePublicIpAddress)
        try writer["DeleteOnTermination"].write(value.deleteOnTermination)
        try writer["Description"].write(value.description)
        try writer["DeviceIndex"].write(value.deviceIndex)
        try writer["Groups"].writeList(value.groups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InterfaceType"].write(value.interfaceType)
        try writer["Ipv4PrefixCount"].write(value.ipv4PrefixCount)
        try writer["Ipv4Prefixes"].writeList(value.ipv4Prefixes, memberWritingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ipv6AddressCount"].write(value.ipv6AddressCount)
        try writer["Ipv6Addresses"].writeList(value.ipv6Addresses, memberWritingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ipv6PrefixCount"].write(value.ipv6PrefixCount)
        try writer["Ipv6Prefixes"].writeList(value.ipv6Prefixes, memberWritingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkCardIndex"].write(value.networkCardIndex)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
        try writer["PrivateIpAddresses"].writeList(value.privateIpAddresses, memberWritingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecondaryPrivateIpAddressCount"].write(value.secondaryPrivateIpAddressCount)
        try writer["SubnetId"].write(value.subnetId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails()
        value.associateCarrierIpAddress = try reader["AssociateCarrierIpAddress"].readIfPresent()
        value.associatePublicIpAddress = try reader["AssociatePublicIpAddress"].readIfPresent()
        value.deleteOnTermination = try reader["DeleteOnTermination"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.deviceIndex = try reader["DeviceIndex"].readIfPresent()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.interfaceType = try reader["InterfaceType"].readIfPresent()
        value.ipv4PrefixCount = try reader["Ipv4PrefixCount"].readIfPresent()
        value.ipv4Prefixes = try reader["Ipv4Prefixes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipv6AddressCount = try reader["Ipv6AddressCount"].readIfPresent()
        value.ipv6Addresses = try reader["Ipv6Addresses"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipv6PrefixCount = try reader["Ipv6PrefixCount"].readIfPresent()
        value.ipv6Prefixes = try reader["Ipv6Prefixes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkCardIndex = try reader["NetworkCardIndex"].readIfPresent()
        value.networkInterfaceId = try reader["NetworkInterfaceId"].readIfPresent()
        value.privateIpAddress = try reader["PrivateIpAddress"].readIfPresent()
        value.privateIpAddresses = try reader["PrivateIpAddresses"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.secondaryPrivateIpAddressCount = try reader["SecondaryPrivateIpAddressCount"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Primary"].write(value.primary)
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails()
        value.primary = try reader["Primary"].readIfPresent()
        value.privateIpAddress = try reader["PrivateIpAddress"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv6Prefix"].write(value.ipv6Prefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails()
        value.ipv6Prefix = try reader["Ipv6Prefix"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv6Address"].write(value.ipv6Address)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails()
        value.ipv6Address = try reader["Ipv6Address"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv4Prefix"].write(value.ipv4Prefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails()
        value.ipv4Prefix = try reader["Ipv4Prefix"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpEndpoint"].write(value.httpEndpoint)
        try writer["HttpProtocolIpv6"].write(value.httpProtocolIpv6)
        try writer["HttpPutResponseHopLimit"].write(value.httpPutResponseHopLimit)
        try writer["HttpTokens"].write(value.httpTokens)
        try writer["InstanceMetadataTags"].write(value.instanceMetadataTags)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails()
        value.httpEndpoint = try reader["HttpEndpoint"].readIfPresent()
        value.httpProtocolIpv6 = try reader["HttpProtocolIpv6"].readIfPresent()
        value.httpTokens = try reader["HttpTokens"].readIfPresent()
        value.httpPutResponseHopLimit = try reader["HttpPutResponseHopLimit"].readIfPresent()
        value.instanceMetadataTags = try reader["InstanceMetadataTags"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoRecovery"].write(value.autoRecovery)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails()
        value.autoRecovery = try reader["AutoRecovery"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails()
        value.licenseConfigurationArn = try reader["LicenseConfigurationArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceleratorCount"].write(value.acceleratorCount, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails.write(value:to:))
        try writer["AcceleratorManufacturers"].writeList(value.acceleratorManufacturers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AcceleratorNames"].writeList(value.acceleratorNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AcceleratorTotalMemoryMiB"].write(value.acceleratorTotalMemoryMiB, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails.write(value:to:))
        try writer["AcceleratorTypes"].writeList(value.acceleratorTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BareMetal"].write(value.bareMetal)
        try writer["BaselineEbsBandwidthMbps"].write(value.baselineEbsBandwidthMbps, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails.write(value:to:))
        try writer["BurstablePerformance"].write(value.burstablePerformance)
        try writer["CpuManufacturers"].writeList(value.cpuManufacturers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludedInstanceTypes"].writeList(value.excludedInstanceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InstanceGenerations"].writeList(value.instanceGenerations, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LocalStorage"].write(value.localStorage)
        try writer["LocalStorageTypes"].writeList(value.localStorageTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MemoryGiBPerVCpu"].write(value.memoryGiBPerVCpu, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails.write(value:to:))
        try writer["MemoryMiB"].write(value.memoryMiB, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails.write(value:to:))
        try writer["NetworkInterfaceCount"].write(value.networkInterfaceCount, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails.write(value:to:))
        try writer["OnDemandMaxPricePercentageOverLowestPrice"].write(value.onDemandMaxPricePercentageOverLowestPrice)
        try writer["RequireHibernateSupport"].write(value.requireHibernateSupport)
        try writer["SpotMaxPricePercentageOverLowestPrice"].write(value.spotMaxPricePercentageOverLowestPrice)
        try writer["TotalLocalStorageGB"].write(value.totalLocalStorageGB, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails.write(value:to:))
        try writer["VCpuCount"].write(value.vCpuCount, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails()
        value.acceleratorCount = try reader["AcceleratorCount"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails.read(from:))
        value.acceleratorManufacturers = try reader["AcceleratorManufacturers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.acceleratorNames = try reader["AcceleratorNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.acceleratorTotalMemoryMiB = try reader["AcceleratorTotalMemoryMiB"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails.read(from:))
        value.acceleratorTypes = try reader["AcceleratorTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.bareMetal = try reader["BareMetal"].readIfPresent()
        value.baselineEbsBandwidthMbps = try reader["BaselineEbsBandwidthMbps"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails.read(from:))
        value.burstablePerformance = try reader["BurstablePerformance"].readIfPresent()
        value.cpuManufacturers = try reader["CpuManufacturers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.excludedInstanceTypes = try reader["ExcludedInstanceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.instanceGenerations = try reader["InstanceGenerations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.localStorage = try reader["LocalStorage"].readIfPresent()
        value.localStorageTypes = try reader["LocalStorageTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.memoryGiBPerVCpu = try reader["MemoryGiBPerVCpu"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails.read(from:))
        value.memoryMiB = try reader["MemoryMiB"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails.read(from:))
        value.networkInterfaceCount = try reader["NetworkInterfaceCount"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails.read(from:))
        value.onDemandMaxPricePercentageOverLowestPrice = try reader["OnDemandMaxPricePercentageOverLowestPrice"].readIfPresent()
        value.requireHibernateSupport = try reader["RequireHibernateSupport"].readIfPresent()
        value.spotMaxPricePercentageOverLowestPrice = try reader["SpotMaxPricePercentageOverLowestPrice"].readIfPresent()
        value.totalLocalStorageGB = try reader["TotalLocalStorageGB"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails.read(from:))
        value.vCpuCount = try reader["VCpuCount"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Max"].write(value.max)
        try writer["Min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails()
        value.max = try reader["Max"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Max"].write(value.max)
        try writer["Min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails()
        value.max = try reader["Max"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Max"].write(value.max)
        try writer["Min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails()
        value.max = try reader["Max"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Max"].write(value.max)
        try writer["Min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails()
        value.max = try reader["Max"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Max"].write(value.max)
        try writer["Min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails()
        value.max = try reader["Max"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Max"].write(value.max)
        try writer["Min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails()
        value.max = try reader["Max"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Max"].write(value.max)
        try writer["Min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails()
        value.max = try reader["Max"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Max"].write(value.max)
        try writer["Min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails()
        value.max = try reader["Max"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MarketType"].write(value.marketType)
        try writer["SpotOptions"].write(value.spotOptions, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails()
        value.marketType = try reader["MarketType"].readIfPresent()
        value.spotOptions = try reader["SpotOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlockDurationMinutes"].write(value.blockDurationMinutes)
        try writer["InstanceInterruptionBehavior"].write(value.instanceInterruptionBehavior)
        try writer["MaxPrice"].write(value.maxPrice)
        try writer["SpotInstanceType"].write(value.spotInstanceType)
        try writer["ValidUntil"].write(value.validUntil)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails()
        value.blockDurationMinutes = try reader["BlockDurationMinutes"].readIfPresent()
        value.instanceInterruptionBehavior = try reader["InstanceInterruptionBehavior"].readIfPresent()
        value.maxPrice = try reader["MaxPrice"].readIfPresent()
        value.spotInstanceType = try reader["SpotInstanceType"].readIfPresent()
        value.validUntil = try reader["ValidUntil"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configured"].write(value.configured)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails()
        value.configured = try reader["Configured"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Count"].write(value.count)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails()
        value.count = try reader["Count"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CpuCredits"].write(value.cpuCredits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails()
        value.cpuCredits = try reader["CpuCredits"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CoreCount"].write(value.coreCount)
        try writer["ThreadsPerCore"].write(value.threadsPerCore)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails()
        value.coreCount = try reader["CoreCount"].readIfPresent()
        value.threadsPerCore = try reader["ThreadsPerCore"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityReservationPreference"].write(value.capacityReservationPreference)
        try writer["CapacityReservationTarget"].write(value.capacityReservationTarget, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails()
        value.capacityReservationPreference = try reader["CapacityReservationPreference"].readIfPresent()
        value.capacityReservationTarget = try reader["CapacityReservationTarget"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityReservationId"].write(value.capacityReservationId)
        try writer["CapacityReservationResourceGroupArn"].write(value.capacityReservationResourceGroupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails()
        value.capacityReservationId = try reader["CapacityReservationId"].readIfPresent()
        value.capacityReservationResourceGroupArn = try reader["CapacityReservationResourceGroupArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceName"].write(value.deviceName)
        try writer["Ebs"].write(value.ebs, with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails.write(value:to:))
        try writer["NoDevice"].write(value.noDevice)
        try writer["VirtualName"].write(value.virtualName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.ebs = try reader["Ebs"].readIfPresent(with: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails.read(from:))
        value.noDevice = try reader["NoDevice"].readIfPresent()
        value.virtualName = try reader["VirtualName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteOnTermination"].write(value.deleteOnTermination)
        try writer["Encrypted"].write(value.encrypted)
        try writer["Iops"].write(value.iops)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["SnapshotId"].write(value.snapshotId)
        try writer["Throughput"].write(value.throughput)
        try writer["VolumeSize"].write(value.volumeSize)
        try writer["VolumeType"].write(value.volumeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails()
        value.deleteOnTermination = try reader["DeleteOnTermination"].readIfPresent()
        value.encrypted = try reader["Encrypted"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.snapshotId = try reader["SnapshotId"].readIfPresent()
        value.throughput = try reader["Throughput"].readIfPresent()
        value.volumeSize = try reader["VolumeSize"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupRecoveryPointDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupRecoveryPointDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupSizeInBytes"].write(value.backupSizeInBytes)
        try writer["BackupVaultArn"].write(value.backupVaultArn)
        try writer["BackupVaultName"].write(value.backupVaultName)
        try writer["CalculatedLifecycle"].write(value.calculatedLifecycle, with: SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails.write(value:to:))
        try writer["CompletionDate"].write(value.completionDate)
        try writer["CreatedBy"].write(value.createdBy, with: SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails.write(value:to:))
        try writer["CreationDate"].write(value.creationDate)
        try writer["EncryptionKeyArn"].write(value.encryptionKeyArn)
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["IsEncrypted"].write(value.isEncrypted)
        try writer["LastRestoreTime"].write(value.lastRestoreTime)
        try writer["Lifecycle"].write(value.lifecycle, with: SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails.write(value:to:))
        try writer["RecoveryPointArn"].write(value.recoveryPointArn)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceType"].write(value.resourceType)
        try writer["SourceBackupVaultArn"].write(value.sourceBackupVaultArn)
        try writer["Status"].write(value.status)
        try writer["StatusMessage"].write(value.statusMessage)
        try writer["StorageClass"].write(value.storageClass)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupRecoveryPointDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupRecoveryPointDetails()
        value.backupSizeInBytes = try reader["BackupSizeInBytes"].readIfPresent()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.calculatedLifecycle = try reader["CalculatedLifecycle"].readIfPresent(with: SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails.read(from:))
        value.completionDate = try reader["CompletionDate"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails.read(from:))
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        value.isEncrypted = try reader["IsEncrypted"].readIfPresent()
        value.lastRestoreTime = try reader["LastRestoreTime"].readIfPresent()
        value.lifecycle = try reader["Lifecycle"].readIfPresent(with: SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails.read(from:))
        value.recoveryPointArn = try reader["RecoveryPointArn"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.sourceBackupVaultArn = try reader["SourceBackupVaultArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.storageClass = try reader["StorageClass"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteAfterDays"].write(value.deleteAfterDays)
        try writer["MoveToColdStorageAfterDays"].write(value.moveToColdStorageAfterDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails()
        value.deleteAfterDays = try reader["DeleteAfterDays"].readIfPresent()
        value.moveToColdStorageAfterDays = try reader["MoveToColdStorageAfterDays"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupPlanArn"].write(value.backupPlanArn)
        try writer["BackupPlanId"].write(value.backupPlanId)
        try writer["BackupPlanVersion"].write(value.backupPlanVersion)
        try writer["BackupRuleId"].write(value.backupRuleId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails()
        value.backupPlanArn = try reader["BackupPlanArn"].readIfPresent()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.backupPlanVersion = try reader["BackupPlanVersion"].readIfPresent()
        value.backupRuleId = try reader["BackupRuleId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteAt"].write(value.deleteAt)
        try writer["MoveToColdStorageAt"].write(value.moveToColdStorageAt)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails()
        value.deleteAt = try reader["DeleteAt"].readIfPresent()
        value.moveToColdStorageAt = try reader["MoveToColdStorageAt"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupBackupPlanDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupBackupPlanDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupPlan"].write(value.backupPlan, with: SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails.write(value:to:))
        try writer["BackupPlanArn"].write(value.backupPlanArn)
        try writer["BackupPlanId"].write(value.backupPlanId)
        try writer["VersionId"].write(value.versionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupBackupPlanDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupBackupPlanDetails()
        value.backupPlan = try reader["BackupPlan"].readIfPresent(with: SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails.read(from:))
        value.backupPlanArn = try reader["BackupPlanArn"].readIfPresent()
        value.backupPlanId = try reader["BackupPlanId"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdvancedBackupSettings"].writeList(value.advancedBackupSettings, memberWritingClosure: SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BackupPlanName"].write(value.backupPlanName)
        try writer["BackupPlanRule"].writeList(value.backupPlanRule, memberWritingClosure: SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails()
        value.backupPlanName = try reader["BackupPlanName"].readIfPresent()
        value.advancedBackupSettings = try reader["AdvancedBackupSettings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.backupPlanRule = try reader["BackupPlanRule"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CompletionWindowMinutes"].write(value.completionWindowMinutes)
        try writer["CopyActions"].writeList(value.copyActions, memberWritingClosure: SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnableContinuousBackup"].write(value.enableContinuousBackup)
        try writer["Lifecycle"].write(value.lifecycle, with: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails.write(value:to:))
        try writer["RuleId"].write(value.ruleId)
        try writer["RuleName"].write(value.ruleName)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
        try writer["StartWindowMinutes"].write(value.startWindowMinutes)
        try writer["TargetBackupVault"].write(value.targetBackupVault)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails()
        value.targetBackupVault = try reader["TargetBackupVault"].readIfPresent()
        value.startWindowMinutes = try reader["StartWindowMinutes"].readIfPresent()
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.ruleId = try reader["RuleId"].readIfPresent()
        value.enableContinuousBackup = try reader["EnableContinuousBackup"].readIfPresent()
        value.completionWindowMinutes = try reader["CompletionWindowMinutes"].readIfPresent()
        value.copyActions = try reader["CopyActions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lifecycle = try reader["Lifecycle"].readIfPresent(with: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteAfterDays"].write(value.deleteAfterDays)
        try writer["MoveToColdStorageAfterDays"].write(value.moveToColdStorageAfterDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails()
        value.deleteAfterDays = try reader["DeleteAfterDays"].readIfPresent()
        value.moveToColdStorageAfterDays = try reader["MoveToColdStorageAfterDays"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationBackupVaultArn"].write(value.destinationBackupVaultArn)
        try writer["Lifecycle"].write(value.lifecycle, with: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails()
        value.destinationBackupVaultArn = try reader["DestinationBackupVaultArn"].readIfPresent()
        value.lifecycle = try reader["Lifecycle"].readIfPresent(with: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupOptions"].writeMap(value.backupOptions, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails()
        value.backupOptions = try reader["BackupOptions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupBackupVaultDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupBackupVaultDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessPolicy"].write(value.accessPolicy)
        try writer["BackupVaultArn"].write(value.backupVaultArn)
        try writer["BackupVaultName"].write(value.backupVaultName)
        try writer["EncryptionKeyArn"].write(value.encryptionKeyArn)
        try writer["Notifications"].write(value.notifications, with: SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupBackupVaultDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupBackupVaultDetails()
        value.backupVaultArn = try reader["BackupVaultArn"].readIfPresent()
        value.backupVaultName = try reader["BackupVaultName"].readIfPresent()
        value.encryptionKeyArn = try reader["EncryptionKeyArn"].readIfPresent()
        value.notifications = try reader["Notifications"].readIfPresent(with: SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails.read(from:))
        value.accessPolicy = try reader["AccessPolicy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails {

    static func write(value: SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackupVaultEvents"].writeList(value.backupVaultEvents, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails()
        value.backupVaultEvents = try reader["BackupVaultEvents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.snsTopicArn = try reader["SnsTopicArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterArn"].write(value.clusterArn)
        try writer["Containers"].writeList(value.containers, memberWritingClosure: SecurityHubClientTypes.AwsEcsContainerDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreatedAt"].write(value.createdAt)
        try writer["Group"].write(value.group)
        try writer["StartedAt"].write(value.startedAt)
        try writer["StartedBy"].write(value.startedBy)
        try writer["TaskDefinitionArn"].write(value.taskDefinitionArn)
        try writer["Version"].write(value.version)
        try writer["Volumes"].writeList(value.volumes, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskVolumeDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDetails()
        value.clusterArn = try reader["ClusterArn"].readIfPresent()
        value.taskDefinitionArn = try reader["TaskDefinitionArn"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.startedAt = try reader["StartedAt"].readIfPresent()
        value.startedBy = try reader["StartedBy"].readIfPresent()
        value.group = try reader["Group"].readIfPresent()
        value.volumes = try reader["Volumes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskVolumeDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.containers = try reader["Containers"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsContainerDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsContainerDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsContainerDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Image"].write(value.image)
        try writer["MountPoints"].writeList(value.mountPoints, memberWritingClosure: SecurityHubClientTypes.AwsMountPoint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Privileged"].write(value.privileged)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsContainerDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsContainerDetails()
        value.name = try reader["Name"].readIfPresent()
        value.image = try reader["Image"].readIfPresent()
        value.mountPoints = try reader["MountPoints"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsMountPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.privileged = try reader["Privileged"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsMountPoint {

    static func write(value: SecurityHubClientTypes.AwsMountPoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerPath"].write(value.containerPath)
        try writer["SourceVolume"].write(value.sourceVolume)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsMountPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsMountPoint()
        value.sourceVolume = try reader["SourceVolume"].readIfPresent()
        value.containerPath = try reader["ContainerPath"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskVolumeDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskVolumeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Host"].write(value.host, with: SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails.write(value:to:))
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskVolumeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskVolumeDetails()
        value.name = try reader["Name"].readIfPresent()
        value.host = try reader["Host"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SourcePath"].write(value.sourcePath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails()
        value.sourcePath = try reader["SourcePath"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRuleGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRuleGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetricName"].write(value.metricName)
        try writer["Name"].write(value.name)
        try writer["RuleGroupId"].write(value.ruleGroupId)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: SecurityHubClientTypes.AwsWafRuleGroupRulesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRuleGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRuleGroupDetails()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ruleGroupId = try reader["RuleGroupId"].readIfPresent()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafRuleGroupRulesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRuleGroupRulesDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRuleGroupRulesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails.write(value:to:))
        try writer["Priority"].write(value.priority)
        try writer["RuleId"].write(value.ruleId)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRuleGroupRulesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRuleGroupRulesDetails()
        value.action = try reader["Action"].readIfPresent(with: SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails.read(from:))
        value.priority = try reader["Priority"].readIfPresent()
        value.ruleId = try reader["RuleId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRuleDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRuleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetricName"].write(value.metricName)
        try writer["Name"].write(value.name)
        try writer["PredicateList"].writeList(value.predicateList, memberWritingClosure: SecurityHubClientTypes.AwsWafRulePredicateListDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RuleId"].write(value.ruleId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRuleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRuleDetails()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.predicateList = try reader["PredicateList"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafRulePredicateListDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleId = try reader["RuleId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRulePredicateListDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRulePredicateListDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataId"].write(value.dataId)
        try writer["Negated"].write(value.negated)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRulePredicateListDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRulePredicateListDetails()
        value.dataId = try reader["DataId"].readIfPresent()
        value.negated = try reader["Negated"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalWebAclDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalWebAclDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultAction"].write(value.defaultAction)
        try writer["MetricName"].write(value.metricName)
        try writer["Name"].write(value.name)
        try writer["RulesList"].writeList(value.rulesList, memberWritingClosure: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WebAclId"].write(value.webAclId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalWebAclDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalWebAclDetails()
        value.defaultAction = try reader["DefaultAction"].readIfPresent()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.rulesList = try reader["RulesList"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.webAclId = try reader["WebAclId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails.write(value:to:))
        try writer["OverrideAction"].write(value.overrideAction, with: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails.write(value:to:))
        try writer["Priority"].write(value.priority)
        try writer["RuleId"].write(value.ruleId)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails()
        value.action = try reader["Action"].readIfPresent(with: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails.read(from:))
        value.overrideAction = try reader["OverrideAction"].readIfPresent(with: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails.read(from:))
        value.priority = try reader["Priority"].readIfPresent()
        value.ruleId = try reader["RuleId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalRuleDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalRuleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetricName"].write(value.metricName)
        try writer["Name"].write(value.name)
        try writer["PredicateList"].writeList(value.predicateList, memberWritingClosure: SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RuleId"].write(value.ruleId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalRuleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalRuleDetails()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.predicateList = try reader["PredicateList"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleId = try reader["RuleId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataId"].write(value.dataId)
        try writer["Negated"].write(value.negated)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails()
        value.dataId = try reader["DataId"].readIfPresent()
        value.negated = try reader["Negated"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MetricName"].write(value.metricName)
        try writer["Name"].write(value.name)
        try writer["RuleGroupId"].write(value.ruleGroupId)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ruleGroupId = try reader["RuleGroupId"].readIfPresent()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails.write(value:to:))
        try writer["Priority"].write(value.priority)
        try writer["RuleId"].write(value.ruleId)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails()
        value.action = try reader["Action"].readIfPresent(with: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails.read(from:))
        value.priority = try reader["Priority"].readIfPresent()
        value.ruleId = try reader["RuleId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccepterVpcInfo"].write(value.accepterVpcInfo, with: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails.write(value:to:))
        try writer["ExpirationTime"].write(value.expirationTime)
        try writer["RequesterVpcInfo"].write(value.requesterVpcInfo, with: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails.write(value:to:))
        try writer["Status"].write(value.status, with: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails.write(value:to:))
        try writer["VpcPeeringConnectionId"].write(value.vpcPeeringConnectionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails()
        value.accepterVpcInfo = try reader["AccepterVpcInfo"].readIfPresent(with: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails.read(from:))
        value.expirationTime = try reader["ExpirationTime"].readIfPresent()
        value.requesterVpcInfo = try reader["RequesterVpcInfo"].readIfPresent(with: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails.read(from:))
        value.status = try reader["Status"].readIfPresent(with: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails.read(from:))
        value.vpcPeeringConnectionId = try reader["VpcPeeringConnectionId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
        try writer["Message"].write(value.message)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CidrBlock"].write(value.cidrBlock)
        try writer["CidrBlockSet"].writeList(value.cidrBlockSet, memberWritingClosure: SecurityHubClientTypes.VpcInfoCidrBlockSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ipv6CidrBlockSet"].writeList(value.ipv6CidrBlockSet, memberWritingClosure: SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OwnerId"].write(value.ownerId)
        try writer["PeeringOptions"].write(value.peeringOptions, with: SecurityHubClientTypes.VpcInfoPeeringOptionsDetails.write(value:to:))
        try writer["Region"].write(value.region)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails()
        value.cidrBlock = try reader["CidrBlock"].readIfPresent()
        value.cidrBlockSet = try reader["CidrBlockSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.VpcInfoCidrBlockSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipv6CidrBlockSet = try reader["Ipv6CidrBlockSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.peeringOptions = try reader["PeeringOptions"].readIfPresent(with: SecurityHubClientTypes.VpcInfoPeeringOptionsDetails.read(from:))
        value.region = try reader["Region"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.VpcInfoPeeringOptionsDetails {

    static func write(value: SecurityHubClientTypes.VpcInfoPeeringOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowDnsResolutionFromRemoteVpc"].write(value.allowDnsResolutionFromRemoteVpc)
        try writer["AllowEgressFromLocalClassicLinkToRemoteVpc"].write(value.allowEgressFromLocalClassicLinkToRemoteVpc)
        try writer["AllowEgressFromLocalVpcToRemoteClassicLink"].write(value.allowEgressFromLocalVpcToRemoteClassicLink)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.VpcInfoPeeringOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.VpcInfoPeeringOptionsDetails()
        value.allowDnsResolutionFromRemoteVpc = try reader["AllowDnsResolutionFromRemoteVpc"].readIfPresent()
        value.allowEgressFromLocalClassicLinkToRemoteVpc = try reader["AllowEgressFromLocalClassicLinkToRemoteVpc"].readIfPresent()
        value.allowEgressFromLocalVpcToRemoteClassicLink = try reader["AllowEgressFromLocalVpcToRemoteClassicLink"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails {

    static func write(value: SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv6CidrBlock"].write(value.ipv6CidrBlock)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails()
        value.ipv6CidrBlock = try reader["Ipv6CidrBlock"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.VpcInfoCidrBlockSetDetails {

    static func write(value: SecurityHubClientTypes.VpcInfoCidrBlockSetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CidrBlock"].write(value.cidrBlock)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.VpcInfoCidrBlockSetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.VpcInfoCidrBlockSetDetails()
        value.cidrBlock = try reader["CidrBlock"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudWatchAlarmDetails {

    static func write(value: SecurityHubClientTypes.AwsCloudWatchAlarmDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionsEnabled"].write(value.actionsEnabled)
        try writer["AlarmActions"].writeList(value.alarmActions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AlarmArn"].write(value.alarmArn)
        try writer["AlarmConfigurationUpdatedTimestamp"].write(value.alarmConfigurationUpdatedTimestamp)
        try writer["AlarmDescription"].write(value.alarmDescription)
        try writer["AlarmName"].write(value.alarmName)
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["DatapointsToAlarm"].write(value.datapointsToAlarm)
        try writer["Dimensions"].writeList(value.dimensions, memberWritingClosure: SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EvaluateLowSampleCountPercentile"].write(value.evaluateLowSampleCountPercentile)
        try writer["EvaluationPeriods"].write(value.evaluationPeriods)
        try writer["ExtendedStatistic"].write(value.extendedStatistic)
        try writer["InsufficientDataActions"].writeList(value.insufficientDataActions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricName"].write(value.metricName)
        try writer["Namespace"].write(value.namespace)
        try writer["OkActions"].writeList(value.okActions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Period"].write(value.period)
        try writer["Statistic"].write(value.statistic)
        try writer["Threshold"].write(value.threshold)
        try writer["ThresholdMetricId"].write(value.thresholdMetricId)
        try writer["TreatMissingData"].write(value.treatMissingData)
        try writer["Unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudWatchAlarmDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudWatchAlarmDetails()
        value.actionsEnabled = try reader["ActionsEnabled"].readIfPresent()
        value.alarmActions = try reader["AlarmActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.alarmArn = try reader["AlarmArn"].readIfPresent()
        value.alarmConfigurationUpdatedTimestamp = try reader["AlarmConfigurationUpdatedTimestamp"].readIfPresent()
        value.alarmDescription = try reader["AlarmDescription"].readIfPresent()
        value.alarmName = try reader["AlarmName"].readIfPresent()
        value.comparisonOperator = try reader["ComparisonOperator"].readIfPresent()
        value.datapointsToAlarm = try reader["DatapointsToAlarm"].readIfPresent()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.evaluateLowSampleCountPercentile = try reader["EvaluateLowSampleCountPercentile"].readIfPresent()
        value.evaluationPeriods = try reader["EvaluationPeriods"].readIfPresent()
        value.extendedStatistic = try reader["ExtendedStatistic"].readIfPresent()
        value.insufficientDataActions = try reader["InsufficientDataActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.metricName = try reader["MetricName"].readIfPresent()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.okActions = try reader["OkActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.period = try reader["Period"].readIfPresent()
        value.statistic = try reader["Statistic"].readIfPresent()
        value.threshold = try reader["Threshold"].readIfPresent()
        value.thresholdMetricId = try reader["ThresholdMetricId"].readIfPresent()
        value.treatMissingData = try reader["TreatMissingData"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails {

    static func write(value: SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFormationStackDetails {

    static func write(value: SecurityHubClientTypes.AwsCloudFormationStackDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreationTime"].write(value.creationTime)
        try writer["Description"].write(value.description)
        try writer["DisableRollback"].write(value.disableRollback)
        try writer["DriftInformation"].write(value.driftInformation, with: SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails.write(value:to:))
        try writer["EnableTerminationProtection"].write(value.enableTerminationProtection)
        try writer["LastUpdatedTime"].write(value.lastUpdatedTime)
        try writer["NotificationArns"].writeList(value.notificationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Outputs"].writeList(value.outputs, memberWritingClosure: SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RoleArn"].write(value.roleArn)
        try writer["StackId"].write(value.stackId)
        try writer["StackName"].write(value.stackName)
        try writer["StackStatus"].write(value.stackStatus)
        try writer["StackStatusReason"].write(value.stackStatusReason)
        try writer["TimeoutInMinutes"].write(value.timeoutInMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFormationStackDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFormationStackDetails()
        value.capabilities = try reader["Capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationTime = try reader["CreationTime"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.disableRollback = try reader["DisableRollback"].readIfPresent()
        value.driftInformation = try reader["DriftInformation"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails.read(from:))
        value.enableTerminationProtection = try reader["EnableTerminationProtection"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readIfPresent()
        value.notificationArns = try reader["NotificationArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputs = try reader["Outputs"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.stackId = try reader["StackId"].readIfPresent()
        value.stackName = try reader["StackName"].readIfPresent()
        value.stackStatus = try reader["StackStatus"].readIfPresent()
        value.stackStatusReason = try reader["StackStatusReason"].readIfPresent()
        value.timeoutInMinutes = try reader["TimeoutInMinutes"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails {

    static func write(value: SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["OutputKey"].write(value.outputKey)
        try writer["OutputValue"].write(value.outputValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails()
        value.description = try reader["Description"].readIfPresent()
        value.outputKey = try reader["OutputKey"].readIfPresent()
        value.outputValue = try reader["OutputValue"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails {

    static func write(value: SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackDriftStatus"].write(value.stackDriftStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails()
        value.stackDriftStatus = try reader["StackDriftStatus"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEfsAccessPointDetails {

    static func write(value: SecurityHubClientTypes.AwsEfsAccessPointDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessPointId"].write(value.accessPointId)
        try writer["Arn"].write(value.arn)
        try writer["ClientToken"].write(value.clientToken)
        try writer["FileSystemId"].write(value.fileSystemId)
        try writer["PosixUser"].write(value.posixUser, with: SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails.write(value:to:))
        try writer["RootDirectory"].write(value.rootDirectory, with: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEfsAccessPointDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEfsAccessPointDetails()
        value.accessPointId = try reader["AccessPointId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.clientToken = try reader["ClientToken"].readIfPresent()
        value.fileSystemId = try reader["FileSystemId"].readIfPresent()
        value.posixUser = try reader["PosixUser"].readIfPresent(with: SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails.read(from:))
        value.rootDirectory = try reader["RootDirectory"].readIfPresent(with: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails {

    static func write(value: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreationInfo"].write(value.creationInfo, with: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails.write(value:to:))
        try writer["Path"].write(value.path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails()
        value.creationInfo = try reader["CreationInfo"].readIfPresent(with: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails.read(from:))
        value.path = try reader["Path"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails {

    static func write(value: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OwnerGid"].write(value.ownerGid)
        try writer["OwnerUid"].write(value.ownerUid)
        try writer["Permissions"].write(value.permissions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails()
        value.ownerGid = try reader["OwnerGid"].readIfPresent()
        value.ownerUid = try reader["OwnerUid"].readIfPresent()
        value.permissions = try reader["Permissions"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails {

    static func write(value: SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Gid"].write(value.gid)
        try writer["SecondaryGids"].writeList(value.secondaryGids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Uid"].write(value.uid)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails()
        value.gid = try reader["Gid"].readIfPresent()
        value.secondaryGids = try reader["SecondaryGids"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.uid = try reader["Uid"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2TransitGatewayDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2TransitGatewayDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmazonSideAsn"].write(value.amazonSideAsn)
        try writer["AssociationDefaultRouteTableId"].write(value.associationDefaultRouteTableId)
        try writer["AutoAcceptSharedAttachments"].write(value.autoAcceptSharedAttachments)
        try writer["DefaultRouteTableAssociation"].write(value.defaultRouteTableAssociation)
        try writer["DefaultRouteTablePropagation"].write(value.defaultRouteTablePropagation)
        try writer["Description"].write(value.description)
        try writer["DnsSupport"].write(value.dnsSupport)
        try writer["Id"].write(value.id)
        try writer["MulticastSupport"].write(value.multicastSupport)
        try writer["PropagationDefaultRouteTableId"].write(value.propagationDefaultRouteTableId)
        try writer["TransitGatewayCidrBlocks"].writeList(value.transitGatewayCidrBlocks, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpnEcmpSupport"].write(value.vpnEcmpSupport)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2TransitGatewayDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2TransitGatewayDetails()
        value.id = try reader["Id"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.defaultRouteTablePropagation = try reader["DefaultRouteTablePropagation"].readIfPresent()
        value.autoAcceptSharedAttachments = try reader["AutoAcceptSharedAttachments"].readIfPresent()
        value.defaultRouteTableAssociation = try reader["DefaultRouteTableAssociation"].readIfPresent()
        value.transitGatewayCidrBlocks = try reader["TransitGatewayCidrBlocks"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.associationDefaultRouteTableId = try reader["AssociationDefaultRouteTableId"].readIfPresent()
        value.propagationDefaultRouteTableId = try reader["PropagationDefaultRouteTableId"].readIfPresent()
        value.vpnEcmpSupport = try reader["VpnEcmpSupport"].readIfPresent()
        value.dnsSupport = try reader["DnsSupport"].readIfPresent()
        value.multicastSupport = try reader["MulticastSupport"].readIfPresent()
        value.amazonSideAsn = try reader["AmazonSideAsn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsKinesisStreamDetails {

    static func write(value: SecurityHubClientTypes.AwsKinesisStreamDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Name"].write(value.name)
        try writer["RetentionPeriodHours"].write(value.retentionPeriodHours)
        try writer["ShardCount"].write(value.shardCount)
        try writer["StreamEncryption"].write(value.streamEncryption, with: SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsKinesisStreamDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsKinesisStreamDetails()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.streamEncryption = try reader["StreamEncryption"].readIfPresent(with: SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails.read(from:))
        value.shardCount = try reader["ShardCount"].readIfPresent()
        value.retentionPeriodHours = try reader["RetentionPeriodHours"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails {

    static func write(value: SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionType"].write(value.encryptionType)
        try writer["KeyId"].write(value.keyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails()
        value.encryptionType = try reader["EncryptionType"].readIfPresent()
        value.keyId = try reader["KeyId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DbSecurityGroupArn"].write(value.dbSecurityGroupArn)
        try writer["DbSecurityGroupDescription"].write(value.dbSecurityGroupDescription)
        try writer["DbSecurityGroupName"].write(value.dbSecurityGroupName)
        try writer["Ec2SecurityGroups"].writeList(value.ec2SecurityGroups, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IpRanges"].writeList(value.ipRanges, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OwnerId"].write(value.ownerId)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails()
        value.dbSecurityGroupArn = try reader["DbSecurityGroupArn"].readIfPresent()
        value.dbSecurityGroupDescription = try reader["DbSecurityGroupDescription"].readIfPresent()
        value.dbSecurityGroupName = try reader["DbSecurityGroupName"].readIfPresent()
        value.ec2SecurityGroups = try reader["Ec2SecurityGroups"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipRanges = try reader["IpRanges"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange {

    static func write(value: SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CidrIp"].write(value.cidrIp)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange()
        value.cidrIp = try reader["CidrIp"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup {

    static func write(value: SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ec2SecurityGroupId"].write(value.ec2SecurityGroupId)
        try writer["Ec2SecurityGroupName"].write(value.ec2SecurityGroupName)
        try writer["Ec2SecurityGroupOwnerId"].write(value.ec2SecurityGroupOwnerId)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup()
        value.ec2SecurityGroupId = try reader["Ec2SecurityGroupId"].readIfPresent()
        value.ec2SecurityGroupName = try reader["Ec2SecurityGroupName"].readIfPresent()
        value.ec2SecurityGroupOwnerId = try reader["Ec2SecurityGroupOwnerId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capacity"].write(value.capacity)
        try writer["Description"].write(value.description)
        try writer["RuleGroup"].write(value.ruleGroup, with: SecurityHubClientTypes.RuleGroupDetails.write(value:to:))
        try writer["RuleGroupArn"].write(value.ruleGroupArn)
        try writer["RuleGroupId"].write(value.ruleGroupId)
        try writer["RuleGroupName"].write(value.ruleGroupName)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails()
        value.capacity = try reader["Capacity"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.ruleGroup = try reader["RuleGroup"].readIfPresent(with: SecurityHubClientTypes.RuleGroupDetails.read(from:))
        value.ruleGroupArn = try reader["RuleGroupArn"].readIfPresent()
        value.ruleGroupId = try reader["RuleGroupId"].readIfPresent()
        value.ruleGroupName = try reader["RuleGroupName"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleVariables"].write(value.ruleVariables, with: SecurityHubClientTypes.RuleGroupVariables.write(value:to:))
        try writer["RulesSource"].write(value.rulesSource, with: SecurityHubClientTypes.RuleGroupSource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupDetails()
        value.ruleVariables = try reader["RuleVariables"].readIfPresent(with: SecurityHubClientTypes.RuleGroupVariables.read(from:))
        value.rulesSource = try reader["RulesSource"].readIfPresent(with: SecurityHubClientTypes.RuleGroupSource.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSource {

    static func write(value: SecurityHubClientTypes.RuleGroupSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RulesSourceList"].write(value.rulesSourceList, with: SecurityHubClientTypes.RuleGroupSourceListDetails.write(value:to:))
        try writer["RulesString"].write(value.rulesString)
        try writer["StatefulRules"].writeList(value.statefulRules, memberWritingClosure: SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StatelessRulesAndCustomActions"].write(value.statelessRulesAndCustomActions, with: SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSource()
        value.rulesSourceList = try reader["RulesSourceList"].readIfPresent(with: SecurityHubClientTypes.RuleGroupSourceListDetails.read(from:))
        value.rulesString = try reader["RulesString"].readIfPresent()
        value.statefulRules = try reader["StatefulRules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statelessRulesAndCustomActions = try reader["StatelessRulesAndCustomActions"].readIfPresent(with: SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomActions"].writeList(value.customActions, memberWritingClosure: SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StatelessRules"].writeList(value.statelessRules, memberWritingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails()
        value.customActions = try reader["CustomActions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statelessRules = try reader["StatelessRules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Priority"].write(value.priority)
        try writer["RuleDefinition"].write(value.ruleDefinition, with: SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails()
        value.priority = try reader["Priority"].readIfPresent()
        value.ruleDefinition = try reader["RuleDefinition"].readIfPresent(with: SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MatchAttributes"].write(value.matchAttributes, with: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition()
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.matchAttributes = try reader["MatchAttributes"].readIfPresent(with: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationPorts"].writeList(value.destinationPorts, memberWritingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Destinations"].writeList(value.destinations, memberWritingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Protocols"].writeList(value.protocols, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourcePorts"].writeList(value.sourcePorts, memberWritingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sources"].writeList(value.sources, memberWritingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TcpFlags"].writeList(value.tcpFlags, memberWritingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes()
        value.destinationPorts = try reader["DestinationPorts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.destinations = try reader["Destinations"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.protocols = try reader["Protocols"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourcePorts = try reader["SourcePorts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sources = try reader["Sources"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tcpFlags = try reader["TcpFlags"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Flags"].writeList(value.flags, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Masks"].writeList(value.masks, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags()
        value.flags = try reader["Flags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.masks = try reader["Masks"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressDefinition"].write(value.addressDefinition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources()
        value.addressDefinition = try reader["AddressDefinition"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromPort"].write(value.fromPort)
        try writer["ToPort"].write(value.toPort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts()
        value.fromPort = try reader["FromPort"].readIfPresent()
        value.toPort = try reader["ToPort"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressDefinition"].write(value.addressDefinition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations()
        value.addressDefinition = try reader["AddressDefinition"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromPort"].write(value.fromPort)
        try writer["ToPort"].write(value.toPort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts()
        value.fromPort = try reader["FromPort"].readIfPresent()
        value.toPort = try reader["ToPort"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionDefinition"].write(value.actionDefinition, with: SecurityHubClientTypes.StatelessCustomActionDefinition.write(value:to:))
        try writer["ActionName"].write(value.actionName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails()
        value.actionDefinition = try reader["ActionDefinition"].readIfPresent(with: SecurityHubClientTypes.StatelessCustomActionDefinition.read(from:))
        value.actionName = try reader["ActionName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StatelessCustomActionDefinition {

    static func write(value: SecurityHubClientTypes.StatelessCustomActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PublishMetricAction"].write(value.publishMetricAction, with: SecurityHubClientTypes.StatelessCustomPublishMetricAction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StatelessCustomActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StatelessCustomActionDefinition()
        value.publishMetricAction = try reader["PublishMetricAction"].readIfPresent(with: SecurityHubClientTypes.StatelessCustomPublishMetricAction.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.StatelessCustomPublishMetricAction {

    static func write(value: SecurityHubClientTypes.StatelessCustomPublishMetricAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].writeList(value.dimensions, memberWritingClosure: SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StatelessCustomPublishMetricAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StatelessCustomPublishMetricAction()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension {

    static func write(value: SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Header"].write(value.header, with: SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails.write(value:to:))
        try writer["RuleOptions"].writeList(value.ruleOptions, memberWritingClosure: SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails()
        value.action = try reader["Action"].readIfPresent()
        value.header = try reader["Header"].readIfPresent(with: SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails.read(from:))
        value.ruleOptions = try reader["RuleOptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Keyword"].write(value.keyword)
        try writer["Settings"].writeList(value.settings, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails()
        value.keyword = try reader["Keyword"].readIfPresent()
        value.settings = try reader["Settings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
        try writer["DestinationPort"].write(value.destinationPort)
        try writer["Direction"].write(value.direction)
        try writer["Protocol"].write(value.`protocol`)
        try writer["Source"].write(value.source)
        try writer["SourcePort"].write(value.sourcePort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails()
        value.destination = try reader["Destination"].readIfPresent()
        value.destinationPort = try reader["DestinationPort"].readIfPresent()
        value.direction = try reader["Direction"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.sourcePort = try reader["SourcePort"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupSourceListDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupSourceListDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GeneratedRulesType"].write(value.generatedRulesType)
        try writer["TargetTypes"].writeList(value.targetTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupSourceListDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupSourceListDetails()
        value.generatedRulesType = try reader["GeneratedRulesType"].readIfPresent()
        value.targetTypes = try reader["TargetTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupVariables {

    static func write(value: SecurityHubClientTypes.RuleGroupVariables?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IpSets"].write(value.ipSets, with: SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails.write(value:to:))
        try writer["PortSets"].write(value.portSets, with: SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupVariables {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupVariables()
        value.ipSets = try reader["IpSets"].readIfPresent(with: SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails.read(from:))
        value.portSets = try reader["PortSets"].readIfPresent(with: SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Definition"].writeList(value.definition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails()
        value.definition = try reader["Definition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails {

    static func write(value: SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Definition"].writeList(value.definition, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails()
        value.definition = try reader["Definition"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails {

    static func write(value: SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteProtection"].write(value.deleteProtection)
        try writer["Description"].write(value.description)
        try writer["FirewallArn"].write(value.firewallArn)
        try writer["FirewallId"].write(value.firewallId)
        try writer["FirewallName"].write(value.firewallName)
        try writer["FirewallPolicyArn"].write(value.firewallPolicyArn)
        try writer["FirewallPolicyChangeProtection"].write(value.firewallPolicyChangeProtection)
        try writer["SubnetChangeProtection"].write(value.subnetChangeProtection)
        try writer["SubnetMappings"].writeList(value.subnetMappings, memberWritingClosure: SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails()
        value.deleteProtection = try reader["DeleteProtection"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.firewallArn = try reader["FirewallArn"].readIfPresent()
        value.firewallId = try reader["FirewallId"].readIfPresent()
        value.firewallName = try reader["FirewallName"].readIfPresent()
        value.firewallPolicyArn = try reader["FirewallPolicyArn"].readIfPresent()
        value.firewallPolicyChangeProtection = try reader["FirewallPolicyChangeProtection"].readIfPresent()
        value.subnetChangeProtection = try reader["SubnetChangeProtection"].readIfPresent()
        value.subnetMappings = try reader["SubnetMappings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails {

    static func write(value: SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubnetId"].write(value.subnetId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails {

    static func write(value: SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["FirewallPolicy"].write(value.firewallPolicy, with: SecurityHubClientTypes.FirewallPolicyDetails.write(value:to:))
        try writer["FirewallPolicyArn"].write(value.firewallPolicyArn)
        try writer["FirewallPolicyId"].write(value.firewallPolicyId)
        try writer["FirewallPolicyName"].write(value.firewallPolicyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails()
        value.firewallPolicy = try reader["FirewallPolicy"].readIfPresent(with: SecurityHubClientTypes.FirewallPolicyDetails.read(from:))
        value.firewallPolicyArn = try reader["FirewallPolicyArn"].readIfPresent()
        value.firewallPolicyId = try reader["FirewallPolicyId"].readIfPresent()
        value.firewallPolicyName = try reader["FirewallPolicyName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.FirewallPolicyDetails {

    static func write(value: SecurityHubClientTypes.FirewallPolicyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StatefulRuleGroupReferences"].writeList(value.statefulRuleGroupReferences, memberWritingClosure: SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StatelessCustomActions"].writeList(value.statelessCustomActions, memberWritingClosure: SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StatelessDefaultActions"].writeList(value.statelessDefaultActions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StatelessFragmentDefaultActions"].writeList(value.statelessFragmentDefaultActions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StatelessRuleGroupReferences"].writeList(value.statelessRuleGroupReferences, memberWritingClosure: SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FirewallPolicyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FirewallPolicyDetails()
        value.statefulRuleGroupReferences = try reader["StatefulRuleGroupReferences"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statelessCustomActions = try reader["StatelessCustomActions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statelessDefaultActions = try reader["StatelessDefaultActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.statelessFragmentDefaultActions = try reader["StatelessFragmentDefaultActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.statelessRuleGroupReferences = try reader["StatelessRuleGroupReferences"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails {

    static func write(value: SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Priority"].write(value.priority)
        try writer["ResourceArn"].write(value.resourceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails()
        value.priority = try reader["Priority"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails {

    static func write(value: SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionDefinition"].write(value.actionDefinition, with: SecurityHubClientTypes.StatelessCustomActionDefinition.write(value:to:))
        try writer["ActionName"].write(value.actionName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails()
        value.actionDefinition = try reader["ActionDefinition"].readIfPresent(with: SecurityHubClientTypes.StatelessCustomActionDefinition.read(from:))
        value.actionName = try reader["ActionName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails {

    static func write(value: SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEksClusterDetails {

    static func write(value: SecurityHubClientTypes.AwsEksClusterDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["CertificateAuthorityData"].write(value.certificateAuthorityData)
        try writer["ClusterStatus"].write(value.clusterStatus)
        try writer["Endpoint"].write(value.endpoint)
        try writer["Logging"].write(value.logging, with: SecurityHubClientTypes.AwsEksClusterLoggingDetails.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["ResourcesVpcConfig"].write(value.resourcesVpcConfig, with: SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails.write(value:to:))
        try writer["RoleArn"].write(value.roleArn)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEksClusterDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEksClusterDetails()
        value.arn = try reader["Arn"].readIfPresent()
        value.certificateAuthorityData = try reader["CertificateAuthorityData"].readIfPresent()
        value.clusterStatus = try reader["ClusterStatus"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.resourcesVpcConfig = try reader["ResourcesVpcConfig"].readIfPresent(with: SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails.read(from:))
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.logging = try reader["Logging"].readIfPresent(with: SecurityHubClientTypes.AwsEksClusterLoggingDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEksClusterLoggingDetails {

    static func write(value: SecurityHubClientTypes.AwsEksClusterLoggingDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterLogging"].writeList(value.clusterLogging, memberWritingClosure: SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEksClusterLoggingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEksClusterLoggingDetails()
        value.clusterLogging = try reader["ClusterLogging"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails {

    static func write(value: SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["Types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.types = try reader["Types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndpointPublicAccess"].write(value.endpointPublicAccess)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.endpointPublicAccess = try reader["EndpointPublicAccess"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcrRepositoryDetails {

    static func write(value: SecurityHubClientTypes.AwsEcrRepositoryDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["ImageScanningConfiguration"].write(value.imageScanningConfiguration, with: SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails.write(value:to:))
        try writer["ImageTagMutability"].write(value.imageTagMutability)
        try writer["LifecyclePolicy"].write(value.lifecyclePolicy, with: SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails.write(value:to:))
        try writer["RepositoryName"].write(value.repositoryName)
        try writer["RepositoryPolicyText"].write(value.repositoryPolicyText)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcrRepositoryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcrRepositoryDetails()
        value.arn = try reader["Arn"].readIfPresent()
        value.imageScanningConfiguration = try reader["ImageScanningConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails.read(from:))
        value.imageTagMutability = try reader["ImageTagMutability"].readIfPresent()
        value.lifecyclePolicy = try reader["LifecyclePolicy"].readIfPresent(with: SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails.read(from:))
        value.repositoryName = try reader["RepositoryName"].readIfPresent()
        value.repositoryPolicyText = try reader["RepositoryPolicyText"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails {

    static func write(value: SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LifecyclePolicyText"].write(value.lifecyclePolicyText)
        try writer["RegistryId"].write(value.registryId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails()
        value.lifecyclePolicyText = try reader["LifecyclePolicyText"].readIfPresent()
        value.registryId = try reader["RegistryId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ScanOnPush"].write(value.scanOnPush)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails()
        value.scanOnPush = try reader["ScanOnPush"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MatchPredicates"].writeList(value.matchPredicates, memberWritingClosure: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricName"].write(value.metricName)
        try writer["Name"].write(value.name)
        try writer["RateKey"].write(value.rateKey)
        try writer["RateLimit"].write(value.rateLimit)
        try writer["RuleId"].write(value.ruleId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.rateKey = try reader["RateKey"].readIfPresent()
        value.rateLimit = try reader["RateLimit"].readIfPresent()
        value.ruleId = try reader["RuleId"].readIfPresent()
        value.matchPredicates = try reader["MatchPredicates"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate {

    static func write(value: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataId"].write(value.dataId)
        try writer["Negated"].write(value.negated)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate()
        value.dataId = try reader["DataId"].readIfPresent()
        value.negated = try reader["Negated"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRateBasedRuleDetails {

    static func write(value: SecurityHubClientTypes.AwsWafRateBasedRuleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MatchPredicates"].writeList(value.matchPredicates, memberWritingClosure: SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricName"].write(value.metricName)
        try writer["Name"].write(value.name)
        try writer["RateKey"].write(value.rateKey)
        try writer["RateLimit"].write(value.rateLimit)
        try writer["RuleId"].write(value.ruleId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRateBasedRuleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRateBasedRuleDetails()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.rateKey = try reader["RateKey"].readIfPresent()
        value.rateLimit = try reader["RateLimit"].readIfPresent()
        value.ruleId = try reader["RuleId"].readIfPresent()
        value.matchPredicates = try reader["MatchPredicates"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate {

    static func write(value: SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataId"].write(value.dataId)
        try writer["Negated"].write(value.negated)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate()
        value.dataId = try reader["DataId"].readIfPresent()
        value.negated = try reader["Negated"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsXrayEncryptionConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsXrayEncryptionConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyId"].write(value.keyId)
        try writer["Status"].write(value.status)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsXrayEncryptionConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsXrayEncryptionConfigDetails()
        value.keyId = try reader["KeyId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptanceRequired"].write(value.acceptanceRequired)
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BaseEndpointDnsNames"].writeList(value.baseEndpointDnsNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GatewayLoadBalancerArns"].writeList(value.gatewayLoadBalancerArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ManagesVpcEndpoints"].write(value.managesVpcEndpoints)
        try writer["NetworkLoadBalancerArns"].writeList(value.networkLoadBalancerArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PrivateDnsName"].write(value.privateDnsName)
        try writer["ServiceId"].write(value.serviceId)
        try writer["ServiceName"].write(value.serviceName)
        try writer["ServiceState"].write(value.serviceState)
        try writer["ServiceType"].writeList(value.serviceType, memberWritingClosure: SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails()
        value.acceptanceRequired = try reader["AcceptanceRequired"].readIfPresent()
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.baseEndpointDnsNames = try reader["BaseEndpointDnsNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.managesVpcEndpoints = try reader["ManagesVpcEndpoints"].readIfPresent()
        value.gatewayLoadBalancerArns = try reader["GatewayLoadBalancerArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkLoadBalancerArns = try reader["NetworkLoadBalancerArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.privateDnsName = try reader["PrivateDnsName"].readIfPresent()
        value.serviceId = try reader["ServiceId"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.serviceState = try reader["ServiceState"].readIfPresent()
        value.serviceType = try reader["ServiceType"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceType"].write(value.serviceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails()
        value.serviceType = try reader["ServiceType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessPolicies"].write(value.accessPolicies)
        try writer["AdvancedSecurityOptions"].write(value.advancedSecurityOptions, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails.write(value:to:))
        try writer["Arn"].write(value.arn)
        try writer["ClusterConfig"].write(value.clusterConfig, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails.write(value:to:))
        try writer["DomainEndpoint"].write(value.domainEndpoint)
        try writer["DomainEndpointOptions"].write(value.domainEndpointOptions, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails.write(value:to:))
        try writer["DomainEndpoints"].writeMap(value.domainEndpoints, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DomainName"].write(value.domainName)
        try writer["EncryptionAtRestOptions"].write(value.encryptionAtRestOptions, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails.write(value:to:))
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["Id"].write(value.id)
        try writer["LogPublishingOptions"].write(value.logPublishingOptions, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails.write(value:to:))
        try writer["NodeToNodeEncryptionOptions"].write(value.nodeToNodeEncryptionOptions, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails.write(value:to:))
        try writer["ServiceSoftwareOptions"].write(value.serviceSoftwareOptions, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails.write(value:to:))
        try writer["VpcOptions"].write(value.vpcOptions, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails()
        value.arn = try reader["Arn"].readIfPresent()
        value.accessPolicies = try reader["AccessPolicies"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.domainEndpoint = try reader["DomainEndpoint"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.encryptionAtRestOptions = try reader["EncryptionAtRestOptions"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails.read(from:))
        value.nodeToNodeEncryptionOptions = try reader["NodeToNodeEncryptionOptions"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails.read(from:))
        value.serviceSoftwareOptions = try reader["ServiceSoftwareOptions"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails.read(from:))
        value.clusterConfig = try reader["ClusterConfig"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails.read(from:))
        value.domainEndpointOptions = try reader["DomainEndpointOptions"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails.read(from:))
        value.vpcOptions = try reader["VpcOptions"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails.read(from:))
        value.logPublishingOptions = try reader["LogPublishingOptions"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails.read(from:))
        value.domainEndpoints = try reader["DomainEndpoints"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.advancedSecurityOptions = try reader["AdvancedSecurityOptions"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["InternalUserDatabaseEnabled"].write(value.internalUserDatabaseEnabled)
        try writer["MasterUserOptions"].write(value.masterUserOptions, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.internalUserDatabaseEnabled = try reader["InternalUserDatabaseEnabled"].readIfPresent()
        value.masterUserOptions = try reader["MasterUserOptions"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MasterUserArn"].write(value.masterUserArn)
        try writer["MasterUserName"].write(value.masterUserName)
        try writer["MasterUserPassword"].write(value.masterUserPassword)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails()
        value.masterUserArn = try reader["MasterUserArn"].readIfPresent()
        value.masterUserName = try reader["MasterUserName"].readIfPresent()
        value.masterUserPassword = try reader["MasterUserPassword"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditLogs"].write(value.auditLogs, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption.write(value:to:))
        try writer["IndexSlowLogs"].write(value.indexSlowLogs, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption.write(value:to:))
        try writer["SearchSlowLogs"].write(value.searchSlowLogs, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails()
        value.indexSlowLogs = try reader["IndexSlowLogs"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption.read(from:))
        value.searchSlowLogs = try reader["SearchSlowLogs"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption.read(from:))
        value.auditLogs = try reader["AuditLogs"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsLogGroupArn"].write(value.cloudWatchLogsLogGroupArn)
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption()
        value.cloudWatchLogsLogGroupArn = try reader["CloudWatchLogsLogGroupArn"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomEndpoint"].write(value.customEndpoint)
        try writer["CustomEndpointCertificateArn"].write(value.customEndpointCertificateArn)
        try writer["CustomEndpointEnabled"].write(value.customEndpointEnabled)
        try writer["EnforceHTTPS"].write(value.enforceHTTPS)
        try writer["TLSSecurityPolicy"].write(value.tlsSecurityPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails()
        value.customEndpointCertificateArn = try reader["CustomEndpointCertificateArn"].readIfPresent()
        value.customEndpointEnabled = try reader["CustomEndpointEnabled"].readIfPresent()
        value.enforceHTTPS = try reader["EnforceHTTPS"].readIfPresent()
        value.customEndpoint = try reader["CustomEndpoint"].readIfPresent()
        value.tlsSecurityPolicy = try reader["TLSSecurityPolicy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DedicatedMasterCount"].write(value.dedicatedMasterCount)
        try writer["DedicatedMasterEnabled"].write(value.dedicatedMasterEnabled)
        try writer["DedicatedMasterType"].write(value.dedicatedMasterType)
        try writer["InstanceCount"].write(value.instanceCount)
        try writer["InstanceType"].write(value.instanceType)
        try writer["WarmCount"].write(value.warmCount)
        try writer["WarmEnabled"].write(value.warmEnabled)
        try writer["WarmType"].write(value.warmType)
        try writer["ZoneAwarenessConfig"].write(value.zoneAwarenessConfig, with: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails.write(value:to:))
        try writer["ZoneAwarenessEnabled"].write(value.zoneAwarenessEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails()
        value.instanceCount = try reader["InstanceCount"].readIfPresent()
        value.warmEnabled = try reader["WarmEnabled"].readIfPresent()
        value.warmCount = try reader["WarmCount"].readIfPresent()
        value.dedicatedMasterEnabled = try reader["DedicatedMasterEnabled"].readIfPresent()
        value.zoneAwarenessConfig = try reader["ZoneAwarenessConfig"].readIfPresent(with: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails.read(from:))
        value.dedicatedMasterCount = try reader["DedicatedMasterCount"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.warmType = try reader["WarmType"].readIfPresent()
        value.zoneAwarenessEnabled = try reader["ZoneAwarenessEnabled"].readIfPresent()
        value.dedicatedMasterType = try reader["DedicatedMasterType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZoneCount"].write(value.availabilityZoneCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails()
        value.availabilityZoneCount = try reader["AvailabilityZoneCount"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomatedUpdateDate"].write(value.automatedUpdateDate)
        try writer["Cancellable"].write(value.cancellable)
        try writer["CurrentVersion"].write(value.currentVersion)
        try writer["Description"].write(value.description)
        try writer["NewVersion"].write(value.newVersion)
        try writer["OptionalDeployment"].write(value.optionalDeployment)
        try writer["UpdateAvailable"].write(value.updateAvailable)
        try writer["UpdateStatus"].write(value.updateStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails()
        value.automatedUpdateDate = try reader["AutomatedUpdateDate"].readIfPresent()
        value.cancellable = try reader["Cancellable"].readIfPresent()
        value.currentVersion = try reader["CurrentVersion"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.newVersion = try reader["NewVersion"].readIfPresent()
        value.updateAvailable = try reader["UpdateAvailable"].readIfPresent()
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        value.optionalDeployment = try reader["OptionalDeployment"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["KmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcrContainerImageDetails {

    static func write(value: SecurityHubClientTypes.AwsEcrContainerImageDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Architecture"].write(value.architecture)
        try writer["ImageDigest"].write(value.imageDigest)
        try writer["ImagePublishedAt"].write(value.imagePublishedAt)
        try writer["ImageTags"].writeList(value.imageTags, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RegistryId"].write(value.registryId)
        try writer["RepositoryName"].write(value.repositoryName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcrContainerImageDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcrContainerImageDetails()
        value.registryId = try reader["RegistryId"].readIfPresent()
        value.repositoryName = try reader["RepositoryName"].readIfPresent()
        value.architecture = try reader["Architecture"].readIfPresent()
        value.imageDigest = try reader["ImageDigest"].readIfPresent()
        value.imageTags = try reader["ImageTags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.imagePublishedAt = try reader["ImagePublishedAt"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpnConnectionDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpnConnectionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
        try writer["CustomerGatewayConfiguration"].write(value.customerGatewayConfiguration)
        try writer["CustomerGatewayId"].write(value.customerGatewayId)
        try writer["Options"].write(value.options, with: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails.write(value:to:))
        try writer["Routes"].writeList(value.routes, memberWritingClosure: SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["State"].write(value.state)
        try writer["TransitGatewayId"].write(value.transitGatewayId)
        try writer["Type"].write(value.type)
        try writer["VgwTelemetry"].writeList(value.vgwTelemetry, memberWritingClosure: SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpnConnectionId"].write(value.vpnConnectionId)
        try writer["VpnGatewayId"].write(value.vpnGatewayId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpnConnectionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpnConnectionDetails()
        value.vpnConnectionId = try reader["VpnConnectionId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.customerGatewayId = try reader["CustomerGatewayId"].readIfPresent()
        value.customerGatewayConfiguration = try reader["CustomerGatewayConfiguration"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.vpnGatewayId = try reader["VpnGatewayId"].readIfPresent()
        value.category = try reader["Category"].readIfPresent()
        value.vgwTelemetry = try reader["VgwTelemetry"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.options = try reader["Options"].readIfPresent(with: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails.read(from:))
        value.routes = try reader["Routes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.transitGatewayId = try reader["TransitGatewayId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationCidrBlock"].write(value.destinationCidrBlock)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails()
        value.destinationCidrBlock = try reader["DestinationCidrBlock"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StaticRoutesOnly"].write(value.staticRoutesOnly)
        try writer["TunnelOptions"].writeList(value.tunnelOptions, memberWritingClosure: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails()
        value.staticRoutesOnly = try reader["StaticRoutesOnly"].readIfPresent()
        value.tunnelOptions = try reader["TunnelOptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DpdTimeoutSeconds"].write(value.dpdTimeoutSeconds)
        try writer["IkeVersions"].writeList(value.ikeVersions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OutsideIpAddress"].write(value.outsideIpAddress)
        try writer["Phase1DhGroupNumbers"].writeList(value.phase1DhGroupNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Phase1EncryptionAlgorithms"].writeList(value.phase1EncryptionAlgorithms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Phase1IntegrityAlgorithms"].writeList(value.phase1IntegrityAlgorithms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Phase1LifetimeSeconds"].write(value.phase1LifetimeSeconds)
        try writer["Phase2DhGroupNumbers"].writeList(value.phase2DhGroupNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Phase2EncryptionAlgorithms"].writeList(value.phase2EncryptionAlgorithms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Phase2IntegrityAlgorithms"].writeList(value.phase2IntegrityAlgorithms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Phase2LifetimeSeconds"].write(value.phase2LifetimeSeconds)
        try writer["PreSharedKey"].write(value.preSharedKey)
        try writer["RekeyFuzzPercentage"].write(value.rekeyFuzzPercentage)
        try writer["RekeyMarginTimeSeconds"].write(value.rekeyMarginTimeSeconds)
        try writer["ReplayWindowSize"].write(value.replayWindowSize)
        try writer["TunnelInsideCidr"].write(value.tunnelInsideCidr)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails()
        value.dpdTimeoutSeconds = try reader["DpdTimeoutSeconds"].readIfPresent()
        value.ikeVersions = try reader["IkeVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.outsideIpAddress = try reader["OutsideIpAddress"].readIfPresent()
        value.phase1DhGroupNumbers = try reader["Phase1DhGroupNumbers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.phase1EncryptionAlgorithms = try reader["Phase1EncryptionAlgorithms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.phase1IntegrityAlgorithms = try reader["Phase1IntegrityAlgorithms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.phase1LifetimeSeconds = try reader["Phase1LifetimeSeconds"].readIfPresent()
        value.phase2DhGroupNumbers = try reader["Phase2DhGroupNumbers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.phase2EncryptionAlgorithms = try reader["Phase2EncryptionAlgorithms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.phase2IntegrityAlgorithms = try reader["Phase2IntegrityAlgorithms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.phase2LifetimeSeconds = try reader["Phase2LifetimeSeconds"].readIfPresent()
        value.preSharedKey = try reader["PreSharedKey"].readIfPresent()
        value.rekeyFuzzPercentage = try reader["RekeyFuzzPercentage"].readIfPresent()
        value.rekeyMarginTimeSeconds = try reader["RekeyMarginTimeSeconds"].readIfPresent()
        value.replayWindowSize = try reader["ReplayWindowSize"].readIfPresent()
        value.tunnelInsideCidr = try reader["TunnelInsideCidr"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptedRouteCount"].write(value.acceptedRouteCount)
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["LastStatusChange"].write(value.lastStatusChange)
        try writer["OutsideIpAddress"].write(value.outsideIpAddress)
        try writer["Status"].write(value.status)
        try writer["StatusMessage"].write(value.statusMessage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails()
        value.acceptedRouteCount = try reader["AcceptedRouteCount"].readIfPresent()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        value.lastStatusChange = try reader["LastStatusChange"].readIfPresent()
        value.outsideIpAddress = try reader["OutsideIpAddress"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociatePublicIpAddress"].write(value.associatePublicIpAddress)
        try writer["BlockDeviceMappings"].writeList(value.blockDeviceMappings, memberWritingClosure: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClassicLinkVpcId"].write(value.classicLinkVpcId)
        try writer["ClassicLinkVpcSecurityGroups"].writeList(value.classicLinkVpcSecurityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreatedTime"].write(value.createdTime)
        try writer["EbsOptimized"].write(value.ebsOptimized)
        try writer["IamInstanceProfile"].write(value.iamInstanceProfile)
        try writer["ImageId"].write(value.imageId)
        try writer["InstanceMonitoring"].write(value.instanceMonitoring, with: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails.write(value:to:))
        try writer["InstanceType"].write(value.instanceType)
        try writer["KernelId"].write(value.kernelId)
        try writer["KeyName"].write(value.keyName)
        try writer["LaunchConfigurationName"].write(value.launchConfigurationName)
        try writer["MetadataOptions"].write(value.metadataOptions, with: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions.write(value:to:))
        try writer["PlacementTenancy"].write(value.placementTenancy)
        try writer["RamdiskId"].write(value.ramdiskId)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SpotPrice"].write(value.spotPrice)
        try writer["UserData"].write(value.userData)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails()
        value.associatePublicIpAddress = try reader["AssociatePublicIpAddress"].readIfPresent()
        value.blockDeviceMappings = try reader["BlockDeviceMappings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.classicLinkVpcId = try reader["ClassicLinkVpcId"].readIfPresent()
        value.classicLinkVpcSecurityGroups = try reader["ClassicLinkVpcSecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.ebsOptimized = try reader["EbsOptimized"].readIfPresent()
        value.iamInstanceProfile = try reader["IamInstanceProfile"].readIfPresent()
        value.imageId = try reader["ImageId"].readIfPresent()
        value.instanceMonitoring = try reader["InstanceMonitoring"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails.read(from:))
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.kernelId = try reader["KernelId"].readIfPresent()
        value.keyName = try reader["KeyName"].readIfPresent()
        value.launchConfigurationName = try reader["LaunchConfigurationName"].readIfPresent()
        value.placementTenancy = try reader["PlacementTenancy"].readIfPresent()
        value.ramdiskId = try reader["RamdiskId"].readIfPresent()
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.spotPrice = try reader["SpotPrice"].readIfPresent()
        value.userData = try reader["UserData"].readIfPresent()
        value.metadataOptions = try reader["MetadataOptions"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpEndpoint"].write(value.httpEndpoint)
        try writer["HttpPutResponseHopLimit"].write(value.httpPutResponseHopLimit)
        try writer["HttpTokens"].write(value.httpTokens)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions()
        value.httpEndpoint = try reader["HttpEndpoint"].readIfPresent()
        value.httpPutResponseHopLimit = try reader["HttpPutResponseHopLimit"].readIfPresent()
        value.httpTokens = try reader["HttpTokens"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceName"].write(value.deviceName)
        try writer["Ebs"].write(value.ebs, with: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails.write(value:to:))
        try writer["NoDevice"].write(value.noDevice)
        try writer["VirtualName"].write(value.virtualName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.ebs = try reader["Ebs"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails.read(from:))
        value.noDevice = try reader["NoDevice"].readIfPresent()
        value.virtualName = try reader["VirtualName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteOnTermination"].write(value.deleteOnTermination)
        try writer["Encrypted"].write(value.encrypted)
        try writer["Iops"].write(value.iops)
        try writer["SnapshotId"].write(value.snapshotId)
        try writer["VolumeSize"].write(value.volumeSize)
        try writer["VolumeType"].write(value.volumeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails()
        value.deleteOnTermination = try reader["DeleteOnTermination"].readIfPresent()
        value.encrypted = try reader["Encrypted"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        value.snapshotId = try reader["SnapshotId"].readIfPresent()
        value.volumeSize = try reader["VolumeSize"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServiceDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServiceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityProviderStrategy"].writeList(value.capacityProviderStrategy, memberWritingClosure: SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Cluster"].write(value.cluster)
        try writer["DeploymentConfiguration"].write(value.deploymentConfiguration, with: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails.write(value:to:))
        try writer["DeploymentController"].write(value.deploymentController, with: SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails.write(value:to:))
        try writer["DesiredCount"].write(value.desiredCount)
        try writer["EnableEcsManagedTags"].write(value.enableEcsManagedTags)
        try writer["EnableExecuteCommand"].write(value.enableExecuteCommand)
        try writer["HealthCheckGracePeriodSeconds"].write(value.healthCheckGracePeriodSeconds)
        try writer["LaunchType"].write(value.launchType)
        try writer["LoadBalancers"].writeList(value.loadBalancers, memberWritingClosure: SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["NetworkConfiguration"].write(value.networkConfiguration, with: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails.write(value:to:))
        try writer["PlacementConstraints"].writeList(value.placementConstraints, memberWritingClosure: SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PlacementStrategies"].writeList(value.placementStrategies, memberWritingClosure: SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PlatformVersion"].write(value.platformVersion)
        try writer["PropagateTags"].write(value.propagateTags)
        try writer["Role"].write(value.role)
        try writer["SchedulingStrategy"].write(value.schedulingStrategy)
        try writer["ServiceArn"].write(value.serviceArn)
        try writer["ServiceName"].write(value.serviceName)
        try writer["ServiceRegistries"].writeList(value.serviceRegistries, memberWritingClosure: SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskDefinition"].write(value.taskDefinition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServiceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServiceDetails()
        value.capacityProviderStrategy = try reader["CapacityProviderStrategy"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cluster = try reader["Cluster"].readIfPresent()
        value.deploymentConfiguration = try reader["DeploymentConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails.read(from:))
        value.deploymentController = try reader["DeploymentController"].readIfPresent(with: SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails.read(from:))
        value.desiredCount = try reader["DesiredCount"].readIfPresent()
        value.enableEcsManagedTags = try reader["EnableEcsManagedTags"].readIfPresent()
        value.enableExecuteCommand = try reader["EnableExecuteCommand"].readIfPresent()
        value.healthCheckGracePeriodSeconds = try reader["HealthCheckGracePeriodSeconds"].readIfPresent()
        value.launchType = try reader["LaunchType"].readIfPresent()
        value.loadBalancers = try reader["LoadBalancers"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.networkConfiguration = try reader["NetworkConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails.read(from:))
        value.placementConstraints = try reader["PlacementConstraints"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.placementStrategies = try reader["PlacementStrategies"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.platformVersion = try reader["PlatformVersion"].readIfPresent()
        value.propagateTags = try reader["PropagateTags"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.schedulingStrategy = try reader["SchedulingStrategy"].readIfPresent()
        value.serviceArn = try reader["ServiceArn"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.serviceRegistries = try reader["ServiceRegistries"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskDefinition = try reader["TaskDefinition"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
        try writer["ContainerPort"].write(value.containerPort)
        try writer["Port"].write(value.port)
        try writer["RegistryArn"].write(value.registryArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails()
        value.containerName = try reader["ContainerName"].readIfPresent()
        value.containerPort = try reader["ContainerPort"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.registryArn = try reader["RegistryArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Field"].write(value.field)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails()
        value.field = try reader["Field"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Expression"].write(value.expression)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails()
        value.expression = try reader["Expression"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsVpcConfiguration"].write(value.awsVpcConfiguration, with: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails()
        value.awsVpcConfiguration = try reader["AwsVpcConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssignPublicIp"].write(value.assignPublicIp)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails()
        value.assignPublicIp = try reader["AssignPublicIp"].readIfPresent()
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
        try writer["ContainerPort"].write(value.containerPort)
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["TargetGroupArn"].write(value.targetGroupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails()
        value.containerName = try reader["ContainerName"].readIfPresent()
        value.containerPort = try reader["ContainerPort"].readIfPresent()
        value.loadBalancerName = try reader["LoadBalancerName"].readIfPresent()
        value.targetGroupArn = try reader["TargetGroupArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeploymentCircuitBreaker"].write(value.deploymentCircuitBreaker, with: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails.write(value:to:))
        try writer["MaximumPercent"].write(value.maximumPercent)
        try writer["MinimumHealthyPercent"].write(value.minimumHealthyPercent)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails()
        value.deploymentCircuitBreaker = try reader["DeploymentCircuitBreaker"].readIfPresent(with: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails.read(from:))
        value.maximumPercent = try reader["MaximumPercent"].readIfPresent()
        value.minimumHealthyPercent = try reader["MinimumHealthyPercent"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enable"].write(value.enable)
        try writer["Rollback"].write(value.rollback)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails()
        value.enable = try reader["Enable"].readIfPresent()
        value.rollback = try reader["Rollback"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Base"].write(value.base)
        try writer["CapacityProvider"].write(value.capacityProvider)
        try writer["Weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails()
        value.base = try reader["Base"].readIfPresent()
        value.capacityProvider = try reader["CapacityProvider"].readIfPresent()
        value.weight = try reader["Weight"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsEventSubscriptionDetails {

    static func write(value: SecurityHubClientTypes.AwsRdsEventSubscriptionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustSubscriptionId"].write(value.custSubscriptionId)
        try writer["CustomerAwsId"].write(value.customerAwsId)
        try writer["Enabled"].write(value.enabled)
        try writer["EventCategoriesList"].writeList(value.eventCategoriesList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EventSubscriptionArn"].write(value.eventSubscriptionArn)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
        try writer["SourceIdsList"].writeList(value.sourceIdsList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceType"].write(value.sourceType)
        try writer["Status"].write(value.status)
        try writer["SubscriptionCreationTime"].write(value.subscriptionCreationTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsEventSubscriptionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsEventSubscriptionDetails()
        value.custSubscriptionId = try reader["CustSubscriptionId"].readIfPresent()
        value.customerAwsId = try reader["CustomerAwsId"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.eventCategoriesList = try reader["EventCategoriesList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventSubscriptionArn = try reader["EventSubscriptionArn"].readIfPresent()
        value.snsTopicArn = try reader["SnsTopicArn"].readIfPresent()
        value.sourceIdsList = try reader["SourceIdsList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.subscriptionCreationTime = try reader["SubscriptionCreationTime"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ContainerDetails {

    static func write(value: SecurityHubClientTypes.ContainerDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerRuntime"].write(value.containerRuntime)
        try writer["ImageId"].write(value.imageId)
        try writer["ImageName"].write(value.imageName)
        try writer["LaunchedAt"].write(value.launchedAt)
        try writer["Name"].write(value.name)
        try writer["Privileged"].write(value.privileged)
        try writer["VolumeMounts"].writeList(value.volumeMounts, memberWritingClosure: SecurityHubClientTypes.VolumeMount.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ContainerDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ContainerDetails()
        value.containerRuntime = try reader["ContainerRuntime"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.imageId = try reader["ImageId"].readIfPresent()
        value.imageName = try reader["ImageName"].readIfPresent()
        value.launchedAt = try reader["LaunchedAt"].readIfPresent()
        value.volumeMounts = try reader["VolumeMounts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.VolumeMount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.privileged = try reader["Privileged"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.VolumeMount {

    static func write(value: SecurityHubClientTypes.VolumeMount?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MountPath"].write(value.mountPath)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.VolumeMount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.VolumeMount()
        value.name = try reader["Name"].readIfPresent()
        value.mountPath = try reader["MountPath"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerDefinitions"].writeList(value.containerDefinitions, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Cpu"].write(value.cpu)
        try writer["ExecutionRoleArn"].write(value.executionRoleArn)
        try writer["Family"].write(value.family)
        try writer["InferenceAccelerators"].writeList(value.inferenceAccelerators, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IpcMode"].write(value.ipcMode)
        try writer["Memory"].write(value.memory)
        try writer["NetworkMode"].write(value.networkMode)
        try writer["PidMode"].write(value.pidMode)
        try writer["PlacementConstraints"].writeList(value.placementConstraints, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProxyConfiguration"].write(value.proxyConfiguration, with: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails.write(value:to:))
        try writer["RequiresCompatibilities"].writeList(value.requiresCompatibilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Status"].write(value.status)
        try writer["TaskRoleArn"].write(value.taskRoleArn)
        try writer["Volumes"].writeList(value.volumes, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionDetails()
        value.containerDefinitions = try reader["ContainerDefinitions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cpu = try reader["Cpu"].readIfPresent()
        value.executionRoleArn = try reader["ExecutionRoleArn"].readIfPresent()
        value.family = try reader["Family"].readIfPresent()
        value.inferenceAccelerators = try reader["InferenceAccelerators"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipcMode = try reader["IpcMode"].readIfPresent()
        value.memory = try reader["Memory"].readIfPresent()
        value.networkMode = try reader["NetworkMode"].readIfPresent()
        value.pidMode = try reader["PidMode"].readIfPresent()
        value.placementConstraints = try reader["PlacementConstraints"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.proxyConfiguration = try reader["ProxyConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails.read(from:))
        value.requiresCompatibilities = try reader["RequiresCompatibilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.taskRoleArn = try reader["TaskRoleArn"].readIfPresent()
        value.volumes = try reader["Volumes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DockerVolumeConfiguration"].write(value.dockerVolumeConfiguration, with: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails.write(value:to:))
        try writer["EfsVolumeConfiguration"].write(value.efsVolumeConfiguration, with: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails.write(value:to:))
        try writer["Host"].write(value.host, with: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails.write(value:to:))
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails()
        value.dockerVolumeConfiguration = try reader["DockerVolumeConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails.read(from:))
        value.efsVolumeConfiguration = try reader["EfsVolumeConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails.read(from:))
        value.host = try reader["Host"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails.read(from:))
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SourcePath"].write(value.sourcePath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails()
        value.sourcePath = try reader["SourcePath"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizationConfig"].write(value.authorizationConfig, with: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails.write(value:to:))
        try writer["FilesystemId"].write(value.filesystemId)
        try writer["RootDirectory"].write(value.rootDirectory)
        try writer["TransitEncryption"].write(value.transitEncryption)
        try writer["TransitEncryptionPort"].write(value.transitEncryptionPort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails()
        value.authorizationConfig = try reader["AuthorizationConfig"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails.read(from:))
        value.filesystemId = try reader["FilesystemId"].readIfPresent()
        value.rootDirectory = try reader["RootDirectory"].readIfPresent()
        value.transitEncryption = try reader["TransitEncryption"].readIfPresent()
        value.transitEncryptionPort = try reader["TransitEncryptionPort"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessPointId"].write(value.accessPointId)
        try writer["Iam"].write(value.iam)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails()
        value.accessPointId = try reader["AccessPointId"].readIfPresent()
        value.iam = try reader["Iam"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Autoprovision"].write(value.autoprovision)
        try writer["Driver"].write(value.driver)
        try writer["DriverOpts"].writeMap(value.driverOpts, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Labels"].writeMap(value.labels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Scope"].write(value.scope)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails()
        value.autoprovision = try reader["Autoprovision"].readIfPresent()
        value.driver = try reader["Driver"].readIfPresent()
        value.driverOpts = try reader["DriverOpts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.labels = try reader["Labels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.scope = try reader["Scope"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerName"].write(value.containerName)
        try writer["ProxyConfigurationProperties"].writeList(value.proxyConfigurationProperties, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails()
        value.containerName = try reader["ContainerName"].readIfPresent()
        value.proxyConfigurationProperties = try reader["ProxyConfigurationProperties"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Expression"].write(value.expression)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails()
        value.expression = try reader["Expression"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceName"].write(value.deviceName)
        try writer["DeviceType"].write(value.deviceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.deviceType = try reader["DeviceType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Command"].writeList(value.command, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Cpu"].write(value.cpu)
        try writer["DependsOn"].writeList(value.dependsOn, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DisableNetworking"].write(value.disableNetworking)
        try writer["DnsSearchDomains"].writeList(value.dnsSearchDomains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DnsServers"].writeList(value.dnsServers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DockerLabels"].writeMap(value.dockerLabels, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DockerSecurityOptions"].writeList(value.dockerSecurityOptions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EntryPoint"].writeList(value.entryPoint, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Environment"].writeList(value.environment, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnvironmentFiles"].writeList(value.environmentFiles, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Essential"].write(value.essential)
        try writer["ExtraHosts"].writeList(value.extraHosts, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FirelensConfiguration"].write(value.firelensConfiguration, with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails.write(value:to:))
        try writer["HealthCheck"].write(value.healthCheck, with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails.write(value:to:))
        try writer["Hostname"].write(value.hostname)
        try writer["Image"].write(value.image)
        try writer["Interactive"].write(value.interactive)
        try writer["Links"].writeList(value.links, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LinuxParameters"].write(value.linuxParameters, with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails.write(value:to:))
        try writer["LogConfiguration"].write(value.logConfiguration, with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails.write(value:to:))
        try writer["Memory"].write(value.memory)
        try writer["MemoryReservation"].write(value.memoryReservation)
        try writer["MountPoints"].writeList(value.mountPoints, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PortMappings"].writeList(value.portMappings, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Privileged"].write(value.privileged)
        try writer["PseudoTerminal"].write(value.pseudoTerminal)
        try writer["ReadonlyRootFilesystem"].write(value.readonlyRootFilesystem)
        try writer["RepositoryCredentials"].write(value.repositoryCredentials, with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails.write(value:to:))
        try writer["ResourceRequirements"].writeList(value.resourceRequirements, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Secrets"].writeList(value.secrets, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StartTimeout"].write(value.startTimeout)
        try writer["StopTimeout"].write(value.stopTimeout)
        try writer["SystemControls"].writeList(value.systemControls, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ulimits"].writeList(value.ulimits, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["User"].write(value.user)
        try writer["VolumesFrom"].writeList(value.volumesFrom, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkingDirectory"].write(value.workingDirectory)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails()
        value.command = try reader["Command"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.cpu = try reader["Cpu"].readIfPresent()
        value.dependsOn = try reader["DependsOn"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.disableNetworking = try reader["DisableNetworking"].readIfPresent()
        value.dnsSearchDomains = try reader["DnsSearchDomains"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dnsServers = try reader["DnsServers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dockerLabels = try reader["DockerLabels"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.dockerSecurityOptions = try reader["DockerSecurityOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.entryPoint = try reader["EntryPoint"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.environment = try reader["Environment"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentFiles = try reader["EnvironmentFiles"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.essential = try reader["Essential"].readIfPresent()
        value.extraHosts = try reader["ExtraHosts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.firelensConfiguration = try reader["FirelensConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails.read(from:))
        value.healthCheck = try reader["HealthCheck"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails.read(from:))
        value.hostname = try reader["Hostname"].readIfPresent()
        value.image = try reader["Image"].readIfPresent()
        value.interactive = try reader["Interactive"].readIfPresent()
        value.links = try reader["Links"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.linuxParameters = try reader["LinuxParameters"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails.read(from:))
        value.logConfiguration = try reader["LogConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails.read(from:))
        value.memory = try reader["Memory"].readIfPresent()
        value.memoryReservation = try reader["MemoryReservation"].readIfPresent()
        value.mountPoints = try reader["MountPoints"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.portMappings = try reader["PortMappings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.privileged = try reader["Privileged"].readIfPresent()
        value.pseudoTerminal = try reader["PseudoTerminal"].readIfPresent()
        value.readonlyRootFilesystem = try reader["ReadonlyRootFilesystem"].readIfPresent()
        value.repositoryCredentials = try reader["RepositoryCredentials"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails.read(from:))
        value.resourceRequirements = try reader["ResourceRequirements"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.secrets = try reader["Secrets"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTimeout = try reader["StartTimeout"].readIfPresent()
        value.stopTimeout = try reader["StopTimeout"].readIfPresent()
        value.systemControls = try reader["SystemControls"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ulimits = try reader["Ulimits"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.user = try reader["User"].readIfPresent()
        value.volumesFrom = try reader["VolumesFrom"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workingDirectory = try reader["WorkingDirectory"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReadOnly"].write(value.readOnly)
        try writer["SourceContainer"].write(value.sourceContainer)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails()
        value.readOnly = try reader["ReadOnly"].readIfPresent()
        value.sourceContainer = try reader["SourceContainer"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HardLimit"].write(value.hardLimit)
        try writer["Name"].write(value.name)
        try writer["SoftLimit"].write(value.softLimit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails()
        value.hardLimit = try reader["HardLimit"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.softLimit = try reader["SoftLimit"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Namespace"].write(value.namespace)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ValueFrom"].write(value.valueFrom)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails()
        value.name = try reader["Name"].readIfPresent()
        value.valueFrom = try reader["ValueFrom"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CredentialsParameter"].write(value.credentialsParameter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails()
        value.credentialsParameter = try reader["CredentialsParameter"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerPort"].write(value.containerPort)
        try writer["HostPort"].write(value.hostPort)
        try writer["Protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails()
        value.containerPort = try reader["ContainerPort"].readIfPresent()
        value.hostPort = try reader["HostPort"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerPath"].write(value.containerPath)
        try writer["ReadOnly"].write(value.readOnly)
        try writer["SourceVolume"].write(value.sourceVolume)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails()
        value.containerPath = try reader["ContainerPath"].readIfPresent()
        value.readOnly = try reader["ReadOnly"].readIfPresent()
        value.sourceVolume = try reader["SourceVolume"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogDriver"].write(value.logDriver)
        try writer["Options"].writeMap(value.options, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["SecretOptions"].writeList(value.secretOptions, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails()
        value.logDriver = try reader["LogDriver"].readIfPresent()
        value.options = try reader["Options"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.secretOptions = try reader["SecretOptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ValueFrom"].write(value.valueFrom)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails()
        value.name = try reader["Name"].readIfPresent()
        value.valueFrom = try reader["ValueFrom"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Capabilities"].write(value.capabilities, with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails.write(value:to:))
        try writer["Devices"].writeList(value.devices, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InitProcessEnabled"].write(value.initProcessEnabled)
        try writer["MaxSwap"].write(value.maxSwap)
        try writer["SharedMemorySize"].write(value.sharedMemorySize)
        try writer["Swappiness"].write(value.swappiness)
        try writer["Tmpfs"].writeList(value.tmpfs, memberWritingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails()
        value.capabilities = try reader["Capabilities"].readIfPresent(with: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails.read(from:))
        value.devices = try reader["Devices"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.initProcessEnabled = try reader["InitProcessEnabled"].readIfPresent()
        value.maxSwap = try reader["MaxSwap"].readIfPresent()
        value.sharedMemorySize = try reader["SharedMemorySize"].readIfPresent()
        value.swappiness = try reader["Swappiness"].readIfPresent()
        value.tmpfs = try reader["Tmpfs"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerPath"].write(value.containerPath)
        try writer["MountOptions"].writeList(value.mountOptions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Size"].write(value.size)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails()
        value.containerPath = try reader["ContainerPath"].readIfPresent()
        value.mountOptions = try reader["MountOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.size = try reader["Size"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContainerPath"].write(value.containerPath)
        try writer["HostPath"].write(value.hostPath)
        try writer["Permissions"].writeList(value.permissions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails()
        value.containerPath = try reader["ContainerPath"].readIfPresent()
        value.hostPath = try reader["HostPath"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Add"].writeList(value.add, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Drop"].writeList(value.drop, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails()
        value.add = try reader["Add"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.drop = try reader["Drop"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Command"].writeList(value.command, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Interval"].write(value.interval)
        try writer["Retries"].write(value.retries)
        try writer["StartPeriod"].write(value.startPeriod)
        try writer["Timeout"].write(value.timeout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails()
        value.command = try reader["Command"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.interval = try reader["Interval"].readIfPresent()
        value.retries = try reader["Retries"].readIfPresent()
        value.startPeriod = try reader["StartPeriod"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Options"].writeMap(value.options, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails()
        value.options = try reader["Options"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hostname"].write(value.hostname)
        try writer["IpAddress"].write(value.ipAddress)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails()
        value.hostname = try reader["Hostname"].readIfPresent()
        value.ipAddress = try reader["IpAddress"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition)
        try writer["ContainerName"].write(value.containerName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails()
        value.condition = try reader["Condition"].readIfPresent()
        value.containerName = try reader["ContainerName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsClusterDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsClusterDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActiveServicesCount"].write(value.activeServicesCount)
        try writer["CapacityProviders"].writeList(value.capacityProviders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClusterArn"].write(value.clusterArn)
        try writer["ClusterName"].write(value.clusterName)
        try writer["ClusterSettings"].writeList(value.clusterSettings, memberWritingClosure: SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Configuration"].write(value.configuration, with: SecurityHubClientTypes.AwsEcsClusterConfigurationDetails.write(value:to:))
        try writer["DefaultCapacityProviderStrategy"].writeList(value.defaultCapacityProviderStrategy, memberWritingClosure: SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RegisteredContainerInstancesCount"].write(value.registeredContainerInstancesCount)
        try writer["RunningTasksCount"].write(value.runningTasksCount)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsClusterDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsClusterDetails()
        value.clusterArn = try reader["ClusterArn"].readIfPresent()
        value.activeServicesCount = try reader["ActiveServicesCount"].readIfPresent()
        value.capacityProviders = try reader["CapacityProviders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.clusterSettings = try reader["ClusterSettings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.configuration = try reader["Configuration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsClusterConfigurationDetails.read(from:))
        value.defaultCapacityProviderStrategy = try reader["DefaultCapacityProviderStrategy"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clusterName = try reader["ClusterName"].readIfPresent()
        value.registeredContainerInstancesCount = try reader["RegisteredContainerInstancesCount"].readIfPresent()
        value.runningTasksCount = try reader["RunningTasksCount"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Base"].write(value.base)
        try writer["CapacityProvider"].write(value.capacityProvider)
        try writer["Weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails()
        value.base = try reader["Base"].readIfPresent()
        value.capacityProvider = try reader["CapacityProvider"].readIfPresent()
        value.weight = try reader["Weight"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsClusterConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsClusterConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecuteCommandConfiguration"].write(value.executeCommandConfiguration, with: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsClusterConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsClusterConfigurationDetails()
        value.executeCommandConfiguration = try reader["ExecuteCommandConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["LogConfiguration"].write(value.logConfiguration, with: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails.write(value:to:))
        try writer["Logging"].write(value.logging)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.logConfiguration = try reader["LogConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails.read(from:))
        value.logging = try reader["Logging"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchEncryptionEnabled"].write(value.cloudWatchEncryptionEnabled)
        try writer["CloudWatchLogGroupName"].write(value.cloudWatchLogGroupName)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3EncryptionEnabled"].write(value.s3EncryptionEnabled)
        try writer["S3KeyPrefix"].write(value.s3KeyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails()
        value.cloudWatchEncryptionEnabled = try reader["CloudWatchEncryptionEnabled"].readIfPresent()
        value.cloudWatchLogGroupName = try reader["CloudWatchLogGroupName"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3EncryptionEnabled = try reader["S3EncryptionEnabled"].readIfPresent()
        value.s3KeyPrefix = try reader["S3KeyPrefix"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails {

    static func write(value: SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbClusterDetails {

    static func write(value: SecurityHubClientTypes.AwsRdsDbClusterDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActivityStreamStatus"].write(value.activityStreamStatus)
        try writer["AllocatedStorage"].write(value.allocatedStorage)
        try writer["AssociatedRoles"].writeList(value.associatedRoles, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AutoMinorVersionUpgrade"].write(value.autoMinorVersionUpgrade)
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BackupRetentionPeriod"].write(value.backupRetentionPeriod)
        try writer["ClusterCreateTime"].write(value.clusterCreateTime)
        try writer["CopyTagsToSnapshot"].write(value.copyTagsToSnapshot)
        try writer["CrossAccountClone"].write(value.crossAccountClone)
        try writer["CustomEndpoints"].writeList(value.customEndpoints, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DatabaseName"].write(value.databaseName)
        try writer["DbClusterIdentifier"].write(value.dbClusterIdentifier)
        try writer["DbClusterMembers"].writeList(value.dbClusterMembers, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbClusterMember.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DbClusterOptionGroupMemberships"].writeList(value.dbClusterOptionGroupMemberships, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DbClusterParameterGroup"].write(value.dbClusterParameterGroup)
        try writer["DbClusterResourceId"].write(value.dbClusterResourceId)
        try writer["DbSubnetGroup"].write(value.dbSubnetGroup)
        try writer["DeletionProtection"].write(value.deletionProtection)
        try writer["DomainMemberships"].writeList(value.domainMemberships, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbDomainMembership.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnabledCloudWatchLogsExports"].writeList(value.enabledCloudWatchLogsExports, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Endpoint"].write(value.endpoint)
        try writer["Engine"].write(value.engine)
        try writer["EngineMode"].write(value.engineMode)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["HostedZoneId"].write(value.hostedZoneId)
        try writer["HttpEndpointEnabled"].write(value.httpEndpointEnabled)
        try writer["IamDatabaseAuthenticationEnabled"].write(value.iamDatabaseAuthenticationEnabled)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MasterUsername"].write(value.masterUsername)
        try writer["MultiAz"].write(value.multiAz)
        try writer["Port"].write(value.port)
        try writer["PreferredBackupWindow"].write(value.preferredBackupWindow)
        try writer["PreferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["ReadReplicaIdentifiers"].writeList(value.readReplicaIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReaderEndpoint"].write(value.readerEndpoint)
        try writer["Status"].write(value.status)
        try writer["StorageEncrypted"].write(value.storageEncrypted)
        try writer["VpcSecurityGroups"].writeList(value.vpcSecurityGroups, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbClusterDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbClusterDetails()
        value.allocatedStorage = try reader["AllocatedStorage"].readIfPresent()
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.backupRetentionPeriod = try reader["BackupRetentionPeriod"].readIfPresent()
        value.databaseName = try reader["DatabaseName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.readerEndpoint = try reader["ReaderEndpoint"].readIfPresent()
        value.customEndpoints = try reader["CustomEndpoints"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.multiAz = try reader["MultiAz"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.masterUsername = try reader["MasterUsername"].readIfPresent()
        value.preferredBackupWindow = try reader["PreferredBackupWindow"].readIfPresent()
        value.preferredMaintenanceWindow = try reader["PreferredMaintenanceWindow"].readIfPresent()
        value.readReplicaIdentifiers = try reader["ReadReplicaIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcSecurityGroups = try reader["VpcSecurityGroups"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.hostedZoneId = try reader["HostedZoneId"].readIfPresent()
        value.storageEncrypted = try reader["StorageEncrypted"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.dbClusterResourceId = try reader["DbClusterResourceId"].readIfPresent()
        value.associatedRoles = try reader["AssociatedRoles"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clusterCreateTime = try reader["ClusterCreateTime"].readIfPresent()
        value.enabledCloudWatchLogsExports = try reader["EnabledCloudWatchLogsExports"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.engineMode = try reader["EngineMode"].readIfPresent()
        value.deletionProtection = try reader["DeletionProtection"].readIfPresent()
        value.httpEndpointEnabled = try reader["HttpEndpointEnabled"].readIfPresent()
        value.activityStreamStatus = try reader["ActivityStreamStatus"].readIfPresent()
        value.copyTagsToSnapshot = try reader["CopyTagsToSnapshot"].readIfPresent()
        value.crossAccountClone = try reader["CrossAccountClone"].readIfPresent()
        value.domainMemberships = try reader["DomainMemberships"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbDomainMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dbClusterParameterGroup = try reader["DbClusterParameterGroup"].readIfPresent()
        value.dbSubnetGroup = try reader["DbSubnetGroup"].readIfPresent()
        value.dbClusterOptionGroupMemberships = try reader["DbClusterOptionGroupMemberships"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dbClusterIdentifier = try reader["DbClusterIdentifier"].readIfPresent()
        value.dbClusterMembers = try reader["DbClusterMembers"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbClusterMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.iamDatabaseAuthenticationEnabled = try reader["IamDatabaseAuthenticationEnabled"].readIfPresent()
        value.autoMinorVersionUpgrade = try reader["AutoMinorVersionUpgrade"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbClusterMember {

    static func write(value: SecurityHubClientTypes.AwsRdsDbClusterMember?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DbClusterParameterGroupStatus"].write(value.dbClusterParameterGroupStatus)
        try writer["DbInstanceIdentifier"].write(value.dbInstanceIdentifier)
        try writer["IsClusterWriter"].write(value.isClusterWriter)
        try writer["PromotionTier"].write(value.promotionTier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbClusterMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbClusterMember()
        value.isClusterWriter = try reader["IsClusterWriter"].readIfPresent()
        value.promotionTier = try reader["PromotionTier"].readIfPresent()
        value.dbInstanceIdentifier = try reader["DbInstanceIdentifier"].readIfPresent()
        value.dbClusterParameterGroupStatus = try reader["DbClusterParameterGroupStatus"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership {

    static func write(value: SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DbClusterOptionGroupName"].write(value.dbClusterOptionGroupName)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership()
        value.dbClusterOptionGroupName = try reader["DbClusterOptionGroupName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbDomainMembership {

    static func write(value: SecurityHubClientTypes.AwsRdsDbDomainMembership?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domain"].write(value.domain)
        try writer["Fqdn"].write(value.fqdn)
        try writer["IamRoleName"].write(value.iamRoleName)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbDomainMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbDomainMembership()
        value.domain = try reader["Domain"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.fqdn = try reader["Fqdn"].readIfPresent()
        value.iamRoleName = try reader["IamRoleName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole {

    static func write(value: SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup {

    static func write(value: SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
        try writer["VpcSecurityGroupId"].write(value.vpcSecurityGroupId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup()
        value.vpcSecurityGroupId = try reader["VpcSecurityGroupId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails {

    static func write(value: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedStorage"].write(value.allocatedStorage)
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClusterCreateTime"].write(value.clusterCreateTime)
        try writer["DbClusterIdentifier"].write(value.dbClusterIdentifier)
        try writer["DbClusterSnapshotAttributes"].writeList(value.dbClusterSnapshotAttributes, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DbClusterSnapshotIdentifier"].write(value.dbClusterSnapshotIdentifier)
        try writer["Engine"].write(value.engine)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["IamDatabaseAuthenticationEnabled"].write(value.iamDatabaseAuthenticationEnabled)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["LicenseModel"].write(value.licenseModel)
        try writer["MasterUsername"].write(value.masterUsername)
        try writer["PercentProgress"].write(value.percentProgress)
        try writer["Port"].write(value.port)
        try writer["SnapshotCreateTime"].write(value.snapshotCreateTime)
        try writer["SnapshotType"].write(value.snapshotType)
        try writer["Status"].write(value.status)
        try writer["StorageEncrypted"].write(value.storageEncrypted)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails()
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.snapshotCreateTime = try reader["SnapshotCreateTime"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.allocatedStorage = try reader["AllocatedStorage"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.clusterCreateTime = try reader["ClusterCreateTime"].readIfPresent()
        value.masterUsername = try reader["MasterUsername"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.licenseModel = try reader["LicenseModel"].readIfPresent()
        value.snapshotType = try reader["SnapshotType"].readIfPresent()
        value.percentProgress = try reader["PercentProgress"].readIfPresent()
        value.storageEncrypted = try reader["StorageEncrypted"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.dbClusterIdentifier = try reader["DbClusterIdentifier"].readIfPresent()
        value.dbClusterSnapshotIdentifier = try reader["DbClusterSnapshotIdentifier"].readIfPresent()
        value.iamDatabaseAuthenticationEnabled = try reader["IamDatabaseAuthenticationEnabled"].readIfPresent()
        value.dbClusterSnapshotAttributes = try reader["DbClusterSnapshotAttributes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute {

    static func write(value: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeValues"].writeList(value.attributeValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute()
        value.attributeName = try reader["AttributeName"].readIfPresent()
        value.attributeValues = try reader["AttributeValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbSnapshotDetails {

    static func write(value: SecurityHubClientTypes.AwsRdsDbSnapshotDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedStorage"].write(value.allocatedStorage)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["DbInstanceIdentifier"].write(value.dbInstanceIdentifier)
        try writer["DbSnapshotIdentifier"].write(value.dbSnapshotIdentifier)
        try writer["DbiResourceId"].write(value.dbiResourceId)
        try writer["Encrypted"].write(value.encrypted)
        try writer["Engine"].write(value.engine)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["IamDatabaseAuthenticationEnabled"].write(value.iamDatabaseAuthenticationEnabled)
        try writer["InstanceCreateTime"].write(value.instanceCreateTime)
        try writer["Iops"].write(value.iops)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["LicenseModel"].write(value.licenseModel)
        try writer["MasterUsername"].write(value.masterUsername)
        try writer["OptionGroupName"].write(value.optionGroupName)
        try writer["PercentProgress"].write(value.percentProgress)
        try writer["Port"].write(value.port)
        try writer["ProcessorFeatures"].writeList(value.processorFeatures, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbProcessorFeature.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SnapshotCreateTime"].write(value.snapshotCreateTime)
        try writer["SnapshotType"].write(value.snapshotType)
        try writer["SourceDbSnapshotIdentifier"].write(value.sourceDbSnapshotIdentifier)
        try writer["SourceRegion"].write(value.sourceRegion)
        try writer["Status"].write(value.status)
        try writer["StorageType"].write(value.storageType)
        try writer["TdeCredentialArn"].write(value.tdeCredentialArn)
        try writer["Timezone"].write(value.timezone)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbSnapshotDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbSnapshotDetails()
        value.dbSnapshotIdentifier = try reader["DbSnapshotIdentifier"].readIfPresent()
        value.dbInstanceIdentifier = try reader["DbInstanceIdentifier"].readIfPresent()
        value.snapshotCreateTime = try reader["SnapshotCreateTime"].readIfPresent()
        value.engine = try reader["Engine"].readIfPresent()
        value.allocatedStorage = try reader["AllocatedStorage"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.instanceCreateTime = try reader["InstanceCreateTime"].readIfPresent()
        value.masterUsername = try reader["MasterUsername"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.licenseModel = try reader["LicenseModel"].readIfPresent()
        value.snapshotType = try reader["SnapshotType"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        value.optionGroupName = try reader["OptionGroupName"].readIfPresent()
        value.percentProgress = try reader["PercentProgress"].readIfPresent()
        value.sourceRegion = try reader["SourceRegion"].readIfPresent()
        value.sourceDbSnapshotIdentifier = try reader["SourceDbSnapshotIdentifier"].readIfPresent()
        value.storageType = try reader["StorageType"].readIfPresent()
        value.tdeCredentialArn = try reader["TdeCredentialArn"].readIfPresent()
        value.encrypted = try reader["Encrypted"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.timezone = try reader["Timezone"].readIfPresent()
        value.iamDatabaseAuthenticationEnabled = try reader["IamDatabaseAuthenticationEnabled"].readIfPresent()
        value.processorFeatures = try reader["ProcessorFeatures"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbProcessorFeature.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dbiResourceId = try reader["DbiResourceId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbProcessorFeature {

    static func write(value: SecurityHubClientTypes.AwsRdsDbProcessorFeature?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbProcessorFeature {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbProcessorFeature()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafWebAclDetails {

    static func write(value: SecurityHubClientTypes.AwsWafWebAclDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultAction"].write(value.defaultAction)
        try writer["Name"].write(value.name)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: SecurityHubClientTypes.AwsWafWebAclRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WebAclId"].write(value.webAclId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafWebAclDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafWebAclDetails()
        value.name = try reader["Name"].readIfPresent()
        value.defaultAction = try reader["DefaultAction"].readIfPresent()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsWafWebAclRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.webAclId = try reader["WebAclId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsWafWebAclRule {

    static func write(value: SecurityHubClientTypes.AwsWafWebAclRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: SecurityHubClientTypes.WafAction.write(value:to:))
        try writer["ExcludedRules"].writeList(value.excludedRules, memberWritingClosure: SecurityHubClientTypes.WafExcludedRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OverrideAction"].write(value.overrideAction, with: SecurityHubClientTypes.WafOverrideAction.write(value:to:))
        try writer["Priority"].write(value.priority)
        try writer["RuleId"].write(value.ruleId)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsWafWebAclRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsWafWebAclRule()
        value.action = try reader["Action"].readIfPresent(with: SecurityHubClientTypes.WafAction.read(from:))
        value.excludedRules = try reader["ExcludedRules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.WafExcludedRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.overrideAction = try reader["OverrideAction"].readIfPresent(with: SecurityHubClientTypes.WafOverrideAction.read(from:))
        value.priority = try reader["Priority"].readIfPresent()
        value.ruleId = try reader["RuleId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.WafOverrideAction {

    static func write(value: SecurityHubClientTypes.WafOverrideAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.WafOverrideAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.WafOverrideAction()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.WafExcludedRule {

    static func write(value: SecurityHubClientTypes.WafExcludedRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleId"].write(value.ruleId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.WafExcludedRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.WafExcludedRule()
        value.ruleId = try reader["RuleId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.WafAction {

    static func write(value: SecurityHubClientTypes.WafAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.WafAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.WafAction()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsSqsQueueDetails {

    static func write(value: SecurityHubClientTypes.AwsSqsQueueDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeadLetterTargetArn"].write(value.deadLetterTargetArn)
        try writer["KmsDataKeyReusePeriodSeconds"].write(value.kmsDataKeyReusePeriodSeconds)
        try writer["KmsMasterKeyId"].write(value.kmsMasterKeyId)
        try writer["QueueName"].write(value.queueName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSqsQueueDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSqsQueueDetails()
        value.kmsDataKeyReusePeriodSeconds = try reader["KmsDataKeyReusePeriodSeconds"].readIfPresent()
        value.kmsMasterKeyId = try reader["KmsMasterKeyId"].readIfPresent()
        value.queueName = try reader["QueueName"].readIfPresent()
        value.deadLetterTargetArn = try reader["DeadLetterTargetArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsSnsTopicDetails {

    static func write(value: SecurityHubClientTypes.AwsSnsTopicDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationSuccessFeedbackRoleArn"].write(value.applicationSuccessFeedbackRoleArn)
        try writer["FirehoseFailureFeedbackRoleArn"].write(value.firehoseFailureFeedbackRoleArn)
        try writer["FirehoseSuccessFeedbackRoleArn"].write(value.firehoseSuccessFeedbackRoleArn)
        try writer["HttpFailureFeedbackRoleArn"].write(value.httpFailureFeedbackRoleArn)
        try writer["HttpSuccessFeedbackRoleArn"].write(value.httpSuccessFeedbackRoleArn)
        try writer["KmsMasterKeyId"].write(value.kmsMasterKeyId)
        try writer["Owner"].write(value.owner)
        try writer["SqsFailureFeedbackRoleArn"].write(value.sqsFailureFeedbackRoleArn)
        try writer["SqsSuccessFeedbackRoleArn"].write(value.sqsSuccessFeedbackRoleArn)
        try writer["Subscription"].writeList(value.subscription, memberWritingClosure: SecurityHubClientTypes.AwsSnsTopicSubscription.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TopicName"].write(value.topicName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSnsTopicDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSnsTopicDetails()
        value.kmsMasterKeyId = try reader["KmsMasterKeyId"].readIfPresent()
        value.subscription = try reader["Subscription"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsSnsTopicSubscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.topicName = try reader["TopicName"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.sqsSuccessFeedbackRoleArn = try reader["SqsSuccessFeedbackRoleArn"].readIfPresent()
        value.sqsFailureFeedbackRoleArn = try reader["SqsFailureFeedbackRoleArn"].readIfPresent()
        value.applicationSuccessFeedbackRoleArn = try reader["ApplicationSuccessFeedbackRoleArn"].readIfPresent()
        value.firehoseSuccessFeedbackRoleArn = try reader["FirehoseSuccessFeedbackRoleArn"].readIfPresent()
        value.firehoseFailureFeedbackRoleArn = try reader["FirehoseFailureFeedbackRoleArn"].readIfPresent()
        value.httpSuccessFeedbackRoleArn = try reader["HttpSuccessFeedbackRoleArn"].readIfPresent()
        value.httpFailureFeedbackRoleArn = try reader["HttpFailureFeedbackRoleArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsSnsTopicSubscription {

    static func write(value: SecurityHubClientTypes.AwsSnsTopicSubscription?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Endpoint"].write(value.endpoint)
        try writer["Protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSnsTopicSubscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSnsTopicSubscription()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbInstanceDetails {

    static func write(value: SecurityHubClientTypes.AwsRdsDbInstanceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedStorage"].write(value.allocatedStorage)
        try writer["AssociatedRoles"].writeList(value.associatedRoles, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AutoMinorVersionUpgrade"].write(value.autoMinorVersionUpgrade)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["BackupRetentionPeriod"].write(value.backupRetentionPeriod)
        try writer["CACertificateIdentifier"].write(value.caCertificateIdentifier)
        try writer["CharacterSetName"].write(value.characterSetName)
        try writer["CopyTagsToSnapshot"].write(value.copyTagsToSnapshot)
        try writer["DBClusterIdentifier"].write(value.dbClusterIdentifier)
        try writer["DBInstanceClass"].write(value.dbInstanceClass)
        try writer["DBInstanceIdentifier"].write(value.dbInstanceIdentifier)
        try writer["DBName"].write(value.dbName)
        try writer["DbInstancePort"].write(value.dbInstancePort)
        try writer["DbInstanceStatus"].write(value.dbInstanceStatus)
        try writer["DbParameterGroups"].writeList(value.dbParameterGroups, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbParameterGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DbSecurityGroups"].writeList(value.dbSecurityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DbSubnetGroup"].write(value.dbSubnetGroup, with: SecurityHubClientTypes.AwsRdsDbSubnetGroup.write(value:to:))
        try writer["DbiResourceId"].write(value.dbiResourceId)
        try writer["DeletionProtection"].write(value.deletionProtection)
        try writer["DomainMemberships"].writeList(value.domainMemberships, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbDomainMembership.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnabledCloudWatchLogsExports"].writeList(value.enabledCloudWatchLogsExports, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Endpoint"].write(value.endpoint, with: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint.write(value:to:))
        try writer["Engine"].write(value.engine)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["EnhancedMonitoringResourceArn"].write(value.enhancedMonitoringResourceArn)
        try writer["IAMDatabaseAuthenticationEnabled"].write(value.iamDatabaseAuthenticationEnabled)
        try writer["InstanceCreateTime"].write(value.instanceCreateTime)
        try writer["Iops"].write(value.iops)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["LatestRestorableTime"].write(value.latestRestorableTime)
        try writer["LicenseModel"].write(value.licenseModel)
        try writer["ListenerEndpoint"].write(value.listenerEndpoint, with: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint.write(value:to:))
        try writer["MasterUsername"].write(value.masterUsername)
        try writer["MaxAllocatedStorage"].write(value.maxAllocatedStorage)
        try writer["MonitoringInterval"].write(value.monitoringInterval)
        try writer["MonitoringRoleArn"].write(value.monitoringRoleArn)
        try writer["MultiAz"].write(value.multiAz)
        try writer["OptionGroupMemberships"].writeList(value.optionGroupMemberships, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbOptionGroupMembership.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PendingModifiedValues"].write(value.pendingModifiedValues, with: SecurityHubClientTypes.AwsRdsDbPendingModifiedValues.write(value:to:))
        try writer["PerformanceInsightsEnabled"].write(value.performanceInsightsEnabled)
        try writer["PerformanceInsightsKmsKeyId"].write(value.performanceInsightsKmsKeyId)
        try writer["PerformanceInsightsRetentionPeriod"].write(value.performanceInsightsRetentionPeriod)
        try writer["PreferredBackupWindow"].write(value.preferredBackupWindow)
        try writer["PreferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["ProcessorFeatures"].writeList(value.processorFeatures, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbProcessorFeature.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PromotionTier"].write(value.promotionTier)
        try writer["PubliclyAccessible"].write(value.publiclyAccessible)
        try writer["ReadReplicaDBClusterIdentifiers"].writeList(value.readReplicaDBClusterIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReadReplicaDBInstanceIdentifiers"].writeList(value.readReplicaDBInstanceIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReadReplicaSourceDBInstanceIdentifier"].write(value.readReplicaSourceDBInstanceIdentifier)
        try writer["SecondaryAvailabilityZone"].write(value.secondaryAvailabilityZone)
        try writer["StatusInfos"].writeList(value.statusInfos, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbStatusInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StorageEncrypted"].write(value.storageEncrypted)
        try writer["StorageType"].write(value.storageType)
        try writer["TdeCredentialArn"].write(value.tdeCredentialArn)
        try writer["Timezone"].write(value.timezone)
        try writer["VpcSecurityGroups"].writeList(value.vpcSecurityGroups, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbInstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbInstanceDetails()
        value.associatedRoles = try reader["AssociatedRoles"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.caCertificateIdentifier = try reader["CACertificateIdentifier"].readIfPresent()
        value.dbClusterIdentifier = try reader["DBClusterIdentifier"].readIfPresent()
        value.dbInstanceIdentifier = try reader["DBInstanceIdentifier"].readIfPresent()
        value.dbInstanceClass = try reader["DBInstanceClass"].readIfPresent()
        value.dbInstancePort = try reader["DbInstancePort"].readIfPresent()
        value.dbiResourceId = try reader["DbiResourceId"].readIfPresent()
        value.dbName = try reader["DBName"].readIfPresent()
        value.deletionProtection = try reader["DeletionProtection"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint.read(from:))
        value.engine = try reader["Engine"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.iamDatabaseAuthenticationEnabled = try reader["IAMDatabaseAuthenticationEnabled"].readIfPresent()
        value.instanceCreateTime = try reader["InstanceCreateTime"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.publiclyAccessible = try reader["PubliclyAccessible"].readIfPresent()
        value.storageEncrypted = try reader["StorageEncrypted"].readIfPresent()
        value.tdeCredentialArn = try reader["TdeCredentialArn"].readIfPresent()
        value.vpcSecurityGroups = try reader["VpcSecurityGroups"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.multiAz = try reader["MultiAz"].readIfPresent()
        value.enhancedMonitoringResourceArn = try reader["EnhancedMonitoringResourceArn"].readIfPresent()
        value.dbInstanceStatus = try reader["DbInstanceStatus"].readIfPresent()
        value.masterUsername = try reader["MasterUsername"].readIfPresent()
        value.allocatedStorage = try reader["AllocatedStorage"].readIfPresent()
        value.preferredBackupWindow = try reader["PreferredBackupWindow"].readIfPresent()
        value.backupRetentionPeriod = try reader["BackupRetentionPeriod"].readIfPresent()
        value.dbSecurityGroups = try reader["DbSecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dbParameterGroups = try reader["DbParameterGroups"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbParameterGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.dbSubnetGroup = try reader["DbSubnetGroup"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbSubnetGroup.read(from:))
        value.preferredMaintenanceWindow = try reader["PreferredMaintenanceWindow"].readIfPresent()
        value.pendingModifiedValues = try reader["PendingModifiedValues"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbPendingModifiedValues.read(from:))
        value.latestRestorableTime = try reader["LatestRestorableTime"].readIfPresent()
        value.autoMinorVersionUpgrade = try reader["AutoMinorVersionUpgrade"].readIfPresent()
        value.readReplicaSourceDBInstanceIdentifier = try reader["ReadReplicaSourceDBInstanceIdentifier"].readIfPresent()
        value.readReplicaDBInstanceIdentifiers = try reader["ReadReplicaDBInstanceIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.readReplicaDBClusterIdentifiers = try reader["ReadReplicaDBClusterIdentifiers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.licenseModel = try reader["LicenseModel"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        value.optionGroupMemberships = try reader["OptionGroupMemberships"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbOptionGroupMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.characterSetName = try reader["CharacterSetName"].readIfPresent()
        value.secondaryAvailabilityZone = try reader["SecondaryAvailabilityZone"].readIfPresent()
        value.statusInfos = try reader["StatusInfos"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbStatusInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.storageType = try reader["StorageType"].readIfPresent()
        value.domainMemberships = try reader["DomainMemberships"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbDomainMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.copyTagsToSnapshot = try reader["CopyTagsToSnapshot"].readIfPresent()
        value.monitoringInterval = try reader["MonitoringInterval"].readIfPresent()
        value.monitoringRoleArn = try reader["MonitoringRoleArn"].readIfPresent()
        value.promotionTier = try reader["PromotionTier"].readIfPresent()
        value.timezone = try reader["Timezone"].readIfPresent()
        value.performanceInsightsEnabled = try reader["PerformanceInsightsEnabled"].readIfPresent()
        value.performanceInsightsKmsKeyId = try reader["PerformanceInsightsKmsKeyId"].readIfPresent()
        value.performanceInsightsRetentionPeriod = try reader["PerformanceInsightsRetentionPeriod"].readIfPresent()
        value.enabledCloudWatchLogsExports = try reader["EnabledCloudWatchLogsExports"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.processorFeatures = try reader["ProcessorFeatures"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbProcessorFeature.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listenerEndpoint = try reader["ListenerEndpoint"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint.read(from:))
        value.maxAllocatedStorage = try reader["MaxAllocatedStorage"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbInstanceEndpoint {

    static func write(value: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["HostedZoneId"].write(value.hostedZoneId)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbInstanceEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbInstanceEndpoint()
        value.address = try reader["Address"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.hostedZoneId = try reader["HostedZoneId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbStatusInfo {

    static func write(value: SecurityHubClientTypes.AwsRdsDbStatusInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Message"].write(value.message)
        try writer["Normal"].write(value.normal)
        try writer["Status"].write(value.status)
        try writer["StatusType"].write(value.statusType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbStatusInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbStatusInfo()
        value.statusType = try reader["StatusType"].readIfPresent()
        value.normal = try reader["Normal"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbOptionGroupMembership {

    static func write(value: SecurityHubClientTypes.AwsRdsDbOptionGroupMembership?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OptionGroupName"].write(value.optionGroupName)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbOptionGroupMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbOptionGroupMembership()
        value.optionGroupName = try reader["OptionGroupName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbPendingModifiedValues {

    static func write(value: SecurityHubClientTypes.AwsRdsDbPendingModifiedValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocatedStorage"].write(value.allocatedStorage)
        try writer["BackupRetentionPeriod"].write(value.backupRetentionPeriod)
        try writer["CaCertificateIdentifier"].write(value.caCertificateIdentifier)
        try writer["DbInstanceClass"].write(value.dbInstanceClass)
        try writer["DbInstanceIdentifier"].write(value.dbInstanceIdentifier)
        try writer["DbSubnetGroupName"].write(value.dbSubnetGroupName)
        try writer["EngineVersion"].write(value.engineVersion)
        try writer["Iops"].write(value.iops)
        try writer["LicenseModel"].write(value.licenseModel)
        try writer["MasterUserPassword"].write(value.masterUserPassword)
        try writer["MultiAZ"].write(value.multiAZ)
        try writer["PendingCloudWatchLogsExports"].write(value.pendingCloudWatchLogsExports, with: SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports.write(value:to:))
        try writer["Port"].write(value.port)
        try writer["ProcessorFeatures"].writeList(value.processorFeatures, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbProcessorFeature.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StorageType"].write(value.storageType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbPendingModifiedValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbPendingModifiedValues()
        value.dbInstanceClass = try reader["DbInstanceClass"].readIfPresent()
        value.allocatedStorage = try reader["AllocatedStorage"].readIfPresent()
        value.masterUserPassword = try reader["MasterUserPassword"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.backupRetentionPeriod = try reader["BackupRetentionPeriod"].readIfPresent()
        value.multiAZ = try reader["MultiAZ"].readIfPresent()
        value.engineVersion = try reader["EngineVersion"].readIfPresent()
        value.licenseModel = try reader["LicenseModel"].readIfPresent()
        value.iops = try reader["Iops"].readIfPresent()
        value.dbInstanceIdentifier = try reader["DbInstanceIdentifier"].readIfPresent()
        value.storageType = try reader["StorageType"].readIfPresent()
        value.caCertificateIdentifier = try reader["CaCertificateIdentifier"].readIfPresent()
        value.dbSubnetGroupName = try reader["DbSubnetGroupName"].readIfPresent()
        value.pendingCloudWatchLogsExports = try reader["PendingCloudWatchLogsExports"].readIfPresent(with: SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports.read(from:))
        value.processorFeatures = try reader["ProcessorFeatures"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbProcessorFeature.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports {

    static func write(value: SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogTypesToDisable"].writeList(value.logTypesToDisable, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LogTypesToEnable"].writeList(value.logTypesToEnable, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports()
        value.logTypesToEnable = try reader["LogTypesToEnable"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.logTypesToDisable = try reader["LogTypesToDisable"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbSubnetGroup {

    static func write(value: SecurityHubClientTypes.AwsRdsDbSubnetGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DbSubnetGroupArn"].write(value.dbSubnetGroupArn)
        try writer["DbSubnetGroupDescription"].write(value.dbSubnetGroupDescription)
        try writer["DbSubnetGroupName"].write(value.dbSubnetGroupName)
        try writer["SubnetGroupStatus"].write(value.subnetGroupStatus)
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbSubnetGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbSubnetGroup()
        value.dbSubnetGroupName = try reader["DbSubnetGroupName"].readIfPresent()
        value.dbSubnetGroupDescription = try reader["DbSubnetGroupDescription"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.subnetGroupStatus = try reader["SubnetGroupStatus"].readIfPresent()
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dbSubnetGroupArn = try reader["DbSubnetGroupArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet {

    static func write(value: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubnetAvailabilityZone"].write(value.subnetAvailabilityZone, with: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone.write(value:to:))
        try writer["SubnetIdentifier"].write(value.subnetIdentifier)
        try writer["SubnetStatus"].write(value.subnetStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet()
        value.subnetIdentifier = try reader["SubnetIdentifier"].readIfPresent()
        value.subnetAvailabilityZone = try reader["SubnetAvailabilityZone"].readIfPresent(with: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone.read(from:))
        value.subnetStatus = try reader["SubnetStatus"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone {

    static func write(value: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbParameterGroup {

    static func write(value: SecurityHubClientTypes.AwsRdsDbParameterGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DbParameterGroupName"].write(value.dbParameterGroupName)
        try writer["ParameterApplyStatus"].write(value.parameterApplyStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbParameterGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbParameterGroup()
        value.dbParameterGroupName = try reader["DbParameterGroupName"].readIfPresent()
        value.parameterApplyStatus = try reader["ParameterApplyStatus"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole {

    static func write(value: SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FeatureName"].write(value.featureName)
        try writer["RoleArn"].write(value.roleArn)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.featureName = try reader["FeatureName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsLambdaLayerVersionDetails {

    static func write(value: SecurityHubClientTypes.AwsLambdaLayerVersionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CompatibleRuntimes"].writeList(value.compatibleRuntimes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreatedDate"].write(value.createdDate)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsLambdaLayerVersionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsLambdaLayerVersionDetails()
        value.version = try reader["Version"].readIfPresent()
        value.compatibleRuntimes = try reader["CompatibleRuntimes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsLambdaFunctionDetails {

    static func write(value: SecurityHubClientTypes.AwsLambdaFunctionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Architectures"].writeList(value.architectures, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Code"].write(value.code, with: SecurityHubClientTypes.AwsLambdaFunctionCode.write(value:to:))
        try writer["CodeSha256"].write(value.codeSha256)
        try writer["DeadLetterConfig"].write(value.deadLetterConfig, with: SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig.write(value:to:))
        try writer["Environment"].write(value.environment, with: SecurityHubClientTypes.AwsLambdaFunctionEnvironment.write(value:to:))
        try writer["FunctionName"].write(value.functionName)
        try writer["Handler"].write(value.handler)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["LastModified"].write(value.lastModified)
        try writer["Layers"].writeList(value.layers, memberWritingClosure: SecurityHubClientTypes.AwsLambdaFunctionLayer.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MasterArn"].write(value.masterArn)
        try writer["MemorySize"].write(value.memorySize)
        try writer["PackageType"].write(value.packageType)
        try writer["RevisionId"].write(value.revisionId)
        try writer["Role"].write(value.role)
        try writer["Runtime"].write(value.runtime)
        try writer["Timeout"].write(value.timeout)
        try writer["TracingConfig"].write(value.tracingConfig, with: SecurityHubClientTypes.AwsLambdaFunctionTracingConfig.write(value:to:))
        try writer["Version"].write(value.version)
        try writer["VpcConfig"].write(value.vpcConfig, with: SecurityHubClientTypes.AwsLambdaFunctionVpcConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsLambdaFunctionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsLambdaFunctionDetails()
        value.code = try reader["Code"].readIfPresent(with: SecurityHubClientTypes.AwsLambdaFunctionCode.read(from:))
        value.codeSha256 = try reader["CodeSha256"].readIfPresent()
        value.deadLetterConfig = try reader["DeadLetterConfig"].readIfPresent(with: SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig.read(from:))
        value.environment = try reader["Environment"].readIfPresent(with: SecurityHubClientTypes.AwsLambdaFunctionEnvironment.read(from:))
        value.functionName = try reader["FunctionName"].readIfPresent()
        value.handler = try reader["Handler"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.layers = try reader["Layers"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsLambdaFunctionLayer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.masterArn = try reader["MasterArn"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.revisionId = try reader["RevisionId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.runtime = try reader["Runtime"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.tracingConfig = try reader["TracingConfig"].readIfPresent(with: SecurityHubClientTypes.AwsLambdaFunctionTracingConfig.read(from:))
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: SecurityHubClientTypes.AwsLambdaFunctionVpcConfig.read(from:))
        value.version = try reader["Version"].readIfPresent()
        value.architectures = try reader["Architectures"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.packageType = try reader["PackageType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsLambdaFunctionVpcConfig {

    static func write(value: SecurityHubClientTypes.AwsLambdaFunctionVpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsLambdaFunctionVpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsLambdaFunctionVpcConfig()
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsLambdaFunctionTracingConfig {

    static func write(value: SecurityHubClientTypes.AwsLambdaFunctionTracingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Mode"].write(value.mode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsLambdaFunctionTracingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsLambdaFunctionTracingConfig()
        value.mode = try reader["Mode"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsLambdaFunctionLayer {

    static func write(value: SecurityHubClientTypes.AwsLambdaFunctionLayer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["CodeSize"].write(value.codeSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsLambdaFunctionLayer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsLambdaFunctionLayer()
        value.arn = try reader["Arn"].readIfPresent()
        value.codeSize = try reader["CodeSize"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsLambdaFunctionEnvironment {

    static func write(value: SecurityHubClientTypes.AwsLambdaFunctionEnvironment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Error"].write(value.error, with: SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError.write(value:to:))
        try writer["Variables"].writeMap(value.variables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsLambdaFunctionEnvironment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsLambdaFunctionEnvironment()
        value.variables = try reader["Variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.error = try reader["Error"].readIfPresent(with: SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError {

    static func write(value: SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ErrorCode"].write(value.errorCode)
        try writer["Message"].write(value.message)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig {

    static func write(value: SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetArn"].write(value.targetArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig()
        value.targetArn = try reader["TargetArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsLambdaFunctionCode {

    static func write(value: SecurityHubClientTypes.AwsLambdaFunctionCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["S3Key"].write(value.s3Key)
        try writer["S3ObjectVersion"].write(value.s3ObjectVersion)
        try writer["ZipFile"].write(value.zipFile)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsLambdaFunctionCode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsLambdaFunctionCode()
        value.s3Bucket = try reader["S3Bucket"].readIfPresent()
        value.s3Key = try reader["S3Key"].readIfPresent()
        value.s3ObjectVersion = try reader["S3ObjectVersion"].readIfPresent()
        value.zipFile = try reader["ZipFile"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsKmsKeyDetails {

    static func write(value: SecurityHubClientTypes.AwsKmsKeyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AWSAccountId"].write(value.awsAccountId)
        try writer["CreationDate"].write(value.creationDate)
        try writer["Description"].write(value.description)
        try writer["KeyId"].write(value.keyId)
        try writer["KeyManager"].write(value.keyManager)
        try writer["KeyRotationStatus"].write(value.keyRotationStatus)
        try writer["KeyState"].write(value.keyState)
        try writer["Origin"].write(value.origin)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsKmsKeyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsKmsKeyDetails()
        value.awsAccountId = try reader["AWSAccountId"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.keyId = try reader["KeyId"].readIfPresent()
        value.keyManager = try reader["KeyManager"].readIfPresent()
        value.keyState = try reader["KeyState"].readIfPresent()
        value.origin = try reader["Origin"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.keyRotationStatus = try reader["KeyRotationStatus"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamRoleDetails {

    static func write(value: SecurityHubClientTypes.AwsIamRoleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssumeRolePolicyDocument"].write(value.assumeRolePolicyDocument)
        try writer["AttachedManagedPolicies"].writeList(value.attachedManagedPolicies, memberWritingClosure: SecurityHubClientTypes.AwsIamAttachedManagedPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreateDate"].write(value.createDate)
        try writer["InstanceProfileList"].writeList(value.instanceProfileList, memberWritingClosure: SecurityHubClientTypes.AwsIamInstanceProfile.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxSessionDuration"].write(value.maxSessionDuration)
        try writer["Path"].write(value.path)
        try writer["PermissionsBoundary"].write(value.permissionsBoundary, with: SecurityHubClientTypes.AwsIamPermissionsBoundary.write(value:to:))
        try writer["RoleId"].write(value.roleId)
        try writer["RoleName"].write(value.roleName)
        try writer["RolePolicyList"].writeList(value.rolePolicyList, memberWritingClosure: SecurityHubClientTypes.AwsIamRolePolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamRoleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamRoleDetails()
        value.assumeRolePolicyDocument = try reader["AssumeRolePolicyDocument"].readIfPresent()
        value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsIamAttachedManagedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createDate = try reader["CreateDate"].readIfPresent()
        value.instanceProfileList = try reader["InstanceProfileList"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsIamInstanceProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(with: SecurityHubClientTypes.AwsIamPermissionsBoundary.read(from:))
        value.roleId = try reader["RoleId"].readIfPresent()
        value.roleName = try reader["RoleName"].readIfPresent()
        value.rolePolicyList = try reader["RolePolicyList"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsIamRolePolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxSessionDuration = try reader["MaxSessionDuration"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamRolePolicy {

    static func write(value: SecurityHubClientTypes.AwsIamRolePolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyName"].write(value.policyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamRolePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamRolePolicy()
        value.policyName = try reader["PolicyName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamPermissionsBoundary {

    static func write(value: SecurityHubClientTypes.AwsIamPermissionsBoundary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PermissionsBoundaryArn"].write(value.permissionsBoundaryArn)
        try writer["PermissionsBoundaryType"].write(value.permissionsBoundaryType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamPermissionsBoundary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamPermissionsBoundary()
        value.permissionsBoundaryArn = try reader["PermissionsBoundaryArn"].readIfPresent()
        value.permissionsBoundaryType = try reader["PermissionsBoundaryType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamInstanceProfile {

    static func write(value: SecurityHubClientTypes.AwsIamInstanceProfile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["CreateDate"].write(value.createDate)
        try writer["InstanceProfileId"].write(value.instanceProfileId)
        try writer["InstanceProfileName"].write(value.instanceProfileName)
        try writer["Path"].write(value.path)
        try writer["Roles"].writeList(value.roles, memberWritingClosure: SecurityHubClientTypes.AwsIamInstanceProfileRole.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamInstanceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamInstanceProfile()
        value.arn = try reader["Arn"].readIfPresent()
        value.createDate = try reader["CreateDate"].readIfPresent()
        value.instanceProfileId = try reader["InstanceProfileId"].readIfPresent()
        value.instanceProfileName = try reader["InstanceProfileName"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.roles = try reader["Roles"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsIamInstanceProfileRole.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsIamInstanceProfileRole {

    static func write(value: SecurityHubClientTypes.AwsIamInstanceProfileRole?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["AssumeRolePolicyDocument"].write(value.assumeRolePolicyDocument)
        try writer["CreateDate"].write(value.createDate)
        try writer["Path"].write(value.path)
        try writer["RoleId"].write(value.roleId)
        try writer["RoleName"].write(value.roleName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamInstanceProfileRole {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamInstanceProfileRole()
        value.arn = try reader["Arn"].readIfPresent()
        value.assumeRolePolicyDocument = try reader["AssumeRolePolicyDocument"].readIfPresent()
        value.createDate = try reader["CreateDate"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.roleId = try reader["RoleId"].readIfPresent()
        value.roleName = try reader["RoleName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamAttachedManagedPolicy {

    static func write(value: SecurityHubClientTypes.AwsIamAttachedManagedPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
        try writer["PolicyName"].write(value.policyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamAttachedManagedPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamAttachedManagedPolicy()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsIamGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachedManagedPolicies"].writeList(value.attachedManagedPolicies, memberWritingClosure: SecurityHubClientTypes.AwsIamAttachedManagedPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreateDate"].write(value.createDate)
        try writer["GroupId"].write(value.groupId)
        try writer["GroupName"].write(value.groupName)
        try writer["GroupPolicyList"].writeList(value.groupPolicyList, memberWritingClosure: SecurityHubClientTypes.AwsIamGroupPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamGroupDetails()
        value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsIamAttachedManagedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createDate = try reader["CreateDate"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.groupPolicyList = try reader["GroupPolicyList"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsIamGroupPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.path = try reader["Path"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamGroupPolicy {

    static func write(value: SecurityHubClientTypes.AwsIamGroupPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyName"].write(value.policyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamGroupPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamGroupPolicy()
        value.policyName = try reader["PolicyName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerDetails {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BackendServerDescriptions"].writeList(value.backendServerDescriptions, memberWritingClosure: SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CanonicalHostedZoneName"].write(value.canonicalHostedZoneName)
        try writer["CanonicalHostedZoneNameID"].write(value.canonicalHostedZoneNameID)
        try writer["CreatedTime"].write(value.createdTime)
        try writer["DnsName"].write(value.dnsName)
        try writer["HealthCheck"].write(value.healthCheck, with: SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck.write(value:to:))
        try writer["Instances"].writeList(value.instances, memberWritingClosure: SecurityHubClientTypes.AwsElbLoadBalancerInstance.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ListenerDescriptions"].writeList(value.listenerDescriptions, memberWritingClosure: SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LoadBalancerAttributes"].write(value.loadBalancerAttributes, with: SecurityHubClientTypes.AwsElbLoadBalancerAttributes.write(value:to:))
        try writer["LoadBalancerName"].write(value.loadBalancerName)
        try writer["Policies"].write(value.policies, with: SecurityHubClientTypes.AwsElbLoadBalancerPolicies.write(value:to:))
        try writer["Scheme"].write(value.scheme)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceSecurityGroup"].write(value.sourceSecurityGroup, with: SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup.write(value:to:))
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerDetails()
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.backendServerDescriptions = try reader["BackendServerDescriptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.canonicalHostedZoneName = try reader["CanonicalHostedZoneName"].readIfPresent()
        value.canonicalHostedZoneNameID = try reader["CanonicalHostedZoneNameID"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.dnsName = try reader["DnsName"].readIfPresent()
        value.healthCheck = try reader["HealthCheck"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck.read(from:))
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsElbLoadBalancerInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listenerDescriptions = try reader["ListenerDescriptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loadBalancerAttributes = try reader["LoadBalancerAttributes"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerAttributes.read(from:))
        value.loadBalancerName = try reader["LoadBalancerName"].readIfPresent()
        value.policies = try reader["Policies"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerPolicies.read(from:))
        value.scheme = try reader["Scheme"].readIfPresent()
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceSecurityGroup = try reader["SourceSecurityGroup"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup.read(from:))
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["OwnerAlias"].write(value.ownerAlias)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.ownerAlias = try reader["OwnerAlias"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerPolicies {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerPolicies?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppCookieStickinessPolicies"].writeList(value.appCookieStickinessPolicies, memberWritingClosure: SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LbCookieStickinessPolicies"].writeList(value.lbCookieStickinessPolicies, memberWritingClosure: SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OtherPolicies"].writeList(value.otherPolicies, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerPolicies {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerPolicies()
        value.appCookieStickinessPolicies = try reader["AppCookieStickinessPolicies"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lbCookieStickinessPolicies = try reader["LbCookieStickinessPolicies"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.otherPolicies = try reader["OtherPolicies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy {

    static func write(value: SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CookieExpirationPeriod"].write(value.cookieExpirationPeriod)
        try writer["PolicyName"].write(value.policyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy()
        value.cookieExpirationPeriod = try reader["CookieExpirationPeriod"].readIfPresent()
        value.policyName = try reader["PolicyName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy {

    static func write(value: SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CookieName"].write(value.cookieName)
        try writer["PolicyName"].write(value.policyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy()
        value.cookieName = try reader["CookieName"].readIfPresent()
        value.policyName = try reader["PolicyName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerAttributes {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessLog"].write(value.accessLog, with: SecurityHubClientTypes.AwsElbLoadBalancerAccessLog.write(value:to:))
        try writer["AdditionalAttributes"].writeList(value.additionalAttributes, memberWritingClosure: SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ConnectionDraining"].write(value.connectionDraining, with: SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining.write(value:to:))
        try writer["ConnectionSettings"].write(value.connectionSettings, with: SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings.write(value:to:))
        try writer["CrossZoneLoadBalancing"].write(value.crossZoneLoadBalancing, with: SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerAttributes()
        value.accessLog = try reader["AccessLog"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerAccessLog.read(from:))
        value.connectionDraining = try reader["ConnectionDraining"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining.read(from:))
        value.connectionSettings = try reader["ConnectionSettings"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings.read(from:))
        value.crossZoneLoadBalancing = try reader["CrossZoneLoadBalancing"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing.read(from:))
        value.additionalAttributes = try reader["AdditionalAttributes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IdleTimeout"].write(value.idleTimeout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings()
        value.idleTimeout = try reader["IdleTimeout"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["Timeout"].write(value.timeout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerAccessLog {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerAccessLog?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmitInterval"].write(value.emitInterval)
        try writer["Enabled"].write(value.enabled)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3BucketPrefix"].write(value.s3BucketPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerAccessLog {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerAccessLog()
        value.emitInterval = try reader["EmitInterval"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3BucketPrefix = try reader["S3BucketPrefix"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Listener"].write(value.listener, with: SecurityHubClientTypes.AwsElbLoadBalancerListener.write(value:to:))
        try writer["PolicyNames"].writeList(value.policyNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription()
        value.listener = try reader["Listener"].readIfPresent(with: SecurityHubClientTypes.AwsElbLoadBalancerListener.read(from:))
        value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerListener {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerListener?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstancePort"].write(value.instancePort)
        try writer["InstanceProtocol"].write(value.instanceProtocol)
        try writer["LoadBalancerPort"].write(value.loadBalancerPort)
        try writer["Protocol"].write(value.`protocol`)
        try writer["SslCertificateId"].write(value.sslCertificateId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerListener {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerListener()
        value.instancePort = try reader["InstancePort"].readIfPresent()
        value.instanceProtocol = try reader["InstanceProtocol"].readIfPresent()
        value.loadBalancerPort = try reader["LoadBalancerPort"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.sslCertificateId = try reader["SslCertificateId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerInstance {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerInstance?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerInstance()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HealthyThreshold"].write(value.healthyThreshold)
        try writer["Interval"].write(value.interval)
        try writer["Target"].write(value.target)
        try writer["Timeout"].write(value.timeout)
        try writer["UnhealthyThreshold"].write(value.unhealthyThreshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck()
        value.healthyThreshold = try reader["HealthyThreshold"].readIfPresent()
        value.interval = try reader["Interval"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.unhealthyThreshold = try reader["UnhealthyThreshold"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription {

    static func write(value: SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstancePort"].write(value.instancePort)
        try writer["PolicyNames"].writeList(value.policyNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription()
        value.instancePort = try reader["InstancePort"].readIfPresent()
        value.policyNames = try reader["PolicyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterDetails {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowVersionUpgrade"].write(value.allowVersionUpgrade)
        try writer["AutomatedSnapshotRetentionPeriod"].write(value.automatedSnapshotRetentionPeriod)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["ClusterAvailabilityStatus"].write(value.clusterAvailabilityStatus)
        try writer["ClusterCreateTime"].write(value.clusterCreateTime)
        try writer["ClusterIdentifier"].write(value.clusterIdentifier)
        try writer["ClusterNodes"].writeList(value.clusterNodes, memberWritingClosure: SecurityHubClientTypes.AwsRedshiftClusterClusterNode.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClusterParameterGroups"].writeList(value.clusterParameterGroups, memberWritingClosure: SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClusterPublicKey"].write(value.clusterPublicKey)
        try writer["ClusterRevisionNumber"].write(value.clusterRevisionNumber)
        try writer["ClusterSecurityGroups"].writeList(value.clusterSecurityGroups, memberWritingClosure: SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClusterSnapshotCopyStatus"].write(value.clusterSnapshotCopyStatus, with: SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus.write(value:to:))
        try writer["ClusterStatus"].write(value.clusterStatus)
        try writer["ClusterSubnetGroupName"].write(value.clusterSubnetGroupName)
        try writer["ClusterVersion"].write(value.clusterVersion)
        try writer["DBName"].write(value.dbName)
        try writer["DeferredMaintenanceWindows"].writeList(value.deferredMaintenanceWindows, memberWritingClosure: SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ElasticIpStatus"].write(value.elasticIpStatus, with: SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus.write(value:to:))
        try writer["ElasticResizeNumberOfNodeOptions"].write(value.elasticResizeNumberOfNodeOptions)
        try writer["Encrypted"].write(value.encrypted)
        try writer["Endpoint"].write(value.endpoint, with: SecurityHubClientTypes.AwsRedshiftClusterEndpoint.write(value:to:))
        try writer["EnhancedVpcRouting"].write(value.enhancedVpcRouting)
        try writer["ExpectedNextSnapshotScheduleTime"].write(value.expectedNextSnapshotScheduleTime)
        try writer["ExpectedNextSnapshotScheduleTimeStatus"].write(value.expectedNextSnapshotScheduleTimeStatus)
        try writer["HsmStatus"].write(value.hsmStatus, with: SecurityHubClientTypes.AwsRedshiftClusterHsmStatus.write(value:to:))
        try writer["IamRoles"].writeList(value.iamRoles, memberWritingClosure: SecurityHubClientTypes.AwsRedshiftClusterIamRole.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["LoggingStatus"].write(value.loggingStatus, with: SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus.write(value:to:))
        try writer["MaintenanceTrackName"].write(value.maintenanceTrackName)
        try writer["ManualSnapshotRetentionPeriod"].write(value.manualSnapshotRetentionPeriod)
        try writer["MasterUsername"].write(value.masterUsername)
        try writer["NextMaintenanceWindowStartTime"].write(value.nextMaintenanceWindowStartTime)
        try writer["NodeType"].write(value.nodeType)
        try writer["NumberOfNodes"].write(value.numberOfNodes)
        try writer["PendingActions"].writeList(value.pendingActions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PendingModifiedValues"].write(value.pendingModifiedValues, with: SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues.write(value:to:))
        try writer["PreferredMaintenanceWindow"].write(value.preferredMaintenanceWindow)
        try writer["PubliclyAccessible"].write(value.publiclyAccessible)
        try writer["ResizeInfo"].write(value.resizeInfo, with: SecurityHubClientTypes.AwsRedshiftClusterResizeInfo.write(value:to:))
        try writer["RestoreStatus"].write(value.restoreStatus, with: SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus.write(value:to:))
        try writer["SnapshotScheduleIdentifier"].write(value.snapshotScheduleIdentifier)
        try writer["SnapshotScheduleState"].write(value.snapshotScheduleState)
        try writer["VpcId"].write(value.vpcId)
        try writer["VpcSecurityGroups"].writeList(value.vpcSecurityGroups, memberWritingClosure: SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterDetails()
        value.allowVersionUpgrade = try reader["AllowVersionUpgrade"].readIfPresent()
        value.automatedSnapshotRetentionPeriod = try reader["AutomatedSnapshotRetentionPeriod"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.clusterAvailabilityStatus = try reader["ClusterAvailabilityStatus"].readIfPresent()
        value.clusterCreateTime = try reader["ClusterCreateTime"].readIfPresent()
        value.clusterIdentifier = try reader["ClusterIdentifier"].readIfPresent()
        value.clusterNodes = try reader["ClusterNodes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRedshiftClusterClusterNode.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clusterParameterGroups = try reader["ClusterParameterGroups"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clusterPublicKey = try reader["ClusterPublicKey"].readIfPresent()
        value.clusterRevisionNumber = try reader["ClusterRevisionNumber"].readIfPresent()
        value.clusterSecurityGroups = try reader["ClusterSecurityGroups"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.clusterSnapshotCopyStatus = try reader["ClusterSnapshotCopyStatus"].readIfPresent(with: SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus.read(from:))
        value.clusterStatus = try reader["ClusterStatus"].readIfPresent()
        value.clusterSubnetGroupName = try reader["ClusterSubnetGroupName"].readIfPresent()
        value.clusterVersion = try reader["ClusterVersion"].readIfPresent()
        value.dbName = try reader["DBName"].readIfPresent()
        value.deferredMaintenanceWindows = try reader["DeferredMaintenanceWindows"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.elasticIpStatus = try reader["ElasticIpStatus"].readIfPresent(with: SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus.read(from:))
        value.elasticResizeNumberOfNodeOptions = try reader["ElasticResizeNumberOfNodeOptions"].readIfPresent()
        value.encrypted = try reader["Encrypted"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent(with: SecurityHubClientTypes.AwsRedshiftClusterEndpoint.read(from:))
        value.enhancedVpcRouting = try reader["EnhancedVpcRouting"].readIfPresent()
        value.expectedNextSnapshotScheduleTime = try reader["ExpectedNextSnapshotScheduleTime"].readIfPresent()
        value.expectedNextSnapshotScheduleTimeStatus = try reader["ExpectedNextSnapshotScheduleTimeStatus"].readIfPresent()
        value.hsmStatus = try reader["HsmStatus"].readIfPresent(with: SecurityHubClientTypes.AwsRedshiftClusterHsmStatus.read(from:))
        value.iamRoles = try reader["IamRoles"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRedshiftClusterIamRole.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.maintenanceTrackName = try reader["MaintenanceTrackName"].readIfPresent()
        value.manualSnapshotRetentionPeriod = try reader["ManualSnapshotRetentionPeriod"].readIfPresent()
        value.masterUsername = try reader["MasterUsername"].readIfPresent()
        value.nextMaintenanceWindowStartTime = try reader["NextMaintenanceWindowStartTime"].readIfPresent()
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.numberOfNodes = try reader["NumberOfNodes"].readIfPresent()
        value.pendingActions = try reader["PendingActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.pendingModifiedValues = try reader["PendingModifiedValues"].readIfPresent(with: SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues.read(from:))
        value.preferredMaintenanceWindow = try reader["PreferredMaintenanceWindow"].readIfPresent()
        value.publiclyAccessible = try reader["PubliclyAccessible"].readIfPresent()
        value.resizeInfo = try reader["ResizeInfo"].readIfPresent(with: SecurityHubClientTypes.AwsRedshiftClusterResizeInfo.read(from:))
        value.restoreStatus = try reader["RestoreStatus"].readIfPresent(with: SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus.read(from:))
        value.snapshotScheduleIdentifier = try reader["SnapshotScheduleIdentifier"].readIfPresent()
        value.snapshotScheduleState = try reader["SnapshotScheduleState"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.vpcSecurityGroups = try reader["VpcSecurityGroups"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.loggingStatus = try reader["LoggingStatus"].readIfPresent(with: SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["LastFailureMessage"].write(value.lastFailureMessage)
        try writer["LastFailureTime"].write(value.lastFailureTime)
        try writer["LastSuccessfulDeliveryTime"].write(value.lastSuccessfulDeliveryTime)
        try writer["LoggingEnabled"].write(value.loggingEnabled)
        try writer["S3KeyPrefix"].write(value.s3KeyPrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus()
        value.bucketName = try reader["BucketName"].readIfPresent()
        value.lastFailureMessage = try reader["LastFailureMessage"].readIfPresent()
        value.lastFailureTime = try reader["LastFailureTime"].readIfPresent()
        value.lastSuccessfulDeliveryTime = try reader["LastSuccessfulDeliveryTime"].readIfPresent()
        value.loggingEnabled = try reader["LoggingEnabled"].readIfPresent()
        value.s3KeyPrefix = try reader["S3KeyPrefix"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
        try writer["VpcSecurityGroupId"].write(value.vpcSecurityGroupId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup()
        value.status = try reader["Status"].readIfPresent()
        value.vpcSecurityGroupId = try reader["VpcSecurityGroupId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrentRestoreRateInMegaBytesPerSecond"].write(value.currentRestoreRateInMegaBytesPerSecond)
        try writer["ElapsedTimeInSeconds"].write(value.elapsedTimeInSeconds)
        try writer["EstimatedTimeToCompletionInSeconds"].write(value.estimatedTimeToCompletionInSeconds)
        try writer["ProgressInMegaBytes"].write(value.progressInMegaBytes)
        try writer["SnapshotSizeInMegaBytes"].write(value.snapshotSizeInMegaBytes)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus()
        value.currentRestoreRateInMegaBytesPerSecond = try reader["CurrentRestoreRateInMegaBytesPerSecond"].readIfPresent()
        value.elapsedTimeInSeconds = try reader["ElapsedTimeInSeconds"].readIfPresent()
        value.estimatedTimeToCompletionInSeconds = try reader["EstimatedTimeToCompletionInSeconds"].readIfPresent()
        value.progressInMegaBytes = try reader["ProgressInMegaBytes"].readIfPresent()
        value.snapshotSizeInMegaBytes = try reader["SnapshotSizeInMegaBytes"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterResizeInfo {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterResizeInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowCancelResize"].write(value.allowCancelResize)
        try writer["ResizeType"].write(value.resizeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterResizeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterResizeInfo()
        value.allowCancelResize = try reader["AllowCancelResize"].readIfPresent()
        value.resizeType = try reader["ResizeType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomatedSnapshotRetentionPeriod"].write(value.automatedSnapshotRetentionPeriod)
        try writer["ClusterIdentifier"].write(value.clusterIdentifier)
        try writer["ClusterType"].write(value.clusterType)
        try writer["ClusterVersion"].write(value.clusterVersion)
        try writer["EncryptionType"].write(value.encryptionType)
        try writer["EnhancedVpcRouting"].write(value.enhancedVpcRouting)
        try writer["MaintenanceTrackName"].write(value.maintenanceTrackName)
        try writer["MasterUserPassword"].write(value.masterUserPassword)
        try writer["NodeType"].write(value.nodeType)
        try writer["NumberOfNodes"].write(value.numberOfNodes)
        try writer["PubliclyAccessible"].write(value.publiclyAccessible)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues()
        value.automatedSnapshotRetentionPeriod = try reader["AutomatedSnapshotRetentionPeriod"].readIfPresent()
        value.clusterIdentifier = try reader["ClusterIdentifier"].readIfPresent()
        value.clusterType = try reader["ClusterType"].readIfPresent()
        value.clusterVersion = try reader["ClusterVersion"].readIfPresent()
        value.encryptionType = try reader["EncryptionType"].readIfPresent()
        value.enhancedVpcRouting = try reader["EnhancedVpcRouting"].readIfPresent()
        value.maintenanceTrackName = try reader["MaintenanceTrackName"].readIfPresent()
        value.masterUserPassword = try reader["MasterUserPassword"].readIfPresent()
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.numberOfNodes = try reader["NumberOfNodes"].readIfPresent()
        value.publiclyAccessible = try reader["PubliclyAccessible"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterIamRole {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterIamRole?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplyStatus"].write(value.applyStatus)
        try writer["IamRoleArn"].write(value.iamRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterIamRole {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterIamRole()
        value.applyStatus = try reader["ApplyStatus"].readIfPresent()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterHsmStatus {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterHsmStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HsmClientCertificateIdentifier"].write(value.hsmClientCertificateIdentifier)
        try writer["HsmConfigurationIdentifier"].write(value.hsmConfigurationIdentifier)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterHsmStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterHsmStatus()
        value.hsmClientCertificateIdentifier = try reader["HsmClientCertificateIdentifier"].readIfPresent()
        value.hsmConfigurationIdentifier = try reader["HsmConfigurationIdentifier"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterEndpoint {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterEndpoint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["Port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterEndpoint()
        value.address = try reader["Address"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ElasticIp"].write(value.elasticIp)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus()
        value.elasticIp = try reader["ElasticIp"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeferMaintenanceEndTime"].write(value.deferMaintenanceEndTime)
        try writer["DeferMaintenanceIdentifier"].write(value.deferMaintenanceIdentifier)
        try writer["DeferMaintenanceStartTime"].write(value.deferMaintenanceStartTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow()
        value.deferMaintenanceEndTime = try reader["DeferMaintenanceEndTime"].readIfPresent()
        value.deferMaintenanceIdentifier = try reader["DeferMaintenanceIdentifier"].readIfPresent()
        value.deferMaintenanceStartTime = try reader["DeferMaintenanceStartTime"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationRegion"].write(value.destinationRegion)
        try writer["ManualSnapshotRetentionPeriod"].write(value.manualSnapshotRetentionPeriod)
        try writer["RetentionPeriod"].write(value.retentionPeriod)
        try writer["SnapshotCopyGrantName"].write(value.snapshotCopyGrantName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus()
        value.destinationRegion = try reader["DestinationRegion"].readIfPresent()
        value.manualSnapshotRetentionPeriod = try reader["ManualSnapshotRetentionPeriod"].readIfPresent()
        value.retentionPeriod = try reader["RetentionPeriod"].readIfPresent()
        value.snapshotCopyGrantName = try reader["SnapshotCopyGrantName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterSecurityGroupName"].write(value.clusterSecurityGroupName)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup()
        value.clusterSecurityGroupName = try reader["ClusterSecurityGroupName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterParameterStatusList"].writeList(value.clusterParameterStatusList, memberWritingClosure: SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ParameterApplyStatus"].write(value.parameterApplyStatus)
        try writer["ParameterGroupName"].write(value.parameterGroupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup()
        value.clusterParameterStatusList = try reader["ClusterParameterStatusList"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameterApplyStatus = try reader["ParameterApplyStatus"].readIfPresent()
        value.parameterGroupName = try reader["ParameterGroupName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ParameterApplyErrorDescription"].write(value.parameterApplyErrorDescription)
        try writer["ParameterApplyStatus"].write(value.parameterApplyStatus)
        try writer["ParameterName"].write(value.parameterName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus()
        value.parameterName = try reader["ParameterName"].readIfPresent()
        value.parameterApplyStatus = try reader["ParameterApplyStatus"].readIfPresent()
        value.parameterApplyErrorDescription = try reader["ParameterApplyErrorDescription"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterNode {

    static func write(value: SecurityHubClientTypes.AwsRedshiftClusterClusterNode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NodeRole"].write(value.nodeRole)
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
        try writer["PublicIpAddress"].write(value.publicIpAddress)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsRedshiftClusterClusterNode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsRedshiftClusterClusterNode()
        value.nodeRole = try reader["NodeRole"].readIfPresent()
        value.privateIpAddress = try reader["PrivateIpAddress"].readIfPresent()
        value.publicIpAddress = try reader["PublicIpAddress"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateDetails {

    static func write(value: SecurityHubClientTypes.AwsCertificateManagerCertificateDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateAuthorityArn"].write(value.certificateAuthorityArn)
        try writer["CreatedAt"].write(value.createdAt)
        try writer["DomainName"].write(value.domainName)
        try writer["DomainValidationOptions"].writeList(value.domainValidationOptions, memberWritingClosure: SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExtendedKeyUsages"].writeList(value.extendedKeyUsages, memberWritingClosure: SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FailureReason"].write(value.failureReason)
        try writer["ImportedAt"].write(value.importedAt)
        try writer["InUseBy"].writeList(value.inUseBy, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IssuedAt"].write(value.issuedAt)
        try writer["Issuer"].write(value.issuer)
        try writer["KeyAlgorithm"].write(value.keyAlgorithm)
        try writer["KeyUsages"].writeList(value.keyUsages, memberWritingClosure: SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotAfter"].write(value.notAfter)
        try writer["NotBefore"].write(value.notBefore)
        try writer["Options"].write(value.options, with: SecurityHubClientTypes.AwsCertificateManagerCertificateOptions.write(value:to:))
        try writer["RenewalEligibility"].write(value.renewalEligibility)
        try writer["RenewalSummary"].write(value.renewalSummary, with: SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary.write(value:to:))
        try writer["Serial"].write(value.serial)
        try writer["SignatureAlgorithm"].write(value.signatureAlgorithm)
        try writer["Status"].write(value.status)
        try writer["Subject"].write(value.subject)
        try writer["SubjectAlternativeNames"].writeList(value.subjectAlternativeNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCertificateManagerCertificateDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCertificateManagerCertificateDetails()
        value.certificateAuthorityArn = try reader["CertificateAuthorityArn"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.domainValidationOptions = try reader["DomainValidationOptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.extendedKeyUsages = try reader["ExtendedKeyUsages"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.importedAt = try reader["ImportedAt"].readIfPresent()
        value.inUseBy = try reader["InUseBy"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.issuedAt = try reader["IssuedAt"].readIfPresent()
        value.issuer = try reader["Issuer"].readIfPresent()
        value.keyAlgorithm = try reader["KeyAlgorithm"].readIfPresent()
        value.keyUsages = try reader["KeyUsages"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notAfter = try reader["NotAfter"].readIfPresent()
        value.notBefore = try reader["NotBefore"].readIfPresent()
        value.options = try reader["Options"].readIfPresent(with: SecurityHubClientTypes.AwsCertificateManagerCertificateOptions.read(from:))
        value.renewalEligibility = try reader["RenewalEligibility"].readIfPresent()
        value.renewalSummary = try reader["RenewalSummary"].readIfPresent(with: SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary.read(from:))
        value.serial = try reader["Serial"].readIfPresent()
        value.signatureAlgorithm = try reader["SignatureAlgorithm"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.subject = try reader["Subject"].readIfPresent()
        value.subjectAlternativeNames = try reader["SubjectAlternativeNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary {

    static func write(value: SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainValidationOptions"].writeList(value.domainValidationOptions, memberWritingClosure: SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RenewalStatus"].write(value.renewalStatus)
        try writer["RenewalStatusReason"].write(value.renewalStatusReason)
        try writer["UpdatedAt"].write(value.updatedAt)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary()
        value.domainValidationOptions = try reader["DomainValidationOptions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.renewalStatus = try reader["RenewalStatus"].readIfPresent()
        value.renewalStatusReason = try reader["RenewalStatusReason"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption {

    static func write(value: SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["ResourceRecord"].write(value.resourceRecord, with: SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord.write(value:to:))
        try writer["ValidationDomain"].write(value.validationDomain)
        try writer["ValidationEmails"].writeList(value.validationEmails, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ValidationMethod"].write(value.validationMethod)
        try writer["ValidationStatus"].write(value.validationStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.resourceRecord = try reader["ResourceRecord"].readIfPresent(with: SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord.read(from:))
        value.validationDomain = try reader["ValidationDomain"].readIfPresent()
        value.validationEmails = try reader["ValidationEmails"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.validationMethod = try reader["ValidationMethod"].readIfPresent()
        value.validationStatus = try reader["ValidationStatus"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord {

    static func write(value: SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateOptions {

    static func write(value: SecurityHubClientTypes.AwsCertificateManagerCertificateOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateTransparencyLoggingPreference"].write(value.certificateTransparencyLoggingPreference)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCertificateManagerCertificateOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCertificateManagerCertificateOptions()
        value.certificateTransparencyLoggingPreference = try reader["CertificateTransparencyLoggingPreference"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage {

    static func write(value: SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage {

    static func write(value: SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["OId"].write(value.oId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage()
        value.name = try reader["Name"].readIfPresent()
        value.oId = try reader["OId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsSsmPatchComplianceDetails {

    static func write(value: SecurityHubClientTypes.AwsSsmPatchComplianceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Patch"].write(value.patch, with: SecurityHubClientTypes.AwsSsmPatch.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSsmPatchComplianceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSsmPatchComplianceDetails()
        value.patch = try reader["Patch"].readIfPresent(with: SecurityHubClientTypes.AwsSsmPatch.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsSsmPatch {

    static func write(value: SecurityHubClientTypes.AwsSsmPatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceSummary"].write(value.complianceSummary, with: SecurityHubClientTypes.AwsSsmComplianceSummary.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSsmPatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSsmPatch()
        value.complianceSummary = try reader["ComplianceSummary"].readIfPresent(with: SecurityHubClientTypes.AwsSsmComplianceSummary.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsSsmComplianceSummary {

    static func write(value: SecurityHubClientTypes.AwsSsmComplianceSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComplianceType"].write(value.complianceType)
        try writer["CompliantCriticalCount"].write(value.compliantCriticalCount)
        try writer["CompliantHighCount"].write(value.compliantHighCount)
        try writer["CompliantInformationalCount"].write(value.compliantInformationalCount)
        try writer["CompliantLowCount"].write(value.compliantLowCount)
        try writer["CompliantMediumCount"].write(value.compliantMediumCount)
        try writer["CompliantUnspecifiedCount"].write(value.compliantUnspecifiedCount)
        try writer["ExecutionType"].write(value.executionType)
        try writer["NonCompliantCriticalCount"].write(value.nonCompliantCriticalCount)
        try writer["NonCompliantHighCount"].write(value.nonCompliantHighCount)
        try writer["NonCompliantInformationalCount"].write(value.nonCompliantInformationalCount)
        try writer["NonCompliantLowCount"].write(value.nonCompliantLowCount)
        try writer["NonCompliantMediumCount"].write(value.nonCompliantMediumCount)
        try writer["NonCompliantUnspecifiedCount"].write(value.nonCompliantUnspecifiedCount)
        try writer["OverallSeverity"].write(value.overallSeverity)
        try writer["PatchBaselineId"].write(value.patchBaselineId)
        try writer["PatchGroup"].write(value.patchGroup)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSsmComplianceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSsmComplianceSummary()
        value.status = try reader["Status"].readIfPresent()
        value.compliantCriticalCount = try reader["CompliantCriticalCount"].readIfPresent()
        value.compliantHighCount = try reader["CompliantHighCount"].readIfPresent()
        value.compliantMediumCount = try reader["CompliantMediumCount"].readIfPresent()
        value.executionType = try reader["ExecutionType"].readIfPresent()
        value.nonCompliantCriticalCount = try reader["NonCompliantCriticalCount"].readIfPresent()
        value.compliantInformationalCount = try reader["CompliantInformationalCount"].readIfPresent()
        value.nonCompliantInformationalCount = try reader["NonCompliantInformationalCount"].readIfPresent()
        value.compliantUnspecifiedCount = try reader["CompliantUnspecifiedCount"].readIfPresent()
        value.nonCompliantLowCount = try reader["NonCompliantLowCount"].readIfPresent()
        value.nonCompliantHighCount = try reader["NonCompliantHighCount"].readIfPresent()
        value.compliantLowCount = try reader["CompliantLowCount"].readIfPresent()
        value.complianceType = try reader["ComplianceType"].readIfPresent()
        value.patchBaselineId = try reader["PatchBaselineId"].readIfPresent()
        value.overallSeverity = try reader["OverallSeverity"].readIfPresent()
        value.nonCompliantMediumCount = try reader["NonCompliantMediumCount"].readIfPresent()
        value.nonCompliantUnspecifiedCount = try reader["NonCompliantUnspecifiedCount"].readIfPresent()
        value.patchGroup = try reader["PatchGroup"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudTrailTrailDetails {

    static func write(value: SecurityHubClientTypes.AwsCloudTrailTrailDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsLogGroupArn"].write(value.cloudWatchLogsLogGroupArn)
        try writer["CloudWatchLogsRoleArn"].write(value.cloudWatchLogsRoleArn)
        try writer["HasCustomEventSelectors"].write(value.hasCustomEventSelectors)
        try writer["HomeRegion"].write(value.homeRegion)
        try writer["IncludeGlobalServiceEvents"].write(value.includeGlobalServiceEvents)
        try writer["IsMultiRegionTrail"].write(value.isMultiRegionTrail)
        try writer["IsOrganizationTrail"].write(value.isOrganizationTrail)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["LogFileValidationEnabled"].write(value.logFileValidationEnabled)
        try writer["Name"].write(value.name)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3KeyPrefix"].write(value.s3KeyPrefix)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
        try writer["SnsTopicName"].write(value.snsTopicName)
        try writer["TrailArn"].write(value.trailArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudTrailTrailDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudTrailTrailDetails()
        value.cloudWatchLogsLogGroupArn = try reader["CloudWatchLogsLogGroupArn"].readIfPresent()
        value.cloudWatchLogsRoleArn = try reader["CloudWatchLogsRoleArn"].readIfPresent()
        value.hasCustomEventSelectors = try reader["HasCustomEventSelectors"].readIfPresent()
        value.homeRegion = try reader["HomeRegion"].readIfPresent()
        value.includeGlobalServiceEvents = try reader["IncludeGlobalServiceEvents"].readIfPresent()
        value.isMultiRegionTrail = try reader["IsMultiRegionTrail"].readIfPresent()
        value.isOrganizationTrail = try reader["IsOrganizationTrail"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.logFileValidationEnabled = try reader["LogFileValidationEnabled"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3KeyPrefix = try reader["S3KeyPrefix"].readIfPresent()
        value.snsTopicArn = try reader["SnsTopicArn"].readIfPresent()
        value.snsTopicName = try reader["SnsTopicName"].readIfPresent()
        value.trailArn = try reader["TrailArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsApiGatewayRestApiDetails {

    static func write(value: SecurityHubClientTypes.AwsApiGatewayRestApiDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApiKeySource"].write(value.apiKeySource)
        try writer["BinaryMediaTypes"].writeList(value.binaryMediaTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreatedDate"].write(value.createdDate)
        try writer["Description"].write(value.description)
        try writer["EndpointConfiguration"].write(value.endpointConfiguration, with: SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration.write(value:to:))
        try writer["Id"].write(value.id)
        try writer["MinimumCompressionSize"].write(value.minimumCompressionSize)
        try writer["Name"].write(value.name)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiGatewayRestApiDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiGatewayRestApiDetails()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.binaryMediaTypes = try reader["BinaryMediaTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.minimumCompressionSize = try reader["MinimumCompressionSize"].readIfPresent()
        value.apiKeySource = try reader["ApiKeySource"].readIfPresent()
        value.endpointConfiguration = try reader["EndpointConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration {

    static func write(value: SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration()
        value.types = try reader["Types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsApiGatewayStageDetails {

    static func write(value: SecurityHubClientTypes.AwsApiGatewayStageDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessLogSettings"].write(value.accessLogSettings, with: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings.write(value:to:))
        try writer["CacheClusterEnabled"].write(value.cacheClusterEnabled)
        try writer["CacheClusterSize"].write(value.cacheClusterSize)
        try writer["CacheClusterStatus"].write(value.cacheClusterStatus)
        try writer["CanarySettings"].write(value.canarySettings, with: SecurityHubClientTypes.AwsApiGatewayCanarySettings.write(value:to:))
        try writer["ClientCertificateId"].write(value.clientCertificateId)
        try writer["CreatedDate"].write(value.createdDate)
        try writer["DeploymentId"].write(value.deploymentId)
        try writer["Description"].write(value.description)
        try writer["DocumentationVersion"].write(value.documentationVersion)
        try writer["LastUpdatedDate"].write(value.lastUpdatedDate)
        try writer["MethodSettings"].writeList(value.methodSettings, memberWritingClosure: SecurityHubClientTypes.AwsApiGatewayMethodSettings.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StageName"].write(value.stageName)
        try writer["TracingEnabled"].write(value.tracingEnabled)
        try writer["Variables"].writeMap(value.variables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["WebAclArn"].write(value.webAclArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiGatewayStageDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiGatewayStageDetails()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        value.clientCertificateId = try reader["ClientCertificateId"].readIfPresent()
        value.stageName = try reader["StageName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.cacheClusterEnabled = try reader["CacheClusterEnabled"].readIfPresent()
        value.cacheClusterSize = try reader["CacheClusterSize"].readIfPresent()
        value.cacheClusterStatus = try reader["CacheClusterStatus"].readIfPresent()
        value.methodSettings = try reader["MethodSettings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsApiGatewayMethodSettings.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.variables = try reader["Variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.documentationVersion = try reader["DocumentationVersion"].readIfPresent()
        value.accessLogSettings = try reader["AccessLogSettings"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings.read(from:))
        value.canarySettings = try reader["CanarySettings"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayCanarySettings.read(from:))
        value.tracingEnabled = try reader["TracingEnabled"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.lastUpdatedDate = try reader["LastUpdatedDate"].readIfPresent()
        value.webAclArn = try reader["WebAclArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsApiGatewayCanarySettings {

    static func write(value: SecurityHubClientTypes.AwsApiGatewayCanarySettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeploymentId"].write(value.deploymentId)
        try writer["PercentTraffic"].write(value.percentTraffic)
        try writer["StageVariableOverrides"].writeMap(value.stageVariableOverrides, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["UseStageCache"].write(value.useStageCache)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiGatewayCanarySettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiGatewayCanarySettings()
        value.percentTraffic = try reader["PercentTraffic"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        value.stageVariableOverrides = try reader["StageVariableOverrides"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.useStageCache = try reader["UseStageCache"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsApiGatewayAccessLogSettings {

    static func write(value: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationArn"].write(value.destinationArn)
        try writer["Format"].write(value.format)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiGatewayAccessLogSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiGatewayAccessLogSettings()
        value.format = try reader["Format"].readIfPresent()
        value.destinationArn = try reader["DestinationArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsApiGatewayMethodSettings {

    static func write(value: SecurityHubClientTypes.AwsApiGatewayMethodSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CacheDataEncrypted"].write(value.cacheDataEncrypted)
        try writer["CacheTtlInSeconds"].write(value.cacheTtlInSeconds)
        try writer["CachingEnabled"].write(value.cachingEnabled)
        try writer["DataTraceEnabled"].write(value.dataTraceEnabled)
        try writer["HttpMethod"].write(value.httpMethod)
        try writer["LoggingLevel"].write(value.loggingLevel)
        try writer["MetricsEnabled"].write(value.metricsEnabled)
        try writer["RequireAuthorizationForCacheControl"].write(value.requireAuthorizationForCacheControl)
        try writer["ResourcePath"].write(value.resourcePath)
        try writer["ThrottlingBurstLimit"].write(value.throttlingBurstLimit)
        try writer["ThrottlingRateLimit"].write(value.throttlingRateLimit)
        try writer["UnauthorizedCacheControlHeaderStrategy"].write(value.unauthorizedCacheControlHeaderStrategy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiGatewayMethodSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiGatewayMethodSettings()
        value.metricsEnabled = try reader["MetricsEnabled"].readIfPresent()
        value.loggingLevel = try reader["LoggingLevel"].readIfPresent()
        value.dataTraceEnabled = try reader["DataTraceEnabled"].readIfPresent()
        value.throttlingBurstLimit = try reader["ThrottlingBurstLimit"].readIfPresent()
        value.throttlingRateLimit = try reader["ThrottlingRateLimit"].readIfPresent()
        value.cachingEnabled = try reader["CachingEnabled"].readIfPresent()
        value.cacheTtlInSeconds = try reader["CacheTtlInSeconds"].readIfPresent()
        value.cacheDataEncrypted = try reader["CacheDataEncrypted"].readIfPresent()
        value.requireAuthorizationForCacheControl = try reader["RequireAuthorizationForCacheControl"].readIfPresent()
        value.unauthorizedCacheControlHeaderStrategy = try reader["UnauthorizedCacheControlHeaderStrategy"].readIfPresent()
        value.httpMethod = try reader["HttpMethod"].readIfPresent()
        value.resourcePath = try reader["ResourcePath"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableDetails {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeDefinitions"].writeList(value.attributeDefinitions, memberWritingClosure: SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BillingModeSummary"].write(value.billingModeSummary, with: SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary.write(value:to:))
        try writer["CreationDateTime"].write(value.creationDateTime)
        try writer["DeletionProtectionEnabled"].write(value.deletionProtectionEnabled)
        try writer["GlobalSecondaryIndexes"].writeList(value.globalSecondaryIndexes, memberWritingClosure: SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GlobalTableVersion"].write(value.globalTableVersion)
        try writer["ItemCount"].write(value.itemCount)
        try writer["KeySchema"].writeList(value.keySchema, memberWritingClosure: SecurityHubClientTypes.AwsDynamoDbTableKeySchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LatestStreamArn"].write(value.latestStreamArn)
        try writer["LatestStreamLabel"].write(value.latestStreamLabel)
        try writer["LocalSecondaryIndexes"].writeList(value.localSecondaryIndexes, memberWritingClosure: SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProvisionedThroughput"].write(value.provisionedThroughput, with: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput.write(value:to:))
        try writer["Replicas"].writeList(value.replicas, memberWritingClosure: SecurityHubClientTypes.AwsDynamoDbTableReplica.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RestoreSummary"].write(value.restoreSummary, with: SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary.write(value:to:))
        try writer["SseDescription"].write(value.sseDescription, with: SecurityHubClientTypes.AwsDynamoDbTableSseDescription.write(value:to:))
        try writer["StreamSpecification"].write(value.streamSpecification, with: SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification.write(value:to:))
        try writer["TableId"].write(value.tableId)
        try writer["TableName"].write(value.tableName)
        try writer["TableSizeBytes"].write(value.tableSizeBytes)
        try writer["TableStatus"].write(value.tableStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableDetails()
        value.attributeDefinitions = try reader["AttributeDefinitions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.billingModeSummary = try reader["BillingModeSummary"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary.read(from:))
        value.creationDateTime = try reader["CreationDateTime"].readIfPresent()
        value.globalSecondaryIndexes = try reader["GlobalSecondaryIndexes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.globalTableVersion = try reader["GlobalTableVersion"].readIfPresent()
        value.itemCount = try reader["ItemCount"].readIfPresent()
        value.keySchema = try reader["KeySchema"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsDynamoDbTableKeySchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.latestStreamArn = try reader["LatestStreamArn"].readIfPresent()
        value.latestStreamLabel = try reader["LatestStreamLabel"].readIfPresent()
        value.localSecondaryIndexes = try reader["LocalSecondaryIndexes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisionedThroughput = try reader["ProvisionedThroughput"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput.read(from:))
        value.replicas = try reader["Replicas"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsDynamoDbTableReplica.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.restoreSummary = try reader["RestoreSummary"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary.read(from:))
        value.sseDescription = try reader["SseDescription"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableSseDescription.read(from:))
        value.streamSpecification = try reader["StreamSpecification"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification.read(from:))
        value.tableId = try reader["TableId"].readIfPresent()
        value.tableName = try reader["TableName"].readIfPresent()
        value.tableSizeBytes = try reader["TableSizeBytes"].readIfPresent()
        value.tableStatus = try reader["TableStatus"].readIfPresent()
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamEnabled"].write(value.streamEnabled)
        try writer["StreamViewType"].write(value.streamViewType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification()
        value.streamEnabled = try reader["StreamEnabled"].readIfPresent()
        value.streamViewType = try reader["StreamViewType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableSseDescription {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableSseDescription?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InaccessibleEncryptionDateTime"].write(value.inaccessibleEncryptionDateTime)
        try writer["KmsMasterKeyArn"].write(value.kmsMasterKeyArn)
        try writer["SseType"].write(value.sseType)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableSseDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableSseDescription()
        value.inaccessibleEncryptionDateTime = try reader["InaccessibleEncryptionDateTime"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.sseType = try reader["SseType"].readIfPresent()
        value.kmsMasterKeyArn = try reader["KmsMasterKeyArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RestoreDateTime"].write(value.restoreDateTime)
        try writer["RestoreInProgress"].write(value.restoreInProgress)
        try writer["SourceBackupArn"].write(value.sourceBackupArn)
        try writer["SourceTableArn"].write(value.sourceTableArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary()
        value.sourceBackupArn = try reader["SourceBackupArn"].readIfPresent()
        value.sourceTableArn = try reader["SourceTableArn"].readIfPresent()
        value.restoreDateTime = try reader["RestoreDateTime"].readIfPresent()
        value.restoreInProgress = try reader["RestoreInProgress"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableReplica {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableReplica?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GlobalSecondaryIndexes"].writeList(value.globalSecondaryIndexes, memberWritingClosure: SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KmsMasterKeyId"].write(value.kmsMasterKeyId)
        try writer["ProvisionedThroughputOverride"].write(value.provisionedThroughputOverride, with: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride.write(value:to:))
        try writer["RegionName"].write(value.regionName)
        try writer["ReplicaStatus"].write(value.replicaStatus)
        try writer["ReplicaStatusDescription"].write(value.replicaStatusDescription)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableReplica {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableReplica()
        value.globalSecondaryIndexes = try reader["GlobalSecondaryIndexes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.kmsMasterKeyId = try reader["KmsMasterKeyId"].readIfPresent()
        value.provisionedThroughputOverride = try reader["ProvisionedThroughputOverride"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride.read(from:))
        value.regionName = try reader["RegionName"].readIfPresent()
        value.replicaStatus = try reader["ReplicaStatus"].readIfPresent()
        value.replicaStatusDescription = try reader["ReplicaStatusDescription"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ReadCapacityUnits"].write(value.readCapacityUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride()
        value.readCapacityUnits = try reader["ReadCapacityUnits"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IndexName"].write(value.indexName)
        try writer["ProvisionedThroughputOverride"].write(value.provisionedThroughputOverride, with: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex()
        value.indexName = try reader["IndexName"].readIfPresent()
        value.provisionedThroughputOverride = try reader["ProvisionedThroughputOverride"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LastDecreaseDateTime"].write(value.lastDecreaseDateTime)
        try writer["LastIncreaseDateTime"].write(value.lastIncreaseDateTime)
        try writer["NumberOfDecreasesToday"].write(value.numberOfDecreasesToday)
        try writer["ReadCapacityUnits"].write(value.readCapacityUnits)
        try writer["WriteCapacityUnits"].write(value.writeCapacityUnits)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput()
        value.lastDecreaseDateTime = try reader["LastDecreaseDateTime"].readIfPresent()
        value.lastIncreaseDateTime = try reader["LastIncreaseDateTime"].readIfPresent()
        value.numberOfDecreasesToday = try reader["NumberOfDecreasesToday"].readIfPresent()
        value.readCapacityUnits = try reader["ReadCapacityUnits"].readIfPresent()
        value.writeCapacityUnits = try reader["WriteCapacityUnits"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IndexArn"].write(value.indexArn)
        try writer["IndexName"].write(value.indexName)
        try writer["KeySchema"].writeList(value.keySchema, memberWritingClosure: SecurityHubClientTypes.AwsDynamoDbTableKeySchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Projection"].write(value.projection, with: SecurityHubClientTypes.AwsDynamoDbTableProjection.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex()
        value.indexArn = try reader["IndexArn"].readIfPresent()
        value.indexName = try reader["IndexName"].readIfPresent()
        value.keySchema = try reader["KeySchema"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsDynamoDbTableKeySchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.projection = try reader["Projection"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableProjection.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableProjection {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableProjection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NonKeyAttributes"].writeList(value.nonKeyAttributes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProjectionType"].write(value.projectionType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableProjection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableProjection()
        value.nonKeyAttributes = try reader["NonKeyAttributes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.projectionType = try reader["ProjectionType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableKeySchema {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableKeySchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["KeyType"].write(value.keyType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableKeySchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableKeySchema()
        value.attributeName = try reader["AttributeName"].readIfPresent()
        value.keyType = try reader["KeyType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Backfilling"].write(value.backfilling)
        try writer["IndexArn"].write(value.indexArn)
        try writer["IndexName"].write(value.indexName)
        try writer["IndexSizeBytes"].write(value.indexSizeBytes)
        try writer["IndexStatus"].write(value.indexStatus)
        try writer["ItemCount"].write(value.itemCount)
        try writer["KeySchema"].writeList(value.keySchema, memberWritingClosure: SecurityHubClientTypes.AwsDynamoDbTableKeySchema.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Projection"].write(value.projection, with: SecurityHubClientTypes.AwsDynamoDbTableProjection.write(value:to:))
        try writer["ProvisionedThroughput"].write(value.provisionedThroughput, with: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex()
        value.backfilling = try reader["Backfilling"].readIfPresent()
        value.indexArn = try reader["IndexArn"].readIfPresent()
        value.indexName = try reader["IndexName"].readIfPresent()
        value.indexSizeBytes = try reader["IndexSizeBytes"].readIfPresent()
        value.indexStatus = try reader["IndexStatus"].readIfPresent()
        value.itemCount = try reader["ItemCount"].readIfPresent()
        value.keySchema = try reader["KeySchema"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsDynamoDbTableKeySchema.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.projection = try reader["Projection"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableProjection.read(from:))
        value.provisionedThroughput = try reader["ProvisionedThroughput"].readIfPresent(with: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingMode"].write(value.billingMode)
        try writer["LastUpdateToPayPerRequestDateTime"].write(value.lastUpdateToPayPerRequestDateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary()
        value.billingMode = try reader["BillingMode"].readIfPresent()
        value.lastUpdateToPayPerRequestDateTime = try reader["LastUpdateToPayPerRequestDateTime"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition {

    static func write(value: SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeType"].write(value.attributeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition()
        value.attributeName = try reader["AttributeName"].readIfPresent()
        value.attributeType = try reader["AttributeType"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsApiGatewayV2ApiDetails {

    static func write(value: SecurityHubClientTypes.AwsApiGatewayV2ApiDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApiEndpoint"].write(value.apiEndpoint)
        try writer["ApiId"].write(value.apiId)
        try writer["ApiKeySelectionExpression"].write(value.apiKeySelectionExpression)
        try writer["CorsConfiguration"].write(value.corsConfiguration, with: SecurityHubClientTypes.AwsCorsConfiguration.write(value:to:))
        try writer["CreatedDate"].write(value.createdDate)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["ProtocolType"].write(value.protocolType)
        try writer["RouteSelectionExpression"].write(value.routeSelectionExpression)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiGatewayV2ApiDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiGatewayV2ApiDetails()
        value.apiEndpoint = try reader["ApiEndpoint"].readIfPresent()
        value.apiId = try reader["ApiId"].readIfPresent()
        value.apiKeySelectionExpression = try reader["ApiKeySelectionExpression"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.protocolType = try reader["ProtocolType"].readIfPresent()
        value.routeSelectionExpression = try reader["RouteSelectionExpression"].readIfPresent()
        value.corsConfiguration = try reader["CorsConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsCorsConfiguration.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsCorsConfiguration {

    static func write(value: SecurityHubClientTypes.AwsCorsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowCredentials"].write(value.allowCredentials)
        try writer["AllowHeaders"].writeList(value.allowHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowMethods"].writeList(value.allowMethods, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllowOrigins"].writeList(value.allowOrigins, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExposeHeaders"].writeList(value.exposeHeaders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxAge"].write(value.maxAge)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCorsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCorsConfiguration()
        value.allowOrigins = try reader["AllowOrigins"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowCredentials = try reader["AllowCredentials"].readIfPresent()
        value.exposeHeaders = try reader["ExposeHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxAge = try reader["MaxAge"].readIfPresent()
        value.allowMethods = try reader["AllowMethods"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowHeaders = try reader["AllowHeaders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsApiGatewayV2StageDetails {

    static func write(value: SecurityHubClientTypes.AwsApiGatewayV2StageDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessLogSettings"].write(value.accessLogSettings, with: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings.write(value:to:))
        try writer["ApiGatewayManaged"].write(value.apiGatewayManaged)
        try writer["AutoDeploy"].write(value.autoDeploy)
        try writer["ClientCertificateId"].write(value.clientCertificateId)
        try writer["CreatedDate"].write(value.createdDate)
        try writer["DefaultRouteSettings"].write(value.defaultRouteSettings, with: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings.write(value:to:))
        try writer["DeploymentId"].write(value.deploymentId)
        try writer["Description"].write(value.description)
        try writer["LastDeploymentStatusMessage"].write(value.lastDeploymentStatusMessage)
        try writer["LastUpdatedDate"].write(value.lastUpdatedDate)
        try writer["RouteSettings"].write(value.routeSettings, with: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings.write(value:to:))
        try writer["StageName"].write(value.stageName)
        try writer["StageVariables"].writeMap(value.stageVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiGatewayV2StageDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiGatewayV2StageDetails()
        value.clientCertificateId = try reader["ClientCertificateId"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.defaultRouteSettings = try reader["DefaultRouteSettings"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings.read(from:))
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        value.lastUpdatedDate = try reader["LastUpdatedDate"].readIfPresent()
        value.routeSettings = try reader["RouteSettings"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings.read(from:))
        value.stageName = try reader["StageName"].readIfPresent()
        value.stageVariables = try reader["StageVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.accessLogSettings = try reader["AccessLogSettings"].readIfPresent(with: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings.read(from:))
        value.autoDeploy = try reader["AutoDeploy"].readIfPresent()
        value.lastDeploymentStatusMessage = try reader["LastDeploymentStatusMessage"].readIfPresent()
        value.apiGatewayManaged = try reader["ApiGatewayManaged"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsApiGatewayV2RouteSettings {

    static func write(value: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataTraceEnabled"].write(value.dataTraceEnabled)
        try writer["DetailedMetricsEnabled"].write(value.detailedMetricsEnabled)
        try writer["LoggingLevel"].write(value.loggingLevel)
        try writer["ThrottlingBurstLimit"].write(value.throttlingBurstLimit)
        try writer["ThrottlingRateLimit"].write(value.throttlingRateLimit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsApiGatewayV2RouteSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsApiGatewayV2RouteSettings()
        value.detailedMetricsEnabled = try reader["DetailedMetricsEnabled"].readIfPresent()
        value.loggingLevel = try reader["LoggingLevel"].readIfPresent()
        value.dataTraceEnabled = try reader["DataTraceEnabled"].readIfPresent()
        value.throttlingBurstLimit = try reader["ThrottlingBurstLimit"].readIfPresent()
        value.throttlingRateLimit = try reader["ThrottlingRateLimit"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamPolicyDetails {

    static func write(value: SecurityHubClientTypes.AwsIamPolicyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachmentCount"].write(value.attachmentCount)
        try writer["CreateDate"].write(value.createDate)
        try writer["DefaultVersionId"].write(value.defaultVersionId)
        try writer["Description"].write(value.description)
        try writer["IsAttachable"].write(value.isAttachable)
        try writer["Path"].write(value.path)
        try writer["PermissionsBoundaryUsageCount"].write(value.permissionsBoundaryUsageCount)
        try writer["PolicyId"].write(value.policyId)
        try writer["PolicyName"].write(value.policyName)
        try writer["PolicyVersionList"].writeList(value.policyVersionList, memberWritingClosure: SecurityHubClientTypes.AwsIamPolicyVersion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UpdateDate"].write(value.updateDate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamPolicyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamPolicyDetails()
        value.attachmentCount = try reader["AttachmentCount"].readIfPresent()
        value.createDate = try reader["CreateDate"].readIfPresent()
        value.defaultVersionId = try reader["DefaultVersionId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.isAttachable = try reader["IsAttachable"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.permissionsBoundaryUsageCount = try reader["PermissionsBoundaryUsageCount"].readIfPresent()
        value.policyId = try reader["PolicyId"].readIfPresent()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.policyVersionList = try reader["PolicyVersionList"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsIamPolicyVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updateDate = try reader["UpdateDate"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamPolicyVersion {

    static func write(value: SecurityHubClientTypes.AwsIamPolicyVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateDate"].write(value.createDate)
        try writer["IsDefaultVersion"].write(value.isDefaultVersion)
        try writer["VersionId"].write(value.versionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamPolicyVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamPolicyVersion()
        value.versionId = try reader["VersionId"].readIfPresent()
        value.isDefaultVersion = try reader["IsDefaultVersion"].readIfPresent()
        value.createDate = try reader["CreateDate"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamUserDetails {

    static func write(value: SecurityHubClientTypes.AwsIamUserDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachedManagedPolicies"].writeList(value.attachedManagedPolicies, memberWritingClosure: SecurityHubClientTypes.AwsIamAttachedManagedPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreateDate"].write(value.createDate)
        try writer["GroupList"].writeList(value.groupList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Path"].write(value.path)
        try writer["PermissionsBoundary"].write(value.permissionsBoundary, with: SecurityHubClientTypes.AwsIamPermissionsBoundary.write(value:to:))
        try writer["UserId"].write(value.userId)
        try writer["UserName"].write(value.userName)
        try writer["UserPolicyList"].writeList(value.userPolicyList, memberWritingClosure: SecurityHubClientTypes.AwsIamUserPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamUserDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamUserDetails()
        value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsIamAttachedManagedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createDate = try reader["CreateDate"].readIfPresent()
        value.groupList = try reader["GroupList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.path = try reader["Path"].readIfPresent()
        value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(with: SecurityHubClientTypes.AwsIamPermissionsBoundary.read(from:))
        value.userId = try reader["UserId"].readIfPresent()
        value.userName = try reader["UserName"].readIfPresent()
        value.userPolicyList = try reader["UserPolicyList"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsIamUserPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsIamUserPolicy {

    static func write(value: SecurityHubClientTypes.AwsIamUserPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyName"].write(value.policyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamUserPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamUserPolicy()
        value.policyName = try reader["PolicyName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamAccessKeyDetails {

    static func write(value: SecurityHubClientTypes.AwsIamAccessKeyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessKeyId"].write(value.accessKeyId)
        try writer["AccountId"].write(value.accountId)
        try writer["CreatedAt"].write(value.createdAt)
        try writer["PrincipalId"].write(value.principalId)
        try writer["PrincipalName"].write(value.principalName)
        try writer["PrincipalType"].write(value.principalType)
        try writer["SessionContext"].write(value.sessionContext, with: SecurityHubClientTypes.AwsIamAccessKeySessionContext.write(value:to:))
        try writer["Status"].write(value.status)
        try writer["UserName"].write(value.userName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamAccessKeyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamAccessKeyDetails()
        value.userName = try reader["UserName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        value.principalType = try reader["PrincipalType"].readIfPresent()
        value.principalName = try reader["PrincipalName"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.accessKeyId = try reader["AccessKeyId"].readIfPresent()
        value.sessionContext = try reader["SessionContext"].readIfPresent(with: SecurityHubClientTypes.AwsIamAccessKeySessionContext.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsIamAccessKeySessionContext {

    static func write(value: SecurityHubClientTypes.AwsIamAccessKeySessionContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].write(value.attributes, with: SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes.write(value:to:))
        try writer["SessionIssuer"].write(value.sessionIssuer, with: SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamAccessKeySessionContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamAccessKeySessionContext()
        value.attributes = try reader["Attributes"].readIfPresent(with: SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes.read(from:))
        value.sessionIssuer = try reader["SessionIssuer"].readIfPresent(with: SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer {

    static func write(value: SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Arn"].write(value.arn)
        try writer["PrincipalId"].write(value.principalId)
        try writer["Type"].write(value.type)
        try writer["UserName"].write(value.userName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer()
        value.type = try reader["Type"].readIfPresent()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.userName = try reader["UserName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes {

    static func write(value: SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreationDate"].write(value.creationDate)
        try writer["MfaAuthenticated"].write(value.mfaAuthenticated)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes()
        value.mfaAuthenticated = try reader["MfaAuthenticated"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsSecretsManagerSecretDetails {

    static func write(value: SecurityHubClientTypes.AwsSecretsManagerSecretDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Deleted"].write(value.deleted)
        try writer["Description"].write(value.description)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["Name"].write(value.name)
        try writer["RotationEnabled"].write(value.rotationEnabled)
        try writer["RotationLambdaArn"].write(value.rotationLambdaArn)
        try writer["RotationOccurredWithinFrequency"].write(value.rotationOccurredWithinFrequency)
        try writer["RotationRules"].write(value.rotationRules, with: SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSecretsManagerSecretDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSecretsManagerSecretDetails()
        value.rotationRules = try reader["RotationRules"].readIfPresent(with: SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules.read(from:))
        value.rotationOccurredWithinFrequency = try reader["RotationOccurredWithinFrequency"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.rotationEnabled = try reader["RotationEnabled"].readIfPresent()
        value.rotationLambdaArn = try reader["RotationLambdaArn"].readIfPresent()
        value.deleted = try reader["Deleted"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules {

    static func write(value: SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomaticallyAfterDays"].write(value.automaticallyAfterDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules()
        value.automaticallyAfterDays = try reader["AutomaticallyAfterDays"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3ObjectDetails {

    static func write(value: SecurityHubClientTypes.AwsS3ObjectDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentType"].write(value.contentType)
        try writer["ETag"].write(value.eTag)
        try writer["LastModified"].write(value.lastModified)
        try writer["SSEKMSKeyId"].write(value.ssekmsKeyId)
        try writer["ServerSideEncryption"].write(value.serverSideEncryption)
        try writer["VersionId"].write(value.versionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3ObjectDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3ObjectDetails()
        value.lastModified = try reader["LastModified"].readIfPresent()
        value.eTag = try reader["ETag"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        value.contentType = try reader["ContentType"].readIfPresent()
        value.serverSideEncryption = try reader["ServerSideEncryption"].readIfPresent()
        value.ssekmsKeyId = try reader["SSEKMSKeyId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessControlList"].write(value.accessControlList)
        try writer["BucketLifecycleConfiguration"].write(value.bucketLifecycleConfiguration, with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails.write(value:to:))
        try writer["BucketLoggingConfiguration"].write(value.bucketLoggingConfiguration, with: SecurityHubClientTypes.AwsS3BucketLoggingConfiguration.write(value:to:))
        try writer["BucketNotificationConfiguration"].write(value.bucketNotificationConfiguration, with: SecurityHubClientTypes.AwsS3BucketNotificationConfiguration.write(value:to:))
        try writer["BucketVersioningConfiguration"].write(value.bucketVersioningConfiguration, with: SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration.write(value:to:))
        try writer["BucketWebsiteConfiguration"].write(value.bucketWebsiteConfiguration, with: SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration.write(value:to:))
        try writer["CreatedAt"].write(value.createdAt)
        try writer["Name"].write(value.name)
        try writer["ObjectLockConfiguration"].write(value.objectLockConfiguration, with: SecurityHubClientTypes.AwsS3BucketObjectLockConfiguration.write(value:to:))
        try writer["OwnerAccountId"].write(value.ownerAccountId)
        try writer["OwnerId"].write(value.ownerId)
        try writer["OwnerName"].write(value.ownerName)
        try writer["PublicAccessBlockConfiguration"].write(value.publicAccessBlockConfiguration, with: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails.write(value:to:))
        try writer["ServerSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketDetails()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.ownerName = try reader["OwnerName"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.serverSideEncryptionConfiguration = try reader["ServerSideEncryptionConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration.read(from:))
        value.bucketLifecycleConfiguration = try reader["BucketLifecycleConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails.read(from:))
        value.publicAccessBlockConfiguration = try reader["PublicAccessBlockConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails.read(from:))
        value.accessControlList = try reader["AccessControlList"].readIfPresent()
        value.bucketLoggingConfiguration = try reader["BucketLoggingConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketLoggingConfiguration.read(from:))
        value.bucketWebsiteConfiguration = try reader["BucketWebsiteConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration.read(from:))
        value.bucketNotificationConfiguration = try reader["BucketNotificationConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketNotificationConfiguration.read(from:))
        value.bucketVersioningConfiguration = try reader["BucketVersioningConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration.read(from:))
        value.objectLockConfiguration = try reader["ObjectLockConfiguration"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketObjectLockConfiguration.read(from:))
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketObjectLockConfiguration {

    static func write(value: SecurityHubClientTypes.AwsS3BucketObjectLockConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectLockEnabled"].write(value.objectLockEnabled)
        try writer["Rule"].write(value.rule, with: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketObjectLockConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketObjectLockConfiguration()
        value.objectLockEnabled = try reader["ObjectLockEnabled"].readIfPresent()
        value.rule = try reader["Rule"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultRetention"].write(value.defaultRetention, with: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDetails()
        value.defaultRetention = try reader["DefaultRetention"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Days"].write(value.days)
        try writer["Mode"].write(value.mode)
        try writer["Years"].write(value.years)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails()
        value.days = try reader["Days"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        value.years = try reader["Years"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsMfaDeleteEnabled"].write(value.isMfaDeleteEnabled)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration()
        value.isMfaDeleteEnabled = try reader["IsMfaDeleteEnabled"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfiguration {

    static func write(value: SecurityHubClientTypes.AwsS3BucketNotificationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configurations"].writeList(value.configurations, memberWritingClosure: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketNotificationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketNotificationConfiguration()
        value.configurations = try reader["Configurations"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail {

    static func write(value: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
        try writer["Events"].writeList(value.events, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail()
        value.events = try reader["Events"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.filter = try reader["Filter"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter.read(from:))
        value.destination = try reader["Destination"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter {

    static func write(value: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3KeyFilter"].write(value.s3KeyFilter, with: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter()
        value.s3KeyFilter = try reader["S3KeyFilter"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter {

    static func write(value: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilterRules"].writeList(value.filterRules, memberWritingClosure: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter()
        value.filterRules = try reader["FilterRules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule {

    static func write(value: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration {

    static func write(value: SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ErrorDocument"].write(value.errorDocument)
        try writer["IndexDocumentSuffix"].write(value.indexDocumentSuffix)
        try writer["RedirectAllRequestsTo"].write(value.redirectAllRequestsTo, with: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo.write(value:to:))
        try writer["RoutingRules"].writeList(value.routingRules, memberWritingClosure: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration()
        value.errorDocument = try reader["ErrorDocument"].readIfPresent()
        value.indexDocumentSuffix = try reader["IndexDocumentSuffix"].readIfPresent()
        value.redirectAllRequestsTo = try reader["RedirectAllRequestsTo"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo.read(from:))
        value.routingRules = try reader["RoutingRules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule {

    static func write(value: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition, with: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition.write(value:to:))
        try writer["Redirect"].write(value.redirect, with: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule()
        value.condition = try reader["Condition"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition.read(from:))
        value.redirect = try reader["Redirect"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {

    static func write(value: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hostname"].write(value.hostname)
        try writer["HttpRedirectCode"].write(value.httpRedirectCode)
        try writer["Protocol"].write(value.`protocol`)
        try writer["ReplaceKeyPrefixWith"].write(value.replaceKeyPrefixWith)
        try writer["ReplaceKeyWith"].write(value.replaceKeyWith)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect()
        value.hostname = try reader["Hostname"].readIfPresent()
        value.httpRedirectCode = try reader["HttpRedirectCode"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.replaceKeyPrefixWith = try reader["ReplaceKeyPrefixWith"].readIfPresent()
        value.replaceKeyWith = try reader["ReplaceKeyWith"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition {

    static func write(value: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpErrorCodeReturnedEquals"].write(value.httpErrorCodeReturnedEquals)
        try writer["KeyPrefixEquals"].write(value.keyPrefixEquals)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition()
        value.httpErrorCodeReturnedEquals = try reader["HttpErrorCodeReturnedEquals"].readIfPresent()
        value.keyPrefixEquals = try reader["KeyPrefixEquals"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo {

    static func write(value: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Hostname"].write(value.hostname)
        try writer["Protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo()
        value.hostname = try reader["Hostname"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketLoggingConfiguration {

    static func write(value: SecurityHubClientTypes.AwsS3BucketLoggingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationBucketName"].write(value.destinationBucketName)
        try writer["LogFilePrefix"].write(value.logFilePrefix)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketLoggingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketLoggingConfiguration()
        value.destinationBucketName = try reader["DestinationBucketName"].readIfPresent()
        value.logFilePrefix = try reader["LogFilePrefix"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Rules"].writeList(value.rules, memberWritingClosure: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AbortIncompleteMultipartUpload"].write(value.abortIncompleteMultipartUpload, with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails.write(value:to:))
        try writer["ExpirationDate"].write(value.expirationDate)
        try writer["ExpirationInDays"].write(value.expirationInDays)
        try writer["ExpiredObjectDeleteMarker"].write(value.expiredObjectDeleteMarker)
        try writer["Filter"].write(value.filter, with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails.write(value:to:))
        try writer["ID"].write(value.id)
        try writer["NoncurrentVersionExpirationInDays"].write(value.noncurrentVersionExpirationInDays)
        try writer["NoncurrentVersionTransitions"].writeList(value.noncurrentVersionTransitions, memberWritingClosure: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Prefix"].write(value.`prefix`)
        try writer["Status"].write(value.status)
        try writer["Transitions"].writeList(value.transitions, memberWritingClosure: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails()
        value.abortIncompleteMultipartUpload = try reader["AbortIncompleteMultipartUpload"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails.read(from:))
        value.expirationDate = try reader["ExpirationDate"].readIfPresent()
        value.expirationInDays = try reader["ExpirationInDays"].readIfPresent()
        value.expiredObjectDeleteMarker = try reader["ExpiredObjectDeleteMarker"].readIfPresent()
        value.filter = try reader["Filter"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails.read(from:))
        value.id = try reader["ID"].readIfPresent()
        value.noncurrentVersionExpirationInDays = try reader["NoncurrentVersionExpirationInDays"].readIfPresent()
        value.noncurrentVersionTransitions = try reader["NoncurrentVersionTransitions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.transitions = try reader["Transitions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Date"].write(value.date)
        try writer["Days"].write(value.days)
        try writer["StorageClass"].write(value.storageClass)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails()
        value.date = try reader["Date"].readIfPresent()
        value.days = try reader["Days"].readIfPresent()
        value.storageClass = try reader["StorageClass"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Days"].write(value.days)
        try writer["StorageClass"].write(value.storageClass)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails()
        value.days = try reader["Days"].readIfPresent()
        value.storageClass = try reader["StorageClass"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Predicate"].write(value.predicate, with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails()
        value.predicate = try reader["Predicate"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Operands"].writeList(value.operands, memberWritingClosure: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Prefix"].write(value.`prefix`)
        try writer["Tag"].write(value.tag, with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails()
        value.operands = try reader["Operands"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.tag = try reader["Tag"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails.read(from:))
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Prefix"].write(value.`prefix`)
        try writer["Tag"].write(value.tag, with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails()
        value.`prefix` = try reader["Prefix"].readIfPresent()
        value.tag = try reader["Tag"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails.read(from:))
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails {

    static func write(value: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DaysAfterInitiation"].write(value.daysAfterInitiation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails()
        value.daysAfterInitiation = try reader["DaysAfterInitiation"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration {

    static func write(value: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Rules"].writeList(value.rules, memberWritingClosure: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule {

    static func write(value: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplyServerSideEncryptionByDefault"].write(value.applyServerSideEncryptionByDefault, with: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule()
        value.applyServerSideEncryptionByDefault = try reader["ApplyServerSideEncryptionByDefault"].readIfPresent(with: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault {

    static func write(value: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KMSMasterKeyID"].write(value.kmsMasterKeyID)
        try writer["SSEAlgorithm"].write(value.sseAlgorithm)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault()
        value.sseAlgorithm = try reader["SSEAlgorithm"].readIfPresent()
        value.kmsMasterKeyID = try reader["KMSMasterKeyID"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainDetails {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessPolicies"].write(value.accessPolicies)
        try writer["DomainEndpointOptions"].write(value.domainEndpointOptions, with: SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions.write(value:to:))
        try writer["DomainId"].write(value.domainId)
        try writer["DomainName"].write(value.domainName)
        try writer["ElasticsearchClusterConfig"].write(value.elasticsearchClusterConfig, with: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails.write(value:to:))
        try writer["ElasticsearchVersion"].write(value.elasticsearchVersion)
        try writer["EncryptionAtRestOptions"].write(value.encryptionAtRestOptions, with: SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions.write(value:to:))
        try writer["Endpoint"].write(value.endpoint)
        try writer["Endpoints"].writeMap(value.endpoints, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["LogPublishingOptions"].write(value.logPublishingOptions, with: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions.write(value:to:))
        try writer["NodeToNodeEncryptionOptions"].write(value.nodeToNodeEncryptionOptions, with: SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions.write(value:to:))
        try writer["ServiceSoftwareOptions"].write(value.serviceSoftwareOptions, with: SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions.write(value:to:))
        try writer["VPCOptions"].write(value.vpcOptions, with: SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainDetails()
        value.accessPolicies = try reader["AccessPolicies"].readIfPresent()
        value.domainEndpointOptions = try reader["DomainEndpointOptions"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions.read(from:))
        value.domainId = try reader["DomainId"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.endpoints = try reader["Endpoints"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.elasticsearchVersion = try reader["ElasticsearchVersion"].readIfPresent()
        value.elasticsearchClusterConfig = try reader["ElasticsearchClusterConfig"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails.read(from:))
        value.encryptionAtRestOptions = try reader["EncryptionAtRestOptions"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions.read(from:))
        value.logPublishingOptions = try reader["LogPublishingOptions"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions.read(from:))
        value.nodeToNodeEncryptionOptions = try reader["NodeToNodeEncryptionOptions"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions.read(from:))
        value.serviceSoftwareOptions = try reader["ServiceSoftwareOptions"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions.read(from:))
        value.vpcOptions = try reader["VPCOptions"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VPCId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions()
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetIds = try reader["SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VPCId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutomatedUpdateDate"].write(value.automatedUpdateDate)
        try writer["Cancellable"].write(value.cancellable)
        try writer["CurrentVersion"].write(value.currentVersion)
        try writer["Description"].write(value.description)
        try writer["NewVersion"].write(value.newVersion)
        try writer["UpdateAvailable"].write(value.updateAvailable)
        try writer["UpdateStatus"].write(value.updateStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions()
        value.automatedUpdateDate = try reader["AutomatedUpdateDate"].readIfPresent()
        value.cancellable = try reader["Cancellable"].readIfPresent()
        value.currentVersion = try reader["CurrentVersion"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.newVersion = try reader["NewVersion"].readIfPresent()
        value.updateAvailable = try reader["UpdateAvailable"].readIfPresent()
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuditLogs"].write(value.auditLogs, with: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig.write(value:to:))
        try writer["IndexSlowLogs"].write(value.indexSlowLogs, with: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig.write(value:to:))
        try writer["SearchSlowLogs"].write(value.searchSlowLogs, with: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions()
        value.indexSlowLogs = try reader["IndexSlowLogs"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig.read(from:))
        value.searchSlowLogs = try reader["SearchSlowLogs"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig.read(from:))
        value.auditLogs = try reader["AuditLogs"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsLogGroupArn"].write(value.cloudWatchLogsLogGroupArn)
        try writer["Enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig()
        value.cloudWatchLogsLogGroupArn = try reader["CloudWatchLogsLogGroupArn"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
        try writer["KmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DedicatedMasterCount"].write(value.dedicatedMasterCount)
        try writer["DedicatedMasterEnabled"].write(value.dedicatedMasterEnabled)
        try writer["DedicatedMasterType"].write(value.dedicatedMasterType)
        try writer["InstanceCount"].write(value.instanceCount)
        try writer["InstanceType"].write(value.instanceType)
        try writer["ZoneAwarenessConfig"].write(value.zoneAwarenessConfig, with: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails.write(value:to:))
        try writer["ZoneAwarenessEnabled"].write(value.zoneAwarenessEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails()
        value.dedicatedMasterCount = try reader["DedicatedMasterCount"].readIfPresent()
        value.dedicatedMasterEnabled = try reader["DedicatedMasterEnabled"].readIfPresent()
        value.dedicatedMasterType = try reader["DedicatedMasterType"].readIfPresent()
        value.instanceCount = try reader["InstanceCount"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.zoneAwarenessConfig = try reader["ZoneAwarenessConfig"].readIfPresent(with: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails.read(from:))
        value.zoneAwarenessEnabled = try reader["ZoneAwarenessEnabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZoneCount"].write(value.availabilityZoneCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails()
        value.availabilityZoneCount = try reader["AvailabilityZoneCount"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions {

    static func write(value: SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnforceHTTPS"].write(value.enforceHTTPS)
        try writer["TLSSecurityPolicy"].write(value.tlsSecurityPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions()
        value.enforceHTTPS = try reader["EnforceHTTPS"].readIfPresent()
        value.tlsSecurityPolicy = try reader["TLSSecurityPolicy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails {

    static func write(value: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationName"].write(value.applicationName)
        try writer["Cname"].write(value.cname)
        try writer["DateCreated"].write(value.dateCreated)
        try writer["DateUpdated"].write(value.dateUpdated)
        try writer["Description"].write(value.description)
        try writer["EndpointUrl"].write(value.endpointUrl)
        try writer["EnvironmentArn"].write(value.environmentArn)
        try writer["EnvironmentId"].write(value.environmentId)
        try writer["EnvironmentLinks"].writeList(value.environmentLinks, memberWritingClosure: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnvironmentName"].write(value.environmentName)
        try writer["OptionSettings"].writeList(value.optionSettings, memberWritingClosure: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PlatformArn"].write(value.platformArn)
        try writer["SolutionStackName"].write(value.solutionStackName)
        try writer["Status"].write(value.status)
        try writer["Tier"].write(value.tier, with: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier.write(value:to:))
        try writer["VersionLabel"].write(value.versionLabel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails()
        value.applicationName = try reader["ApplicationName"].readIfPresent()
        value.cname = try reader["Cname"].readIfPresent()
        value.dateCreated = try reader["DateCreated"].readIfPresent()
        value.dateUpdated = try reader["DateUpdated"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.endpointUrl = try reader["EndpointUrl"].readIfPresent()
        value.environmentArn = try reader["EnvironmentArn"].readIfPresent()
        value.environmentId = try reader["EnvironmentId"].readIfPresent()
        value.environmentLinks = try reader["EnvironmentLinks"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environmentName = try reader["EnvironmentName"].readIfPresent()
        value.optionSettings = try reader["OptionSettings"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.platformArn = try reader["PlatformArn"].readIfPresent()
        value.solutionStackName = try reader["SolutionStackName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tier = try reader["Tier"].readIfPresent(with: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier.read(from:))
        value.versionLabel = try reader["VersionLabel"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier {

    static func write(value: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting {

    static func write(value: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Namespace"].write(value.namespace)
        try writer["OptionName"].write(value.optionName)
        try writer["ResourceName"].write(value.resourceName)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.optionName = try reader["OptionName"].readIfPresent()
        value.resourceName = try reader["ResourceName"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink {

    static func write(value: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnvironmentName"].write(value.environmentName)
        try writer["LinkName"].write(value.linkName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink()
        value.environmentName = try reader["EnvironmentName"].readIfPresent()
        value.linkName = try reader["LinkName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsElbv2LoadBalancerDetails {

    static func write(value: SecurityHubClientTypes.AwsElbv2LoadBalancerDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SecurityHubClientTypes.AvailabilityZone.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CanonicalHostedZoneId"].write(value.canonicalHostedZoneId)
        try writer["CreatedTime"].write(value.createdTime)
        try writer["DNSName"].write(value.dnsName)
        try writer["IpAddressType"].write(value.ipAddressType)
        try writer["LoadBalancerAttributes"].writeList(value.loadBalancerAttributes, memberWritingClosure: SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Scheme"].write(value.scheme)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["State"].write(value.state, with: SecurityHubClientTypes.LoadBalancerState.write(value:to:))
        try writer["Type"].write(value.type)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbv2LoadBalancerDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbv2LoadBalancerDetails()
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AvailabilityZone.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.canonicalHostedZoneId = try reader["CanonicalHostedZoneId"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.dnsName = try reader["DNSName"].readIfPresent()
        value.ipAddressType = try reader["IpAddressType"].readIfPresent()
        value.scheme = try reader["Scheme"].readIfPresent()
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["State"].readIfPresent(with: SecurityHubClientTypes.LoadBalancerState.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.loadBalancerAttributes = try reader["LoadBalancerAttributes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute {

    static func write(value: SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.LoadBalancerState {

    static func write(value: SecurityHubClientTypes.LoadBalancerState?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
        try writer["Reason"].write(value.reason)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.LoadBalancerState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.LoadBalancerState()
        value.code = try reader["Code"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AvailabilityZone {

    static func write(value: SecurityHubClientTypes.AvailabilityZone?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubnetId"].write(value.subnetId)
        try writer["ZoneName"].write(value.zoneName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AvailabilityZone {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AvailabilityZone()
        value.zoneName = try reader["ZoneName"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2NetworkAclDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2NetworkAclDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Associations"].writeList(value.associations, memberWritingClosure: SecurityHubClientTypes.AwsEc2NetworkAclAssociation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Entries"].writeList(value.entries, memberWritingClosure: SecurityHubClientTypes.AwsEc2NetworkAclEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IsDefault"].write(value.isDefault)
        try writer["NetworkAclId"].write(value.networkAclId)
        try writer["OwnerId"].write(value.ownerId)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2NetworkAclDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2NetworkAclDetails()
        value.isDefault = try reader["IsDefault"].readIfPresent()
        value.networkAclId = try reader["NetworkAclId"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.associations = try reader["Associations"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2NetworkAclAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.entries = try reader["Entries"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2NetworkAclEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2NetworkAclEntry {

    static func write(value: SecurityHubClientTypes.AwsEc2NetworkAclEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CidrBlock"].write(value.cidrBlock)
        try writer["Egress"].write(value.egress)
        try writer["IcmpTypeCode"].write(value.icmpTypeCode, with: SecurityHubClientTypes.IcmpTypeCode.write(value:to:))
        try writer["Ipv6CidrBlock"].write(value.ipv6CidrBlock)
        try writer["PortRange"].write(value.portRange, with: SecurityHubClientTypes.PortRangeFromTo.write(value:to:))
        try writer["Protocol"].write(value.`protocol`)
        try writer["RuleAction"].write(value.ruleAction)
        try writer["RuleNumber"].write(value.ruleNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2NetworkAclEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2NetworkAclEntry()
        value.cidrBlock = try reader["CidrBlock"].readIfPresent()
        value.egress = try reader["Egress"].readIfPresent()
        value.icmpTypeCode = try reader["IcmpTypeCode"].readIfPresent(with: SecurityHubClientTypes.IcmpTypeCode.read(from:))
        value.ipv6CidrBlock = try reader["Ipv6CidrBlock"].readIfPresent()
        value.portRange = try reader["PortRange"].readIfPresent(with: SecurityHubClientTypes.PortRangeFromTo.read(from:))
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.ruleAction = try reader["RuleAction"].readIfPresent()
        value.ruleNumber = try reader["RuleNumber"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.PortRangeFromTo {

    static func write(value: SecurityHubClientTypes.PortRangeFromTo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["From"].write(value.from)
        try writer["To"].write(value.to)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.PortRangeFromTo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.PortRangeFromTo()
        value.from = try reader["From"].readIfPresent()
        value.to = try reader["To"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.IcmpTypeCode {

    static func write(value: SecurityHubClientTypes.IcmpTypeCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.IcmpTypeCode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.IcmpTypeCode()
        value.code = try reader["Code"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2NetworkAclAssociation {

    static func write(value: SecurityHubClientTypes.AwsEc2NetworkAclAssociation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NetworkAclAssociationId"].write(value.networkAclAssociationId)
        try writer["NetworkAclId"].write(value.networkAclId)
        try writer["SubnetId"].write(value.subnetId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2NetworkAclAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2NetworkAclAssociation()
        value.networkAclAssociationId = try reader["NetworkAclAssociationId"].readIfPresent()
        value.networkAclId = try reader["NetworkAclId"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2SubnetDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2SubnetDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssignIpv6AddressOnCreation"].write(value.assignIpv6AddressOnCreation)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["AvailabilityZoneId"].write(value.availabilityZoneId)
        try writer["AvailableIpAddressCount"].write(value.availableIpAddressCount)
        try writer["CidrBlock"].write(value.cidrBlock)
        try writer["DefaultForAz"].write(value.defaultForAz)
        try writer["Ipv6CidrBlockAssociationSet"].writeList(value.ipv6CidrBlockAssociationSet, memberWritingClosure: SecurityHubClientTypes.Ipv6CidrBlockAssociation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MapPublicIpOnLaunch"].write(value.mapPublicIpOnLaunch)
        try writer["OwnerId"].write(value.ownerId)
        try writer["State"].write(value.state)
        try writer["SubnetArn"].write(value.subnetArn)
        try writer["SubnetId"].write(value.subnetId)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2SubnetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2SubnetDetails()
        value.assignIpv6AddressOnCreation = try reader["AssignIpv6AddressOnCreation"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.availabilityZoneId = try reader["AvailabilityZoneId"].readIfPresent()
        value.availableIpAddressCount = try reader["AvailableIpAddressCount"].readIfPresent()
        value.cidrBlock = try reader["CidrBlock"].readIfPresent()
        value.defaultForAz = try reader["DefaultForAz"].readIfPresent()
        value.mapPublicIpOnLaunch = try reader["MapPublicIpOnLaunch"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.subnetArn = try reader["SubnetArn"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.ipv6CidrBlockAssociationSet = try reader["Ipv6CidrBlockAssociationSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Ipv6CidrBlockAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.Ipv6CidrBlockAssociation {

    static func write(value: SecurityHubClientTypes.Ipv6CidrBlockAssociation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationId"].write(value.associationId)
        try writer["CidrBlockState"].write(value.cidrBlockState)
        try writer["Ipv6CidrBlock"].write(value.ipv6CidrBlock)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Ipv6CidrBlockAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Ipv6CidrBlockAssociation()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.ipv6CidrBlock = try reader["Ipv6CidrBlock"].readIfPresent()
        value.cidrBlockState = try reader["CidrBlockState"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2EipDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2EipDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllocationId"].write(value.allocationId)
        try writer["AssociationId"].write(value.associationId)
        try writer["Domain"].write(value.domain)
        try writer["InstanceId"].write(value.instanceId)
        try writer["NetworkBorderGroup"].write(value.networkBorderGroup)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["NetworkInterfaceOwnerId"].write(value.networkInterfaceOwnerId)
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
        try writer["PublicIp"].write(value.publicIp)
        try writer["PublicIpv4Pool"].write(value.publicIpv4Pool)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2EipDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2EipDetails()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.publicIp = try reader["PublicIp"].readIfPresent()
        value.allocationId = try reader["AllocationId"].readIfPresent()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.domain = try reader["Domain"].readIfPresent()
        value.publicIpv4Pool = try reader["PublicIpv4Pool"].readIfPresent()
        value.networkBorderGroup = try reader["NetworkBorderGroup"].readIfPresent()
        value.networkInterfaceId = try reader["NetworkInterfaceId"].readIfPresent()
        value.networkInterfaceOwnerId = try reader["NetworkInterfaceOwnerId"].readIfPresent()
        value.privateIpAddress = try reader["PrivateIpAddress"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VpcDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VpcDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CidrBlockAssociationSet"].writeList(value.cidrBlockAssociationSet, memberWritingClosure: SecurityHubClientTypes.CidrBlockAssociation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DhcpOptionsId"].write(value.dhcpOptionsId)
        try writer["Ipv6CidrBlockAssociationSet"].writeList(value.ipv6CidrBlockAssociationSet, memberWritingClosure: SecurityHubClientTypes.Ipv6CidrBlockAssociation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VpcDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VpcDetails()
        value.cidrBlockAssociationSet = try reader["CidrBlockAssociationSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.CidrBlockAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipv6CidrBlockAssociationSet = try reader["Ipv6CidrBlockAssociationSet"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Ipv6CidrBlockAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dhcpOptionsId = try reader["DhcpOptionsId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.CidrBlockAssociation {

    static func write(value: SecurityHubClientTypes.CidrBlockAssociation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationId"].write(value.associationId)
        try writer["CidrBlock"].write(value.cidrBlock)
        try writer["CidrBlockState"].write(value.cidrBlockState)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.CidrBlockAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.CidrBlockAssociation()
        value.associationId = try reader["AssociationId"].readIfPresent()
        value.cidrBlock = try reader["CidrBlock"].readIfPresent()
        value.cidrBlockState = try reader["CidrBlockState"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VolumeDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2VolumeDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attachments"].writeList(value.attachments, memberWritingClosure: SecurityHubClientTypes.AwsEc2VolumeAttachment.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreateTime"].write(value.createTime)
        try writer["DeviceName"].write(value.deviceName)
        try writer["Encrypted"].write(value.encrypted)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["Size"].write(value.size)
        try writer["SnapshotId"].write(value.snapshotId)
        try writer["Status"].write(value.status)
        try writer["VolumeId"].write(value.volumeId)
        try writer["VolumeScanStatus"].write(value.volumeScanStatus)
        try writer["VolumeType"].write(value.volumeType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VolumeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VolumeDetails()
        value.createTime = try reader["CreateTime"].readIfPresent()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.encrypted = try reader["Encrypted"].readIfPresent()
        value.size = try reader["Size"].readIfPresent()
        value.snapshotId = try reader["SnapshotId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.attachments = try reader["Attachments"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2VolumeAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.volumeId = try reader["VolumeId"].readIfPresent()
        value.volumeType = try reader["VolumeType"].readIfPresent()
        value.volumeScanStatus = try reader["VolumeScanStatus"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2VolumeAttachment {

    static func write(value: SecurityHubClientTypes.AwsEc2VolumeAttachment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachTime"].write(value.attachTime)
        try writer["DeleteOnTermination"].write(value.deleteOnTermination)
        try writer["InstanceId"].write(value.instanceId)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2VolumeAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2VolumeAttachment()
        value.attachTime = try reader["AttachTime"].readIfPresent()
        value.deleteOnTermination = try reader["DeleteOnTermination"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2SecurityGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2SecurityGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["GroupName"].write(value.groupName)
        try writer["IpPermissions"].writeList(value.ipPermissions, memberWritingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IpPermissionsEgress"].writeList(value.ipPermissionsEgress, memberWritingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OwnerId"].write(value.ownerId)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2SecurityGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2SecurityGroupDetails()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        value.ownerId = try reader["OwnerId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.ipPermissions = try reader["IpPermissions"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipPermissionsEgress = try reader["IpPermissionsEgress"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission {

    static func write(value: SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromPort"].write(value.fromPort)
        try writer["IpProtocol"].write(value.ipProtocol)
        try writer["IpRanges"].writeList(value.ipRanges, memberWritingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupIpRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ipv6Ranges"].writeList(value.ipv6Ranges, memberWritingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PrefixListIds"].writeList(value.prefixListIds, memberWritingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ToPort"].write(value.toPort)
        try writer["UserIdGroupPairs"].writeList(value.userIdGroupPairs, memberWritingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission()
        value.ipProtocol = try reader["IpProtocol"].readIfPresent()
        value.fromPort = try reader["FromPort"].readIfPresent()
        value.toPort = try reader["ToPort"].readIfPresent()
        value.userIdGroupPairs = try reader["UserIdGroupPairs"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipRanges = try reader["IpRanges"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupIpRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipv6Ranges = try reader["Ipv6Ranges"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.prefixListIds = try reader["PrefixListIds"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId {

    static func write(value: SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PrefixListId"].write(value.prefixListId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId()
        value.prefixListId = try reader["PrefixListId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range {

    static func write(value: SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CidrIpv6"].write(value.cidrIpv6)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range()
        value.cidrIpv6 = try reader["CidrIpv6"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2SecurityGroupIpRange {

    static func write(value: SecurityHubClientTypes.AwsEc2SecurityGroupIpRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CidrIp"].write(value.cidrIp)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2SecurityGroupIpRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2SecurityGroupIpRange()
        value.cidrIp = try reader["CidrIp"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair {

    static func write(value: SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["GroupName"].write(value.groupName)
        try writer["PeeringStatus"].write(value.peeringStatus)
        try writer["UserId"].write(value.userId)
        try writer["VpcId"].write(value.vpcId)
        try writer["VpcPeeringConnectionId"].write(value.vpcPeeringConnectionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair()
        value.groupId = try reader["GroupId"].readIfPresent()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.peeringStatus = try reader["PeeringStatus"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.vpcPeeringConnectionId = try reader["VpcPeeringConnectionId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attachment"].write(value.attachment, with: SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment.write(value:to:))
        try writer["IpV6Addresses"].writeList(value.ipV6Addresses, memberWritingClosure: SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["PrivateIpAddresses"].writeList(value.privateIpAddresses, memberWritingClosure: SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PublicDnsName"].write(value.publicDnsName)
        try writer["PublicIp"].write(value.publicIp)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceDestCheck"].write(value.sourceDestCheck)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails()
        value.attachment = try reader["Attachment"].readIfPresent(with: SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment.read(from:))
        value.networkInterfaceId = try reader["NetworkInterfaceId"].readIfPresent()
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceDestCheck = try reader["SourceDestCheck"].readIfPresent()
        value.ipV6Addresses = try reader["IpV6Addresses"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.privateIpAddresses = try reader["PrivateIpAddresses"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.publicDnsName = try reader["PublicDnsName"].readIfPresent()
        value.publicIp = try reader["PublicIp"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail {

    static func write(value: SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PrivateDnsName"].write(value.privateDnsName)
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail()
        value.privateIpAddress = try reader["PrivateIpAddress"].readIfPresent()
        value.privateDnsName = try reader["PrivateDnsName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail {

    static func write(value: SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IpV6Address"].write(value.ipV6Address)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail()
        value.ipV6Address = try reader["IpV6Address"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup {

    static func write(value: SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["GroupName"].write(value.groupName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment {

    static func write(value: SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachTime"].write(value.attachTime)
        try writer["AttachmentId"].write(value.attachmentId)
        try writer["DeleteOnTermination"].write(value.deleteOnTermination)
        try writer["DeviceIndex"].write(value.deviceIndex)
        try writer["InstanceId"].write(value.instanceId)
        try writer["InstanceOwnerId"].write(value.instanceOwnerId)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment()
        value.attachTime = try reader["AttachTime"].readIfPresent()
        value.attachmentId = try reader["AttachmentId"].readIfPresent()
        value.deleteOnTermination = try reader["DeleteOnTermination"].readIfPresent()
        value.deviceIndex = try reader["DeviceIndex"].readIfPresent()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.instanceOwnerId = try reader["InstanceOwnerId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2InstanceDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2InstanceDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamInstanceProfileArn"].write(value.iamInstanceProfileArn)
        try writer["ImageId"].write(value.imageId)
        try writer["IpV4Addresses"].writeList(value.ipV4Addresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IpV6Addresses"].writeList(value.ipV6Addresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KeyName"].write(value.keyName)
        try writer["LaunchedAt"].write(value.launchedAt)
        try writer["MetadataOptions"].write(value.metadataOptions, with: SecurityHubClientTypes.AwsEc2InstanceMetadataOptions.write(value:to:))
        try writer["Monitoring"].write(value.monitoring, with: SecurityHubClientTypes.AwsEc2InstanceMonitoringDetails.write(value:to:))
        try writer["NetworkInterfaces"].writeList(value.networkInterfaces, memberWritingClosure: SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetId"].write(value.subnetId)
        try writer["Type"].write(value.type)
        try writer["VirtualizationType"].write(value.virtualizationType)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2InstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2InstanceDetails()
        value.type = try reader["Type"].readIfPresent()
        value.imageId = try reader["ImageId"].readIfPresent()
        value.ipV4Addresses = try reader["IpV4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipV6Addresses = try reader["IpV6Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.keyName = try reader["KeyName"].readIfPresent()
        value.iamInstanceProfileArn = try reader["IamInstanceProfileArn"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.launchedAt = try reader["LaunchedAt"].readIfPresent()
        value.networkInterfaces = try reader["NetworkInterfaces"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.virtualizationType = try reader["VirtualizationType"].readIfPresent()
        value.metadataOptions = try reader["MetadataOptions"].readIfPresent(with: SecurityHubClientTypes.AwsEc2InstanceMetadataOptions.read(from:))
        value.monitoring = try reader["Monitoring"].readIfPresent(with: SecurityHubClientTypes.AwsEc2InstanceMonitoringDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2InstanceMonitoringDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2InstanceMonitoringDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2InstanceMonitoringDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2InstanceMonitoringDetails()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2InstanceMetadataOptions {

    static func write(value: SecurityHubClientTypes.AwsEc2InstanceMetadataOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpEndpoint"].write(value.httpEndpoint)
        try writer["HttpProtocolIpv6"].write(value.httpProtocolIpv6)
        try writer["HttpPutResponseHopLimit"].write(value.httpPutResponseHopLimit)
        try writer["HttpTokens"].write(value.httpTokens)
        try writer["InstanceMetadataTags"].write(value.instanceMetadataTags)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2InstanceMetadataOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2InstanceMetadataOptions()
        value.httpEndpoint = try reader["HttpEndpoint"].readIfPresent()
        value.httpProtocolIpv6 = try reader["HttpProtocolIpv6"].readIfPresent()
        value.httpPutResponseHopLimit = try reader["HttpPutResponseHopLimit"].readIfPresent()
        value.httpTokens = try reader["HttpTokens"].readIfPresent()
        value.instanceMetadataTags = try reader["InstanceMetadataTags"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails {

    static func write(value: SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails()
        value.networkInterfaceId = try reader["NetworkInterfaceId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionDetails {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CacheBehaviors"].write(value.cacheBehaviors, with: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors.write(value:to:))
        try writer["DefaultCacheBehavior"].write(value.defaultCacheBehavior, with: SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior.write(value:to:))
        try writer["DefaultRootObject"].write(value.defaultRootObject)
        try writer["DomainName"].write(value.domainName)
        try writer["ETag"].write(value.eTag)
        try writer["LastModifiedTime"].write(value.lastModifiedTime)
        try writer["Logging"].write(value.logging, with: SecurityHubClientTypes.AwsCloudFrontDistributionLogging.write(value:to:))
        try writer["OriginGroups"].write(value.originGroups, with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups.write(value:to:))
        try writer["Origins"].write(value.origins, with: SecurityHubClientTypes.AwsCloudFrontDistributionOrigins.write(value:to:))
        try writer["Status"].write(value.status)
        try writer["ViewerCertificate"].write(value.viewerCertificate, with: SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate.write(value:to:))
        try writer["WebAclId"].write(value.webAclId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionDetails()
        value.cacheBehaviors = try reader["CacheBehaviors"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors.read(from:))
        value.defaultCacheBehavior = try reader["DefaultCacheBehavior"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior.read(from:))
        value.defaultRootObject = try reader["DefaultRootObject"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.eTag = try reader["ETag"].readIfPresent()
        value.lastModifiedTime = try reader["LastModifiedTime"].readIfPresent()
        value.logging = try reader["Logging"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionLogging.read(from:))
        value.origins = try reader["Origins"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionOrigins.read(from:))
        value.originGroups = try reader["OriginGroups"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups.read(from:))
        value.viewerCertificate = try reader["ViewerCertificate"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.webAclId = try reader["WebAclId"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcmCertificateArn"].write(value.acmCertificateArn)
        try writer["Certificate"].write(value.certificate)
        try writer["CertificateSource"].write(value.certificateSource)
        try writer["CloudFrontDefaultCertificate"].write(value.cloudFrontDefaultCertificate)
        try writer["IamCertificateId"].write(value.iamCertificateId)
        try writer["MinimumProtocolVersion"].write(value.minimumProtocolVersion)
        try writer["SslSupportMethod"].write(value.sslSupportMethod)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate()
        value.acmCertificateArn = try reader["AcmCertificateArn"].readIfPresent()
        value.certificate = try reader["Certificate"].readIfPresent()
        value.certificateSource = try reader["CertificateSource"].readIfPresent()
        value.cloudFrontDefaultCertificate = try reader["CloudFrontDefaultCertificate"].readIfPresent()
        value.iamCertificateId = try reader["IamCertificateId"].readIfPresent()
        value.minimumProtocolVersion = try reader["MinimumProtocolVersion"].readIfPresent()
        value.sslSupportMethod = try reader["SslSupportMethod"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailoverCriteria"].write(value.failoverCriteria, with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup()
        value.failoverCriteria = try reader["FailoverCriteria"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StatusCodes"].write(value.statusCodes, with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover()
        value.statusCodes = try reader["StatusCodes"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.quantity = try reader["Quantity"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOrigins {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionOrigins?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionOrigins {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionOrigins()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomOriginConfig"].write(value.customOriginConfig, with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig.write(value:to:))
        try writer["DomainName"].write(value.domainName)
        try writer["Id"].write(value.id)
        try writer["OriginPath"].write(value.originPath)
        try writer["S3OriginConfig"].write(value.s3OriginConfig, with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.originPath = try reader["OriginPath"].readIfPresent()
        value.s3OriginConfig = try reader["S3OriginConfig"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig.read(from:))
        value.customOriginConfig = try reader["CustomOriginConfig"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpPort"].write(value.httpPort)
        try writer["HttpsPort"].write(value.httpsPort)
        try writer["OriginKeepaliveTimeout"].write(value.originKeepaliveTimeout)
        try writer["OriginProtocolPolicy"].write(value.originProtocolPolicy)
        try writer["OriginReadTimeout"].write(value.originReadTimeout)
        try writer["OriginSslProtocols"].write(value.originSslProtocols, with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig()
        value.httpPort = try reader["HttpPort"].readIfPresent()
        value.httpsPort = try reader["HttpsPort"].readIfPresent()
        value.originKeepaliveTimeout = try reader["OriginKeepaliveTimeout"].readIfPresent()
        value.originProtocolPolicy = try reader["OriginProtocolPolicy"].readIfPresent()
        value.originReadTimeout = try reader["OriginReadTimeout"].readIfPresent()
        value.originSslProtocols = try reader["OriginSslProtocols"].readIfPresent(with: SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Quantity"].write(value.quantity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.quantity = try reader["Quantity"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OriginAccessIdentity"].write(value.originAccessIdentity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig()
        value.originAccessIdentity = try reader["OriginAccessIdentity"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionLogging {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionLogging?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bucket"].write(value.bucket)
        try writer["Enabled"].write(value.enabled)
        try writer["IncludeCookies"].write(value.includeCookies)
        try writer["Prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionLogging {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionLogging()
        value.bucket = try reader["Bucket"].readIfPresent()
        value.enabled = try reader["Enabled"].readIfPresent()
        value.includeCookies = try reader["IncludeCookies"].readIfPresent()
        value.`prefix` = try reader["Prefix"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ViewerProtocolPolicy"].write(value.viewerProtocolPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior()
        value.viewerProtocolPolicy = try reader["ViewerProtocolPolicy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior {

    static func write(value: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ViewerProtocolPolicy"].write(value.viewerProtocolPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior()
        value.viewerProtocolPolicy = try reader["ViewerProtocolPolicy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectDetails {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Artifacts"].writeList(value.artifacts, memberWritingClosure: SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EncryptionKey"].write(value.encryptionKey)
        try writer["Environment"].write(value.environment, with: SecurityHubClientTypes.AwsCodeBuildProjectEnvironment.write(value:to:))
        try writer["LogsConfig"].write(value.logsConfig, with: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["SecondaryArtifacts"].writeList(value.secondaryArtifacts, memberWritingClosure: SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ServiceRole"].write(value.serviceRole)
        try writer["Source"].write(value.source, with: SecurityHubClientTypes.AwsCodeBuildProjectSource.write(value:to:))
        try writer["VpcConfig"].write(value.vpcConfig, with: SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectDetails()
        value.encryptionKey = try reader["EncryptionKey"].readIfPresent()
        value.artifacts = try reader["Artifacts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.environment = try reader["Environment"].readIfPresent(with: SecurityHubClientTypes.AwsCodeBuildProjectEnvironment.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.source = try reader["Source"].readIfPresent(with: SecurityHubClientTypes.AwsCodeBuildProjectSource.read(from:))
        value.serviceRole = try reader["ServiceRole"].readIfPresent()
        value.logsConfig = try reader["LogsConfig"].readIfPresent(with: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails.read(from:))
        value.vpcConfig = try reader["VpcConfig"].readIfPresent(with: SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig.read(from:))
        value.secondaryArtifacts = try reader["SecondaryArtifacts"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArtifactIdentifier"].write(value.artifactIdentifier)
        try writer["EncryptionDisabled"].write(value.encryptionDisabled)
        try writer["Location"].write(value.location)
        try writer["Name"].write(value.name)
        try writer["NamespaceType"].write(value.namespaceType)
        try writer["OverrideArtifactName"].write(value.overrideArtifactName)
        try writer["Packaging"].write(value.packaging)
        try writer["Path"].write(value.path)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails()
        value.artifactIdentifier = try reader["ArtifactIdentifier"].readIfPresent()
        value.encryptionDisabled = try reader["EncryptionDisabled"].readIfPresent()
        value.location = try reader["Location"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.namespaceType = try reader["NamespaceType"].readIfPresent()
        value.overrideArtifactName = try reader["OverrideArtifactName"].readIfPresent()
        value.packaging = try reader["Packaging"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogs"].write(value.cloudWatchLogs, with: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails.write(value:to:))
        try writer["S3Logs"].write(value.s3Logs, with: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails()
        value.cloudWatchLogs = try reader["CloudWatchLogs"].readIfPresent(with: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails.read(from:))
        value.s3Logs = try reader["S3Logs"].readIfPresent(with: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncryptionDisabled"].write(value.encryptionDisabled)
        try writer["Location"].write(value.location)
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails()
        value.encryptionDisabled = try reader["EncryptionDisabled"].readIfPresent()
        value.location = try reader["Location"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupName"].write(value.groupName)
        try writer["Status"].write(value.status)
        try writer["StreamName"].write(value.streamName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails()
        value.groupName = try reader["GroupName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.streamName = try reader["StreamName"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectSource {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GitCloneDepth"].write(value.gitCloneDepth)
        try writer["InsecureSsl"].write(value.insecureSsl)
        try writer["Location"].write(value.location)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectSource()
        value.type = try reader["Type"].readIfPresent()
        value.location = try reader["Location"].readIfPresent()
        value.gitCloneDepth = try reader["GitCloneDepth"].readIfPresent()
        value.insecureSsl = try reader["InsecureSsl"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectEnvironment {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectEnvironment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Certificate"].write(value.certificate)
        try writer["EnvironmentVariables"].writeList(value.environmentVariables, memberWritingClosure: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ImagePullCredentialsType"].write(value.imagePullCredentialsType)
        try writer["PrivilegedMode"].write(value.privilegedMode)
        try writer["RegistryCredential"].write(value.registryCredential, with: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectEnvironment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectEnvironment()
        value.certificate = try reader["Certificate"].readIfPresent()
        value.environmentVariables = try reader["EnvironmentVariables"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.privilegedMode = try reader["PrivilegedMode"].readIfPresent()
        value.imagePullCredentialsType = try reader["ImagePullCredentialsType"].readIfPresent()
        value.registryCredential = try reader["RegistryCredential"].readIfPresent(with: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential.read(from:))
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Credential"].write(value.credential)
        try writer["CredentialProvider"].write(value.credentialProvider)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential()
        value.credential = try reader["Credential"].readIfPresent()
        value.credentialProvider = try reader["CredentialProvider"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {

    static func write(value: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZones"].writeList(value.availabilityZones, memberWritingClosure: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CapacityRebalance"].write(value.capacityRebalance)
        try writer["CreatedTime"].write(value.createdTime)
        try writer["HealthCheckGracePeriod"].write(value.healthCheckGracePeriod)
        try writer["HealthCheckType"].write(value.healthCheckType)
        try writer["LaunchConfigurationName"].write(value.launchConfigurationName)
        try writer["LaunchTemplate"].write(value.launchTemplate, with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification.write(value:to:))
        try writer["LoadBalancerNames"].writeList(value.loadBalancerNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MixedInstancesPolicy"].write(value.mixedInstancesPolicy, with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails()
        value.launchConfigurationName = try reader["LaunchConfigurationName"].readIfPresent()
        value.loadBalancerNames = try reader["LoadBalancerNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.healthCheckType = try reader["HealthCheckType"].readIfPresent()
        value.healthCheckGracePeriod = try reader["HealthCheckGracePeriod"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readIfPresent()
        value.mixedInstancesPolicy = try reader["MixedInstancesPolicy"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails.read(from:))
        value.availabilityZones = try reader["AvailabilityZones"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.launchTemplate = try reader["LaunchTemplate"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification.read(from:))
        value.capacityRebalance = try reader["CapacityRebalance"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LaunchTemplateId"].write(value.launchTemplateId)
        try writer["LaunchTemplateName"].write(value.launchTemplateName)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification()
        value.launchTemplateId = try reader["LaunchTemplateId"].readIfPresent()
        value.launchTemplateName = try reader["LaunchTemplateName"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstancesDistribution"].write(value.instancesDistribution, with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails.write(value:to:))
        try writer["LaunchTemplate"].write(value.launchTemplate, with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails()
        value.instancesDistribution = try reader["InstancesDistribution"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails.read(from:))
        value.launchTemplate = try reader["LaunchTemplate"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LaunchTemplateSpecification"].write(value.launchTemplateSpecification, with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification.write(value:to:))
        try writer["Overrides"].writeList(value.overrides, memberWritingClosure: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails()
        value.launchTemplateSpecification = try reader["LaunchTemplateSpecification"].readIfPresent(with: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification.read(from:))
        value.overrides = try reader["Overrides"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceType"].write(value.instanceType)
        try writer["WeightedCapacity"].write(value.weightedCapacity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.weightedCapacity = try reader["WeightedCapacity"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LaunchTemplateId"].write(value.launchTemplateId)
        try writer["LaunchTemplateName"].write(value.launchTemplateName)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification()
        value.launchTemplateId = try reader["LaunchTemplateId"].readIfPresent()
        value.launchTemplateName = try reader["LaunchTemplateName"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails {

    static func write(value: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OnDemandAllocationStrategy"].write(value.onDemandAllocationStrategy)
        try writer["OnDemandBaseCapacity"].write(value.onDemandBaseCapacity)
        try writer["OnDemandPercentageAboveBaseCapacity"].write(value.onDemandPercentageAboveBaseCapacity)
        try writer["SpotAllocationStrategy"].write(value.spotAllocationStrategy)
        try writer["SpotInstancePools"].write(value.spotInstancePools)
        try writer["SpotMaxPrice"].write(value.spotMaxPrice)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails()
        value.onDemandAllocationStrategy = try reader["OnDemandAllocationStrategy"].readIfPresent()
        value.onDemandBaseCapacity = try reader["OnDemandBaseCapacity"].readIfPresent()
        value.onDemandPercentageAboveBaseCapacity = try reader["OnDemandPercentageAboveBaseCapacity"].readIfPresent()
        value.spotAllocationStrategy = try reader["SpotAllocationStrategy"].readIfPresent()
        value.spotInstancePools = try reader["SpotInstancePools"].readIfPresent()
        value.spotMaxPrice = try reader["SpotMaxPrice"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.DataClassificationDetails {

    static func write(value: SecurityHubClientTypes.DataClassificationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DetailedResultsLocation"].write(value.detailedResultsLocation)
        try writer["Result"].write(value.result, with: SecurityHubClientTypes.ClassificationResult.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.DataClassificationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.DataClassificationDetails()
        value.detailedResultsLocation = try reader["DetailedResultsLocation"].readIfPresent()
        value.result = try reader["Result"].readIfPresent(with: SecurityHubClientTypes.ClassificationResult.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.ClassificationResult {

    static func write(value: SecurityHubClientTypes.ClassificationResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalOccurrences"].write(value.additionalOccurrences)
        try writer["CustomDataIdentifiers"].write(value.customDataIdentifiers, with: SecurityHubClientTypes.CustomDataIdentifiersResult.write(value:to:))
        try writer["MimeType"].write(value.mimeType)
        try writer["SensitiveData"].writeList(value.sensitiveData, memberWritingClosure: SecurityHubClientTypes.SensitiveDataResult.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SizeClassified"].write(value.sizeClassified)
        try writer["Status"].write(value.status, with: SecurityHubClientTypes.ClassificationStatus.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ClassificationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ClassificationResult()
        value.mimeType = try reader["MimeType"].readIfPresent()
        value.sizeClassified = try reader["SizeClassified"].readIfPresent()
        value.additionalOccurrences = try reader["AdditionalOccurrences"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: SecurityHubClientTypes.ClassificationStatus.read(from:))
        value.sensitiveData = try reader["SensitiveData"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.SensitiveDataResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customDataIdentifiers = try reader["CustomDataIdentifiers"].readIfPresent(with: SecurityHubClientTypes.CustomDataIdentifiersResult.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.CustomDataIdentifiersResult {

    static func write(value: SecurityHubClientTypes.CustomDataIdentifiersResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Detections"].writeList(value.detections, memberWritingClosure: SecurityHubClientTypes.CustomDataIdentifiersDetections.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TotalCount"].write(value.totalCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.CustomDataIdentifiersResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.CustomDataIdentifiersResult()
        value.detections = try reader["Detections"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.CustomDataIdentifiersDetections.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.CustomDataIdentifiersDetections {

    static func write(value: SecurityHubClientTypes.CustomDataIdentifiersDetections?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Count"].write(value.count)
        try writer["Name"].write(value.name)
        try writer["Occurrences"].write(value.occurrences, with: SecurityHubClientTypes.Occurrences.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.CustomDataIdentifiersDetections {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.CustomDataIdentifiersDetections()
        value.count = try reader["Count"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.occurrences = try reader["Occurrences"].readIfPresent(with: SecurityHubClientTypes.Occurrences.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.Occurrences {

    static func write(value: SecurityHubClientTypes.Occurrences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cells"].writeList(value.cells, memberWritingClosure: SecurityHubClientTypes.Cell.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LineRanges"].writeList(value.lineRanges, memberWritingClosure: SecurityHubClientTypes.Range.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OffsetRanges"].writeList(value.offsetRanges, memberWritingClosure: SecurityHubClientTypes.Range.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Pages"].writeList(value.pages, memberWritingClosure: SecurityHubClientTypes.Page.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Records"].writeList(value.records, memberWritingClosure: SecurityHubClientTypes.Record.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Occurrences {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Occurrences()
        value.lineRanges = try reader["LineRanges"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Range.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.offsetRanges = try reader["OffsetRanges"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Range.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.pages = try reader["Pages"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Page.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.records = try reader["Records"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Record.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cells = try reader["Cells"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.Cell.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.Cell {

    static func write(value: SecurityHubClientTypes.Cell?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CellReference"].write(value.cellReference)
        try writer["Column"].write(value.column)
        try writer["ColumnName"].write(value.columnName)
        try writer["Row"].write(value.row)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Cell {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Cell()
        value.column = try reader["Column"].readIfPresent()
        value.row = try reader["Row"].readIfPresent()
        value.columnName = try reader["ColumnName"].readIfPresent()
        value.cellReference = try reader["CellReference"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Record {

    static func write(value: SecurityHubClientTypes.Record?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JsonPath"].write(value.jsonPath)
        try writer["RecordIndex"].write(value.recordIndex)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Record {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Record()
        value.jsonPath = try reader["JsonPath"].readIfPresent()
        value.recordIndex = try reader["RecordIndex"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Page {

    static func write(value: SecurityHubClientTypes.Page?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LineRange"].write(value.lineRange, with: SecurityHubClientTypes.Range.write(value:to:))
        try writer["OffsetRange"].write(value.offsetRange, with: SecurityHubClientTypes.Range.write(value:to:))
        try writer["PageNumber"].write(value.pageNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Page {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Page()
        value.pageNumber = try reader["PageNumber"].readIfPresent()
        value.lineRange = try reader["LineRange"].readIfPresent(with: SecurityHubClientTypes.Range.read(from:))
        value.offsetRange = try reader["OffsetRange"].readIfPresent(with: SecurityHubClientTypes.Range.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.Range {

    static func write(value: SecurityHubClientTypes.Range?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["End"].write(value.end)
        try writer["Start"].write(value.start)
        try writer["StartColumn"].write(value.startColumn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Range {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Range()
        value.start = try reader["Start"].readIfPresent()
        value.end = try reader["End"].readIfPresent()
        value.startColumn = try reader["StartColumn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.SensitiveDataResult {

    static func write(value: SecurityHubClientTypes.SensitiveDataResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
        try writer["Detections"].writeList(value.detections, memberWritingClosure: SecurityHubClientTypes.SensitiveDataDetections.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TotalCount"].write(value.totalCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SensitiveDataResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SensitiveDataResult()
        value.category = try reader["Category"].readIfPresent()
        value.detections = try reader["Detections"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.SensitiveDataDetections.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalCount = try reader["TotalCount"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.SensitiveDataDetections {

    static func write(value: SecurityHubClientTypes.SensitiveDataDetections?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Count"].write(value.count)
        try writer["Occurrences"].write(value.occurrences, with: SecurityHubClientTypes.Occurrences.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SensitiveDataDetections {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SensitiveDataDetections()
        value.count = try reader["Count"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.occurrences = try reader["Occurrences"].readIfPresent(with: SecurityHubClientTypes.Occurrences.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.ClassificationStatus {

    static func write(value: SecurityHubClientTypes.ClassificationStatus?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
        try writer["Reason"].write(value.reason)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ClassificationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ClassificationStatus()
        value.code = try reader["Code"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ThreatIntelIndicator {

    static func write(value: SecurityHubClientTypes.ThreatIntelIndicator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Category"].write(value.category)
        try writer["LastObservedAt"].write(value.lastObservedAt)
        try writer["Source"].write(value.source)
        try writer["SourceUrl"].write(value.sourceUrl)
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ThreatIntelIndicator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ThreatIntelIndicator()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.category = try reader["Category"].readIfPresent()
        value.lastObservedAt = try reader["LastObservedAt"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.sourceUrl = try reader["SourceUrl"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Threat {

    static func write(value: SecurityHubClientTypes.Threat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FilePaths"].writeList(value.filePaths, memberWritingClosure: SecurityHubClientTypes.FilePaths.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ItemCount"].write(value.itemCount)
        try writer["Name"].write(value.name)
        try writer["Severity"].write(value.severity)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Threat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Threat()
        value.name = try reader["Name"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.itemCount = try reader["ItemCount"].readIfPresent()
        value.filePaths = try reader["FilePaths"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.FilePaths.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.FilePaths {

    static func write(value: SecurityHubClientTypes.FilePaths?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FileName"].write(value.fileName)
        try writer["FilePath"].write(value.filePath)
        try writer["Hash"].write(value.hash)
        try writer["ResourceId"].write(value.resourceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FilePaths {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FilePaths()
        value.filePath = try reader["FilePath"].readIfPresent()
        value.fileName = try reader["FileName"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.hash = try reader["Hash"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ProcessDetails {

    static func write(value: SecurityHubClientTypes.ProcessDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LaunchedAt"].write(value.launchedAt)
        try writer["Name"].write(value.name)
        try writer["ParentPid"].write(value.parentPid)
        try writer["Path"].write(value.path)
        try writer["Pid"].write(value.pid)
        try writer["TerminatedAt"].write(value.terminatedAt)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ProcessDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ProcessDetails()
        value.name = try reader["Name"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.pid = try reader["Pid"].readIfPresent()
        value.parentPid = try reader["ParentPid"].readIfPresent()
        value.launchedAt = try reader["LaunchedAt"].readIfPresent()
        value.terminatedAt = try reader["TerminatedAt"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.NetworkPathComponent {

    static func write(value: SecurityHubClientTypes.NetworkPathComponent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComponentId"].write(value.componentId)
        try writer["ComponentType"].write(value.componentType)
        try writer["Egress"].write(value.egress, with: SecurityHubClientTypes.NetworkHeader.write(value:to:))
        try writer["Ingress"].write(value.ingress, with: SecurityHubClientTypes.NetworkHeader.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.NetworkPathComponent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.NetworkPathComponent()
        value.componentId = try reader["ComponentId"].readIfPresent()
        value.componentType = try reader["ComponentType"].readIfPresent()
        value.egress = try reader["Egress"].readIfPresent(with: SecurityHubClientTypes.NetworkHeader.read(from:))
        value.ingress = try reader["Ingress"].readIfPresent(with: SecurityHubClientTypes.NetworkHeader.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.NetworkHeader {

    static func write(value: SecurityHubClientTypes.NetworkHeader?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination, with: SecurityHubClientTypes.NetworkPathComponentDetails.write(value:to:))
        try writer["Protocol"].write(value.`protocol`)
        try writer["Source"].write(value.source, with: SecurityHubClientTypes.NetworkPathComponentDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.NetworkHeader {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.NetworkHeader()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.destination = try reader["Destination"].readIfPresent(with: SecurityHubClientTypes.NetworkPathComponentDetails.read(from:))
        value.source = try reader["Source"].readIfPresent(with: SecurityHubClientTypes.NetworkPathComponentDetails.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.NetworkPathComponentDetails {

    static func write(value: SecurityHubClientTypes.NetworkPathComponentDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].writeList(value.address, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PortRanges"].writeList(value.portRanges, memberWritingClosure: SecurityHubClientTypes.PortRange.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.NetworkPathComponentDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.NetworkPathComponentDetails()
        value.address = try reader["Address"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.portRanges = try reader["PortRanges"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.PortRange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.PortRange {

    static func write(value: SecurityHubClientTypes.PortRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Begin"].write(value.begin)
        try writer["End"].write(value.end)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.PortRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.PortRange()
        value.begin = try reader["Begin"].readIfPresent()
        value.end = try reader["End"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Network {

    static func write(value: SecurityHubClientTypes.Network?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationDomain"].write(value.destinationDomain)
        try writer["DestinationIpV4"].write(value.destinationIpV4)
        try writer["DestinationIpV6"].write(value.destinationIpV6)
        try writer["DestinationPort"].write(value.destinationPort)
        try writer["Direction"].write(value.direction)
        try writer["OpenPortRange"].write(value.openPortRange, with: SecurityHubClientTypes.PortRange.write(value:to:))
        try writer["Protocol"].write(value.`protocol`)
        try writer["SourceDomain"].write(value.sourceDomain)
        try writer["SourceIpV4"].write(value.sourceIpV4)
        try writer["SourceIpV6"].write(value.sourceIpV6)
        try writer["SourceMac"].write(value.sourceMac)
        try writer["SourcePort"].write(value.sourcePort)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Network {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Network()
        value.direction = try reader["Direction"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.openPortRange = try reader["OpenPortRange"].readIfPresent(with: SecurityHubClientTypes.PortRange.read(from:))
        value.sourceIpV4 = try reader["SourceIpV4"].readIfPresent()
        value.sourceIpV6 = try reader["SourceIpV6"].readIfPresent()
        value.sourcePort = try reader["SourcePort"].readIfPresent()
        value.sourceDomain = try reader["SourceDomain"].readIfPresent()
        value.sourceMac = try reader["SourceMac"].readIfPresent()
        value.destinationIpV4 = try reader["DestinationIpV4"].readIfPresent()
        value.destinationIpV6 = try reader["DestinationIpV6"].readIfPresent()
        value.destinationPort = try reader["DestinationPort"].readIfPresent()
        value.destinationDomain = try reader["DestinationDomain"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Malware {

    static func write(value: SecurityHubClientTypes.Malware?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Path"].write(value.path)
        try writer["State"].write(value.state)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Malware {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Malware()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Remediation {

    static func write(value: SecurityHubClientTypes.Remediation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Recommendation"].write(value.recommendation, with: SecurityHubClientTypes.Recommendation.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Remediation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Remediation()
        value.recommendation = try reader["Recommendation"].readIfPresent(with: SecurityHubClientTypes.Recommendation.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.Recommendation {

    static func write(value: SecurityHubClientTypes.Recommendation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Text"].write(value.text)
        try writer["Url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Recommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Recommendation()
        value.text = try reader["Text"].readIfPresent()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Severity {

    static func write(value: SecurityHubClientTypes.Severity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Label"].write(value.label)
        try writer["Normalized"].write(value.normalized)
        try writer["Original"].write(value.original)
        try writer["Product"].write(value.product)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Severity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Severity()
        value.product = try reader["Product"].readIfPresent()
        value.label = try reader["Label"].readIfPresent()
        value.normalized = try reader["Normalized"].readIfPresent()
        value.original = try reader["Original"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.InsightResults {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.InsightResults {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.InsightResults()
        value.insightArn = try reader["InsightArn"].readIfPresent() ?? ""
        value.groupByAttribute = try reader["GroupByAttribute"].readIfPresent() ?? ""
        value.resultValues = try reader["ResultValues"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.InsightResultValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SecurityHubClientTypes.InsightResultValue {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.InsightResultValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.InsightResultValue()
        value.groupByAttributeValue = try reader["GroupByAttributeValue"].readIfPresent() ?? ""
        value.count = try reader["Count"].readIfPresent() ?? 0
        return value
    }
}

extension SecurityHubClientTypes.Insight {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Insight {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Insight()
        value.insightArn = try reader["InsightArn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.filters = try reader["Filters"].readIfPresent(with: SecurityHubClientTypes.AwsSecurityFindingFilters.read(from:))
        value.groupByAttribute = try reader["GroupByAttribute"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityHubClientTypes.AwsSecurityFindingFilters {

    static func write(value: SecurityHubClientTypes.AwsSecurityFindingFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsAccountId"].writeList(value.awsAccountId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AwsAccountName"].writeList(value.awsAccountName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CompanyName"].writeList(value.companyName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceAssociatedStandardsId"].writeList(value.complianceAssociatedStandardsId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceSecurityControlId"].writeList(value.complianceSecurityControlId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceSecurityControlParametersName"].writeList(value.complianceSecurityControlParametersName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceSecurityControlParametersValue"].writeList(value.complianceSecurityControlParametersValue, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ComplianceStatus"].writeList(value.complianceStatus, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Confidence"].writeList(value.confidence, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreatedAt"].writeList(value.createdAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Criticality"].writeList(value.criticality, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].writeList(value.description, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FindingProviderFieldsConfidence"].writeList(value.findingProviderFieldsConfidence, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FindingProviderFieldsCriticality"].writeList(value.findingProviderFieldsCriticality, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FindingProviderFieldsRelatedFindingsId"].writeList(value.findingProviderFieldsRelatedFindingsId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FindingProviderFieldsRelatedFindingsProductArn"].writeList(value.findingProviderFieldsRelatedFindingsProductArn, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FindingProviderFieldsSeverityLabel"].writeList(value.findingProviderFieldsSeverityLabel, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FindingProviderFieldsSeverityOriginal"].writeList(value.findingProviderFieldsSeverityOriginal, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FindingProviderFieldsTypes"].writeList(value.findingProviderFieldsTypes, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FirstObservedAt"].writeList(value.firstObservedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["GeneratorId"].writeList(value.generatorId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Id"].writeList(value.id, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Keyword"].writeList(value.keyword, memberWritingClosure: SecurityHubClientTypes.KeywordFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LastObservedAt"].writeList(value.lastObservedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MalwareName"].writeList(value.malwareName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MalwarePath"].writeList(value.malwarePath, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MalwareState"].writeList(value.malwareState, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MalwareType"].writeList(value.malwareType, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkDestinationDomain"].writeList(value.networkDestinationDomain, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkDestinationIpV4"].writeList(value.networkDestinationIpV4, memberWritingClosure: SecurityHubClientTypes.IpFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkDestinationIpV6"].writeList(value.networkDestinationIpV6, memberWritingClosure: SecurityHubClientTypes.IpFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkDestinationPort"].writeList(value.networkDestinationPort, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkDirection"].writeList(value.networkDirection, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkProtocol"].writeList(value.networkProtocol, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkSourceDomain"].writeList(value.networkSourceDomain, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkSourceIpV4"].writeList(value.networkSourceIpV4, memberWritingClosure: SecurityHubClientTypes.IpFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkSourceIpV6"].writeList(value.networkSourceIpV6, memberWritingClosure: SecurityHubClientTypes.IpFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkSourceMac"].writeList(value.networkSourceMac, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkSourcePort"].writeList(value.networkSourcePort, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NoteText"].writeList(value.noteText, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NoteUpdatedAt"].writeList(value.noteUpdatedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NoteUpdatedBy"].writeList(value.noteUpdatedBy, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProcessLaunchedAt"].writeList(value.processLaunchedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProcessName"].writeList(value.processName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProcessParentPid"].writeList(value.processParentPid, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProcessPath"].writeList(value.processPath, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProcessPid"].writeList(value.processPid, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProcessTerminatedAt"].writeList(value.processTerminatedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProductArn"].writeList(value.productArn, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProductFields"].writeList(value.productFields, memberWritingClosure: SecurityHubClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProductName"].writeList(value.productName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecommendationText"].writeList(value.recommendationText, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecordState"].writeList(value.recordState, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Region"].writeList(value.region, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RelatedFindingsId"].writeList(value.relatedFindingsId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RelatedFindingsProductArn"].writeList(value.relatedFindingsProductArn, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceApplicationArn"].writeList(value.resourceApplicationArn, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceApplicationName"].writeList(value.resourceApplicationName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsEc2InstanceIamInstanceProfileArn"].writeList(value.resourceAwsEc2InstanceIamInstanceProfileArn, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsEc2InstanceImageId"].writeList(value.resourceAwsEc2InstanceImageId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsEc2InstanceIpV4Addresses"].writeList(value.resourceAwsEc2InstanceIpV4Addresses, memberWritingClosure: SecurityHubClientTypes.IpFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsEc2InstanceIpV6Addresses"].writeList(value.resourceAwsEc2InstanceIpV6Addresses, memberWritingClosure: SecurityHubClientTypes.IpFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsEc2InstanceKeyName"].writeList(value.resourceAwsEc2InstanceKeyName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsEc2InstanceLaunchedAt"].writeList(value.resourceAwsEc2InstanceLaunchedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsEc2InstanceSubnetId"].writeList(value.resourceAwsEc2InstanceSubnetId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsEc2InstanceType"].writeList(value.resourceAwsEc2InstanceType, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsEc2InstanceVpcId"].writeList(value.resourceAwsEc2InstanceVpcId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsIamAccessKeyCreatedAt"].writeList(value.resourceAwsIamAccessKeyCreatedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsIamAccessKeyPrincipalName"].writeList(value.resourceAwsIamAccessKeyPrincipalName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsIamAccessKeyStatus"].writeList(value.resourceAwsIamAccessKeyStatus, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsIamAccessKeyUserName"].writeList(value.resourceAwsIamAccessKeyUserName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsIamUserUserName"].writeList(value.resourceAwsIamUserUserName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsS3BucketOwnerId"].writeList(value.resourceAwsS3BucketOwnerId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceAwsS3BucketOwnerName"].writeList(value.resourceAwsS3BucketOwnerName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceContainerImageId"].writeList(value.resourceContainerImageId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceContainerImageName"].writeList(value.resourceContainerImageName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceContainerLaunchedAt"].writeList(value.resourceContainerLaunchedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceContainerName"].writeList(value.resourceContainerName, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceDetailsOther"].writeList(value.resourceDetailsOther, memberWritingClosure: SecurityHubClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceId"].writeList(value.resourceId, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourcePartition"].writeList(value.resourcePartition, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceRegion"].writeList(value.resourceRegion, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: SecurityHubClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].writeList(value.resourceType, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sample"].writeList(value.sample, memberWritingClosure: SecurityHubClientTypes.BooleanFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SeverityLabel"].writeList(value.severityLabel, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SeverityNormalized"].writeList(value.severityNormalized, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SeverityProduct"].writeList(value.severityProduct, memberWritingClosure: SecurityHubClientTypes.NumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceUrl"].writeList(value.sourceUrl, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThreatIntelIndicatorCategory"].writeList(value.threatIntelIndicatorCategory, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThreatIntelIndicatorLastObservedAt"].writeList(value.threatIntelIndicatorLastObservedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThreatIntelIndicatorSource"].writeList(value.threatIntelIndicatorSource, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThreatIntelIndicatorSourceUrl"].writeList(value.threatIntelIndicatorSourceUrl, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThreatIntelIndicatorType"].writeList(value.threatIntelIndicatorType, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ThreatIntelIndicatorValue"].writeList(value.threatIntelIndicatorValue, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Title"].writeList(value.title, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].writeList(value.type, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UpdatedAt"].writeList(value.updatedAt, memberWritingClosure: SecurityHubClientTypes.DateFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserDefinedFields"].writeList(value.userDefinedFields, memberWritingClosure: SecurityHubClientTypes.MapFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VerificationState"].writeList(value.verificationState, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VulnerabilitiesExploitAvailable"].writeList(value.vulnerabilitiesExploitAvailable, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VulnerabilitiesFixAvailable"].writeList(value.vulnerabilitiesFixAvailable, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkflowState"].writeList(value.workflowState, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkflowStatus"].writeList(value.workflowStatus, memberWritingClosure: SecurityHubClientTypes.StringFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AwsSecurityFindingFilters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AwsSecurityFindingFilters()
        value.productArn = try reader["ProductArn"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsAccountId = try reader["AwsAccountId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.generatorId = try reader["GeneratorId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.region = try reader["Region"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.firstObservedAt = try reader["FirstObservedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastObservedAt = try reader["LastObservedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.severityProduct = try reader["SeverityProduct"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.severityNormalized = try reader["SeverityNormalized"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.severityLabel = try reader["SeverityLabel"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.confidence = try reader["Confidence"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.criticality = try reader["Criticality"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.title = try reader["Title"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["Description"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recommendationText = try reader["RecommendationText"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sourceUrl = try reader["SourceUrl"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.productFields = try reader["ProductFields"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.MapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.productName = try reader["ProductName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.companyName = try reader["CompanyName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.userDefinedFields = try reader["UserDefinedFields"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.MapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.malwareName = try reader["MalwareName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.malwareType = try reader["MalwareType"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.malwarePath = try reader["MalwarePath"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.malwareState = try reader["MalwareState"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkDirection = try reader["NetworkDirection"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkProtocol = try reader["NetworkProtocol"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkSourceIpV4 = try reader["NetworkSourceIpV4"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.IpFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkSourceIpV6 = try reader["NetworkSourceIpV6"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.IpFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkSourcePort = try reader["NetworkSourcePort"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkSourceDomain = try reader["NetworkSourceDomain"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkSourceMac = try reader["NetworkSourceMac"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkDestinationIpV4 = try reader["NetworkDestinationIpV4"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.IpFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkDestinationIpV6 = try reader["NetworkDestinationIpV6"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.IpFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkDestinationPort = try reader["NetworkDestinationPort"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.networkDestinationDomain = try reader["NetworkDestinationDomain"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.processName = try reader["ProcessName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.processPath = try reader["ProcessPath"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.processPid = try reader["ProcessPid"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.processParentPid = try reader["ProcessParentPid"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.processLaunchedAt = try reader["ProcessLaunchedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.processTerminatedAt = try reader["ProcessTerminatedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.threatIntelIndicatorType = try reader["ThreatIntelIndicatorType"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.threatIntelIndicatorValue = try reader["ThreatIntelIndicatorValue"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.threatIntelIndicatorCategory = try reader["ThreatIntelIndicatorCategory"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.threatIntelIndicatorLastObservedAt = try reader["ThreatIntelIndicatorLastObservedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.threatIntelIndicatorSource = try reader["ThreatIntelIndicatorSource"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.threatIntelIndicatorSourceUrl = try reader["ThreatIntelIndicatorSourceUrl"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceId = try reader["ResourceId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourcePartition = try reader["ResourcePartition"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceRegion = try reader["ResourceRegion"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.MapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsEc2InstanceType = try reader["ResourceAwsEc2InstanceType"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsEc2InstanceImageId = try reader["ResourceAwsEc2InstanceImageId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsEc2InstanceIpV4Addresses = try reader["ResourceAwsEc2InstanceIpV4Addresses"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.IpFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsEc2InstanceIpV6Addresses = try reader["ResourceAwsEc2InstanceIpV6Addresses"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.IpFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsEc2InstanceKeyName = try reader["ResourceAwsEc2InstanceKeyName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsEc2InstanceIamInstanceProfileArn = try reader["ResourceAwsEc2InstanceIamInstanceProfileArn"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsEc2InstanceVpcId = try reader["ResourceAwsEc2InstanceVpcId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsEc2InstanceSubnetId = try reader["ResourceAwsEc2InstanceSubnetId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsEc2InstanceLaunchedAt = try reader["ResourceAwsEc2InstanceLaunchedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsS3BucketOwnerId = try reader["ResourceAwsS3BucketOwnerId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsS3BucketOwnerName = try reader["ResourceAwsS3BucketOwnerName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsIamAccessKeyUserName = try reader["ResourceAwsIamAccessKeyUserName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsIamAccessKeyPrincipalName = try reader["ResourceAwsIamAccessKeyPrincipalName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsIamAccessKeyStatus = try reader["ResourceAwsIamAccessKeyStatus"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsIamAccessKeyCreatedAt = try reader["ResourceAwsIamAccessKeyCreatedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceAwsIamUserUserName = try reader["ResourceAwsIamUserUserName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceContainerName = try reader["ResourceContainerName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceContainerImageId = try reader["ResourceContainerImageId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceContainerImageName = try reader["ResourceContainerImageName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceContainerLaunchedAt = try reader["ResourceContainerLaunchedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceDetailsOther = try reader["ResourceDetailsOther"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.MapFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.complianceStatus = try reader["ComplianceStatus"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.verificationState = try reader["VerificationState"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workflowState = try reader["WorkflowState"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workflowStatus = try reader["WorkflowStatus"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recordState = try reader["RecordState"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedFindingsProductArn = try reader["RelatedFindingsProductArn"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedFindingsId = try reader["RelatedFindingsId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.noteText = try reader["NoteText"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.noteUpdatedAt = try reader["NoteUpdatedAt"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.DateFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.noteUpdatedBy = try reader["NoteUpdatedBy"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.keyword = try reader["Keyword"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.KeywordFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingProviderFieldsConfidence = try reader["FindingProviderFieldsConfidence"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingProviderFieldsCriticality = try reader["FindingProviderFieldsCriticality"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.NumberFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingProviderFieldsRelatedFindingsId = try reader["FindingProviderFieldsRelatedFindingsId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingProviderFieldsRelatedFindingsProductArn = try reader["FindingProviderFieldsRelatedFindingsProductArn"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingProviderFieldsSeverityLabel = try reader["FindingProviderFieldsSeverityLabel"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingProviderFieldsSeverityOriginal = try reader["FindingProviderFieldsSeverityOriginal"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.findingProviderFieldsTypes = try reader["FindingProviderFieldsTypes"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sample = try reader["Sample"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.BooleanFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.complianceSecurityControlId = try reader["ComplianceSecurityControlId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.complianceAssociatedStandardsId = try reader["ComplianceAssociatedStandardsId"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vulnerabilitiesExploitAvailable = try reader["VulnerabilitiesExploitAvailable"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vulnerabilitiesFixAvailable = try reader["VulnerabilitiesFixAvailable"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.complianceSecurityControlParametersName = try reader["ComplianceSecurityControlParametersName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.complianceSecurityControlParametersValue = try reader["ComplianceSecurityControlParametersValue"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsAccountName = try reader["AwsAccountName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceApplicationName = try reader["ResourceApplicationName"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceApplicationArn = try reader["ResourceApplicationArn"].readListIfPresent(memberReadingClosure: SecurityHubClientTypes.StringFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.BooleanFilter {

    static func write(value: SecurityHubClientTypes.BooleanFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.BooleanFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.BooleanFilter()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.KeywordFilter {

    static func write(value: SecurityHubClientTypes.KeywordFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.KeywordFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.KeywordFilter()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.IpFilter {

    static func write(value: SecurityHubClientTypes.IpFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cidr"].write(value.cidr)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.IpFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.IpFilter()
        value.cidr = try reader["Cidr"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.Member {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.Member {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.Member()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.masterId = try reader["MasterId"].readIfPresent()
        value.administratorId = try reader["AdministratorId"].readIfPresent()
        value.memberStatus = try reader["MemberStatus"].readIfPresent()
        value.invitedAt = try reader["InvitedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension SecurityHubClientTypes.SecurityControlDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.SecurityControlDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.SecurityControlDefinition()
        value.securityControlId = try reader["SecurityControlId"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.remediationUrl = try reader["RemediationUrl"].readIfPresent() ?? ""
        value.severityRating = try reader["SeverityRating"].readIfPresent() ?? .sdkUnknown("")
        value.currentRegionAvailability = try reader["CurrentRegionAvailability"].readIfPresent() ?? .sdkUnknown("")
        value.customizableProperties = try reader["CustomizableProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SecurityHubClientTypes.SecurityControlProperty>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.parameterDefinitions = try reader["ParameterDefinitions"].readMapIfPresent(valueReadingClosure: SecurityHubClientTypes.ParameterDefinition.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.ParameterDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ParameterDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ParameterDefinition()
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.configurationOptions = try reader["ConfigurationOptions"].readIfPresent(with: SecurityHubClientTypes.ConfigurationOptions.read(from:))
        return value
    }
}

extension SecurityHubClientTypes.ConfigurationOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ConfigurationOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Integer":
                return .integer(try reader["Integer"].read(with: SecurityHubClientTypes.IntegerConfigurationOptions.read(from:)))
            case "IntegerList":
                return .integerlist(try reader["IntegerList"].read(with: SecurityHubClientTypes.IntegerListConfigurationOptions.read(from:)))
            case "Double":
                return .double(try reader["Double"].read(with: SecurityHubClientTypes.DoubleConfigurationOptions.read(from:)))
            case "String":
                return .string(try reader["String"].read(with: SecurityHubClientTypes.StringConfigurationOptions.read(from:)))
            case "StringList":
                return .stringlist(try reader["StringList"].read(with: SecurityHubClientTypes.StringListConfigurationOptions.read(from:)))
            case "Boolean":
                return .boolean(try reader["Boolean"].read(with: SecurityHubClientTypes.BooleanConfigurationOptions.read(from:)))
            case "Enum":
                return .`enum`(try reader["Enum"].read(with: SecurityHubClientTypes.EnumConfigurationOptions.read(from:)))
            case "EnumList":
                return .enumlist(try reader["EnumList"].read(with: SecurityHubClientTypes.EnumListConfigurationOptions.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SecurityHubClientTypes.EnumListConfigurationOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.EnumListConfigurationOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.EnumListConfigurationOptions()
        value.defaultValue = try reader["DefaultValue"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxItems = try reader["MaxItems"].readIfPresent()
        value.allowedValues = try reader["AllowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.EnumConfigurationOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.EnumConfigurationOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.EnumConfigurationOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.allowedValues = try reader["AllowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SecurityHubClientTypes.BooleanConfigurationOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.BooleanConfigurationOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.BooleanConfigurationOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StringListConfigurationOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StringListConfigurationOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StringListConfigurationOptions()
        value.defaultValue = try reader["DefaultValue"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.re2Expression = try reader["Re2Expression"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent()
        value.expressionDescription = try reader["ExpressionDescription"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StringConfigurationOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StringConfigurationOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StringConfigurationOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.re2Expression = try reader["Re2Expression"].readIfPresent()
        value.expressionDescription = try reader["ExpressionDescription"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.DoubleConfigurationOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.DoubleConfigurationOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.DoubleConfigurationOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        value.max = try reader["Max"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.IntegerListConfigurationOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.IntegerListConfigurationOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.IntegerListConfigurationOptions()
        value.defaultValue = try reader["DefaultValue"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        value.min = try reader["Min"].readIfPresent()
        value.max = try reader["Max"].readIfPresent()
        value.maxItems = try reader["MaxItems"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.IntegerConfigurationOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.IntegerConfigurationOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.IntegerConfigurationOptions()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.min = try reader["Min"].readIfPresent()
        value.max = try reader["Max"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AutomationRulesMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AutomationRulesMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AutomationRulesMetadata()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.ruleStatus = try reader["RuleStatus"].readIfPresent()
        value.ruleOrder = try reader["RuleOrder"].readIfPresent()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.isTerminal = try reader["IsTerminal"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.ConfigurationPolicySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.ConfigurationPolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.ConfigurationPolicySummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.serviceEnabled = try reader["ServiceEnabled"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.FindingAggregator {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.FindingAggregator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.FindingAggregator()
        value.findingAggregatorArn = try reader["FindingAggregatorArn"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.AdminAccount {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.AdminAccount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.AdminAccount()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StandardsControlAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityHubClientTypes.StandardsControlAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityHubClientTypes.StandardsControlAssociationSummary()
        value.standardsArn = try reader["StandardsArn"].readIfPresent() ?? ""
        value.securityControlId = try reader["SecurityControlId"].readIfPresent() ?? ""
        value.securityControlArn = try reader["SecurityControlArn"].readIfPresent() ?? ""
        value.associationStatus = try reader["AssociationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.relatedRequirements = try reader["RelatedRequirements"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedReason = try reader["UpdatedReason"].readIfPresent()
        value.standardsControlTitle = try reader["StandardsControlTitle"].readIfPresent()
        value.standardsControlDescription = try reader["StandardsControlDescription"].readIfPresent()
        return value
    }
}

extension SecurityHubClientTypes.StandardsSubscriptionRequest {

    static func write(value: SecurityHubClientTypes.StandardsSubscriptionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StandardsArn"].write(value.standardsArn)
        try writer["StandardsInput"].writeMap(value.standardsInput, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension SecurityHubClientTypes.UpdateAutomationRulesRequestItem {

    static func write(value: SecurityHubClientTypes.UpdateAutomationRulesRequestItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: SecurityHubClientTypes.AutomationRulesAction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Criteria"].write(value.criteria, with: SecurityHubClientTypes.AutomationRulesFindingFilters.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["IsTerminal"].write(value.isTerminal)
        try writer["RuleArn"].write(value.ruleArn)
        try writer["RuleName"].write(value.ruleName)
        try writer["RuleOrder"].write(value.ruleOrder)
        try writer["RuleStatus"].write(value.ruleStatus)
    }
}

extension SecurityHubClientTypes.AccountDetails {

    static func write(value: SecurityHubClientTypes.AccountDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Email"].write(value.email)
    }
}

extension SecurityHubClientTypes.SortCriterion {

    static func write(value: SecurityHubClientTypes.SortCriterion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Field"].write(value.field)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension SecurityHubClientTypes.AssociationFilters {

    static func write(value: SecurityHubClientTypes.AssociationFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociationStatus"].write(value.associationStatus)
        try writer["AssociationType"].write(value.associationType)
        try writer["ConfigurationPolicyId"].write(value.configurationPolicyId)
    }
}

public enum SecurityHubClientTypes {}
