// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SecurityHubClient {
    /// Paginate over `[DescribeActionTargetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeActionTargetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeActionTargetsOutput`
    public func describeActionTargetsPaginated(input: DescribeActionTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeActionTargetsInput, DescribeActionTargetsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeActionTargetsInput, DescribeActionTargetsOutput>(input: input, inputKey: \DescribeActionTargetsInput.nextToken, outputKey: \DescribeActionTargetsOutput.nextToken, paginationFunction: self.describeActionTargets(input:))
    }
}

extension DescribeActionTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeActionTargetsInput {
        return DescribeActionTargetsInput(
            actionTargetArns: self.actionTargetArns,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == DescribeActionTargetsInput, Output == DescribeActionTargetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeActionTargetsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.ActionTarget]`
    /// - Returns: `[SecurityHubClientTypes.ActionTarget]`
    public func actionTargets() async throws -> [SecurityHubClientTypes.ActionTarget] {
        return try await self.asyncCompactMap { item in item.actionTargets }
    }
}
extension SecurityHubClient {
    /// Paginate over `[DescribeProductsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeProductsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeProductsOutput`
    public func describeProductsPaginated(input: DescribeProductsInput) -> ClientRuntime.PaginatorSequence<DescribeProductsInput, DescribeProductsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeProductsInput, DescribeProductsOutput>(input: input, inputKey: \DescribeProductsInput.nextToken, outputKey: \DescribeProductsOutput.nextToken, paginationFunction: self.describeProducts(input:))
    }
}

extension DescribeProductsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeProductsInput {
        return DescribeProductsInput(
            maxResults: self.maxResults,
            nextToken: token,
            productArn: self.productArn
        )}
}

extension PaginatorSequence where Input == DescribeProductsInput, Output == DescribeProductsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeProductsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Product]`
    /// - Returns: `[SecurityHubClientTypes.Product]`
    public func products() async throws -> [SecurityHubClientTypes.Product] {
        return try await self.asyncCompactMap { item in item.products }
    }
}
extension SecurityHubClient {
    /// Paginate over `[DescribeStandardsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeStandardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeStandardsOutput`
    public func describeStandardsPaginated(input: DescribeStandardsInput) -> ClientRuntime.PaginatorSequence<DescribeStandardsInput, DescribeStandardsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeStandardsInput, DescribeStandardsOutput>(input: input, inputKey: \DescribeStandardsInput.nextToken, outputKey: \DescribeStandardsOutput.nextToken, paginationFunction: self.describeStandards(input:))
    }
}

extension DescribeStandardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeStandardsInput {
        return DescribeStandardsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == DescribeStandardsInput, Output == DescribeStandardsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeStandardsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Standard]`
    /// - Returns: `[SecurityHubClientTypes.Standard]`
    public func standards() async throws -> [SecurityHubClientTypes.Standard] {
        return try await self.asyncCompactMap { item in item.standards }
    }
}
extension SecurityHubClient {
    /// Paginate over `[DescribeStandardsControlsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeStandardsControlsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeStandardsControlsOutput`
    public func describeStandardsControlsPaginated(input: DescribeStandardsControlsInput) -> ClientRuntime.PaginatorSequence<DescribeStandardsControlsInput, DescribeStandardsControlsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeStandardsControlsInput, DescribeStandardsControlsOutput>(input: input, inputKey: \DescribeStandardsControlsInput.nextToken, outputKey: \DescribeStandardsControlsOutput.nextToken, paginationFunction: self.describeStandardsControls(input:))
    }
}

extension DescribeStandardsControlsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeStandardsControlsInput {
        return DescribeStandardsControlsInput(
            maxResults: self.maxResults,
            nextToken: token,
            standardsSubscriptionArn: self.standardsSubscriptionArn
        )}
}

extension PaginatorSequence where Input == DescribeStandardsControlsInput, Output == DescribeStandardsControlsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeStandardsControlsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.StandardsControl]`
    /// - Returns: `[SecurityHubClientTypes.StandardsControl]`
    public func controls() async throws -> [SecurityHubClientTypes.StandardsControl] {
        return try await self.asyncCompactMap { item in item.controls }
    }
}
extension SecurityHubClient {
    /// Paginate over `[GetEnabledStandardsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetEnabledStandardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetEnabledStandardsOutput`
    public func getEnabledStandardsPaginated(input: GetEnabledStandardsInput) -> ClientRuntime.PaginatorSequence<GetEnabledStandardsInput, GetEnabledStandardsOutput> {
        return ClientRuntime.PaginatorSequence<GetEnabledStandardsInput, GetEnabledStandardsOutput>(input: input, inputKey: \GetEnabledStandardsInput.nextToken, outputKey: \GetEnabledStandardsOutput.nextToken, paginationFunction: self.getEnabledStandards(input:))
    }
}

extension GetEnabledStandardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEnabledStandardsInput {
        return GetEnabledStandardsInput(
            maxResults: self.maxResults,
            nextToken: token,
            standardsSubscriptionArns: self.standardsSubscriptionArns
        )}
}

extension PaginatorSequence where Input == GetEnabledStandardsInput, Output == GetEnabledStandardsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getEnabledStandardsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.StandardsSubscription]`
    /// - Returns: `[SecurityHubClientTypes.StandardsSubscription]`
    public func standardsSubscriptions() async throws -> [SecurityHubClientTypes.StandardsSubscription] {
        return try await self.asyncCompactMap { item in item.standardsSubscriptions }
    }
}
extension SecurityHubClient {
    /// Paginate over `[GetFindingHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetFindingHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetFindingHistoryOutput`
    public func getFindingHistoryPaginated(input: GetFindingHistoryInput) -> ClientRuntime.PaginatorSequence<GetFindingHistoryInput, GetFindingHistoryOutput> {
        return ClientRuntime.PaginatorSequence<GetFindingHistoryInput, GetFindingHistoryOutput>(input: input, inputKey: \GetFindingHistoryInput.nextToken, outputKey: \GetFindingHistoryOutput.nextToken, paginationFunction: self.getFindingHistory(input:))
    }
}

extension GetFindingHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetFindingHistoryInput {
        return GetFindingHistoryInput(
            endTime: self.endTime,
            findingIdentifier: self.findingIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where Input == GetFindingHistoryInput, Output == GetFindingHistoryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getFindingHistoryPaginated`
    /// to access the nested member `[SecurityHubClientTypes.FindingHistoryRecord]`
    /// - Returns: `[SecurityHubClientTypes.FindingHistoryRecord]`
    public func records() async throws -> [SecurityHubClientTypes.FindingHistoryRecord] {
        return try await self.asyncCompactMap { item in item.records }
    }
}
extension SecurityHubClient {
    /// Paginate over `[GetFindingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetFindingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetFindingsOutput`
    public func getFindingsPaginated(input: GetFindingsInput) -> ClientRuntime.PaginatorSequence<GetFindingsInput, GetFindingsOutput> {
        return ClientRuntime.PaginatorSequence<GetFindingsInput, GetFindingsOutput>(input: input, inputKey: \GetFindingsInput.nextToken, outputKey: \GetFindingsOutput.nextToken, paginationFunction: self.getFindings(input:))
    }
}

extension GetFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetFindingsInput {
        return GetFindingsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}

extension PaginatorSequence where Input == GetFindingsInput, Output == GetFindingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getFindingsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.AwsSecurityFinding]`
    /// - Returns: `[SecurityHubClientTypes.AwsSecurityFinding]`
    public func findings() async throws -> [SecurityHubClientTypes.AwsSecurityFinding] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}
extension SecurityHubClient {
    /// Paginate over `[GetInsightsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetInsightsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetInsightsOutput`
    public func getInsightsPaginated(input: GetInsightsInput) -> ClientRuntime.PaginatorSequence<GetInsightsInput, GetInsightsOutput> {
        return ClientRuntime.PaginatorSequence<GetInsightsInput, GetInsightsOutput>(input: input, inputKey: \GetInsightsInput.nextToken, outputKey: \GetInsightsOutput.nextToken, paginationFunction: self.getInsights(input:))
    }
}

extension GetInsightsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInsightsInput {
        return GetInsightsInput(
            insightArns: self.insightArns,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == GetInsightsInput, Output == GetInsightsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getInsightsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Insight]`
    /// - Returns: `[SecurityHubClientTypes.Insight]`
    public func insights() async throws -> [SecurityHubClientTypes.Insight] {
        return try await self.asyncCompactMap { item in item.insights }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListEnabledProductsForImportOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEnabledProductsForImportInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEnabledProductsForImportOutput`
    public func listEnabledProductsForImportPaginated(input: ListEnabledProductsForImportInput) -> ClientRuntime.PaginatorSequence<ListEnabledProductsForImportInput, ListEnabledProductsForImportOutput> {
        return ClientRuntime.PaginatorSequence<ListEnabledProductsForImportInput, ListEnabledProductsForImportOutput>(input: input, inputKey: \ListEnabledProductsForImportInput.nextToken, outputKey: \ListEnabledProductsForImportOutput.nextToken, paginationFunction: self.listEnabledProductsForImport(input:))
    }
}

extension ListEnabledProductsForImportInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEnabledProductsForImportInput {
        return ListEnabledProductsForImportInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListEnabledProductsForImportInput, Output == ListEnabledProductsForImportOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listEnabledProductsForImportPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func productSubscriptions() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.productSubscriptions }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListFindingAggregatorsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFindingAggregatorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFindingAggregatorsOutput`
    public func listFindingAggregatorsPaginated(input: ListFindingAggregatorsInput) -> ClientRuntime.PaginatorSequence<ListFindingAggregatorsInput, ListFindingAggregatorsOutput> {
        return ClientRuntime.PaginatorSequence<ListFindingAggregatorsInput, ListFindingAggregatorsOutput>(input: input, inputKey: \ListFindingAggregatorsInput.nextToken, outputKey: \ListFindingAggregatorsOutput.nextToken, paginationFunction: self.listFindingAggregators(input:))
    }
}

extension ListFindingAggregatorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFindingAggregatorsInput {
        return ListFindingAggregatorsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFindingAggregatorsInput, Output == ListFindingAggregatorsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFindingAggregatorsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.FindingAggregator]`
    /// - Returns: `[SecurityHubClientTypes.FindingAggregator]`
    public func findingAggregators() async throws -> [SecurityHubClientTypes.FindingAggregator] {
        return try await self.asyncCompactMap { item in item.findingAggregators }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListInvitationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInvitationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInvitationsOutput`
    public func listInvitationsPaginated(input: ListInvitationsInput) -> ClientRuntime.PaginatorSequence<ListInvitationsInput, ListInvitationsOutput> {
        return ClientRuntime.PaginatorSequence<ListInvitationsInput, ListInvitationsOutput>(input: input, inputKey: \ListInvitationsInput.nextToken, outputKey: \ListInvitationsOutput.nextToken, paginationFunction: self.listInvitations(input:))
    }
}

extension ListInvitationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInvitationsInput {
        return ListInvitationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListInvitationsInput, Output == ListInvitationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInvitationsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Invitation]`
    /// - Returns: `[SecurityHubClientTypes.Invitation]`
    public func invitations() async throws -> [SecurityHubClientTypes.Invitation] {
        return try await self.asyncCompactMap { item in item.invitations }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListMembersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMembersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMembersOutput`
    public func listMembersPaginated(input: ListMembersInput) -> ClientRuntime.PaginatorSequence<ListMembersInput, ListMembersOutput> {
        return ClientRuntime.PaginatorSequence<ListMembersInput, ListMembersOutput>(input: input, inputKey: \ListMembersInput.nextToken, outputKey: \ListMembersOutput.nextToken, paginationFunction: self.listMembers(input:))
    }
}

extension ListMembersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMembersInput {
        return ListMembersInput(
            maxResults: self.maxResults,
            nextToken: token,
            onlyAssociated: self.onlyAssociated
        )}
}

extension PaginatorSequence where Input == ListMembersInput, Output == ListMembersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMembersPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Member]`
    /// - Returns: `[SecurityHubClientTypes.Member]`
    public func members() async throws -> [SecurityHubClientTypes.Member] {
        return try await self.asyncCompactMap { item in item.members }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListOrganizationAdminAccountsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOrganizationAdminAccountsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOrganizationAdminAccountsOutput`
    public func listOrganizationAdminAccountsPaginated(input: ListOrganizationAdminAccountsInput) -> ClientRuntime.PaginatorSequence<ListOrganizationAdminAccountsInput, ListOrganizationAdminAccountsOutput> {
        return ClientRuntime.PaginatorSequence<ListOrganizationAdminAccountsInput, ListOrganizationAdminAccountsOutput>(input: input, inputKey: \ListOrganizationAdminAccountsInput.nextToken, outputKey: \ListOrganizationAdminAccountsOutput.nextToken, paginationFunction: self.listOrganizationAdminAccounts(input:))
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOrganizationAdminAccountsInput {
        return ListOrganizationAdminAccountsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListOrganizationAdminAccountsInput, Output == ListOrganizationAdminAccountsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOrganizationAdminAccountsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.AdminAccount]`
    /// - Returns: `[SecurityHubClientTypes.AdminAccount]`
    public func adminAccounts() async throws -> [SecurityHubClientTypes.AdminAccount] {
        return try await self.asyncCompactMap { item in item.adminAccounts }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListSecurityControlDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSecurityControlDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSecurityControlDefinitionsOutput`
    public func listSecurityControlDefinitionsPaginated(input: ListSecurityControlDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListSecurityControlDefinitionsInput, ListSecurityControlDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<ListSecurityControlDefinitionsInput, ListSecurityControlDefinitionsOutput>(input: input, inputKey: \ListSecurityControlDefinitionsInput.nextToken, outputKey: \ListSecurityControlDefinitionsOutput.nextToken, paginationFunction: self.listSecurityControlDefinitions(input:))
    }
}

extension ListSecurityControlDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityControlDefinitionsInput {
        return ListSecurityControlDefinitionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            standardsArn: self.standardsArn
        )}
}

extension PaginatorSequence where Input == ListSecurityControlDefinitionsInput, Output == ListSecurityControlDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSecurityControlDefinitionsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.SecurityControlDefinition]`
    /// - Returns: `[SecurityHubClientTypes.SecurityControlDefinition]`
    public func securityControlDefinitions() async throws -> [SecurityHubClientTypes.SecurityControlDefinition] {
        return try await self.asyncCompactMap { item in item.securityControlDefinitions }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListStandardsControlAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStandardsControlAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStandardsControlAssociationsOutput`
    public func listStandardsControlAssociationsPaginated(input: ListStandardsControlAssociationsInput) -> ClientRuntime.PaginatorSequence<ListStandardsControlAssociationsInput, ListStandardsControlAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListStandardsControlAssociationsInput, ListStandardsControlAssociationsOutput>(input: input, inputKey: \ListStandardsControlAssociationsInput.nextToken, outputKey: \ListStandardsControlAssociationsOutput.nextToken, paginationFunction: self.listStandardsControlAssociations(input:))
    }
}

extension ListStandardsControlAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStandardsControlAssociationsInput {
        return ListStandardsControlAssociationsInput(
            maxResults: self.maxResults,
            nextToken: token,
            securityControlId: self.securityControlId
        )}
}

extension PaginatorSequence where Input == ListStandardsControlAssociationsInput, Output == ListStandardsControlAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listStandardsControlAssociationsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.StandardsControlAssociationSummary]`
    /// - Returns: `[SecurityHubClientTypes.StandardsControlAssociationSummary]`
    public func standardsControlAssociationSummaries() async throws -> [SecurityHubClientTypes.StandardsControlAssociationSummary] {
        return try await self.asyncCompactMap { item in item.standardsControlAssociationSummaries }
    }
}
