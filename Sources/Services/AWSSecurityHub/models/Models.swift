// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptAdministratorInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorId = "AdministratorId"
        case invitationId = "InvitationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorId = self.administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
    }
}

extension AcceptAdministratorInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/administrator"
    }
}

public struct AcceptAdministratorInvitationInput: Swift.Equatable {
    /// The account ID of the Security Hub administrator account that sent the invitation.
    /// This member is required.
    public var administratorId: Swift.String?
    /// The identifier of the invitation sent from the Security Hub administrator account.
    /// This member is required.
    public var invitationId: Swift.String?

    public init (
        administratorId: Swift.String? = nil,
        invitationId: Swift.String? = nil
    )
    {
        self.administratorId = administratorId
        self.invitationId = invitationId
    }
}

struct AcceptAdministratorInvitationInputBody: Swift.Equatable {
    let administratorId: Swift.String?
    let invitationId: Swift.String?
}

extension AcceptAdministratorInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorId = "AdministratorId"
        case invitationId = "InvitationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptAdministratorInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptAdministratorInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcceptAdministratorInvitationOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptAdministratorInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptAdministratorInvitationOutputResponse: Swift.Equatable {

    public init () { }
}

extension AcceptInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationId = "InvitationId"
        case masterId = "MasterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let masterId = self.masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
    }
}

extension AcceptInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/master"
    }
}

public struct AcceptInvitationInput: Swift.Equatable {
    /// The identifier of the invitation sent from the Security Hub administrator account.
    /// This member is required.
    public var invitationId: Swift.String?
    /// The account ID of the Security Hub administrator account that sent the invitation.
    /// This member is required.
    public var masterId: Swift.String?

    public init (
        invitationId: Swift.String? = nil,
        masterId: Swift.String? = nil
    )
    {
        self.invitationId = invitationId
        self.masterId = masterId
    }
}

struct AcceptInvitationInputBody: Swift.Equatable {
    let masterId: Swift.String?
    let invitationId: Swift.String?
}

extension AcceptInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationId = "InvitationId"
        case masterId = "MasterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcceptInvitationOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptInvitationOutputResponse: Swift.Equatable {

    public init () { }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have permission to perform the action specified in the request.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SecurityHubClientTypes.AccountDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case email = "Email"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension SecurityHubClientTypes {
    /// The details of an Amazon Web Services account.
    public struct AccountDetails: Swift.Equatable {
        /// The ID of an Amazon Web Services account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The email of an Amazon Web Services account.
        public var email: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            email: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.email = email
        }
    }

}

extension SecurityHubClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "ActionType"
        case awsApiCallAction = "AwsApiCallAction"
        case dnsRequestAction = "DnsRequestAction"
        case networkConnectionAction = "NetworkConnectionAction"
        case portProbeAction = "PortProbeAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
        if let awsApiCallAction = self.awsApiCallAction {
            try encodeContainer.encode(awsApiCallAction, forKey: .awsApiCallAction)
        }
        if let dnsRequestAction = self.dnsRequestAction {
            try encodeContainer.encode(dnsRequestAction, forKey: .dnsRequestAction)
        }
        if let networkConnectionAction = self.networkConnectionAction {
            try encodeContainer.encode(networkConnectionAction, forKey: .networkConnectionAction)
        }
        if let portProbeAction = self.portProbeAction {
            try encodeContainer.encode(portProbeAction, forKey: .portProbeAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let networkConnectionActionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.NetworkConnectionAction.self, forKey: .networkConnectionAction)
        networkConnectionAction = networkConnectionActionDecoded
        let awsApiCallActionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiCallAction.self, forKey: .awsApiCallAction)
        awsApiCallAction = awsApiCallActionDecoded
        let dnsRequestActionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.DnsRequestAction.self, forKey: .dnsRequestAction)
        dnsRequestAction = dnsRequestActionDecoded
        let portProbeActionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.PortProbeAction.self, forKey: .portProbeAction)
        portProbeAction = portProbeActionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about one of the following actions that affects or that was taken on a resource:
    ///
    /// * A remote IP address issued an Amazon Web Services API call
    ///
    /// * A DNS request was received
    ///
    /// * A remote IP address attempted to connect to an EC2 instance
    ///
    /// * A remote IP address attempted a port probe on an EC2 instance
    public struct Action: Swift.Equatable {
        /// The type of action that was detected. The possible action types are:
        ///
        /// * NETWORK_CONNECTION
        ///
        /// * AWS_API_CALL
        ///
        /// * DNS_REQUEST
        ///
        /// * PORT_PROBE
        public var actionType: Swift.String?
        /// Included if ActionType is AWS_API_CALL. Provides details about the API call that was detected.
        public var awsApiCallAction: SecurityHubClientTypes.AwsApiCallAction?
        /// Included if ActionType is DNS_REQUEST. Provides details about the DNS request that was detected.
        public var dnsRequestAction: SecurityHubClientTypes.DnsRequestAction?
        /// Included if ActionType is NETWORK_CONNECTION. Provides details about the network connection that was detected.
        public var networkConnectionAction: SecurityHubClientTypes.NetworkConnectionAction?
        /// Included if ActionType is PORT_PROBE. Provides details about the port probe that was detected.
        public var portProbeAction: SecurityHubClientTypes.PortProbeAction?

        public init (
            actionType: Swift.String? = nil,
            awsApiCallAction: SecurityHubClientTypes.AwsApiCallAction? = nil,
            dnsRequestAction: SecurityHubClientTypes.DnsRequestAction? = nil,
            networkConnectionAction: SecurityHubClientTypes.NetworkConnectionAction? = nil,
            portProbeAction: SecurityHubClientTypes.PortProbeAction? = nil
        )
        {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
        }
    }

}

extension SecurityHubClientTypes.ActionLocalIpDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressV4 = "IpAddressV4"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressV4 = self.ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the IP address where the scanned port is located.
    public struct ActionLocalIpDetails: Swift.Equatable {
        /// The IP address.
        public var ipAddressV4: Swift.String?

        public init (
            ipAddressV4: Swift.String? = nil
        )
        {
            self.ipAddressV4 = ipAddressV4
        }
    }

}

extension SecurityHubClientTypes.ActionLocalPortDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "Port"
        case portName = "PortName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = self.portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// For NetworkConnectionAction and PortProbeDetails, LocalPortDetails provides information about the local port that was involved in the action.
    public struct ActionLocalPortDetails: Swift.Equatable {
        /// The number of the port.
        public var port: Swift.Int
        /// The port name of the local connection.
        public var portName: Swift.String?

        public init (
            port: Swift.Int = 0,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension SecurityHubClientTypes.ActionRemoteIpDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city = "City"
        case country = "Country"
        case geoLocation = "GeoLocation"
        case ipAddressV4 = "IpAddressV4"
        case organization = "Organization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let geoLocation = self.geoLocation {
            try encodeContainer.encode(geoLocation, forKey: .geoLocation)
        }
        if let ipAddressV4 = self.ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
        if let organization = self.organization {
            try encodeContainer.encode(organization, forKey: .organization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
        let organizationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.IpOrganizationDetails.self, forKey: .organization)
        organization = organizationDecoded
        let countryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Country.self, forKey: .country)
        country = countryDecoded
        let cityDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.City.self, forKey: .city)
        city = cityDecoded
        let geoLocationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.GeoLocation.self, forKey: .geoLocation)
        geoLocation = geoLocationDecoded
    }
}

extension SecurityHubClientTypes {
    /// For AwsApiAction, NetworkConnectionAction, and PortProbeAction, RemoteIpDetails provides information about the remote IP address that was involved in the action.
    public struct ActionRemoteIpDetails: Swift.Equatable {
        /// The city where the remote IP address is located.
        public var city: SecurityHubClientTypes.City?
        /// The country where the remote IP address is located.
        public var country: SecurityHubClientTypes.Country?
        /// The coordinates of the location of the remote IP address.
        public var geoLocation: SecurityHubClientTypes.GeoLocation?
        /// The IP address.
        public var ipAddressV4: Swift.String?
        /// The internet service provider (ISP) organization associated with the remote IP address.
        public var organization: SecurityHubClientTypes.IpOrganizationDetails?

        public init (
            city: SecurityHubClientTypes.City? = nil,
            country: SecurityHubClientTypes.Country? = nil,
            geoLocation: SecurityHubClientTypes.GeoLocation? = nil,
            ipAddressV4: Swift.String? = nil,
            organization: SecurityHubClientTypes.IpOrganizationDetails? = nil
        )
        {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.organization = organization
        }
    }

}

extension SecurityHubClientTypes.ActionRemotePortDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "Port"
        case portName = "PortName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = self.portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the remote port that was involved in an attempted network connection.
    public struct ActionRemotePortDetails: Swift.Equatable {
        /// The number of the port.
        public var port: Swift.Int
        /// The port name of the remote connection.
        public var portName: Swift.String?

        public init (
            port: Swift.Int = 0,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension SecurityHubClientTypes.ActionTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTargetArn = "ActionTargetArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTargetArn = self.actionTargetArn {
            try encodeContainer.encode(actionTargetArn, forKey: .actionTargetArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionTargetArn)
        actionTargetArn = actionTargetArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SecurityHubClientTypes {
    /// An ActionTarget object.
    public struct ActionTarget: Swift.Equatable {
        /// The ARN for the target action.
        /// This member is required.
        public var actionTargetArn: Swift.String?
        /// The description of the target action.
        /// This member is required.
        public var description: Swift.String?
        /// The name of the action target.
        /// This member is required.
        public var name: Swift.String?

        public init (
            actionTargetArn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.actionTargetArn = actionTargetArn
            self.description = description
            self.name = name
        }
    }

}

extension SecurityHubClientTypes.Adjustment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric = "Metric"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension SecurityHubClientTypes {
    /// An adjustment to the CVSS metric.
    public struct Adjustment: Swift.Equatable {
        /// The metric to adjust.
        public var metric: Swift.String?
        /// The reason for the adjustment.
        public var reason: Swift.String?

        public init (
            metric: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.metric = metric
            self.reason = reason
        }
    }

}

extension SecurityHubClientTypes.AdminAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AdminStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Represents a Security Hub administrator account designated by an organization management account.
    public struct AdminAccount: Swift.Equatable {
        /// The Amazon Web Services account identifier of the Security Hub administrator account.
        public var accountId: Swift.String?
        /// The current status of the Security Hub administrator account. Indicates whether the account is currently enabled as a Security Hub administrator.
        public var status: SecurityHubClientTypes.AdminStatus?

        public init (
            accountId: Swift.String? = nil,
            status: SecurityHubClientTypes.AdminStatus? = nil
        )
        {
            self.accountId = accountId
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    public enum AdminStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AdminStatus] {
            return [
                .disableInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdminStatus(rawValue: rawValue) ?? AdminStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes {
    public enum AutoEnableStandards: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoEnableStandards] {
            return [
                .default,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoEnableStandards(rawValue: rawValue) ?? AutoEnableStandards.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.AvailabilityZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetId = "SubnetId"
        case zoneName = "ZoneName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let zoneName = self.zoneName {
            try encodeContainer.encode(zoneName, forKey: .zoneName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zoneName)
        zoneName = zoneNameDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an Availability Zone.
    public struct AvailabilityZone: Swift.Equatable {
        /// The ID of the subnet. You can specify one subnet per Availability Zone.
        public var subnetId: Swift.String?
        /// The name of the Availability Zone.
        public var zoneName: Swift.String?

        public init (
            subnetId: Swift.String? = nil,
            zoneName: Swift.String? = nil
        )
        {
            self.subnetId = subnetId
            self.zoneName = zoneName
        }
    }

}

extension SecurityHubClientTypes.AwsApiCallAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case affectedResources = "AffectedResources"
        case api = "Api"
        case callerType = "CallerType"
        case domainDetails = "DomainDetails"
        case firstSeen = "FirstSeen"
        case lastSeen = "LastSeen"
        case remoteIpDetails = "RemoteIpDetails"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let affectedResources = affectedResources {
            var affectedResourcesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .affectedResources)
            for (dictKey0, fieldMap0) in affectedResources {
                try affectedResourcesContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let api = self.api {
            try encodeContainer.encode(api, forKey: .api)
        }
        if let callerType = self.callerType {
            try encodeContainer.encode(callerType, forKey: .callerType)
        }
        if let domainDetails = self.domainDetails {
            try encodeContainer.encode(domainDetails, forKey: .domainDetails)
        }
        if let firstSeen = self.firstSeen {
            try encodeContainer.encode(firstSeen, forKey: .firstSeen)
        }
        if let lastSeen = self.lastSeen {
            try encodeContainer.encode(lastSeen, forKey: .lastSeen)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .api)
        api = apiDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let callerTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerType)
        callerType = callerTypeDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ActionRemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let domainDetailsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiCallActionDomainDetails.self, forKey: .domainDetails)
        domainDetails = domainDetailsDecoded
        let affectedResourcesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .affectedResources)
        var affectedResourcesDecoded0: [Swift.String:Swift.String]? = nil
        if let affectedResourcesContainer = affectedResourcesContainer {
            affectedResourcesDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in affectedResourcesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    affectedResourcesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        affectedResources = affectedResourcesDecoded0
        let firstSeenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstSeen)
        firstSeen = firstSeenDecoded
        let lastSeenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSeen)
        lastSeen = lastSeenDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provided if ActionType is AWS_API_CALL. It provides details about the API call that was detected.
    public struct AwsApiCallAction: Swift.Equatable {
        /// Identifies the resources that were affected by the API call.
        public var affectedResources: [Swift.String:Swift.String]?
        /// The name of the API method that was issued.
        public var api: Swift.String?
        /// Indicates whether the API call originated from a remote IP address (remoteip) or from a DNS domain (domain).
        public var callerType: Swift.String?
        /// Provided if CallerType is domain. Provides information about the DNS domain that the API call originated from.
        public var domainDetails: SecurityHubClientTypes.AwsApiCallActionDomainDetails?
        /// An ISO8601-formatted timestamp that indicates when the API call was first observed.
        public var firstSeen: Swift.String?
        /// An ISO8601-formatted timestamp that indicates when the API call was most recently observed.
        public var lastSeen: Swift.String?
        /// Provided if CallerType is remoteIp. Provides information about the remote IP address that the API call originated from.
        public var remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails?
        /// The name of the Amazon Web Services service that the API method belongs to.
        public var serviceName: Swift.String?

        public init (
            affectedResources: [Swift.String:Swift.String]? = nil,
            api: Swift.String? = nil,
            callerType: Swift.String? = nil,
            domainDetails: SecurityHubClientTypes.AwsApiCallActionDomainDetails? = nil,
            firstSeen: Swift.String? = nil,
            lastSeen: Swift.String? = nil,
            remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.affectedResources = affectedResources
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
        }
    }

}

extension SecurityHubClientTypes.AwsApiCallActionDomainDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provided if CallerType is domain. It provides information about the DNS domain that issued the API call.
    public struct AwsApiCallActionDomainDetails: Swift.Equatable {
        /// The name of the DNS domain that issued the API call.
        public var domain: Swift.String?

        public init (
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension SecurityHubClientTypes.AwsApiGatewayAccessLogSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn = "DestinationArn"
        case format = "Format"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let format = self.format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about settings for logging access for the stage.
    public struct AwsApiGatewayAccessLogSettings: Swift.Equatable {
        /// The ARN of the CloudWatch Logs log group that receives the access logs.
        public var destinationArn: Swift.String?
        /// A single-line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public var format: Swift.String?

        public init (
            destinationArn: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.format = format
        }
    }

}

extension SecurityHubClientTypes.AwsApiGatewayCanarySettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId = "DeploymentId"
        case percentTraffic = "PercentTraffic"
        case stageVariableOverrides = "StageVariableOverrides"
        case useStageCache = "UseStageCache"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if percentTraffic != 0.0 {
            try encodeContainer.encode(percentTraffic, forKey: .percentTraffic)
        }
        if let stageVariableOverrides = stageVariableOverrides {
            var stageVariableOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariableOverrides)
            for (dictKey0, fieldMap0) in stageVariableOverrides {
                try stageVariableOverridesContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if useStageCache != false {
            try encodeContainer.encode(useStageCache, forKey: .useStageCache)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentTrafficDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .percentTraffic) ?? 0.0
        percentTraffic = percentTrafficDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let stageVariableOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariableOverrides)
        var stageVariableOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariableOverridesContainer = stageVariableOverridesContainer {
            stageVariableOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in stageVariableOverridesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    stageVariableOverridesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        stageVariableOverrides = stageVariableOverridesDecoded0
        let useStageCacheDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useStageCache) ?? false
        useStageCache = useStageCacheDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about settings for canary deployment in the stage.
    public struct AwsApiGatewayCanarySettings: Swift.Equatable {
        /// The deployment identifier for the canary deployment.
        public var deploymentId: Swift.String?
        /// The percentage of traffic that is diverted to a canary deployment.
        public var percentTraffic: Swift.Double
        /// Stage variables that are overridden in the canary release deployment. The variables include new stage variables that are introduced in the canary. Each variable is represented as a string-to-string map between the stage variable name and the variable value.
        public var stageVariableOverrides: [Swift.String:Swift.String]?
        /// Indicates whether the canary deployment uses the stage cache.
        public var useStageCache: Swift.Bool

        public init (
            deploymentId: Swift.String? = nil,
            percentTraffic: Swift.Double = 0.0,
            stageVariableOverrides: [Swift.String:Swift.String]? = nil,
            useStageCache: Swift.Bool = false
        )
        {
            self.deploymentId = deploymentId
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }
    }

}

extension SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case types = "Types"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for nonemptystring0 in types {
                try typesContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .types)
        var typesDecoded0:[Swift.String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [Swift.String]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the endpoints for the API.
    public struct AwsApiGatewayEndpointConfiguration: Swift.Equatable {
        /// A list of endpoint types for the REST API. For an edge-optimized API, the endpoint type is EDGE. For a Regional API, the endpoint type is REGIONAL. For a private API, the endpoint type is PRIVATE.
        public var types: [Swift.String]?

        public init (
            types: [Swift.String]? = nil
        )
        {
            self.types = types
        }
    }

}

extension SecurityHubClientTypes.AwsApiGatewayMethodSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheDataEncrypted = "CacheDataEncrypted"
        case cacheTtlInSeconds = "CacheTtlInSeconds"
        case cachingEnabled = "CachingEnabled"
        case dataTraceEnabled = "DataTraceEnabled"
        case httpMethod = "HttpMethod"
        case loggingLevel = "LoggingLevel"
        case metricsEnabled = "MetricsEnabled"
        case requireAuthorizationForCacheControl = "RequireAuthorizationForCacheControl"
        case resourcePath = "ResourcePath"
        case throttlingBurstLimit = "ThrottlingBurstLimit"
        case throttlingRateLimit = "ThrottlingRateLimit"
        case unauthorizedCacheControlHeaderStrategy = "UnauthorizedCacheControlHeaderStrategy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cacheDataEncrypted != false {
            try encodeContainer.encode(cacheDataEncrypted, forKey: .cacheDataEncrypted)
        }
        if cacheTtlInSeconds != 0 {
            try encodeContainer.encode(cacheTtlInSeconds, forKey: .cacheTtlInSeconds)
        }
        if cachingEnabled != false {
            try encodeContainer.encode(cachingEnabled, forKey: .cachingEnabled)
        }
        if dataTraceEnabled != false {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if let httpMethod = self.httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if metricsEnabled != false {
            try encodeContainer.encode(metricsEnabled, forKey: .metricsEnabled)
        }
        if requireAuthorizationForCacheControl != false {
            try encodeContainer.encode(requireAuthorizationForCacheControl, forKey: .requireAuthorizationForCacheControl)
        }
        if let resourcePath = self.resourcePath {
            try encodeContainer.encode(resourcePath, forKey: .resourcePath)
        }
        if throttlingBurstLimit != 0 {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if throttlingRateLimit != 0.0 {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
        if let unauthorizedCacheControlHeaderStrategy = self.unauthorizedCacheControlHeaderStrategy {
            try encodeContainer.encode(unauthorizedCacheControlHeaderStrategy, forKey: .unauthorizedCacheControlHeaderStrategy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .metricsEnabled) ?? false
        metricsEnabled = metricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let dataTraceEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataTraceEnabled) ?? false
        dataTraceEnabled = dataTraceEnabledDecoded
        let throttlingBurstLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throttlingBurstLimit) ?? 0
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .throttlingRateLimit) ?? 0.0
        throttlingRateLimit = throttlingRateLimitDecoded
        let cachingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cachingEnabled) ?? false
        cachingEnabled = cachingEnabledDecoded
        let cacheTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cacheTtlInSeconds) ?? 0
        cacheTtlInSeconds = cacheTtlInSecondsDecoded
        let cacheDataEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheDataEncrypted) ?? false
        cacheDataEncrypted = cacheDataEncryptedDecoded
        let requireAuthorizationForCacheControlDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireAuthorizationForCacheControl) ?? false
        requireAuthorizationForCacheControl = requireAuthorizationForCacheControlDecoded
        let unauthorizedCacheControlHeaderStrategyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unauthorizedCacheControlHeaderStrategy)
        unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategyDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let resourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePath)
        resourcePath = resourcePathDecoded
    }
}

extension SecurityHubClientTypes {
    /// Defines settings for a method for the stage.
    public struct AwsApiGatewayMethodSettings: Swift.Equatable {
        /// Indicates whether the cached responses are encrypted.
        public var cacheDataEncrypted: Swift.Bool
        /// Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response is cached.
        public var cacheTtlInSeconds: Swift.Int
        /// Indicates whether responses are cached and returned for requests. For responses to be cached, a cache cluster must be enabled on the stage.
        public var cachingEnabled: Swift.Bool
        /// Indicates whether data trace logging is enabled for the method. Data trace logging affects the log entries that are pushed to CloudWatch Logs.
        public var dataTraceEnabled: Swift.Bool
        /// The HTTP method. You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
        public var httpMethod: Swift.String?
        /// The logging level for this method. The logging level affects the log entries that are pushed to CloudWatch Logs. If the logging level is ERROR, then the logs only include error-level entries. If the logging level is INFO, then the logs include both ERROR events and extra informational events. Valid values: OFF | ERROR | INFO
        public var loggingLevel: Swift.String?
        /// Indicates whether CloudWatch metrics are enabled for the method.
        public var metricsEnabled: Swift.Bool
        /// Indicates whether authorization is required for a cache invalidation request.
        public var requireAuthorizationForCacheControl: Swift.Bool
        /// The resource path for this method. Forward slashes (/) are encoded as ~1 . The initial slash must include a forward slash. For example, the path value /resource/subresource must be encoded as /~1resource~1subresource. To specify the root path, use only a slash (/). You can use an asterisk (*) as a wildcard to apply method settings to multiple methods.
        public var resourcePath: Swift.String?
        /// The throttling burst limit for the method.
        public var throttlingBurstLimit: Swift.Int
        /// The throttling rate limit for the method.
        public var throttlingRateLimit: Swift.Double
        /// Indicates how to handle unauthorized requests for cache invalidation. Valid values: FAIL_WITH_403 | SUCCEED_WITH_RESPONSE_HEADER | SUCCEED_WITHOUT_RESPONSE_HEADER
        public var unauthorizedCacheControlHeaderStrategy: Swift.String?

        public init (
            cacheDataEncrypted: Swift.Bool = false,
            cacheTtlInSeconds: Swift.Int = 0,
            cachingEnabled: Swift.Bool = false,
            dataTraceEnabled: Swift.Bool = false,
            httpMethod: Swift.String? = nil,
            loggingLevel: Swift.String? = nil,
            metricsEnabled: Swift.Bool = false,
            requireAuthorizationForCacheControl: Swift.Bool = false,
            resourcePath: Swift.String? = nil,
            throttlingBurstLimit: Swift.Int = 0,
            throttlingRateLimit: Swift.Double = 0.0,
            unauthorizedCacheControlHeaderStrategy: Swift.String? = nil
        )
        {
            self.cacheDataEncrypted = cacheDataEncrypted
            self.cacheTtlInSeconds = cacheTtlInSeconds
            self.cachingEnabled = cachingEnabled
            self.dataTraceEnabled = dataTraceEnabled
            self.httpMethod = httpMethod
            self.loggingLevel = loggingLevel
            self.metricsEnabled = metricsEnabled
            self.requireAuthorizationForCacheControl = requireAuthorizationForCacheControl
            self.resourcePath = resourcePath
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
            self.unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy
        }
    }

}

extension SecurityHubClientTypes.AwsApiGatewayRestApiDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource = "ApiKeySource"
        case binaryMediaTypes = "BinaryMediaTypes"
        case createdDate = "CreatedDate"
        case description = "Description"
        case endpointConfiguration = "EndpointConfiguration"
        case id = "Id"
        case minimumCompressionSize = "MinimumCompressionSize"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySource = self.apiKeySource {
            try encodeContainer.encode(apiKeySource, forKey: .apiKeySource)
        }
        if let binaryMediaTypes = binaryMediaTypes {
            var binaryMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binaryMediaTypes)
            for nonemptystring0 in binaryMediaTypes {
                try binaryMediaTypesContainer.encode(nonemptystring0)
            }
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpointConfiguration = self.endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if minimumCompressionSize != 0 {
            try encodeContainer.encode(minimumCompressionSize, forKey: .minimumCompressionSize)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize) ?? 0
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a REST API in version 1 of Amazon API Gateway.
    public struct AwsApiGatewayRestApiDetails: Swift.Equatable {
        /// The source of the API key for metering requests according to a usage plan. HEADER indicates whether to read the API key from the X-API-Key header of a request. AUTHORIZER indicates whether to read the API key from the UsageIdentifierKey from a custom authorizer.
        public var apiKeySource: Swift.String?
        /// The list of binary media types supported by the REST API.
        public var binaryMediaTypes: [Swift.String]?
        /// Indicates when the API was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdDate: Swift.String?
        /// A description of the REST API.
        public var description: Swift.String?
        /// The endpoint configuration of the REST API.
        public var endpointConfiguration: SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration?
        /// The identifier of the REST API.
        public var id: Swift.String?
        /// The minimum size in bytes of a payload before compression is enabled. If null, then compression is disabled. If 0, then all payloads are compressed.
        public var minimumCompressionSize: Swift.Int
        /// The name of the REST API.
        public var name: Swift.String?
        /// The version identifier for the REST API.
        public var version: Swift.String?

        public init (
            apiKeySource: Swift.String? = nil,
            binaryMediaTypes: [Swift.String]? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            endpointConfiguration: SecurityHubClientTypes.AwsApiGatewayEndpointConfiguration? = nil,
            id: Swift.String? = nil,
            minimumCompressionSize: Swift.Int = 0,
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.apiKeySource = apiKeySource
            self.binaryMediaTypes = binaryMediaTypes
            self.createdDate = createdDate
            self.description = description
            self.endpointConfiguration = endpointConfiguration
            self.id = id
            self.minimumCompressionSize = minimumCompressionSize
            self.name = name
            self.version = version
        }
    }

}

extension SecurityHubClientTypes.AwsApiGatewayStageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "AccessLogSettings"
        case cacheClusterEnabled = "CacheClusterEnabled"
        case cacheClusterSize = "CacheClusterSize"
        case cacheClusterStatus = "CacheClusterStatus"
        case canarySettings = "CanarySettings"
        case clientCertificateId = "ClientCertificateId"
        case createdDate = "CreatedDate"
        case deploymentId = "DeploymentId"
        case description = "Description"
        case documentationVersion = "DocumentationVersion"
        case lastUpdatedDate = "LastUpdatedDate"
        case methodSettings = "MethodSettings"
        case stageName = "StageName"
        case tracingEnabled = "TracingEnabled"
        case variables = "Variables"
        case webAclArn = "WebAclArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = self.accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if cacheClusterEnabled != false {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = self.cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize, forKey: .cacheClusterSize)
        }
        if let cacheClusterStatus = self.cacheClusterStatus {
            try encodeContainer.encode(cacheClusterStatus, forKey: .cacheClusterStatus)
        }
        if let canarySettings = self.canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let clientCertificateId = self.clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = self.documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate, forKey: .lastUpdatedDate)
        }
        if let methodSettings = methodSettings {
            var methodSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .methodSettings)
            for awsapigatewaymethodsettings0 in methodSettings {
                try methodSettingsContainer.encode(awsapigatewaymethodsettings0)
            }
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if tracingEnabled != false {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, fieldMap0) in variables {
                try variablesContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let webAclArn = self.webAclArn {
            try encodeContainer.encode(webAclArn, forKey: .webAclArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheClusterEnabled) ?? false
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsApiGatewayMethodSettings?].self, forKey: .methodSettings)
        var methodSettingsDecoded0:[SecurityHubClientTypes.AwsApiGatewayMethodSettings]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [SecurityHubClientTypes.AwsApiGatewayMethodSettings]()
            for structure0 in methodSettingsContainer {
                if let structure0 = structure0 {
                    methodSettingsDecoded0?.append(structure0)
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in variablesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    variablesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayAccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayCanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tracingEnabled) ?? false
        tracingEnabled = tracingEnabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about a version 1 Amazon API Gateway stage.
    public struct AwsApiGatewayStageDetails: Swift.Equatable {
        /// Settings for logging access for the stage.
        public var accessLogSettings: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings?
        /// Indicates whether a cache cluster is enabled for the stage.
        public var cacheClusterEnabled: Swift.Bool
        /// If a cache cluster is enabled, the size of the cache cluster.
        public var cacheClusterSize: Swift.String?
        /// If a cache cluster is enabled, the status of the cache cluster.
        public var cacheClusterStatus: Swift.String?
        /// Information about settings for canary deployment in the stage.
        public var canarySettings: SecurityHubClientTypes.AwsApiGatewayCanarySettings?
        /// The identifier of the client certificate for the stage.
        public var clientCertificateId: Swift.String?
        /// Indicates when the stage was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdDate: Swift.String?
        /// The identifier of the deployment that the stage points to.
        public var deploymentId: Swift.String?
        /// A description of the stage.
        public var description: Swift.String?
        /// The version of the API documentation that is associated with the stage.
        public var documentationVersion: Swift.String?
        /// Indicates when the stage was most recently updated. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastUpdatedDate: Swift.String?
        /// Defines the method settings for the stage.
        public var methodSettings: [SecurityHubClientTypes.AwsApiGatewayMethodSettings]?
        /// The name of the stage.
        public var stageName: Swift.String?
        /// Indicates whether active tracing with X-Ray is enabled for the stage.
        public var tracingEnabled: Swift.Bool
        /// A map that defines the stage variables for the stage. Variable names can have alphanumeric and underscore characters. Variable values can contain the following characters:
        ///
        /// * Uppercase and lowercase letters
        ///
        /// * Numbers
        ///
        /// * Special characters -._~:/?#&=,
        public var variables: [Swift.String:Swift.String]?
        /// The ARN of the web ACL associated with the stage.
        public var webAclArn: Swift.String?

        public init (
            accessLogSettings: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings? = nil,
            cacheClusterEnabled: Swift.Bool = false,
            cacheClusterSize: Swift.String? = nil,
            cacheClusterStatus: Swift.String? = nil,
            canarySettings: SecurityHubClientTypes.AwsApiGatewayCanarySettings? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            documentationVersion: Swift.String? = nil,
            lastUpdatedDate: Swift.String? = nil,
            methodSettings: [SecurityHubClientTypes.AwsApiGatewayMethodSettings]? = nil,
            stageName: Swift.String? = nil,
            tracingEnabled: Swift.Bool = false,
            variables: [Swift.String:Swift.String]? = nil,
            webAclArn: Swift.String? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.cacheClusterEnabled = cacheClusterEnabled
            self.cacheClusterSize = cacheClusterSize
            self.cacheClusterStatus = cacheClusterStatus
            self.canarySettings = canarySettings
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.description = description
            self.documentationVersion = documentationVersion
            self.lastUpdatedDate = lastUpdatedDate
            self.methodSettings = methodSettings
            self.stageName = stageName
            self.tracingEnabled = tracingEnabled
            self.variables = variables
            self.webAclArn = webAclArn
        }
    }

}

extension SecurityHubClientTypes.AwsApiGatewayV2ApiDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiEndpoint = "ApiEndpoint"
        case apiId = "ApiId"
        case apiKeySelectionExpression = "ApiKeySelectionExpression"
        case corsConfiguration = "CorsConfiguration"
        case createdDate = "CreatedDate"
        case description = "Description"
        case name = "Name"
        case protocolType = "ProtocolType"
        case routeSelectionExpression = "RouteSelectionExpression"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiEndpoint = self.apiEndpoint {
            try encodeContainer.encode(apiEndpoint, forKey: .apiEndpoint)
        }
        if let apiId = self.apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let apiKeySelectionExpression = self.apiKeySelectionExpression {
            try encodeContainer.encode(apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
        }
        if let corsConfiguration = self.corsConfiguration {
            try encodeContainer.encode(corsConfiguration, forKey: .corsConfiguration)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolType = self.protocolType {
            try encodeContainer.encode(protocolType, forKey: .protocolType)
        }
        if let routeSelectionExpression = self.routeSelectionExpression {
            try encodeContainer.encode(routeSelectionExpression, forKey: .routeSelectionExpression)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiEndpoint)
        apiEndpoint = apiEndpointDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let apiKeySelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeySelectionExpression)
        apiKeySelectionExpression = apiKeySelectionExpressionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolType)
        protocolType = protocolTypeDecoded
        let routeSelectionExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .routeSelectionExpression)
        routeSelectionExpression = routeSelectionExpressionDecoded
        let corsConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCorsConfiguration.self, forKey: .corsConfiguration)
        corsConfiguration = corsConfigurationDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a version 2 API in Amazon API Gateway.
    public struct AwsApiGatewayV2ApiDetails: Swift.Equatable {
        /// The URI of the API. Uses the format  .execute-api..amazonaws.com The stage name is typically appended to the URI to form a complete path to a deployed API stage.
        public var apiEndpoint: Swift.String?
        /// The identifier of the API.
        public var apiId: Swift.String?
        /// An API key selection expression. Supported only for WebSocket APIs.
        public var apiKeySelectionExpression: Swift.String?
        /// A cross-origin resource sharing (CORS) configuration. Supported only for HTTP APIs.
        public var corsConfiguration: SecurityHubClientTypes.AwsCorsConfiguration?
        /// Indicates when the API was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdDate: Swift.String?
        /// A description of the API.
        public var description: Swift.String?
        /// The name of the API.
        public var name: Swift.String?
        /// The API protocol for the API. Valid values: WEBSOCKET | HTTP
        public var protocolType: Swift.String?
        /// The route selection expression for the API. For HTTP APIs, must be ${request.method} ${request.path}. This is the default value for HTTP APIs. For WebSocket APIs, there is no default value.
        public var routeSelectionExpression: Swift.String?
        /// The version identifier for the API.
        public var version: Swift.String?

        public init (
            apiEndpoint: Swift.String? = nil,
            apiId: Swift.String? = nil,
            apiKeySelectionExpression: Swift.String? = nil,
            corsConfiguration: SecurityHubClientTypes.AwsCorsConfiguration? = nil,
            createdDate: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            protocolType: Swift.String? = nil,
            routeSelectionExpression: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.apiEndpoint = apiEndpoint
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.version = version
        }
    }

}

extension SecurityHubClientTypes.AwsApiGatewayV2RouteSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTraceEnabled = "DataTraceEnabled"
        case detailedMetricsEnabled = "DetailedMetricsEnabled"
        case loggingLevel = "LoggingLevel"
        case throttlingBurstLimit = "ThrottlingBurstLimit"
        case throttlingRateLimit = "ThrottlingRateLimit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dataTraceEnabled != false {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if detailedMetricsEnabled != false {
            try encodeContainer.encode(detailedMetricsEnabled, forKey: .detailedMetricsEnabled)
        }
        if let loggingLevel = self.loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if throttlingBurstLimit != 0 {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if throttlingRateLimit != 0.0 {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .detailedMetricsEnabled) ?? false
        detailedMetricsEnabled = detailedMetricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let dataTraceEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataTraceEnabled) ?? false
        dataTraceEnabled = dataTraceEnabledDecoded
        let throttlingBurstLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throttlingBurstLimit) ?? 0
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .throttlingRateLimit) ?? 0.0
        throttlingRateLimit = throttlingRateLimitDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains route settings for a stage.
    public struct AwsApiGatewayV2RouteSettings: Swift.Equatable {
        /// Indicates whether data trace logging is enabled. Data trace logging affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs.
        public var dataTraceEnabled: Swift.Bool
        /// Indicates whether detailed metrics are enabled.
        public var detailedMetricsEnabled: Swift.Bool
        /// The logging level. The logging level affects the log entries that are pushed to CloudWatch Logs. Supported only for WebSocket APIs. If the logging level is ERROR, then the logs only include error-level entries. If the logging level is INFO, then the logs include both ERROR events and extra informational events. Valid values: OFF | ERROR | INFO
        public var loggingLevel: Swift.String?
        /// The throttling burst limit.
        public var throttlingBurstLimit: Swift.Int
        /// The throttling rate limit.
        public var throttlingRateLimit: Swift.Double

        public init (
            dataTraceEnabled: Swift.Bool = false,
            detailedMetricsEnabled: Swift.Bool = false,
            loggingLevel: Swift.String? = nil,
            throttlingBurstLimit: Swift.Int = 0,
            throttlingRateLimit: Swift.Double = 0.0
        )
        {
            self.dataTraceEnabled = dataTraceEnabled
            self.detailedMetricsEnabled = detailedMetricsEnabled
            self.loggingLevel = loggingLevel
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
        }
    }

}

extension SecurityHubClientTypes.AwsApiGatewayV2StageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings = "AccessLogSettings"
        case apiGatewayManaged = "ApiGatewayManaged"
        case autoDeploy = "AutoDeploy"
        case clientCertificateId = "ClientCertificateId"
        case createdDate = "CreatedDate"
        case defaultRouteSettings = "DefaultRouteSettings"
        case deploymentId = "DeploymentId"
        case description = "Description"
        case lastDeploymentStatusMessage = "LastDeploymentStatusMessage"
        case lastUpdatedDate = "LastUpdatedDate"
        case routeSettings = "RouteSettings"
        case stageName = "StageName"
        case stageVariables = "StageVariables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = self.accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if apiGatewayManaged != false {
            try encodeContainer.encode(apiGatewayManaged, forKey: .apiGatewayManaged)
        }
        if autoDeploy != false {
            try encodeContainer.encode(autoDeploy, forKey: .autoDeploy)
        }
        if let clientCertificateId = self.clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let defaultRouteSettings = self.defaultRouteSettings {
            try encodeContainer.encode(defaultRouteSettings, forKey: .defaultRouteSettings)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastDeploymentStatusMessage = self.lastDeploymentStatusMessage {
            try encodeContainer.encode(lastDeploymentStatusMessage, forKey: .lastDeploymentStatusMessage)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate, forKey: .lastUpdatedDate)
        }
        if let routeSettings = self.routeSettings {
            try encodeContainer.encode(routeSettings, forKey: .routeSettings)
        }
        if let stageName = self.stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, fieldMap0) in stageVariables {
                try stageVariablesContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRouteSettingsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayV2RouteSettings.self, forKey: .defaultRouteSettings)
        defaultRouteSettings = defaultRouteSettingsDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let routeSettingsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayV2RouteSettings.self, forKey: .routeSettings)
        routeSettings = routeSettingsDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in stageVariablesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    stageVariablesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayAccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let autoDeployDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploy) ?? false
        autoDeploy = autoDeployDecoded
        let lastDeploymentStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDeploymentStatusMessage)
        lastDeploymentStatusMessage = lastDeploymentStatusMessageDecoded
        let apiGatewayManagedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiGatewayManaged) ?? false
        apiGatewayManaged = apiGatewayManagedDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a version 2 stage for Amazon API Gateway.
    public struct AwsApiGatewayV2StageDetails: Swift.Equatable {
        /// Information about settings for logging access for the stage.
        public var accessLogSettings: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings?
        /// Indicates whether the stage is managed by API Gateway.
        public var apiGatewayManaged: Swift.Bool
        /// Indicates whether updates to an API automatically trigger a new deployment.
        public var autoDeploy: Swift.Bool
        /// The identifier of a client certificate for a stage. Supported only for WebSocket API calls.
        public var clientCertificateId: Swift.String?
        /// Indicates when the stage was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdDate: Swift.String?
        /// Default route settings for the stage.
        public var defaultRouteSettings: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings?
        /// The identifier of the deployment that the stage is associated with.
        public var deploymentId: Swift.String?
        /// The description of the stage.
        public var description: Swift.String?
        /// The status of the last deployment of a stage. Supported only if the stage has automatic deployment enabled.
        public var lastDeploymentStatusMessage: Swift.String?
        /// Indicates when the stage was most recently updated. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastUpdatedDate: Swift.String?
        /// The route settings for the stage.
        public var routeSettings: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings?
        /// The name of the stage.
        public var stageName: Swift.String?
        /// A map that defines the stage variables for the stage. Variable names can have alphanumeric and underscore characters. Variable values can contain the following characters:
        ///
        /// * Uppercase and lowercase letters
        ///
        /// * Numbers
        ///
        /// * Special characters -._~:/?#&=,
        public var stageVariables: [Swift.String:Swift.String]?

        public init (
            accessLogSettings: SecurityHubClientTypes.AwsApiGatewayAccessLogSettings? = nil,
            apiGatewayManaged: Swift.Bool = false,
            autoDeploy: Swift.Bool = false,
            clientCertificateId: Swift.String? = nil,
            createdDate: Swift.String? = nil,
            defaultRouteSettings: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            lastDeploymentStatusMessage: Swift.String? = nil,
            lastUpdatedDate: Swift.String? = nil,
            routeSettings: SecurityHubClientTypes.AwsApiGatewayV2RouteSettings? = nil,
            stageName: Swift.String? = nil,
            stageVariables: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// An Availability Zone for the automatic scaling group.
    public struct AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails: Swift.Equatable {
        /// The name of the Availability Zone.
        public var value: Swift.String?

        public init (
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case capacityRebalance = "CapacityRebalance"
        case createdTime = "CreatedTime"
        case healthCheckGracePeriod = "HealthCheckGracePeriod"
        case healthCheckType = "HealthCheckType"
        case launchConfigurationName = "LaunchConfigurationName"
        case launchTemplate = "LaunchTemplate"
        case loadBalancerNames = "LoadBalancerNames"
        case mixedInstancesPolicy = "MixedInstancesPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for awsautoscalingautoscalinggroupavailabilityzoneslistdetails0 in availabilityZones {
                try availabilityZonesContainer.encode(awsautoscalingautoscalinggroupavailabilityzoneslistdetails0)
            }
        }
        if capacityRebalance != false {
            try encodeContainer.encode(capacityRebalance, forKey: .capacityRebalance)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if healthCheckGracePeriod != 0 {
            try encodeContainer.encode(healthCheckGracePeriod, forKey: .healthCheckGracePeriod)
        }
        if let healthCheckType = self.healthCheckType {
            try encodeContainer.encode(healthCheckType, forKey: .healthCheckType)
        }
        if let launchConfigurationName = self.launchConfigurationName {
            try encodeContainer.encode(launchConfigurationName, forKey: .launchConfigurationName)
        }
        if let launchTemplate = self.launchTemplate {
            try encodeContainer.encode(launchTemplate, forKey: .launchTemplate)
        }
        if let loadBalancerNames = loadBalancerNames {
            var loadBalancerNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loadBalancerNames)
            for nonemptystring0 in loadBalancerNames {
                try loadBalancerNamesContainer.encode(nonemptystring0)
            }
        }
        if let mixedInstancesPolicy = self.mixedInstancesPolicy {
            try encodeContainer.encode(mixedInstancesPolicy, forKey: .mixedInstancesPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationName)
        launchConfigurationName = launchConfigurationNameDecoded
        let loadBalancerNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .loadBalancerNames)
        var loadBalancerNamesDecoded0:[Swift.String]? = nil
        if let loadBalancerNamesContainer = loadBalancerNamesContainer {
            loadBalancerNamesDecoded0 = [Swift.String]()
            for string0 in loadBalancerNamesContainer {
                if let string0 = string0 {
                    loadBalancerNamesDecoded0?.append(string0)
                }
            }
        }
        loadBalancerNames = loadBalancerNamesDecoded0
        let healthCheckTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckType)
        healthCheckType = healthCheckTypeDecoded
        let healthCheckGracePeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckGracePeriod) ?? 0
        healthCheckGracePeriod = healthCheckGracePeriodDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let mixedInstancesPolicyDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails.self, forKey: .mixedInstancesPolicy)
        mixedInstancesPolicy = mixedInstancesPolicyDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let launchTemplateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification.self, forKey: .launchTemplate)
        launchTemplate = launchTemplateDecoded
        let capacityRebalanceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .capacityRebalance) ?? false
        capacityRebalance = capacityRebalanceDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an auto scaling group.
    public struct AwsAutoScalingAutoScalingGroupDetails: Swift.Equatable {
        /// The list of Availability Zones for the automatic scaling group.
        public var availabilityZones: [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]?
        /// Indicates whether capacity rebalancing is enabled.
        public var capacityRebalance: Swift.Bool
        /// Indicates when the auto scaling group was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdTime: Swift.String?
        /// The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it checks the health status of an EC2 instance that has come into service.
        public var healthCheckGracePeriod: Swift.Int
        /// The service to use for the health checks. Valid values are EC2 or ELB.
        public var healthCheckType: Swift.String?
        /// The name of the launch configuration.
        public var launchConfigurationName: Swift.String?
        /// The launch template to use.
        public var launchTemplate: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification?
        /// The list of load balancers associated with the group.
        public var loadBalancerNames: [Swift.String]?
        /// The mixed instances policy for the automatic scaling group.
        public var mixedInstancesPolicy: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails?

        public init (
            availabilityZones: [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails]? = nil,
            capacityRebalance: Swift.Bool = false,
            createdTime: Swift.String? = nil,
            healthCheckGracePeriod: Swift.Int = 0,
            healthCheckType: Swift.String? = nil,
            launchConfigurationName: Swift.String? = nil,
            launchTemplate: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification? = nil,
            loadBalancerNames: [Swift.String]? = nil,
            mixedInstancesPolicy: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.capacityRebalance = capacityRebalance
            self.createdTime = createdTime
            self.healthCheckGracePeriod = healthCheckGracePeriod
            self.healthCheckType = healthCheckType
            self.launchConfigurationName = launchConfigurationName
            self.launchTemplate = launchTemplate
            self.loadBalancerNames = loadBalancerNames
            self.mixedInstancesPolicy = mixedInstancesPolicy
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchTemplateId = self.launchTemplateId {
            try encodeContainer.encode(launchTemplateId, forKey: .launchTemplateId)
        }
        if let launchTemplateName = self.launchTemplateName {
            try encodeContainer.encode(launchTemplateName, forKey: .launchTemplateName)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateId)
        launchTemplateId = launchTemplateIdDecoded
        let launchTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateName)
        launchTemplateName = launchTemplateNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the launch template to use.
    public struct AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification: Swift.Equatable {
        /// The identifier of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public var launchTemplateId: Swift.String?
        /// The name of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public var launchTemplateName: Swift.String?
        /// Identifies the version of the launch template. You can specify a version identifier, or use the values $Latest or $Default.
        public var version: Swift.String?

        public init (
            launchTemplateId: Swift.String? = nil,
            launchTemplateName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.version = version
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancesDistribution = "InstancesDistribution"
        case launchTemplate = "LaunchTemplate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instancesDistribution = self.instancesDistribution {
            try encodeContainer.encode(instancesDistribution, forKey: .instancesDistribution)
        }
        if let launchTemplate = self.launchTemplate {
            try encodeContainer.encode(launchTemplate, forKey: .launchTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesDistributionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails.self, forKey: .instancesDistribution)
        instancesDistribution = instancesDistributionDecoded
        let launchTemplateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails.self, forKey: .launchTemplate)
        launchTemplate = launchTemplateDecoded
    }
}

extension SecurityHubClientTypes {
    /// The mixed instances policy for the automatic scaling group.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails: Swift.Equatable {
        /// The instances distribution. The instances distribution specifies the distribution of On-Demand Instances and Spot Instances, the maximum price to pay for Spot Instances, and how the Auto Scaling group allocates instance types to fulfill On-Demand and Spot capacity.
        public var instancesDistribution: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails?
        /// The launch template to use and the instance types (overrides) to use to provision EC2 instances to fulfill On-Demand and Spot capacities.
        public var launchTemplate: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails?

        public init (
            instancesDistribution: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails? = nil,
            launchTemplate: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails? = nil
        )
        {
            self.instancesDistribution = instancesDistribution
            self.launchTemplate = launchTemplate
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onDemandAllocationStrategy = "OnDemandAllocationStrategy"
        case onDemandBaseCapacity = "OnDemandBaseCapacity"
        case onDemandPercentageAboveBaseCapacity = "OnDemandPercentageAboveBaseCapacity"
        case spotAllocationStrategy = "SpotAllocationStrategy"
        case spotInstancePools = "SpotInstancePools"
        case spotMaxPrice = "SpotMaxPrice"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onDemandAllocationStrategy = self.onDemandAllocationStrategy {
            try encodeContainer.encode(onDemandAllocationStrategy, forKey: .onDemandAllocationStrategy)
        }
        if onDemandBaseCapacity != 0 {
            try encodeContainer.encode(onDemandBaseCapacity, forKey: .onDemandBaseCapacity)
        }
        if onDemandPercentageAboveBaseCapacity != 0 {
            try encodeContainer.encode(onDemandPercentageAboveBaseCapacity, forKey: .onDemandPercentageAboveBaseCapacity)
        }
        if let spotAllocationStrategy = self.spotAllocationStrategy {
            try encodeContainer.encode(spotAllocationStrategy, forKey: .spotAllocationStrategy)
        }
        if spotInstancePools != 0 {
            try encodeContainer.encode(spotInstancePools, forKey: .spotInstancePools)
        }
        if let spotMaxPrice = self.spotMaxPrice {
            try encodeContainer.encode(spotMaxPrice, forKey: .spotMaxPrice)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandAllocationStrategyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandAllocationStrategy)
        onDemandAllocationStrategy = onDemandAllocationStrategyDecoded
        let onDemandBaseCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .onDemandBaseCapacity) ?? 0
        onDemandBaseCapacity = onDemandBaseCapacityDecoded
        let onDemandPercentageAboveBaseCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .onDemandPercentageAboveBaseCapacity) ?? 0
        onDemandPercentageAboveBaseCapacity = onDemandPercentageAboveBaseCapacityDecoded
        let spotAllocationStrategyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spotAllocationStrategy)
        spotAllocationStrategy = spotAllocationStrategyDecoded
        let spotInstancePoolsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .spotInstancePools) ?? 0
        spotInstancePools = spotInstancePoolsDecoded
        let spotMaxPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spotMaxPrice)
        spotMaxPrice = spotMaxPriceDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the instances distribution.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails: Swift.Equatable {
        /// How to allocate instance types to fulfill On-Demand capacity. The valid value is prioritized.
        public var onDemandAllocationStrategy: Swift.String?
        /// The minimum amount of the Auto Scaling group's capacity that must be fulfilled by On-Demand Instances.
        public var onDemandBaseCapacity: Swift.Int
        /// The percentage of On-Demand Instances and Spot Instances for additional capacity beyond OnDemandBaseCapacity.
        public var onDemandPercentageAboveBaseCapacity: Swift.Int
        /// How to allocate instances across Spot Instance pools. Valid values are as follows:
        ///
        /// * lowest-price
        ///
        /// * capacity-optimized
        ///
        /// * capacity-optimized-prioritized
        public var spotAllocationStrategy: Swift.String?
        /// The number of Spot Instance pools across which to allocate your Spot Instances.
        public var spotInstancePools: Swift.Int
        /// The maximum price per unit hour that you are willing to pay for a Spot Instance.
        public var spotMaxPrice: Swift.String?

        public init (
            onDemandAllocationStrategy: Swift.String? = nil,
            onDemandBaseCapacity: Swift.Int = 0,
            onDemandPercentageAboveBaseCapacity: Swift.Int = 0,
            spotAllocationStrategy: Swift.String? = nil,
            spotInstancePools: Swift.Int = 0,
            spotMaxPrice: Swift.String? = nil
        )
        {
            self.onDemandAllocationStrategy = onDemandAllocationStrategy
            self.onDemandBaseCapacity = onDemandBaseCapacity
            self.onDemandPercentageAboveBaseCapacity = onDemandPercentageAboveBaseCapacity
            self.spotAllocationStrategy = spotAllocationStrategy
            self.spotInstancePools = spotInstancePools
            self.spotMaxPrice = spotMaxPrice
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchTemplateSpecification = "LaunchTemplateSpecification"
        case overrides = "Overrides"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchTemplateSpecification = self.launchTemplateSpecification {
            try encodeContainer.encode(launchTemplateSpecification, forKey: .launchTemplateSpecification)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for awsautoscalingautoscalinggroupmixedinstancespolicylaunchtemplateoverrideslistdetails0 in overrides {
                try overridesContainer.encode(awsautoscalingautoscalinggroupmixedinstancespolicylaunchtemplateoverrideslistdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateSpecificationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification.self, forKey: .launchTemplateSpecification)
        launchTemplateSpecification = launchTemplateSpecificationDecoded
        let overridesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails?].self, forKey: .overrides)
        var overridesDecoded0:[SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Describes a launch template and overrides for a mixed instances policy.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails: Swift.Equatable {
        /// The launch template to use for a mixed instances policy.
        public var launchTemplateSpecification: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification?
        /// Property values to use to override the values in the launch template.
        public var overrides: [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]?

        public init (
            launchTemplateSpecification: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification? = nil,
            overrides: [SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails]? = nil
        )
        {
            self.launchTemplateSpecification = launchTemplateSpecification
            self.overrides = overrides
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchTemplateId = "LaunchTemplateId"
        case launchTemplateName = "LaunchTemplateName"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchTemplateId = self.launchTemplateId {
            try encodeContainer.encode(launchTemplateId, forKey: .launchTemplateId)
        }
        if let launchTemplateName = self.launchTemplateName {
            try encodeContainer.encode(launchTemplateName, forKey: .launchTemplateName)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateId)
        launchTemplateId = launchTemplateIdDecoded
        let launchTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateName)
        launchTemplateName = launchTemplateNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the launch template to use for a mixed instances policy.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification: Swift.Equatable {
        /// The identifier of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public var launchTemplateId: Swift.String?
        /// The name of the launch template. You must specify either LaunchTemplateId or LaunchTemplateName.
        public var launchTemplateName: Swift.String?
        /// Identifies the version of the launch template. You can specify a version identifier, or use the values $Latest or $Default.
        public var version: Swift.String?

        public init (
            launchTemplateId: Swift.String? = nil,
            launchTemplateName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.version = version
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceType = "InstanceType"
        case weightedCapacity = "WeightedCapacity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let weightedCapacity = self.weightedCapacity {
            try encodeContainer.encode(weightedCapacity, forKey: .weightedCapacity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let weightedCapacityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .weightedCapacity)
        weightedCapacity = weightedCapacityDecoded
    }
}

extension SecurityHubClientTypes {
    /// Property values to use to override the values in the launch template.
    public struct AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails: Swift.Equatable {
        /// The instance type. For example, m3.xlarge.
        public var instanceType: Swift.String?
        /// The number of capacity units provided by the specified instance type in terms of virtual CPUs, memory, storage, throughput, or other relative performance characteristic.
        public var weightedCapacity: Swift.String?

        public init (
            instanceType: Swift.String? = nil,
            weightedCapacity: Swift.String? = nil
        )
        {
            self.instanceType = instanceType
            self.weightedCapacity = weightedCapacity
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName = "DeviceName"
        case ebs = "Ebs"
        case noDevice = "NoDevice"
        case virtualName = "VirtualName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = self.ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
        if noDevice != false {
            try encodeContainer.encode(noDevice, forKey: .noDevice)
        }
        if let virtualName = self.virtualName {
            try encodeContainer.encode(virtualName, forKey: .virtualName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails.self, forKey: .ebs)
        ebs = ebsDecoded
        let noDeviceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noDevice) ?? false
        noDevice = noDeviceDecoded
        let virtualNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualName)
        virtualName = virtualNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// A block device for the instance.
    public struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails: Swift.Equatable {
        /// The device name that is exposed to the EC2 instance. For example, /dev/sdh or xvdh.
        public var deviceName: Swift.String?
        /// Parameters that are used to automatically set up Amazon EBS volumes when an instance is launched.
        public var ebs: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails?
        /// Whether to suppress the device that is included in the block device mapping of the Amazon Machine Image (AMI). If NoDevice is true, then you cannot specify Ebs.>
        public var noDevice: Swift.Bool
        /// The name of the virtual device (for example, ephemeral0). You can provide either VirtualName or Ebs, but not both.
        public var virtualName: Swift.String?

        public init (
            deviceName: Swift.String? = nil,
            ebs: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails? = nil,
            noDevice: Swift.Bool = false,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteOnTermination = "DeleteOnTermination"
        case encrypted = "Encrypted"
        case iops = "Iops"
        case snapshotId = "SnapshotId"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteOnTermination != false {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if encrypted != false {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if volumeSize != 0 {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination) ?? false
        deleteOnTermination = deleteOnTerminationDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted) ?? false
        encrypted = encryptedDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops) ?? 0
        iops = iopsDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize) ?? 0
        volumeSize = volumeSizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Parameters that are used to automatically set up EBS volumes when an instance is launched.
    public struct AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails: Swift.Equatable {
        /// Whether to delete the volume when the instance is terminated.
        public var deleteOnTermination: Swift.Bool
        /// Whether to encrypt the volume.
        public var encrypted: Swift.Bool
        /// The number of input/output (I/O) operations per second (IOPS) to provision for the volume. Only supported for gp3 or io1 volumes. Required for io1 volumes. Not used with standard, gp2, st1, or sc1 volumes.
        public var iops: Swift.Int
        /// The snapshot ID of the volume to use. You must specify either VolumeSize or SnapshotId.
        public var snapshotId: Swift.String?
        /// The volume size, in GiBs. The following are the supported volumes sizes for each volume type:
        ///
        /// * gp2 and gp3: 1-16,384
        ///
        /// * io1: 4-16,384
        ///
        /// * st1 and sc1: 125-16,384
        ///
        /// * standard: 1-1,024
        ///
        ///
        /// You must specify either SnapshotId or VolumeSize. If you specify both SnapshotId and VolumeSize, the volume size must be equal or greater than the size of the snapshot.
        public var volumeSize: Swift.Int
        /// The volume type. Valid values are as follows:
        ///
        /// * gp2
        ///
        /// * gp3
        ///
        /// * io1
        ///
        /// * sc1
        ///
        /// * st1
        ///
        /// * standard
        public var volumeType: Swift.String?

        public init (
            deleteOnTermination: Swift.Bool = false,
            encrypted: Swift.Bool = false,
            iops: Swift.Int = 0,
            snapshotId: Swift.String? = nil,
            volumeSize: Swift.Int = 0,
            volumeType: Swift.String? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.snapshotId = snapshotId
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case blockDeviceMappings = "BlockDeviceMappings"
        case classicLinkVpcId = "ClassicLinkVpcId"
        case classicLinkVpcSecurityGroups = "ClassicLinkVpcSecurityGroups"
        case createdTime = "CreatedTime"
        case ebsOptimized = "EbsOptimized"
        case iamInstanceProfile = "IamInstanceProfile"
        case imageId = "ImageId"
        case instanceMonitoring = "InstanceMonitoring"
        case instanceType = "InstanceType"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case launchConfigurationName = "LaunchConfigurationName"
        case metadataOptions = "MetadataOptions"
        case placementTenancy = "PlacementTenancy"
        case ramdiskId = "RamdiskId"
        case securityGroups = "SecurityGroups"
        case spotPrice = "SpotPrice"
        case userData = "UserData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if associatePublicIpAddress != false {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for awsautoscalinglaunchconfigurationblockdevicemappingsdetails0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(awsautoscalinglaunchconfigurationblockdevicemappingsdetails0)
            }
        }
        if let classicLinkVpcId = self.classicLinkVpcId {
            try encodeContainer.encode(classicLinkVpcId, forKey: .classicLinkVpcId)
        }
        if let classicLinkVpcSecurityGroups = classicLinkVpcSecurityGroups {
            var classicLinkVpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .classicLinkVpcSecurityGroups)
            for nonemptystring0 in classicLinkVpcSecurityGroups {
                try classicLinkVpcSecurityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if ebsOptimized != false {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let iamInstanceProfile = self.iamInstanceProfile {
            try encodeContainer.encode(iamInstanceProfile, forKey: .iamInstanceProfile)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let instanceMonitoring = self.instanceMonitoring {
            try encodeContainer.encode(instanceMonitoring, forKey: .instanceMonitoring)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let kernelId = self.kernelId {
            try encodeContainer.encode(kernelId, forKey: .kernelId)
        }
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let launchConfigurationName = self.launchConfigurationName {
            try encodeContainer.encode(launchConfigurationName, forKey: .launchConfigurationName)
        }
        if let metadataOptions = self.metadataOptions {
            try encodeContainer.encode(metadataOptions, forKey: .metadataOptions)
        }
        if let placementTenancy = self.placementTenancy {
            try encodeContainer.encode(placementTenancy, forKey: .placementTenancy)
        }
        if let ramdiskId = self.ramdiskId {
            try encodeContainer.encode(ramdiskId, forKey: .ramdiskId)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for nonemptystring0 in securityGroups {
                try securityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let spotPrice = self.spotPrice {
            try encodeContainer.encode(spotPrice, forKey: .spotPrice)
        }
        if let userData = self.userData {
            try encodeContainer.encode(userData, forKey: .userData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress) ?? false
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let classicLinkVpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classicLinkVpcId)
        classicLinkVpcId = classicLinkVpcIdDecoded
        let classicLinkVpcSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .classicLinkVpcSecurityGroups)
        var classicLinkVpcSecurityGroupsDecoded0:[Swift.String]? = nil
        if let classicLinkVpcSecurityGroupsContainer = classicLinkVpcSecurityGroupsContainer {
            classicLinkVpcSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in classicLinkVpcSecurityGroupsContainer {
                if let string0 = string0 {
                    classicLinkVpcSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        classicLinkVpcSecurityGroups = classicLinkVpcSecurityGroupsDecoded0
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized) ?? false
        ebsOptimized = ebsOptimizedDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceMonitoringDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails.self, forKey: .instanceMonitoring)
        instanceMonitoring = instanceMonitoringDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let kernelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let launchConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationName)
        launchConfigurationName = launchConfigurationNameDecoded
        let placementTenancyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementTenancy)
        placementTenancy = placementTenancyDecoded
        let ramdiskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ramdiskId)
        ramdiskId = ramdiskIdDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let spotPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spotPrice)
        spotPrice = spotPriceDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userData)
        userData = userDataDecoded
        let metadataOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions.self, forKey: .metadataOptions)
        metadataOptions = metadataOptionsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about a launch configuration.
    public struct AwsAutoScalingLaunchConfigurationDetails: Swift.Equatable {
        /// For Auto Scaling groups that run in a VPC, specifies whether to assign a public IP address to the group's instances.
        public var associatePublicIpAddress: Swift.Bool
        /// Specifies the block devices for the instance.
        public var blockDeviceMappings: [SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]?
        /// The identifier of a ClassicLink-enabled VPC that EC2-Classic instances are linked to.
        public var classicLinkVpcId: Swift.String?
        /// The identifiers of one or more security groups for the VPC that is specified in ClassicLinkVPCId.
        public var classicLinkVpcSecurityGroups: [Swift.String]?
        /// The creation date and time for the launch configuration. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdTime: Swift.String?
        /// Whether the launch configuration is optimized for Amazon EBS I/O.
        public var ebsOptimized: Swift.Bool
        /// The name or the ARN of the instance profile associated with the IAM role for the instance. The instance profile contains the IAM role.
        public var iamInstanceProfile: Swift.String?
        /// The identifier of the Amazon Machine Image (AMI) that is used to launch EC2 instances.
        public var imageId: Swift.String?
        /// Indicates the type of monitoring for instances in the group.
        public var instanceMonitoring: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails?
        /// The instance type for the instances.
        public var instanceType: Swift.String?
        /// The identifier of the kernel associated with the AMI.
        public var kernelId: Swift.String?
        /// The name of the key pair.
        public var keyName: Swift.String?
        /// The name of the launch configuration.
        public var launchConfigurationName: Swift.String?
        /// The metadata options for the instances.
        public var metadataOptions: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions?
        /// The tenancy of the instance. An instance with dedicated tenancy runs on isolated, single-tenant hardware and can only be launched into a VPC.
        public var placementTenancy: Swift.String?
        /// The identifier of the RAM disk associated with the AMI.
        public var ramdiskId: Swift.String?
        /// The security groups to assign to the instances in the Auto Scaling group.
        public var securityGroups: [Swift.String]?
        /// The maximum hourly price to be paid for any Spot Instance that is launched to fulfill the request.
        public var spotPrice: Swift.String?
        /// The user data to make available to the launched EC2 instances. Must be base64-encoded text.
        public var userData: Swift.String?

        public init (
            associatePublicIpAddress: Swift.Bool = false,
            blockDeviceMappings: [SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails]? = nil,
            classicLinkVpcId: Swift.String? = nil,
            classicLinkVpcSecurityGroups: [Swift.String]? = nil,
            createdTime: Swift.String? = nil,
            ebsOptimized: Swift.Bool = false,
            iamInstanceProfile: Swift.String? = nil,
            imageId: Swift.String? = nil,
            instanceMonitoring: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails? = nil,
            instanceType: Swift.String? = nil,
            kernelId: Swift.String? = nil,
            keyName: Swift.String? = nil,
            launchConfigurationName: Swift.String? = nil,
            metadataOptions: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions? = nil,
            placementTenancy: Swift.String? = nil,
            ramdiskId: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            spotPrice: Swift.String? = nil,
            userData: Swift.String? = nil
        )
        {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.blockDeviceMappings = blockDeviceMappings
            self.classicLinkVpcId = classicLinkVpcId
            self.classicLinkVpcSecurityGroups = classicLinkVpcSecurityGroups
            self.createdTime = createdTime
            self.ebsOptimized = ebsOptimized
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceMonitoring = instanceMonitoring
            self.instanceType = instanceType
            self.kernelId = kernelId
            self.keyName = keyName
            self.launchConfigurationName = launchConfigurationName
            self.metadataOptions = metadataOptions
            self.placementTenancy = placementTenancy
            self.ramdiskId = ramdiskId
            self.securityGroups = securityGroups
            self.spotPrice = spotPrice
            self.userData = userData
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the type of monitoring for instances in the group.
    public struct AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails: Swift.Equatable {
        /// If set to true, then instances in the group launch with detailed monitoring. If set to false, then instances in the group launch with basic monitoring.
        public var enabled: Swift.Bool

        public init (
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationMetadataOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpEndpoint = "HttpEndpoint"
        case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
        case httpTokens = "HttpTokens"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpEndpoint = self.httpEndpoint {
            try encodeContainer.encode(httpEndpoint, forKey: .httpEndpoint)
        }
        if httpPutResponseHopLimit != 0 {
            try encodeContainer.encode(httpPutResponseHopLimit, forKey: .httpPutResponseHopLimit)
        }
        if let httpTokens = self.httpTokens {
            try encodeContainer.encode(httpTokens, forKey: .httpTokens)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpEndpoint)
        httpEndpoint = httpEndpointDecoded
        let httpPutResponseHopLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpPutResponseHopLimit) ?? 0
        httpPutResponseHopLimit = httpPutResponseHopLimitDecoded
        let httpTokensDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpTokens)
        httpTokens = httpTokensDecoded
    }
}

extension SecurityHubClientTypes {
    /// The metadata options for the instances.
    public struct AwsAutoScalingLaunchConfigurationMetadataOptions: Swift.Equatable {
        /// Enables or disables the HTTP metadata endpoint on your instances. By default, the metadata endpoint is enabled.
        public var httpEndpoint: Swift.String?
        /// The HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        public var httpPutResponseHopLimit: Swift.Int
        /// Indicates whether token usage is required or optional for metadata requests. By default, token usage is optional.
        public var httpTokens: Swift.String?

        public init (
            httpEndpoint: Swift.String? = nil,
            httpPutResponseHopLimit: Swift.Int = 0,
            httpTokens: Swift.String? = nil
        )
        {
            self.httpEndpoint = httpEndpoint
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }
    }

}

extension SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupOptions = "BackupOptions"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupOptions = backupOptions {
            var backupOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .backupOptions)
            for (dictKey0, fieldMap0) in backupOptions {
                try backupOptionsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .backupOptions)
        var backupOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let backupOptionsContainer = backupOptionsContainer {
            backupOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in backupOptionsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    backupOptionsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        backupOptions = backupOptionsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides a list of backup options for each resource type.
    public struct AwsBackupBackupPlanAdvancedBackupSettingsDetails: Swift.Equatable {
        /// Specifies the backup option for a selected resource. This option is only available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid values are as follows:
        ///
        /// * Set to WindowsVSS: enabled to enable the WindowsVSS backup option and create a Windows VSS backup.
        ///
        /// * Set to WindowsVSS: disabled to create a regular backup. The WindowsVSS option is not enabled by default.
        public var backupOptions: [Swift.String:Swift.String]?
        /// The name of a resource type. The only supported resource type is Amazon EC2 instances with Windows VSS. The only valid value is EC2.
        public var resourceType: Swift.String?

        public init (
            backupOptions: [Swift.String:Swift.String]? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.backupOptions = backupOptions
            self.resourceType = resourceType
        }
    }

}

extension SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case advancedBackupSettings = "AdvancedBackupSettings"
        case backupPlanName = "BackupPlanName"
        case backupPlanRule = "BackupPlanRule"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedBackupSettings = advancedBackupSettings {
            var advancedBackupSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedBackupSettings)
            for awsbackupbackupplanadvancedbackupsettingsdetails0 in advancedBackupSettings {
                try advancedBackupSettingsContainer.encode(awsbackupbackupplanadvancedbackupsettingsdetails0)
            }
        }
        if let backupPlanName = self.backupPlanName {
            try encodeContainer.encode(backupPlanName, forKey: .backupPlanName)
        }
        if let backupPlanRule = backupPlanRule {
            var backupPlanRuleContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backupPlanRule)
            for awsbackupbackupplanruledetails0 in backupPlanRule {
                try backupPlanRuleContainer.encode(awsbackupbackupplanruledetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanName)
        backupPlanName = backupPlanNameDecoded
        let advancedBackupSettingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails?].self, forKey: .advancedBackupSettings)
        var advancedBackupSettingsDecoded0:[SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails]? = nil
        if let advancedBackupSettingsContainer = advancedBackupSettingsContainer {
            advancedBackupSettingsDecoded0 = [SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails]()
            for structure0 in advancedBackupSettingsContainer {
                if let structure0 = structure0 {
                    advancedBackupSettingsDecoded0?.append(structure0)
                }
            }
        }
        advancedBackupSettings = advancedBackupSettingsDecoded0
        let backupPlanRuleContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails?].self, forKey: .backupPlanRule)
        var backupPlanRuleDecoded0:[SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails]? = nil
        if let backupPlanRuleContainer = backupPlanRuleContainer {
            backupPlanRuleDecoded0 = [SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails]()
            for structure0 in backupPlanRuleContainer {
                if let structure0 = structure0 {
                    backupPlanRuleDecoded0?.append(structure0)
                }
            }
        }
        backupPlanRule = backupPlanRuleDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an Backup backup plan and an array of BackupRule objects, each of which specifies a backup rule.
    public struct AwsBackupBackupPlanBackupPlanDetails: Swift.Equatable {
        /// A list of backup options for each resource type.
        public var advancedBackupSettings: [SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails]?
        /// The display name of a backup plan.
        public var backupPlanName: Swift.String?
        /// An array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
        public var backupPlanRule: [SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails]?

        public init (
            advancedBackupSettings: [SecurityHubClientTypes.AwsBackupBackupPlanAdvancedBackupSettingsDetails]? = nil,
            backupPlanName: Swift.String? = nil,
            backupPlanRule: [SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails]? = nil
        )
        {
            self.advancedBackupSettings = advancedBackupSettings
            self.backupPlanName = backupPlanName
            self.backupPlanRule = backupPlanRule
        }
    }

}

extension SecurityHubClientTypes.AwsBackupBackupPlanDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlan = "BackupPlan"
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlan = self.backupPlan {
            try encodeContainer.encode(backupPlan, forKey: .backupPlan)
        }
        if let backupPlanArn = self.backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = self.backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails.self, forKey: .backupPlan)
        backupPlan = backupPlanDecoded
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an Backup backup plan and an array of BackupRule objects, each of which specifies a backup rule.
    public struct AwsBackupBackupPlanDetails: Swift.Equatable {
        /// Uniquely identifies the backup plan to be associated with the selection of resources.
        public var backupPlan: SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails?
        /// An Amazon Resource Name (ARN) that uniquely identifies the backup plan.
        public var backupPlanArn: Swift.String?
        /// A unique ID for the backup plan.
        public var backupPlanId: Swift.String?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings. Version IDs cannot be edited.
        public var versionId: Swift.String?

        public init (
            backupPlan: SecurityHubClientTypes.AwsBackupBackupPlanBackupPlanDetails? = nil,
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.backupPlan = backupPlan
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.versionId = versionId
        }
    }

}

extension SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAfterDays = "DeleteAfterDays"
        case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteAfterDays != 0 {
            try encodeContainer.encode(deleteAfterDays, forKey: .deleteAfterDays)
        }
        if moveToColdStorageAfterDays != 0 {
            try encodeContainer.encode(moveToColdStorageAfterDays, forKey: .moveToColdStorageAfterDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deleteAfterDays) ?? 0
        deleteAfterDays = deleteAfterDaysDecoded
        let moveToColdStorageAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .moveToColdStorageAfterDays) ?? 0
        moveToColdStorageAfterDays = moveToColdStorageAfterDaysDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides lifecycle details for the backup plan. A lifecycle defines when a backup is transitioned to cold storage and when it expires.
    public struct AwsBackupBackupPlanLifecycleDetails: Swift.Equatable {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public var deleteAfterDays: Swift.Int
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAfterDays: Swift.Int

        public init (
            deleteAfterDays: Swift.Int = 0,
            moveToColdStorageAfterDays: Swift.Int = 0
        )
        {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }
    }

}

extension SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBackupVaultArn = "DestinationBackupVaultArn"
        case lifecycle = "Lifecycle"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBackupVaultArn = self.destinationBackupVaultArn {
            try encodeContainer.encode(destinationBackupVaultArn, forKey: .destinationBackupVaultArn)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBackupVaultArn)
        destinationBackupVaultArn = destinationBackupVaultArnDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension SecurityHubClientTypes {
    /// An array of CopyAction objects, each of which contains details of the copy operation.
    public struct AwsBackupBackupPlanRuleCopyActionsDetails: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies the destination backup vault for the copied backup.
        public var destinationBackupVaultArn: Swift.String?
        /// Defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. If you do not specify a lifecycle, Backup applies the lifecycle policy of the source backup to the destination backup. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days.
        public var lifecycle: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails?

        public init (
            destinationBackupVaultArn: Swift.String? = nil,
            lifecycle: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails? = nil
        )
        {
            self.destinationBackupVaultArn = destinationBackupVaultArn
            self.lifecycle = lifecycle
        }
    }

}

extension SecurityHubClientTypes.AwsBackupBackupPlanRuleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionWindowMinutes = "CompletionWindowMinutes"
        case copyActions = "CopyActions"
        case enableContinuousBackup = "EnableContinuousBackup"
        case lifecycle = "Lifecycle"
        case ruleId = "RuleId"
        case ruleName = "RuleName"
        case scheduleExpression = "ScheduleExpression"
        case startWindowMinutes = "StartWindowMinutes"
        case targetBackupVault = "TargetBackupVault"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if completionWindowMinutes != 0 {
            try encodeContainer.encode(completionWindowMinutes, forKey: .completionWindowMinutes)
        }
        if let copyActions = copyActions {
            var copyActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyActions)
            for awsbackupbackupplanrulecopyactionsdetails0 in copyActions {
                try copyActionsContainer.encode(awsbackupbackupplanrulecopyactionsdetails0)
            }
        }
        if enableContinuousBackup != false {
            try encodeContainer.encode(enableContinuousBackup, forKey: .enableContinuousBackup)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if startWindowMinutes != 0 {
            try encodeContainer.encode(startWindowMinutes, forKey: .startWindowMinutes)
        }
        if let targetBackupVault = self.targetBackupVault {
            try encodeContainer.encode(targetBackupVault, forKey: .targetBackupVault)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetBackupVaultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetBackupVault)
        targetBackupVault = targetBackupVaultDecoded
        let startWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startWindowMinutes) ?? 0
        startWindowMinutes = startWindowMinutesDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let enableContinuousBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableContinuousBackup) ?? false
        enableContinuousBackup = enableContinuousBackupDecoded
        let completionWindowMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .completionWindowMinutes) ?? 0
        completionWindowMinutes = completionWindowMinutesDecoded
        let copyActionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails?].self, forKey: .copyActions)
        var copyActionsDecoded0:[SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails]? = nil
        if let copyActionsContainer = copyActionsContainer {
            copyActionsDecoded0 = [SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails]()
            for structure0 in copyActionsContainer {
                if let structure0 = structure0 {
                    copyActionsDecoded0?.append(structure0)
                }
            }
        }
        copyActions = copyActionsDecoded0
        let lifecycleDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an array of BackupRule objects, each of which specifies a scheduled task that is used to back up a selection of resources.
    public struct AwsBackupBackupPlanRuleDetails: Swift.Equatable {
        /// A value in minutes after a backup job is successfully started before it must be completed, or it is canceled by Backup.
        public var completionWindowMinutes: Swift.Int
        /// An array of CopyAction objects, each of which contains details of the copy operation.
        public var copyActions: [SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails]?
        /// Specifies whether Backup creates continuous backups capable of point-in-time restore (PITR).
        public var enableContinuousBackup: Swift.Bool
        /// Defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define. If you do not specify a lifecycle, Backup applies the lifecycle policy of the source backup to the destination backup. Backups transitioned to cold storage must be stored in cold storage for a minimum of 90 days.
        public var lifecycle: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails?
        /// Uniquely identifies a rule that is used to schedule the backup of a selection of resources.
        public var ruleId: Swift.String?
        /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.' characters.
        public var ruleName: Swift.String?
        /// A cron expression in UTC specifying when Backup initiates a backup job.
        public var scheduleExpression: Swift.String?
        /// A value in minutes after a backup is scheduled before a job will be canceled if it doesn't start successfully.
        public var startWindowMinutes: Swift.Int
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region where they are created. They consist of letters, numbers, and hyphens.
        public var targetBackupVault: Swift.String?

        public init (
            completionWindowMinutes: Swift.Int = 0,
            copyActions: [SecurityHubClientTypes.AwsBackupBackupPlanRuleCopyActionsDetails]? = nil,
            enableContinuousBackup: Swift.Bool = false,
            lifecycle: SecurityHubClientTypes.AwsBackupBackupPlanLifecycleDetails? = nil,
            ruleId: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            scheduleExpression: Swift.String? = nil,
            startWindowMinutes: Swift.Int = 0,
            targetBackupVault: Swift.String? = nil
        )
        {
            self.completionWindowMinutes = completionWindowMinutes
            self.copyActions = copyActions
            self.enableContinuousBackup = enableContinuousBackup
            self.lifecycle = lifecycle
            self.ruleId = ruleId
            self.ruleName = ruleName
            self.scheduleExpression = scheduleExpression
            self.startWindowMinutes = startWindowMinutes
            self.targetBackupVault = targetBackupVault
        }
    }

}

extension SecurityHubClientTypes.AwsBackupBackupVaultDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicy = "AccessPolicy"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case encryptionKeyArn = "EncryptionKeyArn"
        case notifications = "Notifications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicy = self.accessPolicy {
            try encodeContainer.encode(accessPolicy, forKey: .accessPolicy)
        }
        if let backupVaultArn = self.backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let notifications = self.notifications {
            try encodeContainer.encode(notifications, forKey: .notifications)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let notificationsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails.self, forKey: .notifications)
        notifications = notificationsDecoded
        let accessPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicy)
        accessPolicy = accessPolicyDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an Backup backup vault. In Backup, a backup vault is a container that stores and organizes your backups.
    public struct AwsBackupBackupVaultDetails: Swift.Equatable {
        /// A resource-based policy that is used to manage access permissions on the target backup vault.
        public var accessPolicy: Swift.String?
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// The unique ARN associated with the server-side encryption key. You can specify a key to encrypt your backups from services that support full Backup management. If you do not specify a key, Backup creates an KMS key for you by default.
        public var encryptionKeyArn: Swift.String?
        /// The Amazon SNS event notifications for the specified backup vault.
        public var notifications: SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails?

        public init (
            accessPolicy: Swift.String? = nil,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            notifications: SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails? = nil
        )
        {
            self.accessPolicy = accessPolicy
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.encryptionKeyArn = encryptionKeyArn
            self.notifications = notifications
        }
    }

}

extension SecurityHubClientTypes.AwsBackupBackupVaultNotificationsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupVaultEvents = "BackupVaultEvents"
        case snsTopicArn = "SnsTopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupVaultEvents = backupVaultEvents {
            var backupVaultEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backupVaultEvents)
            for nonemptystring0 in backupVaultEvents {
                try backupVaultEventsContainer.encode(nonemptystring0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupVaultEventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .backupVaultEvents)
        var backupVaultEventsDecoded0:[Swift.String]? = nil
        if let backupVaultEventsContainer = backupVaultEventsContainer {
            backupVaultEventsDecoded0 = [Swift.String]()
            for string0 in backupVaultEventsContainer {
                if let string0 = string0 {
                    backupVaultEventsDecoded0?.append(string0)
                }
            }
        }
        backupVaultEvents = backupVaultEventsDecoded0
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the Amazon SNS event notifications for the specified backup vault.
    public struct AwsBackupBackupVaultNotificationsDetails: Swift.Equatable {
        /// An array of events that indicate the status of jobs to back up resources to the backup vault. The following events are supported:
        ///
        /// * BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED
        ///
        /// * COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED
        ///
        /// * RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED | RECOVERY_POINT_MODIFIED
        ///
        /// * S3_BACKUP_OBJECT_FAILED | S3_RESTORE_OBJECT_FAILED
        public var backupVaultEvents: [Swift.String]?
        /// An ARN that uniquely identifies the Amazon SNS topic for a backup vaults events.
        public var snsTopicArn: Swift.String?

        public init (
            backupVaultEvents: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil
        )
        {
            self.backupVaultEvents = backupVaultEvents
            self.snsTopicArn = snsTopicArn
        }
    }

}

extension SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAt = "DeleteAt"
        case moveToColdStorageAt = "MoveToColdStorageAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAt = self.deleteAt {
            try encodeContainer.encode(deleteAt, forKey: .deleteAt)
        }
        if let moveToColdStorageAt = self.moveToColdStorageAt {
            try encodeContainer.encode(moveToColdStorageAt, forKey: .moveToColdStorageAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deleteAt)
        deleteAt = deleteAtDecoded
        let moveToColdStorageAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .moveToColdStorageAt)
        moveToColdStorageAt = moveToColdStorageAtDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies how long in days before a recovery point transitions to cold storage or is deleted.
    public struct AwsBackupRecoveryPointCalculatedLifecycleDetails: Swift.Equatable {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public var deleteAt: Swift.String?
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAt: Swift.String?

        public init (
            deleteAt: Swift.String? = nil,
            moveToColdStorageAt: Swift.String? = nil
        )
        {
            self.deleteAt = deleteAt
            self.moveToColdStorageAt = moveToColdStorageAt
        }
    }

}

extension SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPlanArn = "BackupPlanArn"
        case backupPlanId = "BackupPlanId"
        case backupPlanVersion = "BackupPlanVersion"
        case backupRuleId = "BackupRuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPlanArn = self.backupPlanArn {
            try encodeContainer.encode(backupPlanArn, forKey: .backupPlanArn)
        }
        if let backupPlanId = self.backupPlanId {
            try encodeContainer.encode(backupPlanId, forKey: .backupPlanId)
        }
        if let backupPlanVersion = self.backupPlanVersion {
            try encodeContainer.encode(backupPlanVersion, forKey: .backupPlanVersion)
        }
        if let backupRuleId = self.backupRuleId {
            try encodeContainer.encode(backupRuleId, forKey: .backupRuleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanArn)
        backupPlanArn = backupPlanArnDecoded
        let backupPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanId)
        backupPlanId = backupPlanIdDecoded
        let backupPlanVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupPlanVersion)
        backupPlanVersion = backupPlanVersionDecoded
        let backupRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupRuleId)
        backupRuleId = backupRuleIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the backup plan and rule that Backup used to initiate the recovery point backup.
    public struct AwsBackupRecoveryPointCreatedByDetails: Swift.Equatable {
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan.
        public var backupPlanArn: Swift.String?
        /// Uniquely identifies a backup plan.
        public var backupPlanId: Swift.String?
        /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most 1,024 bytes long. Version IDs cannot be edited.
        public var backupPlanVersion: Swift.String?
        /// Uniquely identifies a rule used to schedule the backup of a selection of resources.
        public var backupRuleId: Swift.String?

        public init (
            backupPlanArn: Swift.String? = nil,
            backupPlanId: Swift.String? = nil,
            backupPlanVersion: Swift.String? = nil,
            backupRuleId: Swift.String? = nil
        )
        {
            self.backupPlanArn = backupPlanArn
            self.backupPlanId = backupPlanId
            self.backupPlanVersion = backupPlanVersion
            self.backupRuleId = backupRuleId
        }
    }

}

extension SecurityHubClientTypes.AwsBackupRecoveryPointDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupSizeInBytes = "BackupSizeInBytes"
        case backupVaultArn = "BackupVaultArn"
        case backupVaultName = "BackupVaultName"
        case calculatedLifecycle = "CalculatedLifecycle"
        case completionDate = "CompletionDate"
        case createdBy = "CreatedBy"
        case creationDate = "CreationDate"
        case encryptionKeyArn = "EncryptionKeyArn"
        case iamRoleArn = "IamRoleArn"
        case isEncrypted = "IsEncrypted"
        case lastRestoreTime = "LastRestoreTime"
        case lifecycle = "Lifecycle"
        case recoveryPointArn = "RecoveryPointArn"
        case resourceArn = "ResourceArn"
        case resourceType = "ResourceType"
        case sourceBackupVaultArn = "SourceBackupVaultArn"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backupSizeInBytes != 0 {
            try encodeContainer.encode(backupSizeInBytes, forKey: .backupSizeInBytes)
        }
        if let backupVaultArn = self.backupVaultArn {
            try encodeContainer.encode(backupVaultArn, forKey: .backupVaultArn)
        }
        if let backupVaultName = self.backupVaultName {
            try encodeContainer.encode(backupVaultName, forKey: .backupVaultName)
        }
        if let calculatedLifecycle = self.calculatedLifecycle {
            try encodeContainer.encode(calculatedLifecycle, forKey: .calculatedLifecycle)
        }
        if let completionDate = self.completionDate {
            try encodeContainer.encode(completionDate, forKey: .completionDate)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let encryptionKeyArn = self.encryptionKeyArn {
            try encodeContainer.encode(encryptionKeyArn, forKey: .encryptionKeyArn)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if isEncrypted != false {
            try encodeContainer.encode(isEncrypted, forKey: .isEncrypted)
        }
        if let lastRestoreTime = self.lastRestoreTime {
            try encodeContainer.encode(lastRestoreTime, forKey: .lastRestoreTime)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let recoveryPointArn = self.recoveryPointArn {
            try encodeContainer.encode(recoveryPointArn, forKey: .recoveryPointArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let sourceBackupVaultArn = self.sourceBackupVaultArn {
            try encodeContainer.encode(sourceBackupVaultArn, forKey: .sourceBackupVaultArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass, forKey: .storageClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupSizeInBytes) ?? 0
        backupSizeInBytes = backupSizeInBytesDecoded
        let backupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultArn)
        backupVaultArn = backupVaultArnDecoded
        let backupVaultNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupVaultName)
        backupVaultName = backupVaultNameDecoded
        let calculatedLifecycleDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails.self, forKey: .calculatedLifecycle)
        calculatedLifecycle = calculatedLifecycleDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let encryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKeyArn)
        encryptionKeyArn = encryptionKeyArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let isEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEncrypted) ?? false
        isEncrypted = isEncryptedDecoded
        let lastRestoreTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRestoreTime)
        lastRestoreTime = lastRestoreTimeDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let recoveryPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryPointArn)
        recoveryPointArn = recoveryPointArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let sourceBackupVaultArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupVaultArn)
        sourceBackupVaultArn = sourceBackupVaultArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains detailed information about the recovery points stored in an Backup backup vault. A backup, or recovery point, represents the content of a resource at a specified time.
    public struct AwsBackupRecoveryPointDetails: Swift.Equatable {
        /// The size, in bytes, of a backup.
        public var backupSizeInBytes: Swift.Int
        /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
        public var backupVaultArn: Swift.String?
        /// The name of a logical container where backups are stored. Backup vaults are identified by names that are unique to the Amazon Web Services account used to create them and the Amazon Web Services Region where they are created. They consist of lowercase letters, numbers, and hyphens.
        public var backupVaultName: Swift.String?
        /// A CalculatedLifecycle object containing DeleteAt and MoveToColdStorageAt timestamps.
        public var calculatedLifecycle: SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails?
        /// The date and time that a job to create a recovery point is completed, in Unix format and UTC. The value of CompletionDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var completionDate: Swift.String?
        /// Contains identifying information about the creation of a recovery point, including the BackupPlanArn, BackupPlanId, BackupPlanVersion, and BackupRuleId of the backup plan that is used to create it.
        public var createdBy: SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails?
        /// The date and time a recovery point is created, in Unix format and UTC. The value of CreationDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var creationDate: Swift.String?
        /// The ARN for the server-side encryption key that is used to protect your backups.
        public var encryptionKeyArn: Swift.String?
        /// Specifies the IAM role ARN used to create the target recovery point
        public var iamRoleArn: Swift.String?
        /// A Boolean value that is returned as TRUE if the specified recovery point is encrypted, or FALSE if the recovery point is not encrypted.
        public var isEncrypted: Swift.Bool
        /// The date and time that a recovery point was last restored, in Unix format and UTC. The value of LastRestoreTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var lastRestoreTime: Swift.String?
        /// The lifecycle defines when a protected resource is transitioned to cold storage and when it expires. Backup transitions and expires backups automatically according to the lifecycle that you define
        public var lifecycle: SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails?
        /// An ARN that uniquely identifies a recovery point.
        public var recoveryPointArn: Swift.String?
        /// An ARN that uniquely identifies a resource. The format of the ARN depends on the resource type.
        public var resourceArn: Swift.String?
        /// The type of Amazon Web Services resource saved as a recovery point, such as an Amazon EBS volume or an Amazon RDS database.
        public var resourceType: Swift.String?
        /// The ARN for the backup vault where the recovery point was originally copied from. If the recovery point is restored to the same account, this value will be null.
        public var sourceBackupVaultArn: Swift.String?
        /// A status code specifying the state of the recovery point. Valid values are as follows:
        ///
        /// * COMPLETED
        ///
        /// * DELETING
        ///
        /// * EXPIRED
        ///
        /// * PARTIAL
        public var status: Swift.String?
        /// A message explaining the reason of the recovery point deletion failure.
        public var statusMessage: Swift.String?
        /// Specifies the storage class of the recovery point. Valid values are as follows:
        ///
        /// * COLD
        ///
        /// * DELETED
        ///
        /// * WARM
        public var storageClass: Swift.String?

        public init (
            backupSizeInBytes: Swift.Int = 0,
            backupVaultArn: Swift.String? = nil,
            backupVaultName: Swift.String? = nil,
            calculatedLifecycle: SecurityHubClientTypes.AwsBackupRecoveryPointCalculatedLifecycleDetails? = nil,
            completionDate: Swift.String? = nil,
            createdBy: SecurityHubClientTypes.AwsBackupRecoveryPointCreatedByDetails? = nil,
            creationDate: Swift.String? = nil,
            encryptionKeyArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            isEncrypted: Swift.Bool = false,
            lastRestoreTime: Swift.String? = nil,
            lifecycle: SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails? = nil,
            recoveryPointArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            sourceBackupVaultArn: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            storageClass: Swift.String? = nil
        )
        {
            self.backupSizeInBytes = backupSizeInBytes
            self.backupVaultArn = backupVaultArn
            self.backupVaultName = backupVaultName
            self.calculatedLifecycle = calculatedLifecycle
            self.completionDate = completionDate
            self.createdBy = createdBy
            self.creationDate = creationDate
            self.encryptionKeyArn = encryptionKeyArn
            self.iamRoleArn = iamRoleArn
            self.isEncrypted = isEncrypted
            self.lastRestoreTime = lastRestoreTime
            self.lifecycle = lifecycle
            self.recoveryPointArn = recoveryPointArn
            self.resourceArn = resourceArn
            self.resourceType = resourceType
            self.sourceBackupVaultArn = sourceBackupVaultArn
            self.status = status
            self.statusMessage = statusMessage
            self.storageClass = storageClass
        }
    }

}

extension SecurityHubClientTypes.AwsBackupRecoveryPointLifecycleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAfterDays = "DeleteAfterDays"
        case moveToColdStorageAfterDays = "MoveToColdStorageAfterDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteAfterDays != 0 {
            try encodeContainer.encode(deleteAfterDays, forKey: .deleteAfterDays)
        }
        if moveToColdStorageAfterDays != 0 {
            try encodeContainer.encode(moveToColdStorageAfterDays, forKey: .moveToColdStorageAfterDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deleteAfterDays) ?? 0
        deleteAfterDays = deleteAfterDaysDecoded
        let moveToColdStorageAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .moveToColdStorageAfterDays) ?? 0
        moveToColdStorageAfterDays = moveToColdStorageAfterDaysDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains an array of Transition objects specifying how long in days before a recovery point transitions to cold storage or is deleted.
    public struct AwsBackupRecoveryPointLifecycleDetails: Swift.Equatable {
        /// Specifies the number of days after creation that a recovery point is deleted. Must be greater than 90 days plus MoveToColdStorageAfterDays.
        public var deleteAfterDays: Swift.Int
        /// Specifies the number of days after creation that a recovery point is moved to cold storage.
        public var moveToColdStorageAfterDays: Swift.Int

        public init (
            deleteAfterDays: Swift.Int = 0,
            moveToColdStorageAfterDays: Swift.Int = 0
        )
        {
            self.deleteAfterDays = deleteAfterDays
            self.moveToColdStorageAfterDays = moveToColdStorageAfterDays
        }
    }

}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case domainValidationOptions = "DomainValidationOptions"
        case extendedKeyUsages = "ExtendedKeyUsages"
        case failureReason = "FailureReason"
        case importedAt = "ImportedAt"
        case inUseBy = "InUseBy"
        case issuedAt = "IssuedAt"
        case issuer = "Issuer"
        case keyAlgorithm = "KeyAlgorithm"
        case keyUsages = "KeyUsages"
        case notAfter = "NotAfter"
        case notBefore = "NotBefore"
        case options = "Options"
        case renewalEligibility = "RenewalEligibility"
        case renewalSummary = "RenewalSummary"
        case serial = "Serial"
        case signatureAlgorithm = "SignatureAlgorithm"
        case status = "Status"
        case subject = "Subject"
        case subjectAlternativeNames = "SubjectAlternativeNames"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainValidationOptions = domainValidationOptions {
            var domainValidationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainValidationOptions)
            for awscertificatemanagercertificatedomainvalidationoption0 in domainValidationOptions {
                try domainValidationOptionsContainer.encode(awscertificatemanagercertificatedomainvalidationoption0)
            }
        }
        if let extendedKeyUsages = extendedKeyUsages {
            var extendedKeyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendedKeyUsages)
            for awscertificatemanagercertificateextendedkeyusage0 in extendedKeyUsages {
                try extendedKeyUsagesContainer.encode(awscertificatemanagercertificateextendedkeyusage0)
            }
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let importedAt = self.importedAt {
            try encodeContainer.encode(importedAt, forKey: .importedAt)
        }
        if let inUseBy = inUseBy {
            var inUseByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inUseBy)
            for nonemptystring0 in inUseBy {
                try inUseByContainer.encode(nonemptystring0)
            }
        }
        if let issuedAt = self.issuedAt {
            try encodeContainer.encode(issuedAt, forKey: .issuedAt)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let keyAlgorithm = self.keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm, forKey: .keyAlgorithm)
        }
        if let keyUsages = keyUsages {
            var keyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyUsages)
            for awscertificatemanagercertificatekeyusage0 in keyUsages {
                try keyUsagesContainer.encode(awscertificatemanagercertificatekeyusage0)
            }
        }
        if let notAfter = self.notAfter {
            try encodeContainer.encode(notAfter, forKey: .notAfter)
        }
        if let notBefore = self.notBefore {
            try encodeContainer.encode(notBefore, forKey: .notBefore)
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let renewalEligibility = self.renewalEligibility {
            try encodeContainer.encode(renewalEligibility, forKey: .renewalEligibility)
        }
        if let renewalSummary = self.renewalSummary {
            try encodeContainer.encode(renewalSummary, forKey: .renewalSummary)
        }
        if let serial = self.serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let signatureAlgorithm = self.signatureAlgorithm {
            try encodeContainer.encode(signatureAlgorithm, forKey: .signatureAlgorithm)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let subjectAlternativeNames = subjectAlternativeNames {
            var subjectAlternativeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNames)
            for nonemptystring0 in subjectAlternativeNames {
                try subjectAlternativeNamesContainer.encode(nonemptystring0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainValidationOptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption?].self, forKey: .domainValidationOptions)
        var domainValidationOptionsDecoded0:[SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]? = nil
        if let domainValidationOptionsContainer = domainValidationOptionsContainer {
            domainValidationOptionsDecoded0 = [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]()
            for structure0 in domainValidationOptionsContainer {
                if let structure0 = structure0 {
                    domainValidationOptionsDecoded0?.append(structure0)
                }
            }
        }
        domainValidationOptions = domainValidationOptionsDecoded0
        let extendedKeyUsagesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage?].self, forKey: .extendedKeyUsages)
        var extendedKeyUsagesDecoded0:[SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage]? = nil
        if let extendedKeyUsagesContainer = extendedKeyUsagesContainer {
            extendedKeyUsagesDecoded0 = [SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage]()
            for structure0 in extendedKeyUsagesContainer {
                if let structure0 = structure0 {
                    extendedKeyUsagesDecoded0?.append(structure0)
                }
            }
        }
        extendedKeyUsages = extendedKeyUsagesDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let importedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importedAt)
        importedAt = importedAtDecoded
        let inUseByContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inUseBy)
        var inUseByDecoded0:[Swift.String]? = nil
        if let inUseByContainer = inUseByContainer {
            inUseByDecoded0 = [Swift.String]()
            for string0 in inUseByContainer {
                if let string0 = string0 {
                    inUseByDecoded0?.append(string0)
                }
            }
        }
        inUseBy = inUseByDecoded0
        let issuedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let keyUsagesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage?].self, forKey: .keyUsages)
        var keyUsagesDecoded0:[SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage]? = nil
        if let keyUsagesContainer = keyUsagesContainer {
            keyUsagesDecoded0 = [SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage]()
            for structure0 in keyUsagesContainer {
                if let structure0 = structure0 {
                    keyUsagesDecoded0?.append(structure0)
                }
            }
        }
        keyUsages = keyUsagesDecoded0
        let notAfterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCertificateManagerCertificateOptions.self, forKey: .options)
        options = optionsDecoded
        let renewalEligibilityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .renewalEligibility)
        renewalEligibility = renewalEligibilityDecoded
        let renewalSummaryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary.self, forKey: .renewalSummary)
        renewalSummary = renewalSummaryDecoded
        let serialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serial)
        serial = serialDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let subjectAlternativeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subjectAlternativeNames)
        var subjectAlternativeNamesDecoded0:[Swift.String]? = nil
        if let subjectAlternativeNamesContainer = subjectAlternativeNamesContainer {
            subjectAlternativeNamesDecoded0 = [Swift.String]()
            for string0 in subjectAlternativeNamesContainer {
                if let string0 = string0 {
                    subjectAlternativeNamesDecoded0?.append(string0)
                }
            }
        }
        subjectAlternativeNames = subjectAlternativeNamesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an Certificate Manager certificate.
    public struct AwsCertificateManagerCertificateDetails: Swift.Equatable {
        /// The ARN of the private certificate authority (CA) that will be used to issue the certificate.
        public var certificateAuthorityArn: Swift.String?
        /// Indicates when the certificate was requested. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdAt: Swift.String?
        /// The fully qualified domain name (FQDN), such as www.example.com, that is secured by the certificate.
        public var domainName: Swift.String?
        /// Contains information about the initial validation of each domain name that occurs as a result of the RequestCertificate request. Only provided if the certificate type is AMAZON_ISSUED.
        public var domainValidationOptions: [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]?
        /// Contains a list of Extended Key Usage X.509 v3 extension objects. Each object specifies a purpose for which the certificate public key can be used and consists of a name and an object identifier (OID).
        public var extendedKeyUsages: [SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage]?
        /// For a failed certificate request, the reason for the failure. Valid values: NO_AVAILABLE_CONTACTS | ADDITIONAL_VERIFICATION_REQUIRED | DOMAIN_NOT_ALLOWED | INVALID_PUBLIC_DOMAIN | DOMAIN_VALIDATION_DENIED | CAA_ERROR | PCA_LIMIT_EXCEEDED | PCA_INVALID_ARN | PCA_INVALID_STATE | PCA_REQUEST_FAILED | PCA_NAME_CONSTRAINTS_VALIDATION | PCA_RESOURCE_NOT_FOUND | PCA_INVALID_ARGS | PCA_INVALID_DURATION | PCA_ACCESS_DENIED | SLR_NOT_FOUND | OTHER
        public var failureReason: Swift.String?
        /// Indicates when the certificate was imported. Provided if the certificate type is IMPORTED. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var importedAt: Swift.String?
        /// The list of ARNs for the Amazon Web Services resources that use the certificate.
        public var inUseBy: [Swift.String]?
        /// Indicates when the certificate was issued. Provided if the certificate type is AMAZON_ISSUED. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var issuedAt: Swift.String?
        /// The name of the certificate authority that issued and signed the certificate.
        public var issuer: Swift.String?
        /// The algorithm that was used to generate the public-private key pair. Valid values: RSA_2048 | RSA_1024 | RSA_4096 | EC_prime256v1 | EC_secp384r1 | EC_secp521r1
        public var keyAlgorithm: Swift.String?
        /// A list of key usage X.509 v3 extension objects.
        public var keyUsages: [SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage]?
        /// The time after which the certificate becomes invalid. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var notAfter: Swift.String?
        /// The time before which the certificate is not valid. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var notBefore: Swift.String?
        /// Provides a value that specifies whether to add the certificate to a transparency log.
        public var options: SecurityHubClientTypes.AwsCertificateManagerCertificateOptions?
        /// Whether the certificate is eligible for renewal. Valid values: ELIGIBLE | INELIGIBLE
        public var renewalEligibility: Swift.String?
        /// Information about the status of the Certificate Manager managed renewal for the certificate. Provided only when the certificate type is AMAZON_ISSUED.
        public var renewalSummary: SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary?
        /// The serial number of the certificate.
        public var serial: Swift.String?
        /// The algorithm that was used to sign the certificate.
        public var signatureAlgorithm: Swift.String?
        /// The status of the certificate. Valid values: PENDING_VALIDATION | ISSUED | INACTIVE | EXPIRED | VALIDATION_TIMED_OUT | REVOKED | FAILED
        public var status: Swift.String?
        /// The name of the entity that is associated with the public key contained in the certificate.
        public var subject: Swift.String?
        /// One or more domain names (subject alternative names) included in the certificate. This list contains the domain names that are bound to the public key that is contained in the certificate. The subject alternative names include the canonical domain name (CN) of the certificate and additional domain names that can be used to connect to the website.
        public var subjectAlternativeNames: [Swift.String]?
        /// The source of the certificate. For certificates that Certificate Manager provides, Type is AMAZON_ISSUED. For certificates that are imported with ImportCertificate, Type is IMPORTED. Valid values: IMPORTED | AMAZON_ISSUED | PRIVATE
        public var type: Swift.String?

        public init (
            certificateAuthorityArn: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainValidationOptions: [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]? = nil,
            extendedKeyUsages: [SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage]? = nil,
            failureReason: Swift.String? = nil,
            importedAt: Swift.String? = nil,
            inUseBy: [Swift.String]? = nil,
            issuedAt: Swift.String? = nil,
            issuer: Swift.String? = nil,
            keyAlgorithm: Swift.String? = nil,
            keyUsages: [SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage]? = nil,
            notAfter: Swift.String? = nil,
            notBefore: Swift.String? = nil,
            options: SecurityHubClientTypes.AwsCertificateManagerCertificateOptions? = nil,
            renewalEligibility: Swift.String? = nil,
            renewalSummary: SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary? = nil,
            serial: Swift.String? = nil,
            signatureAlgorithm: Swift.String? = nil,
            status: Swift.String? = nil,
            subject: Swift.String? = nil,
            subjectAlternativeNames: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.createdAt = createdAt
            self.domainName = domainName
            self.domainValidationOptions = domainValidationOptions
            self.extendedKeyUsages = extendedKeyUsages
            self.failureReason = failureReason
            self.importedAt = importedAt
            self.inUseBy = inUseBy
            self.issuedAt = issuedAt
            self.issuer = issuer
            self.keyAlgorithm = keyAlgorithm
            self.keyUsages = keyUsages
            self.notAfter = notAfter
            self.notBefore = notBefore
            self.options = options
            self.renewalEligibility = renewalEligibility
            self.renewalSummary = renewalSummary
            self.serial = serial
            self.signatureAlgorithm = signatureAlgorithm
            self.status = status
            self.subject = subject
            self.subjectAlternativeNames = subjectAlternativeNames
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case resourceRecord = "ResourceRecord"
        case validationDomain = "ValidationDomain"
        case validationEmails = "ValidationEmails"
        case validationMethod = "ValidationMethod"
        case validationStatus = "ValidationStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let resourceRecord = self.resourceRecord {
            try encodeContainer.encode(resourceRecord, forKey: .resourceRecord)
        }
        if let validationDomain = self.validationDomain {
            try encodeContainer.encode(validationDomain, forKey: .validationDomain)
        }
        if let validationEmails = validationEmails {
            var validationEmailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validationEmails)
            for nonemptystring0 in validationEmails {
                try validationEmailsContainer.encode(nonemptystring0)
            }
        }
        if let validationMethod = self.validationMethod {
            try encodeContainer.encode(validationMethod, forKey: .validationMethod)
        }
        if let validationStatus = self.validationStatus {
            try encodeContainer.encode(validationStatus, forKey: .validationStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let resourceRecordDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord.self, forKey: .resourceRecord)
        resourceRecord = resourceRecordDecoded
        let validationDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationDomain)
        validationDomain = validationDomainDecoded
        let validationEmailsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validationEmails)
        var validationEmailsDecoded0:[Swift.String]? = nil
        if let validationEmailsContainer = validationEmailsContainer {
            validationEmailsDecoded0 = [Swift.String]()
            for string0 in validationEmailsContainer {
                if let string0 = string0 {
                    validationEmailsDecoded0?.append(string0)
                }
            }
        }
        validationEmails = validationEmailsDecoded0
        let validationMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationMethod)
        validationMethod = validationMethodDecoded
        let validationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationStatus)
        validationStatus = validationStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about one of the following:
    ///
    /// * The initial validation of each domain name that occurs as a result of the RequestCertificate request
    ///
    /// * The validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal
    public struct AwsCertificateManagerCertificateDomainValidationOption: Swift.Equatable {
        /// A fully qualified domain name (FQDN) in the certificate.
        public var domainName: Swift.String?
        /// The CNAME record that is added to the DNS database for domain validation.
        public var resourceRecord: SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord?
        /// The domain name that Certificate Manager uses to send domain validation emails.
        public var validationDomain: Swift.String?
        /// A list of email addresses that Certificate Manager uses to send domain validation emails.
        public var validationEmails: [Swift.String]?
        /// The method used to validate the domain name.
        public var validationMethod: Swift.String?
        /// The validation status of the domain name.
        public var validationStatus: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            resourceRecord: SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord? = nil,
            validationDomain: Swift.String? = nil,
            validationEmails: [Swift.String]? = nil,
            validationMethod: Swift.String? = nil,
            validationStatus: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.resourceRecord = resourceRecord
            self.validationDomain = validationDomain
            self.validationEmails = validationEmails
            self.validationMethod = validationMethod
            self.validationStatus = validationStatus
        }
    }

}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateExtendedKeyUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case oId = "OId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let oId = self.oId {
            try encodeContainer.encode(oId, forKey: .oId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let oIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oId)
        oId = oIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about an extended key usage X.509 v3 extension object.
    public struct AwsCertificateManagerCertificateExtendedKeyUsage: Swift.Equatable {
        /// The name of an extension value. Indicates the purpose for which the certificate public key can be used.
        public var name: Swift.String?
        /// An object identifier (OID) for the extension value. The format is numbers separated by periods.
        public var oId: Swift.String?

        public init (
            name: Swift.String? = nil,
            oId: Swift.String? = nil
        )
        {
            self.name = name
            self.oId = oId
        }
    }

}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateKeyUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a key usage X.509 v3 extension object.
    public struct AwsCertificateManagerCertificateKeyUsage: Swift.Equatable {
        /// The key usage extension name.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateTransparencyLoggingPreference = "CertificateTransparencyLoggingPreference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateTransparencyLoggingPreference = self.certificateTransparencyLoggingPreference {
            try encodeContainer.encode(certificateTransparencyLoggingPreference, forKey: .certificateTransparencyLoggingPreference)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateTransparencyLoggingPreferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateTransparencyLoggingPreference)
        certificateTransparencyLoggingPreference = certificateTransparencyLoggingPreferenceDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains other options for the certificate.
    public struct AwsCertificateManagerCertificateOptions: Swift.Equatable {
        /// Whether to add the certificate to a transparency log. Valid values: DISABLED | ENABLED
        public var certificateTransparencyLoggingPreference: Swift.String?

        public init (
            certificateTransparencyLoggingPreference: Swift.String? = nil
        )
        {
            self.certificateTransparencyLoggingPreference = certificateTransparencyLoggingPreference
        }
    }

}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateRenewalSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainValidationOptions = "DomainValidationOptions"
        case renewalStatus = "RenewalStatus"
        case renewalStatusReason = "RenewalStatusReason"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainValidationOptions = domainValidationOptions {
            var domainValidationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainValidationOptions)
            for awscertificatemanagercertificatedomainvalidationoption0 in domainValidationOptions {
                try domainValidationOptionsContainer.encode(awscertificatemanagercertificatedomainvalidationoption0)
            }
        }
        if let renewalStatus = self.renewalStatus {
            try encodeContainer.encode(renewalStatus, forKey: .renewalStatus)
        }
        if let renewalStatusReason = self.renewalStatusReason {
            try encodeContainer.encode(renewalStatusReason, forKey: .renewalStatusReason)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainValidationOptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption?].self, forKey: .domainValidationOptions)
        var domainValidationOptionsDecoded0:[SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]? = nil
        if let domainValidationOptionsContainer = domainValidationOptionsContainer {
            domainValidationOptionsDecoded0 = [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]()
            for structure0 in domainValidationOptionsContainer {
                if let structure0 = structure0 {
                    domainValidationOptionsDecoded0?.append(structure0)
                }
            }
        }
        domainValidationOptions = domainValidationOptionsDecoded0
        let renewalStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .renewalStatus)
        renewalStatus = renewalStatusDecoded
        let renewalStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .renewalStatusReason)
        renewalStatusReason = renewalStatusReasonDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the Certificate Manager managed renewal for an AMAZON_ISSUED certificate.
    public struct AwsCertificateManagerCertificateRenewalSummary: Swift.Equatable {
        /// Information about the validation of each domain name in the certificate, as it pertains to Certificate Manager managed renewal. Provided only when the certificate type is AMAZON_ISSUED.
        public var domainValidationOptions: [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]?
        /// The status of the Certificate Manager managed renewal of the certificate. Valid values: PENDING_AUTO_RENEWAL | PENDING_VALIDATION | SUCCESS | FAILED
        public var renewalStatus: Swift.String?
        /// The reason that a renewal request was unsuccessful. This attribute is used only when RenewalStatus is FAILED. Valid values: NO_AVAILABLE_CONTACTS | ADDITIONAL_VERIFICATION_REQUIRED | DOMAIN_NOT_ALLOWED | INVALID_PUBLIC_DOMAIN | DOMAIN_VALIDATION_DENIED | CAA_ERROR | PCA_LIMIT_EXCEEDED | PCA_INVALID_ARN | PCA_INVALID_STATE | PCA_REQUEST_FAILED | PCA_NAME_CONSTRAINTS_VALIDATION | PCA_RESOURCE_NOT_FOUND | PCA_INVALID_ARGS | PCA_INVALID_DURATION | PCA_ACCESS_DENIED | SLR_NOT_FOUND | OTHER
        public var renewalStatusReason: Swift.String?
        /// Indicates when the renewal summary was last updated. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var updatedAt: Swift.String?

        public init (
            domainValidationOptions: [SecurityHubClientTypes.AwsCertificateManagerCertificateDomainValidationOption]? = nil,
            renewalStatus: Swift.String? = nil,
            renewalStatusReason: Swift.String? = nil,
            updatedAt: Swift.String? = nil
        )
        {
            self.domainValidationOptions = domainValidationOptions
            self.renewalStatus = renewalStatus
            self.renewalStatusReason = renewalStatusReason
            self.updatedAt = updatedAt
        }
    }

}

extension SecurityHubClientTypes.AwsCertificateManagerCertificateResourceRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the CNAME record that is added to the DNS database for domain validation.
    public struct AwsCertificateManagerCertificateResourceRecord: Swift.Equatable {
        /// The name of the resource.
        public var name: Swift.String?
        /// The type of resource.
        public var type: Swift.String?
        /// The value of the resource.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFormationStackDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case creationTime = "CreationTime"
        case description = "Description"
        case disableRollback = "DisableRollback"
        case driftInformation = "DriftInformation"
        case enableTerminationProtection = "EnableTerminationProtection"
        case lastUpdatedTime = "LastUpdatedTime"
        case notificationArns = "NotificationArns"
        case outputs = "Outputs"
        case roleArn = "RoleArn"
        case stackId = "StackId"
        case stackName = "StackName"
        case stackStatus = "StackStatus"
        case stackStatusReason = "StackStatusReason"
        case timeoutInMinutes = "TimeoutInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for nonemptystring0 in capabilities {
                try capabilitiesContainer.encode(nonemptystring0)
            }
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableRollback != false {
            try encodeContainer.encode(disableRollback, forKey: .disableRollback)
        }
        if let driftInformation = self.driftInformation {
            try encodeContainer.encode(driftInformation, forKey: .driftInformation)
        }
        if enableTerminationProtection != false {
            try encodeContainer.encode(enableTerminationProtection, forKey: .enableTerminationProtection)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for nonemptystring0 in notificationArns {
                try notificationArnsContainer.encode(nonemptystring0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for awscloudformationstackoutputsdetails0 in outputs {
                try outputsContainer.encode(awscloudformationstackoutputsdetails0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let stackStatus = self.stackStatus {
            try encodeContainer.encode(stackStatus, forKey: .stackStatus)
        }
        if let stackStatusReason = self.stackStatusReason {
            try encodeContainer.encode(stackStatusReason, forKey: .stackStatusReason)
        }
        if timeoutInMinutes != 0 {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let disableRollbackDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableRollback) ?? false
        disableRollback = disableRollbackDecoded
        let driftInformationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails.self, forKey: .driftInformation)
        driftInformation = driftInformationDecoded
        let enableTerminationProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableTerminationProtection) ?? false
        enableTerminationProtection = enableTerminationProtectionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[Swift.String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [Swift.String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails?].self, forKey: .outputs)
        var outputsDecoded0:[SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let stackStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackStatus)
        stackStatus = stackStatusDecoded
        let stackStatusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackStatusReason)
        stackStatusReason = stackStatusReasonDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMinutes) ?? 0
        timeoutInMinutes = timeoutInMinutesDecoded
    }
}

extension SecurityHubClientTypes {
    /// Nests a stack as a resource in a top-level template. Nested stacks are stacks created as resources for another stack.
    public struct AwsCloudFormationStackDetails: Swift.Equatable {
        /// The capabilities allowed in the stack.
        public var capabilities: [Swift.String]?
        /// The time at which the stack was created.
        public var creationTime: Swift.String?
        /// A user-defined description associated with the stack.
        public var description: Swift.String?
        /// Boolean to enable or disable rollback on stack creation failures.
        public var disableRollback: Swift.Bool
        /// Information about whether a stack's actual configuration differs, or has drifted, from its expected configuration, as defined in the stack template and any values specified as template parameters.
        public var driftInformation: SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails?
        /// Whether termination protection is enabled for the stack.
        public var enableTerminationProtection: Swift.Bool
        /// The time the nested stack was last updated. This field will only be returned if the stack has been updated at least once.
        public var lastUpdatedTime: Swift.String?
        /// The Amazon Resource Names (ARNs) of the Amazon SNS topic to which stack-related events are published.
        public var notificationArns: [Swift.String]?
        /// A list of output structures.
        public var outputs: [SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails]?
        /// The ARN of an IAM role that's associated with the stack.
        public var roleArn: Swift.String?
        /// Unique identifier of the stack.
        public var stackId: Swift.String?
        /// The name associated with the stack.
        public var stackName: Swift.String?
        /// Current status of the stack.
        public var stackStatus: Swift.String?
        /// Success or failure message associated with the stack status.
        public var stackStatusReason: Swift.String?
        /// The length of time, in minutes, that CloudFormation waits for the nested stack to reach the CREATE_COMPLETE state.
        public var timeoutInMinutes: Swift.Int

        public init (
            capabilities: [Swift.String]? = nil,
            creationTime: Swift.String? = nil,
            description: Swift.String? = nil,
            disableRollback: Swift.Bool = false,
            driftInformation: SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails? = nil,
            enableTerminationProtection: Swift.Bool = false,
            lastUpdatedTime: Swift.String? = nil,
            notificationArns: [Swift.String]? = nil,
            outputs: [SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails]? = nil,
            roleArn: Swift.String? = nil,
            stackId: Swift.String? = nil,
            stackName: Swift.String? = nil,
            stackStatus: Swift.String? = nil,
            stackStatusReason: Swift.String? = nil,
            timeoutInMinutes: Swift.Int = 0
        )
        {
            self.capabilities = capabilities
            self.creationTime = creationTime
            self.description = description
            self.disableRollback = disableRollback
            self.driftInformation = driftInformation
            self.enableTerminationProtection = enableTerminationProtection
            self.lastUpdatedTime = lastUpdatedTime
            self.notificationArns = notificationArns
            self.outputs = outputs
            self.roleArn = roleArn
            self.stackId = stackId
            self.stackName = stackName
            self.stackStatus = stackStatus
            self.stackStatusReason = stackStatusReason
            self.timeoutInMinutes = timeoutInMinutes
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFormationStackDriftInformationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackDriftStatus = "StackDriftStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackDriftStatus = self.stackDriftStatus {
            try encodeContainer.encode(stackDriftStatus, forKey: .stackDriftStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDriftStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackDriftStatus)
        stackDriftStatus = stackDriftStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the stack's conformity to its expected template configuration.
    public struct AwsCloudFormationStackDriftInformationDetails: Swift.Equatable {
        /// Status of the stack's actual configuration compared to its expected template configuration.
        public var stackDriftStatus: Swift.String?

        public init (
            stackDriftStatus: Swift.String? = nil
        )
        {
            self.stackDriftStatus = stackDriftStatus
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFormationStackOutputsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case outputKey = "OutputKey"
        case outputValue = "OutputValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let outputKey = self.outputKey {
            try encodeContainer.encode(outputKey, forKey: .outputKey)
        }
        if let outputValue = self.outputValue {
            try encodeContainer.encode(outputValue, forKey: .outputValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let outputKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputKey)
        outputKey = outputKeyDecoded
        let outputValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputValue)
        outputValue = outputValueDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the CloudFormation stack output.
    public struct AwsCloudFormationStackOutputsDetails: Swift.Equatable {
        /// A user-defined description associated with the output.
        public var description: Swift.String?
        /// The key associated with the output.
        public var outputKey: Swift.String?
        /// The value associated with the output.
        public var outputValue: Swift.String?

        public init (
            description: Swift.String? = nil,
            outputKey: Swift.String? = nil,
            outputValue: Swift.String? = nil
        )
        {
            self.description = description
            self.outputKey = outputKey
            self.outputValue = outputValue
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let viewerProtocolPolicy = self.viewerProtocolPolicy {
            try encodeContainer.encode(viewerProtocolPolicy, forKey: .viewerProtocolPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a cache behavior for the distribution.
    public struct AwsCloudFrontDistributionCacheBehavior: Swift.Equatable {
        /// The protocol that viewers can use to access the files in an origin. You can specify the following options:
        ///
        /// * allow-all - Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.
        ///
        /// * https-only - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).
        public var viewerProtocolPolicy: Swift.String?

        public init (
            viewerProtocolPolicy: Swift.String? = nil
        )
        {
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for awscloudfrontdistributioncachebehavior0 in items {
                try itemsContainer.encode(awscloudfrontdistributioncachebehavior0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior?].self, forKey: .items)
        var itemsDecoded0:[SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Provides information about caching for the CloudFront distribution.
    public struct AwsCloudFrontDistributionCacheBehaviors: Swift.Equatable {
        /// The cache behaviors for the distribution.
        public var items: [SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior]?

        public init (
            items: [SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehavior]? = nil
        )
        {
            self.items = items
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let viewerProtocolPolicy = self.viewerProtocolPolicy {
            try encodeContainer.encode(viewerProtocolPolicy, forKey: .viewerProtocolPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the default cache configuration for the CloudFront distribution.
    public struct AwsCloudFrontDistributionDefaultCacheBehavior: Swift.Equatable {
        /// The protocol that viewers can use to access the files in an origin. You can specify the following options:
        ///
        /// * allow-all - Viewers can use HTTP or HTTPS.
        ///
        /// * redirect-to-https - CloudFront responds to HTTP requests with an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer then uses the new URL to resubmit.
        ///
        /// * https-only - CloudFront responds to HTTP request with an HTTP status code of 403 (Forbidden).
        public var viewerProtocolPolicy: Swift.String?

        public init (
            viewerProtocolPolicy: Swift.String? = nil
        )
        {
            self.viewerProtocolPolicy = viewerProtocolPolicy
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheBehaviors = "CacheBehaviors"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case defaultRootObject = "DefaultRootObject"
        case domainName = "DomainName"
        case eTag = "ETag"
        case lastModifiedTime = "LastModifiedTime"
        case logging = "Logging"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case status = "Status"
        case viewerCertificate = "ViewerCertificate"
        case webAclId = "WebAclId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheBehaviors = self.cacheBehaviors {
            try encodeContainer.encode(cacheBehaviors, forKey: .cacheBehaviors)
        }
        if let defaultCacheBehavior = self.defaultCacheBehavior {
            try encodeContainer.encode(defaultCacheBehavior, forKey: .defaultCacheBehavior)
        }
        if let defaultRootObject = self.defaultRootObject {
            try encodeContainer.encode(defaultRootObject, forKey: .defaultRootObject)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let eTag = self.eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let originGroups = self.originGroups {
            try encodeContainer.encode(originGroups, forKey: .originGroups)
        }
        if let origins = self.origins {
            try encodeContainer.encode(origins, forKey: .origins)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let viewerCertificate = self.viewerCertificate {
            try encodeContainer.encode(viewerCertificate, forKey: .viewerCertificate)
        }
        if let webAclId = self.webAclId {
            try encodeContainer.encode(webAclId, forKey: .webAclId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let defaultRootObjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRootObject)
        defaultRootObject = defaultRootObjectDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionLogging.self, forKey: .logging)
        logging = loggingDecoded
        let originsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionOrigins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let webAclIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclId)
        webAclId = webAclIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// A CloudFront distribution configuration.
    public struct AwsCloudFrontDistributionDetails: Swift.Equatable {
        /// Provides information about the cache configuration for the distribution.
        public var cacheBehaviors: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors?
        /// The default cache behavior for the configuration.
        public var defaultCacheBehavior: SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior?
        /// The object that CloudFront sends in response to requests from the origin (for example, index.html) when a viewer requests the root URL for the distribution (http://www.example.com) instead of an object in your distribution (http://www.example.com/product-description.html).
        public var defaultRootObject: Swift.String?
        /// The domain name corresponding to the distribution.
        public var domainName: Swift.String?
        /// The entity tag is a hash of the object.
        public var eTag: Swift.String?
        /// Indicates when that the distribution was last modified. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastModifiedTime: Swift.String?
        /// A complex type that controls whether access logs are written for the distribution.
        public var logging: SecurityHubClientTypes.AwsCloudFrontDistributionLogging?
        /// Provides information about the origin groups in the distribution.
        public var originGroups: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups?
        /// A complex type that contains information about origins for this distribution.
        public var origins: SecurityHubClientTypes.AwsCloudFrontDistributionOrigins?
        /// Indicates the current status of the distribution.
        public var status: Swift.String?
        /// Provides information about the TLS/SSL configuration that the distribution uses to communicate with viewers.
        public var viewerCertificate: SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate?
        /// A unique identifier that specifies the WAF web ACL, if any, to associate with this distribution.
        public var webAclId: Swift.String?

        public init (
            cacheBehaviors: SecurityHubClientTypes.AwsCloudFrontDistributionCacheBehaviors? = nil,
            defaultCacheBehavior: SecurityHubClientTypes.AwsCloudFrontDistributionDefaultCacheBehavior? = nil,
            defaultRootObject: Swift.String? = nil,
            domainName: Swift.String? = nil,
            eTag: Swift.String? = nil,
            lastModifiedTime: Swift.String? = nil,
            logging: SecurityHubClientTypes.AwsCloudFrontDistributionLogging? = nil,
            originGroups: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups? = nil,
            origins: SecurityHubClientTypes.AwsCloudFrontDistributionOrigins? = nil,
            status: Swift.String? = nil,
            viewerCertificate: SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate? = nil,
            webAclId: Swift.String? = nil
        )
        {
            self.cacheBehaviors = cacheBehaviors
            self.defaultCacheBehavior = defaultCacheBehavior
            self.defaultRootObject = defaultRootObject
            self.domainName = domainName
            self.eTag = eTag
            self.lastModifiedTime = lastModifiedTime
            self.logging = logging
            self.originGroups = originGroups
            self.origins = origins
            self.status = status
            self.viewerCertificate = viewerCertificate
            self.webAclId = webAclId
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionLogging: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case includeCookies = "IncludeCookies"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if includeCookies != false {
            try encodeContainer.encode(includeCookies, forKey: .includeCookies)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let includeCookiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCookies) ?? false
        includeCookies = includeCookiesDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension SecurityHubClientTypes {
    /// A complex type that controls whether access logs are written for the CloudFront distribution.
    public struct AwsCloudFrontDistributionLogging: Swift.Equatable {
        /// The S3 bucket to store the access logs in.
        public var bucket: Swift.String?
        /// With this field, you can enable or disable the selected distribution.
        public var enabled: Swift.Bool
        /// Specifies whether you want CloudFront to include cookies in access logs.
        public var includeCookies: Swift.Bool
        /// An optional string that you want CloudFront to use as a prefix to the access log filenames for this distribution.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            enabled: Swift.Bool = false,
            includeCookies: Swift.Bool = false,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.includeCookies = includeCookies
            self.`prefix` = `prefix`
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPort = "HttpPort"
        case httpsPort = "HttpsPort"
        case originKeepaliveTimeout = "OriginKeepaliveTimeout"
        case originProtocolPolicy = "OriginProtocolPolicy"
        case originReadTimeout = "OriginReadTimeout"
        case originSslProtocols = "OriginSslProtocols"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if httpPort != 0 {
            try encodeContainer.encode(httpPort, forKey: .httpPort)
        }
        if httpsPort != 0 {
            try encodeContainer.encode(httpsPort, forKey: .httpsPort)
        }
        if originKeepaliveTimeout != 0 {
            try encodeContainer.encode(originKeepaliveTimeout, forKey: .originKeepaliveTimeout)
        }
        if let originProtocolPolicy = self.originProtocolPolicy {
            try encodeContainer.encode(originProtocolPolicy, forKey: .originProtocolPolicy)
        }
        if originReadTimeout != 0 {
            try encodeContainer.encode(originReadTimeout, forKey: .originReadTimeout)
        }
        if let originSslProtocols = self.originSslProtocols {
            try encodeContainer.encode(originSslProtocols, forKey: .originSslProtocols)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpPort) ?? 0
        httpPort = httpPortDecoded
        let httpsPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpsPort) ?? 0
        httpsPort = httpsPortDecoded
        let originKeepaliveTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originKeepaliveTimeout) ?? 0
        originKeepaliveTimeout = originKeepaliveTimeoutDecoded
        let originProtocolPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originProtocolPolicy)
        originProtocolPolicy = originProtocolPolicyDecoded
        let originReadTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originReadTimeout) ?? 0
        originReadTimeout = originReadTimeoutDecoded
        let originSslProtocolsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols.self, forKey: .originSslProtocols)
        originSslProtocols = originSslProtocolsDecoded
    }
}

extension SecurityHubClientTypes {
    /// A custom origin. A custom origin is any origin that is not an Amazon S3 bucket, with one exception. An Amazon S3 bucket that is [configured with static website hosting](https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) is a custom origin.
    public struct AwsCloudFrontDistributionOriginCustomOriginConfig: Swift.Equatable {
        /// The HTTP port that CloudFront uses to connect to the origin.
        public var httpPort: Swift.Int
        /// The HTTPS port that CloudFront uses to connect to the origin.
        public var httpsPort: Swift.Int
        /// Specifies how long, in seconds, CloudFront persists its connection to the origin.
        public var originKeepaliveTimeout: Swift.Int
        /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin.
        public var originProtocolPolicy: Swift.String?
        /// Specifies how long, in seconds, CloudFront waits for a response from the origin.
        public var originReadTimeout: Swift.Int
        /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over HTTPS.
        public var originSslProtocols: SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols?

        public init (
            httpPort: Swift.Int = 0,
            httpsPort: Swift.Int = 0,
            originKeepaliveTimeout: Swift.Int = 0,
            originProtocolPolicy: Swift.String? = nil,
            originReadTimeout: Swift.Int = 0,
            originSslProtocols: SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols? = nil
        )
        {
            self.httpPort = httpPort
            self.httpsPort = httpsPort
            self.originKeepaliveTimeout = originKeepaliveTimeout
            self.originProtocolPolicy = originProtocolPolicy
            self.originReadTimeout = originReadTimeout
            self.originSslProtocols = originSslProtocols
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverCriteria = "FailoverCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failoverCriteria = self.failoverCriteria {
            try encodeContainer.encode(failoverCriteria, forKey: .failoverCriteria)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failoverCriteriaDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover.self, forKey: .failoverCriteria)
        failoverCriteria = failoverCriteriaDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an origin group for the CloudFront distribution.
    public struct AwsCloudFrontDistributionOriginGroup: Swift.Equatable {
        /// Provides the criteria for an origin group to fail over.
        public var failoverCriteria: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover?

        public init (
            failoverCriteria: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover? = nil
        )
        {
            self.failoverCriteria = failoverCriteria
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailover: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCodes = "StatusCodes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCodes = self.statusCodes {
            try encodeContainer.encode(statusCodes, forKey: .statusCodes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes.self, forKey: .statusCodes)
        statusCodes = statusCodesDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about when an origin group fails over.
    public struct AwsCloudFrontDistributionOriginGroupFailover: Swift.Equatable {
        /// Information about the status codes that cause an origin group to fail over.
        public var statusCodes: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes?

        public init (
            statusCodes: SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes? = nil
        )
        {
            self.statusCodes = statusCodes
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroupFailoverStatusCodes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for integer0 in items {
                try itemsContainer.encode(integer0)
            }
        }
        if quantity != 0 {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .items)
        var itemsDecoded0:[Swift.Int]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Swift.Int]()
            for integer0 in itemsContainer {
                if let integer0 = integer0 {
                    itemsDecoded0?.append(integer0)
                }
            }
        }
        items = itemsDecoded0
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity) ?? 0
        quantity = quantityDecoded
    }
}

extension SecurityHubClientTypes {
    /// The status codes that cause an origin group to fail over.
    public struct AwsCloudFrontDistributionOriginGroupFailoverStatusCodes: Swift.Equatable {
        /// The list of status code values that can cause a failover to the next origin.
        public var items: [Swift.Int]?
        /// The number of status codes that can cause a failover.
        public var quantity: Swift.Int

        public init (
            items: [Swift.Int]? = nil,
            quantity: Swift.Int = 0
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroups: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for awscloudfrontdistributionorigingroup0 in items {
                try itemsContainer.encode(awscloudfrontdistributionorigingroup0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup?].self, forKey: .items)
        var itemsDecoded0:[SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Provides information about origin groups that are associated with the CloudFront distribution.
    public struct AwsCloudFrontDistributionOriginGroups: Swift.Equatable {
        /// The list of origin groups.
        public var items: [SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup]?

        public init (
            items: [SecurityHubClientTypes.AwsCloudFrontDistributionOriginGroup]? = nil
        )
        {
            self.items = items
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customOriginConfig = "CustomOriginConfig"
        case domainName = "DomainName"
        case id = "Id"
        case originPath = "OriginPath"
        case s3OriginConfig = "S3OriginConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customOriginConfig = self.customOriginConfig {
            try encodeContainer.encode(customOriginConfig, forKey: .customOriginConfig)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let originPath = self.originPath {
            try encodeContainer.encode(originPath, forKey: .originPath)
        }
        if let s3OriginConfig = self.s3OriginConfig {
            try encodeContainer.encode(s3OriginConfig, forKey: .s3OriginConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let originPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originPath)
        originPath = originPathDecoded
        let s3OriginConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig.self, forKey: .s3OriginConfig)
        s3OriginConfig = s3OriginConfigDecoded
        let customOriginConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig.self, forKey: .customOriginConfig)
        customOriginConfig = customOriginConfigDecoded
    }
}

extension SecurityHubClientTypes {
    /// A complex type that describes the Amazon S3 bucket, HTTP server (for example, a web server), AWS Elemental MediaStore, or other server from which CloudFront gets your files.
    public struct AwsCloudFrontDistributionOriginItem: Swift.Equatable {
        /// An origin that is not an Amazon S3 bucket, with one exception. If the Amazon S3 bucket is configured with static website hosting, use this attribute. If the Amazon S3 bucket is not configured with static website hosting, use the S3OriginConfig type instead.
        public var customOriginConfig: SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig?
        /// Amazon S3 origins: The DNS name of the S3 bucket from which you want CloudFront to get objects for this origin.
        public var domainName: Swift.String?
        /// A unique identifier for the origin or origin group.
        public var id: Swift.String?
        /// An optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin.
        public var originPath: Swift.String?
        /// An origin that is an S3 bucket that is not configured with static website hosting.
        public var s3OriginConfig: SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig?

        public init (
            customOriginConfig: SecurityHubClientTypes.AwsCloudFrontDistributionOriginCustomOriginConfig? = nil,
            domainName: Swift.String? = nil,
            id: Swift.String? = nil,
            originPath: Swift.String? = nil,
            s3OriginConfig: SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig? = nil
        )
        {
            self.customOriginConfig = customOriginConfig
            self.domainName = domainName
            self.id = id
            self.originPath = originPath
            self.s3OriginConfig = s3OriginConfig
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginS3OriginConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let originAccessIdentity = self.originAccessIdentity {
            try encodeContainer.encode(originAccessIdentity, forKey: .originAccessIdentity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an origin that is an Amazon S3 bucket that is not configured with static website hosting.
    public struct AwsCloudFrontDistributionOriginS3OriginConfig: Swift.Equatable {
        /// The CloudFront origin access identity to associate with the origin.
        public var originAccessIdentity: Swift.String?

        public init (
            originAccessIdentity: Swift.String? = nil
        )
        {
            self.originAccessIdentity = originAccessIdentity
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOriginSslProtocols: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for nonemptystring0 in items {
                try itemsContainer.encode(nonemptystring0)
            }
        }
        if quantity != 0 {
            try encodeContainer.encode(quantity, forKey: .quantity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .items)
        var itemsDecoded0:[Swift.String]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Swift.String]()
            for string0 in itemsContainer {
                if let string0 = string0 {
                    itemsDecoded0?.append(string0)
                }
            }
        }
        items = itemsDecoded0
        let quantityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quantity) ?? 0
        quantity = quantityDecoded
    }
}

extension SecurityHubClientTypes {
    /// A complex type that contains information about the SSL/TLS protocols that CloudFront can use when establishing an HTTPS connection with your origin.
    public struct AwsCloudFrontDistributionOriginSslProtocols: Swift.Equatable {
        /// A list that contains allowed SSL/TLS protocols for this distribution.
        public var items: [Swift.String]?
        /// The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an HTTPS connection with this origin.
        public var quantity: Swift.Int

        public init (
            items: [Swift.String]? = nil,
            quantity: Swift.Int = 0
        )
        {
            self.items = items
            self.quantity = quantity
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionOrigins: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for awscloudfrontdistributionoriginitem0 in items {
                try itemsContainer.encode(awscloudfrontdistributionoriginitem0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem?].self, forKey: .items)
        var itemsDecoded0:[SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// A complex type that contains information about origins and origin groups for this CloudFront distribution.
    public struct AwsCloudFrontDistributionOrigins: Swift.Equatable {
        /// A complex type that contains origins or origin groups for this distribution.
        public var items: [SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem]?

        public init (
            items: [SecurityHubClientTypes.AwsCloudFrontDistributionOriginItem]? = nil
        )
        {
            self.items = items
        }
    }

}

extension SecurityHubClientTypes.AwsCloudFrontDistributionViewerCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acmCertificateArn = "AcmCertificateArn"
        case certificate = "Certificate"
        case certificateSource = "CertificateSource"
        case cloudFrontDefaultCertificate = "CloudFrontDefaultCertificate"
        case iamCertificateId = "IamCertificateId"
        case minimumProtocolVersion = "MinimumProtocolVersion"
        case sslSupportMethod = "SslSupportMethod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acmCertificateArn = self.acmCertificateArn {
            try encodeContainer.encode(acmCertificateArn, forKey: .acmCertificateArn)
        }
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let certificateSource = self.certificateSource {
            try encodeContainer.encode(certificateSource, forKey: .certificateSource)
        }
        if cloudFrontDefaultCertificate != false {
            try encodeContainer.encode(cloudFrontDefaultCertificate, forKey: .cloudFrontDefaultCertificate)
        }
        if let iamCertificateId = self.iamCertificateId {
            try encodeContainer.encode(iamCertificateId, forKey: .iamCertificateId)
        }
        if let minimumProtocolVersion = self.minimumProtocolVersion {
            try encodeContainer.encode(minimumProtocolVersion, forKey: .minimumProtocolVersion)
        }
        if let sslSupportMethod = self.sslSupportMethod {
            try encodeContainer.encode(sslSupportMethod, forKey: .sslSupportMethod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acmCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acmCertificateArn)
        acmCertificateArn = acmCertificateArnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateSource)
        certificateSource = certificateSourceDecoded
        let cloudFrontDefaultCertificateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudFrontDefaultCertificate) ?? false
        cloudFrontDefaultCertificate = cloudFrontDefaultCertificateDecoded
        let iamCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamCertificateId)
        iamCertificateId = iamCertificateIdDecoded
        let minimumProtocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumProtocolVersion)
        minimumProtocolVersion = minimumProtocolVersionDecoded
        let sslSupportMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslSupportMethod)
        sslSupportMethod = sslSupportMethodDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the TLS/SSL configuration that the CloudFront distribution uses to communicate with viewers.
    public struct AwsCloudFrontDistributionViewerCertificate: Swift.Equatable {
        /// The ARN of the ACM certificate. Used if the certificate is stored in ACM. If you provide an ACM certificate ARN, you must also provide MinimumCertificateVersion and SslSupportMethod.
        public var acmCertificateArn: Swift.String?
        /// The identifier of the certificate. Note that in CloudFront, this attribute is deprecated.
        public var certificate: Swift.String?
        /// The source of the certificate identified by Certificate. Note that in CloudFront, this attribute is deprecated.
        public var certificateSource: Swift.String?
        /// Whether the distribution uses the CloudFront domain name. If set to false, then you provide either AcmCertificateArn or IamCertificateId.
        public var cloudFrontDefaultCertificate: Swift.Bool
        /// The identifier of the IAM certificate. Used if the certificate is stored in IAM. If you provide IamCertificateId, then you also must provide MinimumProtocolVersion and SslSupportMethod.
        public var iamCertificateId: Swift.String?
        /// The security policy that CloudFront uses for HTTPS connections with viewers. If SslSupportMethod is sni-only, then MinimumProtocolVersion must be TLSv1 or higher.
        public var minimumProtocolVersion: Swift.String?
        /// The viewers that the distribution accepts HTTPS connections from.
        public var sslSupportMethod: Swift.String?

        public init (
            acmCertificateArn: Swift.String? = nil,
            certificate: Swift.String? = nil,
            certificateSource: Swift.String? = nil,
            cloudFrontDefaultCertificate: Swift.Bool = false,
            iamCertificateId: Swift.String? = nil,
            minimumProtocolVersion: Swift.String? = nil,
            sslSupportMethod: Swift.String? = nil
        )
        {
            self.acmCertificateArn = acmCertificateArn
            self.certificate = certificate
            self.certificateSource = certificateSource
            self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
            self.iamCertificateId = iamCertificateId
            self.minimumProtocolVersion = minimumProtocolVersion
            self.sslSupportMethod = sslSupportMethod
        }
    }

}

extension SecurityHubClientTypes.AwsCloudTrailTrailDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case hasCustomEventSelectors = "HasCustomEventSelectors"
        case homeRegion = "HomeRegion"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicArn = "SnsTopicArn"
        case snsTopicName = "SnsTopicName"
        case trailArn = "TrailArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = self.cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if hasCustomEventSelectors != false {
            try encodeContainer.encode(hasCustomEventSelectors, forKey: .hasCustomEventSelectors)
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if includeGlobalServiceEvents != false {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if isMultiRegionTrail != false {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if isOrganizationTrail != false {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if logFileValidationEnabled != false {
            try encodeContainer.encode(logFileValidationEnabled, forKey: .logFileValidationEnabled)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let snsTopicName = self.snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let trailArn = self.trailArn {
            try encodeContainer.encode(trailArn, forKey: .trailArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let hasCustomEventSelectorsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasCustomEventSelectors) ?? false
        hasCustomEventSelectors = hasCustomEventSelectorsDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeGlobalServiceEvents) ?? false
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMultiRegionTrail) ?? false
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOrganizationTrail) ?? false
        isOrganizationTrail = isOrganizationTrailDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .logFileValidationEnabled) ?? false
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let trailArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trailArn)
        trailArn = trailArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about a CloudTrail trail.
    public struct AwsCloudTrailTrailDetails: Swift.Equatable {
        /// The ARN of the log group that CloudTrail logs are delivered to.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// The ARN of the role that the CloudWatch Events endpoint assumes when it writes to the log group.
        public var cloudWatchLogsRoleArn: Swift.String?
        /// Indicates whether the trail has custom event selectors.
        public var hasCustomEventSelectors: Swift.Bool
        /// The Region where the trail was created.
        public var homeRegion: Swift.String?
        /// Indicates whether the trail publishes events from global services such as IAM to the log files.
        public var includeGlobalServiceEvents: Swift.Bool
        /// Indicates whether the trail applies only to the current Region or to all Regions.
        public var isMultiRegionTrail: Swift.Bool
        /// Whether the trail is created for all accounts in an organization in Organizations, or only for the current Amazon Web Services account.
        public var isOrganizationTrail: Swift.Bool
        /// The KMS key ID to use to encrypt the logs.
        public var kmsKeyId: Swift.String?
        /// Indicates whether CloudTrail log file validation is enabled.
        public var logFileValidationEnabled: Swift.Bool
        /// The name of the trail.
        public var name: Swift.String?
        /// The name of the S3 bucket where the log files are published.
        public var s3BucketName: Swift.String?
        /// The S3 key prefix. The key prefix is added after the name of the S3 bucket where the log files are published.
        public var s3KeyPrefix: Swift.String?
        /// The ARN of the SNS topic that is used for notifications of log file delivery.
        public var snsTopicArn: Swift.String?
        /// The name of the SNS topic that is used for notifications of log file delivery.
        public var snsTopicName: Swift.String?
        /// The ARN of the trail.
        public var trailArn: Swift.String?

        public init (
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            cloudWatchLogsRoleArn: Swift.String? = nil,
            hasCustomEventSelectors: Swift.Bool = false,
            homeRegion: Swift.String? = nil,
            includeGlobalServiceEvents: Swift.Bool = false,
            isMultiRegionTrail: Swift.Bool = false,
            isOrganizationTrail: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil,
            logFileValidationEnabled: Swift.Bool = false,
            name: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            snsTopicName: Swift.String? = nil,
            trailArn: Swift.String? = nil
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
            self.hasCustomEventSelectors = hasCustomEventSelectors
            self.homeRegion = homeRegion
            self.includeGlobalServiceEvents = includeGlobalServiceEvents
            self.isMultiRegionTrail = isMultiRegionTrail
            self.isOrganizationTrail = isOrganizationTrail
            self.kmsKeyId = kmsKeyId
            self.logFileValidationEnabled = logFileValidationEnabled
            self.name = name
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.snsTopicArn = snsTopicArn
            self.snsTopicName = snsTopicName
            self.trailArn = trailArn
        }
    }

}

extension SecurityHubClientTypes.AwsCloudWatchAlarmDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsEnabled = "ActionsEnabled"
        case alarmActions = "AlarmActions"
        case alarmArn = "AlarmArn"
        case alarmConfigurationUpdatedTimestamp = "AlarmConfigurationUpdatedTimestamp"
        case alarmDescription = "AlarmDescription"
        case alarmName = "AlarmName"
        case comparisonOperator = "ComparisonOperator"
        case datapointsToAlarm = "DatapointsToAlarm"
        case dimensions = "Dimensions"
        case evaluateLowSampleCountPercentile = "EvaluateLowSampleCountPercentile"
        case evaluationPeriods = "EvaluationPeriods"
        case extendedStatistic = "ExtendedStatistic"
        case insufficientDataActions = "InsufficientDataActions"
        case metricName = "MetricName"
        case namespace = "Namespace"
        case okActions = "OkActions"
        case period = "Period"
        case statistic = "Statistic"
        case threshold = "Threshold"
        case thresholdMetricId = "ThresholdMetricId"
        case treatMissingData = "TreatMissingData"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if actionsEnabled != false {
            try encodeContainer.encode(actionsEnabled, forKey: .actionsEnabled)
        }
        if let alarmActions = alarmActions {
            var alarmActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .alarmActions)
            for nonemptystring0 in alarmActions {
                try alarmActionsContainer.encode(nonemptystring0)
            }
        }
        if let alarmArn = self.alarmArn {
            try encodeContainer.encode(alarmArn, forKey: .alarmArn)
        }
        if let alarmConfigurationUpdatedTimestamp = self.alarmConfigurationUpdatedTimestamp {
            try encodeContainer.encode(alarmConfigurationUpdatedTimestamp, forKey: .alarmConfigurationUpdatedTimestamp)
        }
        if let alarmDescription = self.alarmDescription {
            try encodeContainer.encode(alarmDescription, forKey: .alarmDescription)
        }
        if let alarmName = self.alarmName {
            try encodeContainer.encode(alarmName, forKey: .alarmName)
        }
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator, forKey: .comparisonOperator)
        }
        if datapointsToAlarm != 0 {
            try encodeContainer.encode(datapointsToAlarm, forKey: .datapointsToAlarm)
        }
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for awscloudwatchalarmdimensionsdetails0 in dimensions {
                try dimensionsContainer.encode(awscloudwatchalarmdimensionsdetails0)
            }
        }
        if let evaluateLowSampleCountPercentile = self.evaluateLowSampleCountPercentile {
            try encodeContainer.encode(evaluateLowSampleCountPercentile, forKey: .evaluateLowSampleCountPercentile)
        }
        if evaluationPeriods != 0 {
            try encodeContainer.encode(evaluationPeriods, forKey: .evaluationPeriods)
        }
        if let extendedStatistic = self.extendedStatistic {
            try encodeContainer.encode(extendedStatistic, forKey: .extendedStatistic)
        }
        if let insufficientDataActions = insufficientDataActions {
            var insufficientDataActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insufficientDataActions)
            for nonemptystring0 in insufficientDataActions {
                try insufficientDataActionsContainer.encode(nonemptystring0)
            }
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let okActions = okActions {
            var okActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .okActions)
            for nonemptystring0 in okActions {
                try okActionsContainer.encode(nonemptystring0)
            }
        }
        if period != 0 {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let statistic = self.statistic {
            try encodeContainer.encode(statistic, forKey: .statistic)
        }
        if threshold != 0.0 {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let thresholdMetricId = self.thresholdMetricId {
            try encodeContainer.encode(thresholdMetricId, forKey: .thresholdMetricId)
        }
        if let treatMissingData = self.treatMissingData {
            try encodeContainer.encode(treatMissingData, forKey: .treatMissingData)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .actionsEnabled) ?? false
        actionsEnabled = actionsEnabledDecoded
        let alarmActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .alarmActions)
        var alarmActionsDecoded0:[Swift.String]? = nil
        if let alarmActionsContainer = alarmActionsContainer {
            alarmActionsDecoded0 = [Swift.String]()
            for string0 in alarmActionsContainer {
                if let string0 = string0 {
                    alarmActionsDecoded0?.append(string0)
                }
            }
        }
        alarmActions = alarmActionsDecoded0
        let alarmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmArn)
        alarmArn = alarmArnDecoded
        let alarmConfigurationUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmConfigurationUpdatedTimestamp)
        alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestampDecoded
        let alarmDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmDescription)
        alarmDescription = alarmDescriptionDecoded
        let alarmNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmName)
        alarmName = alarmNameDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let datapointsToAlarmDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .datapointsToAlarm) ?? 0
        datapointsToAlarm = datapointsToAlarmDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails?].self, forKey: .dimensions)
        var dimensionsDecoded0:[SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let evaluateLowSampleCountPercentileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluateLowSampleCountPercentile)
        evaluateLowSampleCountPercentile = evaluateLowSampleCountPercentileDecoded
        let evaluationPeriodsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationPeriods) ?? 0
        evaluationPeriods = evaluationPeriodsDecoded
        let extendedStatisticDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extendedStatistic)
        extendedStatistic = extendedStatisticDecoded
        let insufficientDataActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insufficientDataActions)
        var insufficientDataActionsDecoded0:[Swift.String]? = nil
        if let insufficientDataActionsContainer = insufficientDataActionsContainer {
            insufficientDataActionsDecoded0 = [Swift.String]()
            for string0 in insufficientDataActionsContainer {
                if let string0 = string0 {
                    insufficientDataActionsDecoded0?.append(string0)
                }
            }
        }
        insufficientDataActions = insufficientDataActionsDecoded0
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let okActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .okActions)
        var okActionsDecoded0:[Swift.String]? = nil
        if let okActionsContainer = okActionsContainer {
            okActionsDecoded0 = [Swift.String]()
            for string0 in okActionsContainer {
                if let string0 = string0 {
                    okActionsDecoded0?.append(string0)
                }
            }
        }
        okActions = okActionsDecoded0
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period) ?? 0
        period = periodDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statistic)
        statistic = statisticDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .threshold) ?? 0.0
        threshold = thresholdDecoded
        let thresholdMetricIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thresholdMetricId)
        thresholdMetricId = thresholdMetricIdDecoded
        let treatMissingDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treatMissingData)
        treatMissingData = treatMissingDataDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies an alarm and associates it with the specified metric or metric math expression.
    public struct AwsCloudWatchAlarmDetails: Swift.Equatable {
        /// Indicates whether actions should be executed during any changes to the alarm state.
        public var actionsEnabled: Swift.Bool
        /// The list of actions, specified as Amazon Resource Names (ARNs) to execute when this alarm transitions into an ALARM state from any other state.
        public var alarmActions: [Swift.String]?
        /// The ARN of the alarm.
        public var alarmArn: Swift.String?
        /// The time stamp of the last update to the alarm configuration.
        public var alarmConfigurationUpdatedTimestamp: Swift.String?
        /// The description of the alarm.
        public var alarmDescription: Swift.String?
        /// The name of the alarm. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the alarm name.
        public var alarmName: Swift.String?
        /// The arithmetic operation to use when comparing the specified statistic and threshold. The specified statistic value is used as the first operand.
        public var comparisonOperator: Swift.String?
        /// The number of datapoints that must be breaching to trigger the alarm.
        public var datapointsToAlarm: Swift.Int
        /// The dimensions for the metric associated with the alarm.
        public var dimensions: [SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails]?
        /// Used only for alarms based on percentiles. If ignore, the alarm state does not change during periods with too few data points to be statistically significant. If evaluate or this parameter is not used, the alarm is always evaluated and possibly changes state no matter how many data points are available.
        public var evaluateLowSampleCountPercentile: Swift.String?
        /// The number of periods over which data is compared to the specified threshold.
        public var evaluationPeriods: Swift.Int
        /// The percentile statistic for the metric associated with the alarm.
        public var extendedStatistic: Swift.String?
        /// The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state. Each action is specified as an ARN.
        public var insufficientDataActions: [Swift.String]?
        /// The name of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you use Metrics instead and you can't specify MetricName.
        public var metricName: Swift.String?
        /// The namespace of the metric associated with the alarm. This is required for an alarm based on a metric. For an alarm based on a math expression, you can't specify Namespace and you use Metrics instead.
        public var namespace: Swift.String?
        /// The actions to execute when this alarm transitions to the OK state from any other state. Each action is specified as an ARN.
        public var okActions: [Swift.String]?
        /// The period, in seconds, over which the statistic is applied. This is required for an alarm based on a metric.
        public var period: Swift.Int
        /// The statistic for the metric associated with the alarm, other than percentile. For percentile statistics, use ExtendedStatistic. For an alarm based on a metric, you must specify either Statistic or ExtendedStatistic but not both. For an alarm based on a math expression, you can't specify Statistic. Instead, you use Metrics.
        public var statistic: Swift.String?
        /// The value to compare with the specified statistic.
        public var threshold: Swift.Double
        /// n an alarm based on an anomaly detection model, this is the ID of the ANOMALY_DETECTION_BAND function used as the threshold for the alarm.
        public var thresholdMetricId: Swift.String?
        /// Sets how this alarm is to handle missing data points.
        public var treatMissingData: Swift.String?
        /// The unit of the metric associated with the alarm.
        public var unit: Swift.String?

        public init (
            actionsEnabled: Swift.Bool = false,
            alarmActions: [Swift.String]? = nil,
            alarmArn: Swift.String? = nil,
            alarmConfigurationUpdatedTimestamp: Swift.String? = nil,
            alarmDescription: Swift.String? = nil,
            alarmName: Swift.String? = nil,
            comparisonOperator: Swift.String? = nil,
            datapointsToAlarm: Swift.Int = 0,
            dimensions: [SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails]? = nil,
            evaluateLowSampleCountPercentile: Swift.String? = nil,
            evaluationPeriods: Swift.Int = 0,
            extendedStatistic: Swift.String? = nil,
            insufficientDataActions: [Swift.String]? = nil,
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil,
            okActions: [Swift.String]? = nil,
            period: Swift.Int = 0,
            statistic: Swift.String? = nil,
            threshold: Swift.Double = 0.0,
            thresholdMetricId: Swift.String? = nil,
            treatMissingData: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.actionsEnabled = actionsEnabled
            self.alarmActions = alarmActions
            self.alarmArn = alarmArn
            self.alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestamp
            self.alarmDescription = alarmDescription
            self.alarmName = alarmName
            self.comparisonOperator = comparisonOperator
            self.datapointsToAlarm = datapointsToAlarm
            self.dimensions = dimensions
            self.evaluateLowSampleCountPercentile = evaluateLowSampleCountPercentile
            self.evaluationPeriods = evaluationPeriods
            self.extendedStatistic = extendedStatistic
            self.insufficientDataActions = insufficientDataActions
            self.metricName = metricName
            self.namespace = namespace
            self.okActions = okActions
            self.period = period
            self.statistic = statistic
            self.threshold = threshold
            self.thresholdMetricId = thresholdMetricId
            self.treatMissingData = treatMissingData
            self.unit = unit
        }
    }

}

extension SecurityHubClientTypes.AwsCloudWatchAlarmDimensionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the dimensions for the metric associated with the alarm.
    public struct AwsCloudWatchAlarmDimensionsDetails: Swift.Equatable {
        /// The name of a dimension.
        public var name: Swift.String?
        /// The value of a dimension.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactIdentifier = "ArtifactIdentifier"
        case encryptionDisabled = "EncryptionDisabled"
        case location = "Location"
        case name = "Name"
        case namespaceType = "NamespaceType"
        case overrideArtifactName = "OverrideArtifactName"
        case packaging = "Packaging"
        case path = "Path"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactIdentifier = self.artifactIdentifier {
            try encodeContainer.encode(artifactIdentifier, forKey: .artifactIdentifier)
        }
        if encryptionDisabled != false {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespaceType = self.namespaceType {
            try encodeContainer.encode(namespaceType, forKey: .namespaceType)
        }
        if overrideArtifactName != false {
            try encodeContainer.encode(overrideArtifactName, forKey: .overrideArtifactName)
        }
        if let packaging = self.packaging {
            try encodeContainer.encode(packaging, forKey: .packaging)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let artifactIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactIdentifier)
        artifactIdentifier = artifactIdentifierDecoded
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encryptionDisabled) ?? false
        encryptionDisabled = encryptionDisabledDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let namespaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceType)
        namespaceType = namespaceTypeDecoded
        let overrideArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .overrideArtifactName) ?? false
        overrideArtifactName = overrideArtifactNameDecoded
        let packagingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packaging)
        packaging = packagingDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the build artifacts for the CodeBuild project.
    public struct AwsCodeBuildProjectArtifactsDetails: Swift.Equatable {
        /// An identifier for the artifact definition.
        public var artifactIdentifier: Swift.String?
        /// Indicates whether to disable encryption on the artifact. Only valid when Type is S3.
        public var encryptionDisabled: Swift.Bool
        /// Only used when Type is S3. The name of the S3 bucket where the artifact is located.
        public var location: Swift.String?
        /// Only used when Type is S3. The name of the artifact. Used with NamepaceType and Path to determine the pattern for storing the artifact.
        public var name: Swift.String?
        /// Only used when Type is S3. The value to use for the namespace. Used with Name and Path to determine the pattern for storing the artifact.
        public var namespaceType: Swift.String?
        /// Whether the name specified in the buildspec file overrides the artifact name.
        public var overrideArtifactName: Swift.Bool
        /// Only used when Type is S3. The type of output artifact to create.
        public var packaging: Swift.String?
        /// Only used when Type is S3. The path to the artifact. Used with Name and NamespaceType to determine the pattern for storing the artifact.
        public var path: Swift.String?
        /// The type of build artifact.
        public var type: Swift.String?

        public init (
            artifactIdentifier: Swift.String? = nil,
            encryptionDisabled: Swift.Bool = false,
            location: Swift.String? = nil,
            name: Swift.String? = nil,
            namespaceType: Swift.String? = nil,
            overrideArtifactName: Swift.Bool = false,
            packaging: Swift.String? = nil,
            path: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.artifactIdentifier = artifactIdentifier
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.name = name
            self.namespaceType = namespaceType
            self.overrideArtifactName = overrideArtifactName
            self.packaging = packaging
            self.path = path
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifacts = "Artifacts"
        case encryptionKey = "EncryptionKey"
        case environment = "Environment"
        case logsConfig = "LogsConfig"
        case name = "Name"
        case secondaryArtifacts = "SecondaryArtifacts"
        case serviceRole = "ServiceRole"
        case source = "Source"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifacts = artifacts {
            var artifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .artifacts)
            for awscodebuildprojectartifactsdetails0 in artifacts {
                try artifactsContainer.encode(awscodebuildprojectartifactsdetails0)
            }
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let logsConfig = self.logsConfig {
            try encodeContainer.encode(logsConfig, forKey: .logsConfig)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for awscodebuildprojectartifactsdetails0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(awscodebuildprojectartifactsdetails0)
            }
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let artifactsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails?].self, forKey: .artifacts)
        var artifactsDecoded0:[SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]? = nil
        if let artifactsContainer = artifactsContainer {
            artifactsDecoded0 = [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]()
            for structure0 in artifactsContainer {
                if let structure0 = structure0 {
                    artifactsDecoded0?.append(structure0)
                }
            }
        }
        artifacts = artifactsDecoded0
        let environmentDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCodeBuildProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCodeBuildProjectSource.self, forKey: .source)
        source = sourceDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let logsConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails.self, forKey: .logsConfig)
        logsConfig = logsConfigDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Information about an CodeBuild project.
    public struct AwsCodeBuildProjectDetails: Swift.Equatable {
        /// Information about the build artifacts for the CodeBuild project.
        public var artifacts: [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]?
        /// The KMS key used to encrypt the build output artifacts. You can specify either the ARN of the KMS key or, if available, the KMS key alias (using the format alias/alias-name).
        public var encryptionKey: Swift.String?
        /// Information about the build environment for this build project.
        public var environment: SecurityHubClientTypes.AwsCodeBuildProjectEnvironment?
        /// Information about logs for the build project.
        public var logsConfig: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails?
        /// The name of the build project.
        public var name: Swift.String?
        /// Information about the secondary artifacts for the CodeBuild project.
        public var secondaryArtifacts: [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]?
        /// The ARN of the IAM role that enables CodeBuild to interact with dependent Amazon Web Services services on behalf of the Amazon Web Services account.
        public var serviceRole: Swift.String?
        /// Information about the build input source code for this build project.
        public var source: SecurityHubClientTypes.AwsCodeBuildProjectSource?
        /// Information about the VPC configuration that CodeBuild accesses.
        public var vpcConfig: SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig?

        public init (
            artifacts: [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]? = nil,
            encryptionKey: Swift.String? = nil,
            environment: SecurityHubClientTypes.AwsCodeBuildProjectEnvironment? = nil,
            logsConfig: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails? = nil,
            name: Swift.String? = nil,
            secondaryArtifacts: [SecurityHubClientTypes.AwsCodeBuildProjectArtifactsDetails]? = nil,
            serviceRole: Swift.String? = nil,
            source: SecurityHubClientTypes.AwsCodeBuildProjectSource? = nil,
            vpcConfig: SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig? = nil
        )
        {
            self.artifacts = artifacts
            self.encryptionKey = encryptionKey
            self.environment = environment
            self.logsConfig = logsConfig
            self.name = name
            self.secondaryArtifacts = secondaryArtifacts
            self.serviceRole = serviceRole
            self.source = source
            self.vpcConfig = vpcConfig
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectEnvironment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificate = "Certificate"
        case environmentVariables = "EnvironmentVariables"
        case imagePullCredentialsType = "ImagePullCredentialsType"
        case privilegedMode = "PrivilegedMode"
        case registryCredential = "RegistryCredential"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = self.certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let environmentVariables = environmentVariables {
            var environmentVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentVariables)
            for awscodebuildprojectenvironmentenvironmentvariablesdetails0 in environmentVariables {
                try environmentVariablesContainer.encode(awscodebuildprojectenvironmentenvironmentvariablesdetails0)
            }
        }
        if let imagePullCredentialsType = self.imagePullCredentialsType {
            try encodeContainer.encode(imagePullCredentialsType, forKey: .imagePullCredentialsType)
        }
        if privilegedMode != false {
            try encodeContainer.encode(privilegedMode, forKey: .privilegedMode)
        }
        if let registryCredential = self.registryCredential {
            try encodeContainer.encode(registryCredential, forKey: .registryCredential)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificate)
        certificate = certificateDecoded
        let environmentVariablesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails?].self, forKey: .environmentVariables)
        var environmentVariablesDecoded0:[SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]? = nil
        if let environmentVariablesContainer = environmentVariablesContainer {
            environmentVariablesDecoded0 = [SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]()
            for structure0 in environmentVariablesContainer {
                if let structure0 = structure0 {
                    environmentVariablesDecoded0?.append(structure0)
                }
            }
        }
        environmentVariables = environmentVariablesDecoded0
        let privilegedModeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privilegedMode) ?? false
        privilegedMode = privilegedModeDecoded
        let imagePullCredentialsTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePullCredentialsType)
        imagePullCredentialsType = imagePullCredentialsTypeDecoded
        let registryCredentialDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential.self, forKey: .registryCredential)
        registryCredential = registryCredentialDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the build environment for this build project.
    public struct AwsCodeBuildProjectEnvironment: Swift.Equatable {
        /// The certificate to use with this build project.
        public var certificate: Swift.String?
        /// A set of environment variables to make available to builds for the build project.
        public var environmentVariables: [SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]?
        /// The type of credentials CodeBuild uses to pull images in your build. Valid values:
        ///
        /// * CODEBUILD specifies that CodeBuild uses its own credentials. This requires that you modify your ECR repository policy to trust the CodeBuild service principal.
        ///
        /// * SERVICE_ROLE specifies that CodeBuild uses your build project's service role.
        ///
        ///
        /// When you use a cross-account or private registry image, you must use SERVICE_ROLE credentials. When you use an CodeBuild curated image, you must use CODEBUILD credentials.
        public var imagePullCredentialsType: Swift.String?
        /// Whether to allow the Docker daemon to run inside a Docker container. Set to true if the build project is used to build Docker images.
        public var privilegedMode: Swift.Bool
        /// The credentials for access to a private registry.
        public var registryCredential: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential?
        /// The type of build environment to use for related builds. The environment type ARM_CONTAINER is available only in Regions US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland), Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and Europe (Frankfurt). The environment type LINUX_CONTAINER with compute type build.general1.2xlarge is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia). The environment type LINUX_GPU_CONTAINER is available only in Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing), and China (Ningxia). Valid values: WINDOWS_CONTAINER | LINUX_CONTAINER | LINUX_GPU_CONTAINER | ARM_CONTAINER
        public var type: Swift.String?

        public init (
            certificate: Swift.String? = nil,
            environmentVariables: [SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails]? = nil,
            imagePullCredentialsType: Swift.String? = nil,
            privilegedMode: Swift.Bool = false,
            registryCredential: SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential? = nil,
            type: Swift.String? = nil
        )
        {
            self.certificate = certificate
            self.environmentVariables = environmentVariables
            self.imagePullCredentialsType = imagePullCredentialsType
            self.privilegedMode = privilegedMode
            self.registryCredential = registryCredential
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an environment variable that is available to builds for the build project.
    public struct AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails: Swift.Equatable {
        /// The name of the environment variable.
        public var name: Swift.String?
        /// The type of environment variable.
        public var type: Swift.String?
        /// The value of the environment variable.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectEnvironmentRegistryCredential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credential = "Credential"
        case credentialProvider = "CredentialProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credential = self.credential {
            try encodeContainer.encode(credential, forKey: .credential)
        }
        if let credentialProvider = self.credentialProvider {
            try encodeContainer.encode(credentialProvider, forKey: .credentialProvider)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credential)
        credential = credentialDecoded
        let credentialProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialProvider)
        credentialProvider = credentialProviderDecoded
    }
}

extension SecurityHubClientTypes {
    /// The credentials for access to a private registry.
    public struct AwsCodeBuildProjectEnvironmentRegistryCredential: Swift.Equatable {
        /// The ARN or name of credentials created using Secrets Manager. The credential can use the name of the credentials only if they exist in your current Amazon Web Services Region.
        public var credential: Swift.String?
        /// The service that created the credentials to access a private Docker registry. The valid value, SECRETS_MANAGER, is for Secrets Manager.
        public var credentialProvider: Swift.String?

        public init (
            credential: Swift.String? = nil,
            credentialProvider: Swift.String? = nil
        )
        {
            self.credential = credential
            self.credentialProvider = credentialProvider
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case status = "Status"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about CloudWatch Logs for the build project.
    public struct AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails: Swift.Equatable {
        /// The group name of the logs in CloudWatch Logs.
        public var groupName: Swift.String?
        /// The current status of the logs in CloudWatch Logs for a build project.
        public var status: Swift.String?
        /// The prefix of the stream name of the CloudWatch Logs.
        public var streamName: Swift.String?

        public init (
            groupName: Swift.String? = nil,
            status: Swift.String? = nil,
            streamName: Swift.String? = nil
        )
        {
            self.groupName = groupName
            self.status = status
            self.streamName = streamName
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogs = "CloudWatchLogs"
        case s3Logs = "S3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogs = self.cloudWatchLogs {
            try encodeContainer.encode(cloudWatchLogs, forKey: .cloudWatchLogs)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails.self, forKey: .cloudWatchLogs)
        cloudWatchLogs = cloudWatchLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about logs for the build project.
    public struct AwsCodeBuildProjectLogsConfigDetails: Swift.Equatable {
        /// Information about CloudWatch Logs for the build project.
        public var cloudWatchLogs: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails?
        /// Information about logs built to an S3 bucket for a build project.
        public var s3Logs: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails?

        public init (
            cloudWatchLogs: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails? = nil,
            s3Logs: SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.s3Logs = s3Logs
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectLogsConfigS3LogsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionDisabled = "EncryptionDisabled"
        case location = "Location"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if encryptionDisabled != false {
            try encodeContainer.encode(encryptionDisabled, forKey: .encryptionDisabled)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encryptionDisabled) ?? false
        encryptionDisabled = encryptionDisabledDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about logs built to an S3 bucket for a build project.
    public struct AwsCodeBuildProjectLogsConfigS3LogsDetails: Swift.Equatable {
        /// Whether to disable encryption of the S3 build log output.
        public var encryptionDisabled: Swift.Bool
        /// The ARN of the S3 bucket and the path prefix for S3 logs.
        public var location: Swift.String?
        /// The current status of the S3 build logs.
        public var status: Swift.String?

        public init (
            encryptionDisabled: Swift.Bool = false,
            location: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.encryptionDisabled = encryptionDisabled
            self.location = location
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gitCloneDepth = "GitCloneDepth"
        case insecureSsl = "InsecureSsl"
        case location = "Location"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if gitCloneDepth != 0 {
            try encodeContainer.encode(gitCloneDepth, forKey: .gitCloneDepth)
        }
        if insecureSsl != false {
            try encodeContainer.encode(insecureSsl, forKey: .insecureSsl)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let gitCloneDepthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gitCloneDepth) ?? 0
        gitCloneDepth = gitCloneDepthDecoded
        let insecureSslDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insecureSsl) ?? false
        insecureSsl = insecureSslDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the build input source code for this build project.
    public struct AwsCodeBuildProjectSource: Swift.Equatable {
        /// Information about the Git clone depth for the build project.
        public var gitCloneDepth: Swift.Int
        /// Whether to ignore SSL warnings while connecting to the project source code.
        public var insecureSsl: Swift.Bool
        /// Information about the location of the source code to be built. Valid values include:
        ///
        /// * For source code settings that are specified in the source action of a pipeline in CodePipeline, location should not be specified. If it is specified, CodePipeline ignores it. This is because CodePipeline uses the settings in a pipeline's source action instead of this value.
        ///
        /// * For source code in an CodeCommit repository, the HTTPS clone URL to the repository that contains the source code and the build spec file (for example, https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name ).
        ///
        /// * For source code in an S3 input bucket, one of the following.
        ///
        /// * The path to the ZIP file that contains the source code (for example, bucket-name/path/to/object-name.zip).
        ///
        /// * The path to the folder that contains the source code (for example, bucket-name/path/to/source-code/folder/).
        ///
        ///
        ///
        ///
        /// * For source code in a GitHub repository, the HTTPS clone URL to the repository that contains the source and the build spec file.
        ///
        /// * For source code in a Bitbucket repository, the HTTPS clone URL to the repository that contains the source and the build spec file.
        public var location: Swift.String?
        /// The type of repository that contains the source code to be built. Valid values are:
        ///
        /// * BITBUCKET - The source code is in a Bitbucket repository.
        ///
        /// * CODECOMMIT - The source code is in an CodeCommit repository.
        ///
        /// * CODEPIPELINE - The source code settings are specified in the source action of a pipeline in CodePipeline.
        ///
        /// * GITHUB - The source code is in a GitHub repository.
        ///
        /// * GITHUB_ENTERPRISE - The source code is in a GitHub Enterprise repository.
        ///
        /// * NO_SOURCE - The project does not have input source code.
        ///
        /// * S3 - The source code is in an S3 input bucket.
        public var type: Swift.String?

        public init (
            gitCloneDepth: Swift.Int = 0,
            insecureSsl: Swift.Bool = false,
            location: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.gitCloneDepth = gitCloneDepth
            self.insecureSsl = insecureSsl
            self.location = location
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsCodeBuildProjectVpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for nonemptystring0 in subnets {
                try subnetsContainer.encode(nonemptystring0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Information about the VPC configuration that CodeBuild accesses.
    public struct AwsCodeBuildProjectVpcConfig: Swift.Equatable {
        /// A list of one or more security group IDs in your VPC.
        public var securityGroupIds: [Swift.String]?
        /// A list of one or more subnet IDs in your VPC.
        public var subnets: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsCorsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCredentials = "AllowCredentials"
        case allowHeaders = "AllowHeaders"
        case allowMethods = "AllowMethods"
        case allowOrigins = "AllowOrigins"
        case exposeHeaders = "ExposeHeaders"
        case maxAge = "MaxAge"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowCredentials != false {
            try encodeContainer.encode(allowCredentials, forKey: .allowCredentials)
        }
        if let allowHeaders = allowHeaders {
            var allowHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowHeaders)
            for nonemptystring0 in allowHeaders {
                try allowHeadersContainer.encode(nonemptystring0)
            }
        }
        if let allowMethods = allowMethods {
            var allowMethodsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowMethods)
            for nonemptystring0 in allowMethods {
                try allowMethodsContainer.encode(nonemptystring0)
            }
        }
        if let allowOrigins = allowOrigins {
            var allowOriginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowOrigins)
            for nonemptystring0 in allowOrigins {
                try allowOriginsContainer.encode(nonemptystring0)
            }
        }
        if let exposeHeaders = exposeHeaders {
            var exposeHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exposeHeaders)
            for nonemptystring0 in exposeHeaders {
                try exposeHeadersContainer.encode(nonemptystring0)
            }
        }
        if maxAge != 0 {
            try encodeContainer.encode(maxAge, forKey: .maxAge)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowOriginsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowOrigins)
        var allowOriginsDecoded0:[Swift.String]? = nil
        if let allowOriginsContainer = allowOriginsContainer {
            allowOriginsDecoded0 = [Swift.String]()
            for string0 in allowOriginsContainer {
                if let string0 = string0 {
                    allowOriginsDecoded0?.append(string0)
                }
            }
        }
        allowOrigins = allowOriginsDecoded0
        let allowCredentialsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCredentials) ?? false
        allowCredentials = allowCredentialsDecoded
        let exposeHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .exposeHeaders)
        var exposeHeadersDecoded0:[Swift.String]? = nil
        if let exposeHeadersContainer = exposeHeadersContainer {
            exposeHeadersDecoded0 = [Swift.String]()
            for string0 in exposeHeadersContainer {
                if let string0 = string0 {
                    exposeHeadersDecoded0?.append(string0)
                }
            }
        }
        exposeHeaders = exposeHeadersDecoded0
        let maxAgeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAge) ?? 0
        maxAge = maxAgeDecoded
        let allowMethodsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowMethods)
        var allowMethodsDecoded0:[Swift.String]? = nil
        if let allowMethodsContainer = allowMethodsContainer {
            allowMethodsDecoded0 = [Swift.String]()
            for string0 in allowMethodsContainer {
                if let string0 = string0 {
                    allowMethodsDecoded0?.append(string0)
                }
            }
        }
        allowMethods = allowMethodsDecoded0
        let allowHeadersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowHeaders)
        var allowHeadersDecoded0:[Swift.String]? = nil
        if let allowHeadersContainer = allowHeadersContainer {
            allowHeadersDecoded0 = [Swift.String]()
            for string0 in allowHeadersContainer {
                if let string0 = string0 {
                    allowHeadersDecoded0?.append(string0)
                }
            }
        }
        allowHeaders = allowHeadersDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Contains the cross-origin resource sharing (CORS) configuration for the API. CORS is only supported for HTTP APIs.
    public struct AwsCorsConfiguration: Swift.Equatable {
        /// Indicates whether the CORS request includes credentials.
        public var allowCredentials: Swift.Bool
        /// The allowed headers for CORS requests.
        public var allowHeaders: [Swift.String]?
        /// The allowed methods for CORS requests.
        public var allowMethods: [Swift.String]?
        /// The allowed origins for CORS requests.
        public var allowOrigins: [Swift.String]?
        /// The exposed headers for CORS requests.
        public var exposeHeaders: [Swift.String]?
        /// The number of seconds for which the browser caches preflight request results.
        public var maxAge: Swift.Int

        public init (
            allowCredentials: Swift.Bool = false,
            allowHeaders: [Swift.String]? = nil,
            allowMethods: [Swift.String]? = nil,
            allowOrigins: [Swift.String]? = nil,
            exposeHeaders: [Swift.String]? = nil,
            maxAge: Swift.Int = 0
        )
        {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeType = self.attributeType {
            try encodeContainer.encode(attributeType, forKey: .attributeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains a definition of an attribute for the table.
    public struct AwsDynamoDbTableAttributeDefinition: Swift.Equatable {
        /// The name of the attribute.
        public var attributeName: Swift.String?
        /// The type of the attribute.
        public var attributeType: Swift.String?

        public init (
            attributeName: Swift.String? = nil,
            attributeType: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case billingMode = "BillingMode"
        case lastUpdateToPayPerRequestDateTime = "LastUpdateToPayPerRequestDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let billingMode = self.billingMode {
            try encodeContainer.encode(billingMode, forKey: .billingMode)
        }
        if let lastUpdateToPayPerRequestDateTime = self.lastUpdateToPayPerRequestDateTime {
            try encodeContainer.encode(lastUpdateToPayPerRequestDateTime, forKey: .lastUpdateToPayPerRequestDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let billingModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .billingMode)
        billingMode = billingModeDecoded
        let lastUpdateToPayPerRequestDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateToPayPerRequestDateTime)
        lastUpdateToPayPerRequestDateTime = lastUpdateToPayPerRequestDateTimeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the billing for read/write capacity on the table.
    public struct AwsDynamoDbTableBillingModeSummary: Swift.Equatable {
        /// The method used to charge for read and write throughput and to manage capacity.
        public var billingMode: Swift.String?
        /// If the billing mode is PAY_PER_REQUEST, indicates when the billing mode was set to that value. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastUpdateToPayPerRequestDateTime: Swift.String?

        public init (
            billingMode: Swift.String? = nil,
            lastUpdateToPayPerRequestDateTime: Swift.String? = nil
        )
        {
            self.billingMode = billingMode
            self.lastUpdateToPayPerRequestDateTime = lastUpdateToPayPerRequestDateTime
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeDefinitions = "AttributeDefinitions"
        case billingModeSummary = "BillingModeSummary"
        case creationDateTime = "CreationDateTime"
        case globalSecondaryIndexes = "GlobalSecondaryIndexes"
        case globalTableVersion = "GlobalTableVersion"
        case itemCount = "ItemCount"
        case keySchema = "KeySchema"
        case latestStreamArn = "LatestStreamArn"
        case latestStreamLabel = "LatestStreamLabel"
        case localSecondaryIndexes = "LocalSecondaryIndexes"
        case provisionedThroughput = "ProvisionedThroughput"
        case replicas = "Replicas"
        case restoreSummary = "RestoreSummary"
        case sseDescription = "SseDescription"
        case streamSpecification = "StreamSpecification"
        case tableId = "TableId"
        case tableName = "TableName"
        case tableSizeBytes = "TableSizeBytes"
        case tableStatus = "TableStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeDefinitions = attributeDefinitions {
            var attributeDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeDefinitions)
            for awsdynamodbtableattributedefinition0 in attributeDefinitions {
                try attributeDefinitionsContainer.encode(awsdynamodbtableattributedefinition0)
            }
        }
        if let billingModeSummary = self.billingModeSummary {
            try encodeContainer.encode(billingModeSummary, forKey: .billingModeSummary)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let globalSecondaryIndexes = globalSecondaryIndexes {
            var globalSecondaryIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .globalSecondaryIndexes)
            for awsdynamodbtableglobalsecondaryindex0 in globalSecondaryIndexes {
                try globalSecondaryIndexesContainer.encode(awsdynamodbtableglobalsecondaryindex0)
            }
        }
        if let globalTableVersion = self.globalTableVersion {
            try encodeContainer.encode(globalTableVersion, forKey: .globalTableVersion)
        }
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let keySchema = keySchema {
            var keySchemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keySchema)
            for awsdynamodbtablekeyschema0 in keySchema {
                try keySchemaContainer.encode(awsdynamodbtablekeyschema0)
            }
        }
        if let latestStreamArn = self.latestStreamArn {
            try encodeContainer.encode(latestStreamArn, forKey: .latestStreamArn)
        }
        if let latestStreamLabel = self.latestStreamLabel {
            try encodeContainer.encode(latestStreamLabel, forKey: .latestStreamLabel)
        }
        if let localSecondaryIndexes = localSecondaryIndexes {
            var localSecondaryIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .localSecondaryIndexes)
            for awsdynamodbtablelocalsecondaryindex0 in localSecondaryIndexes {
                try localSecondaryIndexesContainer.encode(awsdynamodbtablelocalsecondaryindex0)
            }
        }
        if let provisionedThroughput = self.provisionedThroughput {
            try encodeContainer.encode(provisionedThroughput, forKey: .provisionedThroughput)
        }
        if let replicas = replicas {
            var replicasContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicas)
            for awsdynamodbtablereplica0 in replicas {
                try replicasContainer.encode(awsdynamodbtablereplica0)
            }
        }
        if let restoreSummary = self.restoreSummary {
            try encodeContainer.encode(restoreSummary, forKey: .restoreSummary)
        }
        if let sseDescription = self.sseDescription {
            try encodeContainer.encode(sseDescription, forKey: .sseDescription)
        }
        if let streamSpecification = self.streamSpecification {
            try encodeContainer.encode(streamSpecification, forKey: .streamSpecification)
        }
        if let tableId = self.tableId {
            try encodeContainer.encode(tableId, forKey: .tableId)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if tableSizeBytes != 0 {
            try encodeContainer.encode(tableSizeBytes, forKey: .tableSizeBytes)
        }
        if let tableStatus = self.tableStatus {
            try encodeContainer.encode(tableStatus, forKey: .tableStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDefinitionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition?].self, forKey: .attributeDefinitions)
        var attributeDefinitionsDecoded0:[SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition]? = nil
        if let attributeDefinitionsContainer = attributeDefinitionsContainer {
            attributeDefinitionsDecoded0 = [SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition]()
            for structure0 in attributeDefinitionsContainer {
                if let structure0 = structure0 {
                    attributeDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        attributeDefinitions = attributeDefinitionsDecoded0
        let billingModeSummaryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary.self, forKey: .billingModeSummary)
        billingModeSummary = billingModeSummaryDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let globalSecondaryIndexesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex?].self, forKey: .globalSecondaryIndexes)
        var globalSecondaryIndexesDecoded0:[SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex]? = nil
        if let globalSecondaryIndexesContainer = globalSecondaryIndexesContainer {
            globalSecondaryIndexesDecoded0 = [SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex]()
            for structure0 in globalSecondaryIndexesContainer {
                if let structure0 = structure0 {
                    globalSecondaryIndexesDecoded0?.append(structure0)
                }
            }
        }
        globalSecondaryIndexes = globalSecondaryIndexesDecoded0
        let globalTableVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalTableVersion)
        globalTableVersion = globalTableVersionDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount) ?? 0
        itemCount = itemCountDecoded
        let keySchemaContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsDynamoDbTableKeySchema?].self, forKey: .keySchema)
        var keySchemaDecoded0:[SecurityHubClientTypes.AwsDynamoDbTableKeySchema]? = nil
        if let keySchemaContainer = keySchemaContainer {
            keySchemaDecoded0 = [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]()
            for structure0 in keySchemaContainer {
                if let structure0 = structure0 {
                    keySchemaDecoded0?.append(structure0)
                }
            }
        }
        keySchema = keySchemaDecoded0
        let latestStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestStreamArn)
        latestStreamArn = latestStreamArnDecoded
        let latestStreamLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestStreamLabel)
        latestStreamLabel = latestStreamLabelDecoded
        let localSecondaryIndexesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex?].self, forKey: .localSecondaryIndexes)
        var localSecondaryIndexesDecoded0:[SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex]? = nil
        if let localSecondaryIndexesContainer = localSecondaryIndexesContainer {
            localSecondaryIndexesDecoded0 = [SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex]()
            for structure0 in localSecondaryIndexesContainer {
                if let structure0 = structure0 {
                    localSecondaryIndexesDecoded0?.append(structure0)
                }
            }
        }
        localSecondaryIndexes = localSecondaryIndexesDecoded0
        let provisionedThroughputDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput.self, forKey: .provisionedThroughput)
        provisionedThroughput = provisionedThroughputDecoded
        let replicasContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsDynamoDbTableReplica?].self, forKey: .replicas)
        var replicasDecoded0:[SecurityHubClientTypes.AwsDynamoDbTableReplica]? = nil
        if let replicasContainer = replicasContainer {
            replicasDecoded0 = [SecurityHubClientTypes.AwsDynamoDbTableReplica]()
            for structure0 in replicasContainer {
                if let structure0 = structure0 {
                    replicasDecoded0?.append(structure0)
                }
            }
        }
        replicas = replicasDecoded0
        let restoreSummaryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary.self, forKey: .restoreSummary)
        restoreSummary = restoreSummaryDecoded
        let sseDescriptionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableSseDescription.self, forKey: .sseDescription)
        sseDescription = sseDescriptionDecoded
        let streamSpecificationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification.self, forKey: .streamSpecification)
        streamSpecification = streamSpecificationDecoded
        let tableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableId)
        tableId = tableIdDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let tableSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .tableSizeBytes) ?? 0
        tableSizeBytes = tableSizeBytesDecoded
        let tableStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableStatus)
        tableStatus = tableStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about a DynamoDB table.
    public struct AwsDynamoDbTableDetails: Swift.Equatable {
        /// A list of attribute definitions for the table.
        public var attributeDefinitions: [SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition]?
        /// Information about the billing for read/write capacity on the table.
        public var billingModeSummary: SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary?
        /// Indicates when the table was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var creationDateTime: Swift.String?
        /// List of global secondary indexes for the table.
        public var globalSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex]?
        /// The version of global tables being used.
        public var globalTableVersion: Swift.String?
        /// The number of items in the table.
        public var itemCount: Swift.Int
        /// The primary key structure for the table.
        public var keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]?
        /// The ARN of the latest stream for the table.
        public var latestStreamArn: Swift.String?
        /// The label of the latest stream. The label is not a unique identifier.
        public var latestStreamLabel: Swift.String?
        /// The list of local secondary indexes for the table.
        public var localSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex]?
        /// Information about the provisioned throughput for the table.
        public var provisionedThroughput: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput?
        /// The list of replicas of this table.
        public var replicas: [SecurityHubClientTypes.AwsDynamoDbTableReplica]?
        /// Information about the restore for the table.
        public var restoreSummary: SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary?
        /// Information about the server-side encryption for the table.
        public var sseDescription: SecurityHubClientTypes.AwsDynamoDbTableSseDescription?
        /// The current DynamoDB Streams configuration for the table.
        public var streamSpecification: SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification?
        /// The identifier of the table.
        public var tableId: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?
        /// The total size of the table in bytes.
        public var tableSizeBytes: Swift.Int
        /// The current status of the table. Valid values are as follows:
        ///
        /// * ACTIVE
        ///
        /// * ARCHIVED
        ///
        /// * ARCHIVING
        ///
        /// * CREATING
        ///
        /// * DELETING
        ///
        /// * INACCESSIBLE_ENCRYPTION_CREDENTIALS
        ///
        /// * UPDATING
        public var tableStatus: Swift.String?

        public init (
            attributeDefinitions: [SecurityHubClientTypes.AwsDynamoDbTableAttributeDefinition]? = nil,
            billingModeSummary: SecurityHubClientTypes.AwsDynamoDbTableBillingModeSummary? = nil,
            creationDateTime: Swift.String? = nil,
            globalSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex]? = nil,
            globalTableVersion: Swift.String? = nil,
            itemCount: Swift.Int = 0,
            keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]? = nil,
            latestStreamArn: Swift.String? = nil,
            latestStreamLabel: Swift.String? = nil,
            localSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex]? = nil,
            provisionedThroughput: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput? = nil,
            replicas: [SecurityHubClientTypes.AwsDynamoDbTableReplica]? = nil,
            restoreSummary: SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary? = nil,
            sseDescription: SecurityHubClientTypes.AwsDynamoDbTableSseDescription? = nil,
            streamSpecification: SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification? = nil,
            tableId: Swift.String? = nil,
            tableName: Swift.String? = nil,
            tableSizeBytes: Swift.Int = 0,
            tableStatus: Swift.String? = nil
        )
        {
            self.attributeDefinitions = attributeDefinitions
            self.billingModeSummary = billingModeSummary
            self.creationDateTime = creationDateTime
            self.globalSecondaryIndexes = globalSecondaryIndexes
            self.globalTableVersion = globalTableVersion
            self.itemCount = itemCount
            self.keySchema = keySchema
            self.latestStreamArn = latestStreamArn
            self.latestStreamLabel = latestStreamLabel
            self.localSecondaryIndexes = localSecondaryIndexes
            self.provisionedThroughput = provisionedThroughput
            self.replicas = replicas
            self.restoreSummary = restoreSummary
            self.sseDescription = sseDescription
            self.streamSpecification = streamSpecification
            self.tableId = tableId
            self.tableName = tableName
            self.tableSizeBytes = tableSizeBytes
            self.tableStatus = tableStatus
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableGlobalSecondaryIndex: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backfilling = "Backfilling"
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case indexSizeBytes = "IndexSizeBytes"
        case indexStatus = "IndexStatus"
        case itemCount = "ItemCount"
        case keySchema = "KeySchema"
        case projection = "Projection"
        case provisionedThroughput = "ProvisionedThroughput"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backfilling != false {
            try encodeContainer.encode(backfilling, forKey: .backfilling)
        }
        if let indexArn = self.indexArn {
            try encodeContainer.encode(indexArn, forKey: .indexArn)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if indexSizeBytes != 0 {
            try encodeContainer.encode(indexSizeBytes, forKey: .indexSizeBytes)
        }
        if let indexStatus = self.indexStatus {
            try encodeContainer.encode(indexStatus, forKey: .indexStatus)
        }
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let keySchema = keySchema {
            var keySchemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keySchema)
            for awsdynamodbtablekeyschema0 in keySchema {
                try keySchemaContainer.encode(awsdynamodbtablekeyschema0)
            }
        }
        if let projection = self.projection {
            try encodeContainer.encode(projection, forKey: .projection)
        }
        if let provisionedThroughput = self.provisionedThroughput {
            try encodeContainer.encode(provisionedThroughput, forKey: .provisionedThroughput)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backfillingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .backfilling) ?? false
        backfilling = backfillingDecoded
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let indexSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .indexSizeBytes) ?? 0
        indexSizeBytes = indexSizeBytesDecoded
        let indexStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexStatus)
        indexStatus = indexStatusDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount) ?? 0
        itemCount = itemCountDecoded
        let keySchemaContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsDynamoDbTableKeySchema?].self, forKey: .keySchema)
        var keySchemaDecoded0:[SecurityHubClientTypes.AwsDynamoDbTableKeySchema]? = nil
        if let keySchemaContainer = keySchemaContainer {
            keySchemaDecoded0 = [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]()
            for structure0 in keySchemaContainer {
                if let structure0 = structure0 {
                    keySchemaDecoded0?.append(structure0)
                }
            }
        }
        keySchema = keySchemaDecoded0
        let projectionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableProjection.self, forKey: .projection)
        projection = projectionDecoded
        let provisionedThroughputDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput.self, forKey: .provisionedThroughput)
        provisionedThroughput = provisionedThroughputDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information abut a global secondary index for the table.
    public struct AwsDynamoDbTableGlobalSecondaryIndex: Swift.Equatable {
        /// Whether the index is currently backfilling.
        public var backfilling: Swift.Bool
        /// The ARN of the index.
        public var indexArn: Swift.String?
        /// The name of the index.
        public var indexName: Swift.String?
        /// The total size in bytes of the index.
        public var indexSizeBytes: Swift.Int
        /// The current status of the index.
        ///
        /// * ACTIVE
        ///
        /// * CREATING
        ///
        /// * DELETING
        ///
        /// * UPDATING
        public var indexStatus: Swift.String?
        /// The number of items in the index.
        public var itemCount: Swift.Int
        /// The key schema for the index.
        public var keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]?
        /// Attributes that are copied from the table into an index.
        public var projection: SecurityHubClientTypes.AwsDynamoDbTableProjection?
        /// Information about the provisioned throughput settings for the indexes.
        public var provisionedThroughput: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput?

        public init (
            backfilling: Swift.Bool = false,
            indexArn: Swift.String? = nil,
            indexName: Swift.String? = nil,
            indexSizeBytes: Swift.Int = 0,
            indexStatus: Swift.String? = nil,
            itemCount: Swift.Int = 0,
            keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]? = nil,
            projection: SecurityHubClientTypes.AwsDynamoDbTableProjection? = nil,
            provisionedThroughput: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput? = nil
        )
        {
            self.backfilling = backfilling
            self.indexArn = indexArn
            self.indexName = indexName
            self.indexSizeBytes = indexSizeBytes
            self.indexStatus = indexStatus
            self.itemCount = itemCount
            self.keySchema = keySchema
            self.projection = projection
            self.provisionedThroughput = provisionedThroughput
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableKeySchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case keyType = "KeyType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let keyType = self.keyType {
            try encodeContainer.encode(keyType, forKey: .keyType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A component of the key schema for the DynamoDB table, a global secondary index, or a local secondary index.
    public struct AwsDynamoDbTableKeySchema: Swift.Equatable {
        /// The name of the key schema attribute.
        public var attributeName: Swift.String?
        /// The type of key used for the key schema attribute. Valid values are HASH or RANGE.
        public var keyType: Swift.String?

        public init (
            attributeName: Swift.String? = nil,
            keyType: Swift.String? = nil
        )
        {
            self.attributeName = attributeName
            self.keyType = keyType
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableLocalSecondaryIndex: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexArn = "IndexArn"
        case indexName = "IndexName"
        case keySchema = "KeySchema"
        case projection = "Projection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexArn = self.indexArn {
            try encodeContainer.encode(indexArn, forKey: .indexArn)
        }
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let keySchema = keySchema {
            var keySchemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keySchema)
            for awsdynamodbtablekeyschema0 in keySchema {
                try keySchemaContainer.encode(awsdynamodbtablekeyschema0)
            }
        }
        if let projection = self.projection {
            try encodeContainer.encode(projection, forKey: .projection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexArn)
        indexArn = indexArnDecoded
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let keySchemaContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsDynamoDbTableKeySchema?].self, forKey: .keySchema)
        var keySchemaDecoded0:[SecurityHubClientTypes.AwsDynamoDbTableKeySchema]? = nil
        if let keySchemaContainer = keySchemaContainer {
            keySchemaDecoded0 = [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]()
            for structure0 in keySchemaContainer {
                if let structure0 = structure0 {
                    keySchemaDecoded0?.append(structure0)
                }
            }
        }
        keySchema = keySchemaDecoded0
        let projectionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableProjection.self, forKey: .projection)
        projection = projectionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a local secondary index for a DynamoDB table.
    public struct AwsDynamoDbTableLocalSecondaryIndex: Swift.Equatable {
        /// The ARN of the index.
        public var indexArn: Swift.String?
        /// The name of the index.
        public var indexName: Swift.String?
        /// The complete key schema for the index.
        public var keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]?
        /// Attributes that are copied from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        public var projection: SecurityHubClientTypes.AwsDynamoDbTableProjection?

        public init (
            indexArn: Swift.String? = nil,
            indexName: Swift.String? = nil,
            keySchema: [SecurityHubClientTypes.AwsDynamoDbTableKeySchema]? = nil,
            projection: SecurityHubClientTypes.AwsDynamoDbTableProjection? = nil
        )
        {
            self.indexArn = indexArn
            self.indexName = indexName
            self.keySchema = keySchema
            self.projection = projection
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableProjection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nonKeyAttributes = "NonKeyAttributes"
        case projectionType = "ProjectionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nonKeyAttributes = nonKeyAttributes {
            var nonKeyAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nonKeyAttributes)
            for nonemptystring0 in nonKeyAttributes {
                try nonKeyAttributesContainer.encode(nonemptystring0)
            }
        }
        if let projectionType = self.projectionType {
            try encodeContainer.encode(projectionType, forKey: .projectionType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nonKeyAttributesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonKeyAttributes)
        var nonKeyAttributesDecoded0:[Swift.String]? = nil
        if let nonKeyAttributesContainer = nonKeyAttributesContainer {
            nonKeyAttributesDecoded0 = [Swift.String]()
            for string0 in nonKeyAttributesContainer {
                if let string0 = string0 {
                    nonKeyAttributesDecoded0?.append(string0)
                }
            }
        }
        nonKeyAttributes = nonKeyAttributesDecoded0
        let projectionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectionType)
        projectionType = projectionTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// For global and local secondary indexes, identifies the attributes that are copied from the table into the index.
    public struct AwsDynamoDbTableProjection: Swift.Equatable {
        /// The nonkey attributes that are projected into the index. For each attribute, provide the attribute name.
        public var nonKeyAttributes: [Swift.String]?
        /// The types of attributes that are projected into the index. Valid values are as follows:
        ///
        /// * ALL
        ///
        /// * INCLUDE
        ///
        /// * KEYS_ONLY
        public var projectionType: Swift.String?

        public init (
            nonKeyAttributes: [Swift.String]? = nil,
            projectionType: Swift.String? = nil
        )
        {
            self.nonKeyAttributes = nonKeyAttributes
            self.projectionType = projectionType
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastDecreaseDateTime = "LastDecreaseDateTime"
        case lastIncreaseDateTime = "LastIncreaseDateTime"
        case numberOfDecreasesToday = "NumberOfDecreasesToday"
        case readCapacityUnits = "ReadCapacityUnits"
        case writeCapacityUnits = "WriteCapacityUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastDecreaseDateTime = self.lastDecreaseDateTime {
            try encodeContainer.encode(lastDecreaseDateTime, forKey: .lastDecreaseDateTime)
        }
        if let lastIncreaseDateTime = self.lastIncreaseDateTime {
            try encodeContainer.encode(lastIncreaseDateTime, forKey: .lastIncreaseDateTime)
        }
        if numberOfDecreasesToday != 0 {
            try encodeContainer.encode(numberOfDecreasesToday, forKey: .numberOfDecreasesToday)
        }
        if readCapacityUnits != 0 {
            try encodeContainer.encode(readCapacityUnits, forKey: .readCapacityUnits)
        }
        if writeCapacityUnits != 0 {
            try encodeContainer.encode(writeCapacityUnits, forKey: .writeCapacityUnits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastDecreaseDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastDecreaseDateTime)
        lastDecreaseDateTime = lastDecreaseDateTimeDecoded
        let lastIncreaseDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastIncreaseDateTime)
        lastIncreaseDateTime = lastIncreaseDateTimeDecoded
        let numberOfDecreasesTodayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDecreasesToday) ?? 0
        numberOfDecreasesToday = numberOfDecreasesTodayDecoded
        let readCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readCapacityUnits) ?? 0
        readCapacityUnits = readCapacityUnitsDecoded
        let writeCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .writeCapacityUnits) ?? 0
        writeCapacityUnits = writeCapacityUnitsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the provisioned throughput for the table or for a global secondary index.
    public struct AwsDynamoDbTableProvisionedThroughput: Swift.Equatable {
        /// Indicates when the provisioned throughput was last decreased. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastDecreaseDateTime: Swift.String?
        /// Indicates when the provisioned throughput was last increased. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastIncreaseDateTime: Swift.String?
        /// The number of times during the current UTC calendar day that the provisioned throughput was decreased.
        public var numberOfDecreasesToday: Swift.Int
        /// The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ThrottlingException.
        public var readCapacityUnits: Swift.Int
        /// The maximum number of writes consumed per second before DynamoDB returns a ThrottlingException.
        public var writeCapacityUnits: Swift.Int

        public init (
            lastDecreaseDateTime: Swift.String? = nil,
            lastIncreaseDateTime: Swift.String? = nil,
            numberOfDecreasesToday: Swift.Int = 0,
            readCapacityUnits: Swift.Int = 0,
            writeCapacityUnits: Swift.Int = 0
        )
        {
            self.lastDecreaseDateTime = lastDecreaseDateTime
            self.lastIncreaseDateTime = lastIncreaseDateTime
            self.numberOfDecreasesToday = numberOfDecreasesToday
            self.readCapacityUnits = readCapacityUnits
            self.writeCapacityUnits = writeCapacityUnits
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readCapacityUnits = "ReadCapacityUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if readCapacityUnits != 0 {
            try encodeContainer.encode(readCapacityUnits, forKey: .readCapacityUnits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readCapacityUnitsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .readCapacityUnits) ?? 0
        readCapacityUnits = readCapacityUnitsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Replica-specific configuration for the provisioned throughput.
    public struct AwsDynamoDbTableProvisionedThroughputOverride: Swift.Equatable {
        /// The read capacity units for the replica.
        public var readCapacityUnits: Swift.Int

        public init (
            readCapacityUnits: Swift.Int = 0
        )
        {
            self.readCapacityUnits = readCapacityUnits
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableReplica: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case globalSecondaryIndexes = "GlobalSecondaryIndexes"
        case kmsMasterKeyId = "KmsMasterKeyId"
        case provisionedThroughputOverride = "ProvisionedThroughputOverride"
        case regionName = "RegionName"
        case replicaStatus = "ReplicaStatus"
        case replicaStatusDescription = "ReplicaStatusDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalSecondaryIndexes = globalSecondaryIndexes {
            var globalSecondaryIndexesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .globalSecondaryIndexes)
            for awsdynamodbtablereplicaglobalsecondaryindex0 in globalSecondaryIndexes {
                try globalSecondaryIndexesContainer.encode(awsdynamodbtablereplicaglobalsecondaryindex0)
            }
        }
        if let kmsMasterKeyId = self.kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
        if let provisionedThroughputOverride = self.provisionedThroughputOverride {
            try encodeContainer.encode(provisionedThroughputOverride, forKey: .provisionedThroughputOverride)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let replicaStatus = self.replicaStatus {
            try encodeContainer.encode(replicaStatus, forKey: .replicaStatus)
        }
        if let replicaStatusDescription = self.replicaStatusDescription {
            try encodeContainer.encode(replicaStatusDescription, forKey: .replicaStatusDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalSecondaryIndexesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex?].self, forKey: .globalSecondaryIndexes)
        var globalSecondaryIndexesDecoded0:[SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex]? = nil
        if let globalSecondaryIndexesContainer = globalSecondaryIndexesContainer {
            globalSecondaryIndexesDecoded0 = [SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex]()
            for structure0 in globalSecondaryIndexesContainer {
                if let structure0 = structure0 {
                    globalSecondaryIndexesDecoded0?.append(structure0)
                }
            }
        }
        globalSecondaryIndexes = globalSecondaryIndexesDecoded0
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
        let provisionedThroughputOverrideDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride.self, forKey: .provisionedThroughputOverride)
        provisionedThroughputOverride = provisionedThroughputOverrideDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let replicaStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicaStatus)
        replicaStatus = replicaStatusDecoded
        let replicaStatusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicaStatusDescription)
        replicaStatusDescription = replicaStatusDescriptionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a replica of a DynamoDB table.
    public struct AwsDynamoDbTableReplica: Swift.Equatable {
        /// List of global secondary indexes for the replica.
        public var globalSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex]?
        /// The identifier of the KMS key that will be used for KMS encryption for the replica.
        public var kmsMasterKeyId: Swift.String?
        /// Replica-specific configuration for the provisioned throughput.
        public var provisionedThroughputOverride: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride?
        /// The name of the Region where the replica is located.
        public var regionName: Swift.String?
        /// The current status of the replica. Valid values are as follows:
        ///
        /// * ACTIVE
        ///
        /// * CREATING
        ///
        /// * CREATION_FAILED
        ///
        /// * DELETING
        ///
        /// * UPDATING
        public var replicaStatus: Swift.String?
        /// Detailed information about the replica status.
        public var replicaStatusDescription: Swift.String?

        public init (
            globalSecondaryIndexes: [SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex]? = nil,
            kmsMasterKeyId: Swift.String? = nil,
            provisionedThroughputOverride: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride? = nil,
            regionName: Swift.String? = nil,
            replicaStatus: Swift.String? = nil,
            replicaStatusDescription: Swift.String? = nil
        )
        {
            self.globalSecondaryIndexes = globalSecondaryIndexes
            self.kmsMasterKeyId = kmsMasterKeyId
            self.provisionedThroughputOverride = provisionedThroughputOverride
            self.regionName = regionName
            self.replicaStatus = replicaStatus
            self.replicaStatusDescription = replicaStatusDescription
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableReplicaGlobalSecondaryIndex: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case indexName = "IndexName"
        case provisionedThroughputOverride = "ProvisionedThroughputOverride"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let indexName = self.indexName {
            try encodeContainer.encode(indexName, forKey: .indexName)
        }
        if let provisionedThroughputOverride = self.provisionedThroughputOverride {
            try encodeContainer.encode(provisionedThroughputOverride, forKey: .provisionedThroughputOverride)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexName)
        indexName = indexNameDecoded
        let provisionedThroughputOverrideDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride.self, forKey: .provisionedThroughputOverride)
        provisionedThroughputOverride = provisionedThroughputOverrideDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a global secondary index for a DynamoDB table replica.
    public struct AwsDynamoDbTableReplicaGlobalSecondaryIndex: Swift.Equatable {
        /// The name of the index.
        public var indexName: Swift.String?
        /// Replica-specific configuration for the provisioned throughput for the index.
        public var provisionedThroughputOverride: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride?

        public init (
            indexName: Swift.String? = nil,
            provisionedThroughputOverride: SecurityHubClientTypes.AwsDynamoDbTableProvisionedThroughputOverride? = nil
        )
        {
            self.indexName = indexName
            self.provisionedThroughputOverride = provisionedThroughputOverride
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableRestoreSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restoreDateTime = "RestoreDateTime"
        case restoreInProgress = "RestoreInProgress"
        case sourceBackupArn = "SourceBackupArn"
        case sourceTableArn = "SourceTableArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let restoreDateTime = self.restoreDateTime {
            try encodeContainer.encode(restoreDateTime, forKey: .restoreDateTime)
        }
        if restoreInProgress != false {
            try encodeContainer.encode(restoreInProgress, forKey: .restoreInProgress)
        }
        if let sourceBackupArn = self.sourceBackupArn {
            try encodeContainer.encode(sourceBackupArn, forKey: .sourceBackupArn)
        }
        if let sourceTableArn = self.sourceTableArn {
            try encodeContainer.encode(sourceTableArn, forKey: .sourceTableArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceBackupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceBackupArn)
        sourceBackupArn = sourceBackupArnDecoded
        let sourceTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceTableArn)
        sourceTableArn = sourceTableArnDecoded
        let restoreDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreDateTime)
        restoreDateTime = restoreDateTimeDecoded
        let restoreInProgressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restoreInProgress) ?? false
        restoreInProgress = restoreInProgressDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the restore for the table.
    public struct AwsDynamoDbTableRestoreSummary: Swift.Equatable {
        /// Indicates the point in time that the table was restored to. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var restoreDateTime: Swift.String?
        /// Whether a restore is currently in progress.
        public var restoreInProgress: Swift.Bool
        /// The ARN of the source backup from which the table was restored.
        public var sourceBackupArn: Swift.String?
        /// The ARN of the source table for the backup.
        public var sourceTableArn: Swift.String?

        public init (
            restoreDateTime: Swift.String? = nil,
            restoreInProgress: Swift.Bool = false,
            sourceBackupArn: Swift.String? = nil,
            sourceTableArn: Swift.String? = nil
        )
        {
            self.restoreDateTime = restoreDateTime
            self.restoreInProgress = restoreInProgress
            self.sourceBackupArn = sourceBackupArn
            self.sourceTableArn = sourceTableArn
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableSseDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inaccessibleEncryptionDateTime = "InaccessibleEncryptionDateTime"
        case kmsMasterKeyArn = "KmsMasterKeyArn"
        case sseType = "SseType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inaccessibleEncryptionDateTime = self.inaccessibleEncryptionDateTime {
            try encodeContainer.encode(inaccessibleEncryptionDateTime, forKey: .inaccessibleEncryptionDateTime)
        }
        if let kmsMasterKeyArn = self.kmsMasterKeyArn {
            try encodeContainer.encode(kmsMasterKeyArn, forKey: .kmsMasterKeyArn)
        }
        if let sseType = self.sseType {
            try encodeContainer.encode(sseType, forKey: .sseType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inaccessibleEncryptionDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inaccessibleEncryptionDateTime)
        inaccessibleEncryptionDateTime = inaccessibleEncryptionDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let sseTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sseType)
        sseType = sseTypeDecoded
        let kmsMasterKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyArn)
        kmsMasterKeyArn = kmsMasterKeyArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the server-side encryption for the table.
    public struct AwsDynamoDbTableSseDescription: Swift.Equatable {
        /// If the key is inaccessible, the date and time when DynamoDB detected that the key was inaccessible. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var inaccessibleEncryptionDateTime: Swift.String?
        /// The ARN of the KMS key that is used for the KMS encryption.
        public var kmsMasterKeyArn: Swift.String?
        /// The type of server-side encryption.
        public var sseType: Swift.String?
        /// The status of the server-side encryption.
        public var status: Swift.String?

        public init (
            inaccessibleEncryptionDateTime: Swift.String? = nil,
            kmsMasterKeyArn: Swift.String? = nil,
            sseType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.inaccessibleEncryptionDateTime = inaccessibleEncryptionDateTime
            self.kmsMasterKeyArn = kmsMasterKeyArn
            self.sseType = sseType
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsDynamoDbTableStreamSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamEnabled = "StreamEnabled"
        case streamViewType = "StreamViewType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if streamEnabled != false {
            try encodeContainer.encode(streamEnabled, forKey: .streamEnabled)
        }
        if let streamViewType = self.streamViewType {
            try encodeContainer.encode(streamViewType, forKey: .streamViewType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .streamEnabled) ?? false
        streamEnabled = streamEnabledDecoded
        let streamViewTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamViewType)
        streamViewType = streamViewTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// The current DynamoDB Streams configuration for the table.
    public struct AwsDynamoDbTableStreamSpecification: Swift.Equatable {
        /// Indicates whether DynamoDB Streams is enabled on the table.
        public var streamEnabled: Swift.Bool
        /// Determines the information that is written to the table.
        public var streamViewType: Swift.String?

        public init (
            streamEnabled: Swift.Bool = false,
            streamViewType: Swift.String? = nil
        )
        {
            self.streamEnabled = streamEnabled
            self.streamViewType = streamViewType
        }
    }

}

extension SecurityHubClientTypes.AwsEc2EipDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocationId = "AllocationId"
        case associationId = "AssociationId"
        case domain = "Domain"
        case instanceId = "InstanceId"
        case networkBorderGroup = "NetworkBorderGroup"
        case networkInterfaceId = "NetworkInterfaceId"
        case networkInterfaceOwnerId = "NetworkInterfaceOwnerId"
        case privateIpAddress = "PrivateIpAddress"
        case publicIp = "PublicIp"
        case publicIpv4Pool = "PublicIpv4Pool"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocationId = self.allocationId {
            try encodeContainer.encode(allocationId, forKey: .allocationId)
        }
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let networkBorderGroup = self.networkBorderGroup {
            try encodeContainer.encode(networkBorderGroup, forKey: .networkBorderGroup)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let networkInterfaceOwnerId = self.networkInterfaceOwnerId {
            try encodeContainer.encode(networkInterfaceOwnerId, forKey: .networkInterfaceOwnerId)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let publicIp = self.publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let publicIpv4Pool = self.publicIpv4Pool {
            try encodeContainer.encode(publicIpv4Pool, forKey: .publicIpv4Pool)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let allocationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allocationId)
        allocationId = allocationIdDecoded
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let publicIpv4PoolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIpv4Pool)
        publicIpv4Pool = publicIpv4PoolDecoded
        let networkBorderGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkBorderGroup)
        networkBorderGroup = networkBorderGroupDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let networkInterfaceOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceOwnerId)
        networkInterfaceOwnerId = networkInterfaceOwnerIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an Elastic IP address.
    public struct AwsEc2EipDetails: Swift.Equatable {
        /// The identifier that Amazon Web Services assigns to represent the allocation of the Elastic IP address for use with Amazon VPC.
        public var allocationId: Swift.String?
        /// The identifier that represents the association of the Elastic IP address with an EC2 instance.
        public var associationId: Swift.String?
        /// The domain in which to allocate the address. If the address is for use with EC2 instances in a VPC, then Domain is vpc. Otherwise, Domain is standard.
        public var domain: Swift.String?
        /// The identifier of the EC2 instance.
        public var instanceId: Swift.String?
        /// The name of the location from which the Elastic IP address is advertised.
        public var networkBorderGroup: Swift.String?
        /// The identifier of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The Amazon Web Services account ID of the owner of the network interface.
        public var networkInterfaceOwnerId: Swift.String?
        /// The private IP address that is associated with the Elastic IP address.
        public var privateIpAddress: Swift.String?
        /// A public IP address that is associated with the EC2 instance.
        public var publicIp: Swift.String?
        /// The identifier of an IP address pool. This parameter allows Amazon EC2 to select an IP address from the address pool.
        public var publicIpv4Pool: Swift.String?

        public init (
            allocationId: Swift.String? = nil,
            associationId: Swift.String? = nil,
            domain: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            networkBorderGroup: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            networkInterfaceOwnerId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            publicIpv4Pool: Swift.String? = nil
        )
        {
            self.allocationId = allocationId
            self.associationId = associationId
            self.domain = domain
            self.instanceId = instanceId
            self.networkBorderGroup = networkBorderGroup
            self.networkInterfaceId = networkInterfaceId
            self.networkInterfaceOwnerId = networkInterfaceOwnerId
            self.privateIpAddress = privateIpAddress
            self.publicIp = publicIp
            self.publicIpv4Pool = publicIpv4Pool
        }
    }

}

extension SecurityHubClientTypes.AwsEc2InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamInstanceProfileArn = "IamInstanceProfileArn"
        case imageId = "ImageId"
        case ipV4Addresses = "IpV4Addresses"
        case ipV6Addresses = "IpV6Addresses"
        case keyName = "KeyName"
        case launchedAt = "LaunchedAt"
        case metadataOptions = "MetadataOptions"
        case networkInterfaces = "NetworkInterfaces"
        case subnetId = "SubnetId"
        case type = "Type"
        case virtualizationType = "VirtualizationType"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamInstanceProfileArn = self.iamInstanceProfileArn {
            try encodeContainer.encode(iamInstanceProfileArn, forKey: .iamInstanceProfileArn)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let ipV4Addresses = ipV4Addresses {
            var ipV4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV4Addresses)
            for nonemptystring0 in ipV4Addresses {
                try ipV4AddressesContainer.encode(nonemptystring0)
            }
        }
        if let ipV6Addresses = ipV6Addresses {
            var ipV6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV6Addresses)
            for nonemptystring0 in ipV6Addresses {
                try ipV6AddressesContainer.encode(nonemptystring0)
            }
        }
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let launchedAt = self.launchedAt {
            try encodeContainer.encode(launchedAt, forKey: .launchedAt)
        }
        if let metadataOptions = self.metadataOptions {
            try encodeContainer.encode(metadataOptions, forKey: .metadataOptions)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for awsec2instancenetworkinterfacesdetails0 in networkInterfaces {
                try networkInterfacesContainer.encode(awsec2instancenetworkinterfacesdetails0)
            }
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let virtualizationType = self.virtualizationType {
            try encodeContainer.encode(virtualizationType, forKey: .virtualizationType)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let ipV4AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipV4Addresses)
        var ipV4AddressesDecoded0:[Swift.String]? = nil
        if let ipV4AddressesContainer = ipV4AddressesContainer {
            ipV4AddressesDecoded0 = [Swift.String]()
            for string0 in ipV4AddressesContainer {
                if let string0 = string0 {
                    ipV4AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV4Addresses = ipV4AddressesDecoded0
        let ipV6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipV6Addresses)
        var ipV6AddressesDecoded0:[Swift.String]? = nil
        if let ipV6AddressesContainer = ipV6AddressesContainer {
            ipV6AddressesDecoded0 = [Swift.String]()
            for string0 in ipV6AddressesContainer {
                if let string0 = string0 {
                    ipV6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipV6Addresses = ipV6AddressesDecoded0
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let iamInstanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamInstanceProfileArn)
        iamInstanceProfileArn = iamInstanceProfileArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let launchedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchedAt)
        launchedAt = launchedAtDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
        let metadataOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2InstanceMetadataOptions.self, forKey: .metadataOptions)
        metadataOptions = metadataOptionsDecoded
    }
}

extension SecurityHubClientTypes {
    /// The details of an Amazon EC2 instance.
    public struct AwsEc2InstanceDetails: Swift.Equatable {
        /// The IAM profile ARN of the instance.
        public var iamInstanceProfileArn: Swift.String?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public var imageId: Swift.String?
        /// The IPv4 addresses associated with the instance.
        public var ipV4Addresses: [Swift.String]?
        /// The IPv6 addresses associated with the instance.
        public var ipV6Addresses: [Swift.String]?
        /// The key name associated with the instance.
        public var keyName: Swift.String?
        /// Indicates when the instance was launched. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var launchedAt: Swift.String?
        /// Details about the metadata options for the Amazon EC2 instance.
        public var metadataOptions: SecurityHubClientTypes.AwsEc2InstanceMetadataOptions?
        /// The identifiers of the network interfaces for the EC2 instance. The details for each network interface are in a corresponding AwsEc2NetworkInterfacesDetails object.
        public var networkInterfaces: [SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails]?
        /// The identifier of the subnet that the instance was launched in.
        public var subnetId: Swift.String?
        /// The instance type of the instance.
        public var type: Swift.String?
        /// The virtualization type of the Amazon Machine Image (AMI) required to launch the instance.
        public var virtualizationType: Swift.String?
        /// The identifier of the VPC that the instance was launched in.
        public var vpcId: Swift.String?

        public init (
            iamInstanceProfileArn: Swift.String? = nil,
            imageId: Swift.String? = nil,
            ipV4Addresses: [Swift.String]? = nil,
            ipV6Addresses: [Swift.String]? = nil,
            keyName: Swift.String? = nil,
            launchedAt: Swift.String? = nil,
            metadataOptions: SecurityHubClientTypes.AwsEc2InstanceMetadataOptions? = nil,
            networkInterfaces: [SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails]? = nil,
            subnetId: Swift.String? = nil,
            type: Swift.String? = nil,
            virtualizationType: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.imageId = imageId
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
            self.keyName = keyName
            self.launchedAt = launchedAt
            self.metadataOptions = metadataOptions
            self.networkInterfaces = networkInterfaces
            self.subnetId = subnetId
            self.type = type
            self.virtualizationType = virtualizationType
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2InstanceMetadataOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpEndpoint = "HttpEndpoint"
        case httpProtocolIpv6 = "HttpProtocolIpv6"
        case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
        case httpTokens = "HttpTokens"
        case instanceMetadataTags = "InstanceMetadataTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpEndpoint = self.httpEndpoint {
            try encodeContainer.encode(httpEndpoint, forKey: .httpEndpoint)
        }
        if let httpProtocolIpv6 = self.httpProtocolIpv6 {
            try encodeContainer.encode(httpProtocolIpv6, forKey: .httpProtocolIpv6)
        }
        if httpPutResponseHopLimit != 0 {
            try encodeContainer.encode(httpPutResponseHopLimit, forKey: .httpPutResponseHopLimit)
        }
        if let httpTokens = self.httpTokens {
            try encodeContainer.encode(httpTokens, forKey: .httpTokens)
        }
        if let instanceMetadataTags = self.instanceMetadataTags {
            try encodeContainer.encode(instanceMetadataTags, forKey: .instanceMetadataTags)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpEndpoint)
        httpEndpoint = httpEndpointDecoded
        let httpProtocolIpv6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpProtocolIpv6)
        httpProtocolIpv6 = httpProtocolIpv6Decoded
        let httpPutResponseHopLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpPutResponseHopLimit) ?? 0
        httpPutResponseHopLimit = httpPutResponseHopLimitDecoded
        let httpTokensDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpTokens)
        httpTokens = httpTokensDecoded
        let instanceMetadataTagsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceMetadataTags)
        instanceMetadataTags = instanceMetadataTagsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Metadata options that allow you to configure and secure the Amazon EC2 instance.
    public struct AwsEc2InstanceMetadataOptions: Swift.Equatable {
        /// Enables or disables the HTTP metadata endpoint on the instance.
        public var httpEndpoint: Swift.String?
        /// Enables or disables the IPv6 endpoint for the instance metadata service.
        public var httpProtocolIpv6: Swift.String?
        /// The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        public var httpPutResponseHopLimit: Swift.Int
        /// The state of token usage for your instance metadata requests.
        public var httpTokens: Swift.String?
        /// Specifies whether to allow access to instance tags from the instance metadata.
        public var instanceMetadataTags: Swift.String?

        public init (
            httpEndpoint: Swift.String? = nil,
            httpProtocolIpv6: Swift.String? = nil,
            httpPutResponseHopLimit: Swift.Int = 0,
            httpTokens: Swift.String? = nil,
            instanceMetadataTags: Swift.String? = nil
        )
        {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }
    }

}

extension SecurityHubClientTypes.AwsEc2InstanceNetworkInterfacesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaceId = "NetworkInterfaceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Identifies a network interface for the Amazon EC2 instance.
    public struct AwsEc2InstanceNetworkInterfacesDetails: Swift.Equatable {
        /// The identifier of the network interface. The details are in a corresponding AwsEc2NetworkInterfacesDetails object.
        public var networkInterfaceId: Swift.String?

        public init (
            networkInterfaceId: Swift.String? = nil
        )
        {
            self.networkInterfaceId = networkInterfaceId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName = "DeviceName"
        case ebs = "Ebs"
        case noDevice = "NoDevice"
        case virtualName = "VirtualName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = self.ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
        if let noDevice = self.noDevice {
            try encodeContainer.encode(noDevice, forKey: .noDevice)
        }
        if let virtualName = self.virtualName {
            try encodeContainer.encode(virtualName, forKey: .virtualName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails.self, forKey: .ebs)
        ebs = ebsDecoded
        let noDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .noDevice)
        noDevice = noDeviceDecoded
        let virtualNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualName)
        virtualName = virtualNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a block device mapping for an Amazon Elastic Compute Cloud (Amazon EC2) launch template.
    public struct AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails: Swift.Equatable {
        /// The device name.
        public var deviceName: Swift.String?
        /// Parameters used to automatically set up Amazon EBS volumes when the instance is launched.
        public var ebs: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails?
        /// Omits the device from the block device mapping when an empty string is specified.
        public var noDevice: Swift.String?
        /// The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type.
        public var virtualName: Swift.String?

        public init (
            deviceName: Swift.String? = nil,
            ebs: SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteOnTermination = "DeleteOnTermination"
        case encrypted = "Encrypted"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case snapshotId = "SnapshotId"
        case throughput = "Throughput"
        case volumeSize = "VolumeSize"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteOnTermination != false {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if encrypted != false {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if throughput != 0 {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
        if volumeSize != 0 {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination) ?? false
        deleteOnTermination = deleteOnTerminationDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted) ?? false
        encrypted = encryptedDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops) ?? 0
        iops = iopsDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput) ?? 0
        throughput = throughputDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize) ?? 0
        volumeSize = volumeSizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Parameters for a block device for an Amazon Elastic Block Store (Amazon EBS) volume in an Amazon EC2 launch template.
    public struct AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails: Swift.Equatable {
        /// Indicates whether the EBS volume is deleted on instance termination.
        public var deleteOnTermination: Swift.Bool
        /// Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you're creating a volume from a snapshot, you can't specify an encryption value.
        public var encrypted: Swift.Bool
        /// The number of I/O operations per second (IOPS).
        public var iops: Swift.Int
        /// The Amazon Resource Name (ARN) of the symmetric Key Management Service (KMS) customer managed key used for encryption.
        public var kmsKeyId: Swift.String?
        /// The ID of the EBS snapshot.
        public var snapshotId: Swift.String?
        /// The throughput to provision for a gp3 volume, with a maximum of 1,000 MiB/s.
        public var throughput: Swift.Int
        /// The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
        public var volumeSize: Swift.Int
        /// The volume type.
        public var volumeType: Swift.String?

        public init (
            deleteOnTermination: Swift.Bool = false,
            encrypted: Swift.Bool = false,
            iops: Swift.Int = 0,
            kmsKeyId: Swift.String? = nil,
            snapshotId: Swift.String? = nil,
            throughput: Swift.Int = 0,
            volumeSize: Swift.Int = 0,
            volumeType: Swift.String? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityReservationId = "CapacityReservationId"
        case capacityReservationResourceGroupArn = "CapacityReservationResourceGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityReservationId = self.capacityReservationId {
            try encodeContainer.encode(capacityReservationId, forKey: .capacityReservationId)
        }
        if let capacityReservationResourceGroupArn = self.capacityReservationResourceGroupArn {
            try encodeContainer.encode(capacityReservationResourceGroupArn, forKey: .capacityReservationResourceGroupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityReservationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationId)
        capacityReservationId = capacityReservationIdDecoded
        let capacityReservationResourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationResourceGroupArn)
        capacityReservationResourceGroupArn = capacityReservationResourceGroupArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the target Capacity Reservation or Capacity Reservation group in which to run an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails: Swift.Equatable {
        /// The ID of the Capacity Reservation in which to run the instance.
        public var capacityReservationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Capacity Reservation resource group in which to run the instance.
        public var capacityReservationResourceGroupArn: Swift.String?

        public init (
            capacityReservationId: Swift.String? = nil,
            capacityReservationResourceGroupArn: Swift.String? = nil
        )
        {
            self.capacityReservationId = capacityReservationId
            self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityReservationPreference = "CapacityReservationPreference"
        case capacityReservationTarget = "CapacityReservationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityReservationPreference = self.capacityReservationPreference {
            try encodeContainer.encode(capacityReservationPreference, forKey: .capacityReservationPreference)
        }
        if let capacityReservationTarget = self.capacityReservationTarget {
            try encodeContainer.encode(capacityReservationTarget, forKey: .capacityReservationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityReservationPreferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationPreference)
        capacityReservationPreference = capacityReservationPreferenceDecoded
        let capacityReservationTargetDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails.self, forKey: .capacityReservationTarget)
        capacityReservationTarget = capacityReservationTargetDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies the Capacity Reservation targeting option of an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails: Swift.Equatable {
        /// Indicates the instance's Capacity Reservation preferences. If equal to open, the instance can run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). If equal to none, the instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        public var capacityReservationPreference: Swift.String?
        /// Specifies a target Capacity Reservation.
        public var capacityReservationTarget: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails?

        public init (
            capacityReservationPreference: Swift.String? = nil,
            capacityReservationTarget: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails? = nil
        )
        {
            self.capacityReservationPreference = capacityReservationPreference
            self.capacityReservationTarget = capacityReservationTarget
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreCount = "CoreCount"
        case threadsPerCore = "ThreadsPerCore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if coreCount != 0 {
            try encodeContainer.encode(coreCount, forKey: .coreCount)
        }
        if threadsPerCore != 0 {
            try encodeContainer.encode(threadsPerCore, forKey: .threadsPerCore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .coreCount) ?? 0
        coreCount = coreCountDecoded
        let threadsPerCoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .threadsPerCore) ?? 0
        threadsPerCore = threadsPerCoreDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies the CPU options for an Amazon EC2 instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the Amazon Elastic Compute Cloud User Guide.
    public struct AwsEc2LaunchTemplateDataCpuOptionsDetails: Swift.Equatable {
        /// The number of CPU cores for the instance.
        public var coreCount: Swift.Int
        /// The number of threads per CPU core. A value of 1 disables multithreading for the instance, The default value is 2.
        public var threadsPerCore: Swift.Int

        public init (
            coreCount: Swift.Int = 0,
            threadsPerCore: Swift.Int = 0
        )
        {
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuCredits = "CpuCredits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpuCredits = self.cpuCredits {
            try encodeContainer.encode(cpuCredits, forKey: .cpuCredits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuCreditsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpuCredits)
        cpuCredits = cpuCreditsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies the credit option for CPU usage of a T2, T3, or T3a Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataCreditSpecificationDetails: Swift.Equatable {
        /// The credit option for CPU usage of a T instance.
        public var cpuCredits: Swift.String?

        public init (
            cpuCredits: Swift.String? = nil
        )
        {
            self.cpuCredits = cpuCredits
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockDeviceMappingSet = "BlockDeviceMappingSet"
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case cpuOptions = "CpuOptions"
        case creditSpecification = "CreditSpecification"
        case disableApiStop = "DisableApiStop"
        case disableApiTermination = "DisableApiTermination"
        case ebsOptimized = "EbsOptimized"
        case elasticGpuSpecificationSet = "ElasticGpuSpecificationSet"
        case elasticInferenceAcceleratorSet = "ElasticInferenceAcceleratorSet"
        case enclaveOptions = "EnclaveOptions"
        case hibernationOptions = "HibernationOptions"
        case iamInstanceProfile = "IamInstanceProfile"
        case imageId = "ImageId"
        case instanceInitiatedShutdownBehavior = "InstanceInitiatedShutdownBehavior"
        case instanceMarketOptions = "InstanceMarketOptions"
        case instanceRequirements = "InstanceRequirements"
        case instanceType = "InstanceType"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case licenseSet = "LicenseSet"
        case maintenanceOptions = "MaintenanceOptions"
        case metadataOptions = "MetadataOptions"
        case monitoring = "Monitoring"
        case networkInterfaceSet = "NetworkInterfaceSet"
        case placement = "Placement"
        case privateDnsNameOptions = "PrivateDnsNameOptions"
        case ramDiskId = "RamDiskId"
        case securityGroupIdSet = "SecurityGroupIdSet"
        case securityGroupSet = "SecurityGroupSet"
        case userData = "UserData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockDeviceMappingSet = blockDeviceMappingSet {
            var blockDeviceMappingSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappingSet)
            for awsec2launchtemplatedatablockdevicemappingsetdetails0 in blockDeviceMappingSet {
                try blockDeviceMappingSetContainer.encode(awsec2launchtemplatedatablockdevicemappingsetdetails0)
            }
        }
        if let capacityReservationSpecification = self.capacityReservationSpecification {
            try encodeContainer.encode(capacityReservationSpecification, forKey: .capacityReservationSpecification)
        }
        if let cpuOptions = self.cpuOptions {
            try encodeContainer.encode(cpuOptions, forKey: .cpuOptions)
        }
        if let creditSpecification = self.creditSpecification {
            try encodeContainer.encode(creditSpecification, forKey: .creditSpecification)
        }
        if disableApiStop != false {
            try encodeContainer.encode(disableApiStop, forKey: .disableApiStop)
        }
        if disableApiTermination != false {
            try encodeContainer.encode(disableApiTermination, forKey: .disableApiTermination)
        }
        if ebsOptimized != false {
            try encodeContainer.encode(ebsOptimized, forKey: .ebsOptimized)
        }
        if let elasticGpuSpecificationSet = elasticGpuSpecificationSet {
            var elasticGpuSpecificationSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elasticGpuSpecificationSet)
            for awsec2launchtemplatedataelasticgpuspecificationsetdetails0 in elasticGpuSpecificationSet {
                try elasticGpuSpecificationSetContainer.encode(awsec2launchtemplatedataelasticgpuspecificationsetdetails0)
            }
        }
        if let elasticInferenceAcceleratorSet = elasticInferenceAcceleratorSet {
            var elasticInferenceAcceleratorSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elasticInferenceAcceleratorSet)
            for awsec2launchtemplatedataelasticinferenceacceleratorsetdetails0 in elasticInferenceAcceleratorSet {
                try elasticInferenceAcceleratorSetContainer.encode(awsec2launchtemplatedataelasticinferenceacceleratorsetdetails0)
            }
        }
        if let enclaveOptions = self.enclaveOptions {
            try encodeContainer.encode(enclaveOptions, forKey: .enclaveOptions)
        }
        if let hibernationOptions = self.hibernationOptions {
            try encodeContainer.encode(hibernationOptions, forKey: .hibernationOptions)
        }
        if let iamInstanceProfile = self.iamInstanceProfile {
            try encodeContainer.encode(iamInstanceProfile, forKey: .iamInstanceProfile)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let instanceInitiatedShutdownBehavior = self.instanceInitiatedShutdownBehavior {
            try encodeContainer.encode(instanceInitiatedShutdownBehavior, forKey: .instanceInitiatedShutdownBehavior)
        }
        if let instanceMarketOptions = self.instanceMarketOptions {
            try encodeContainer.encode(instanceMarketOptions, forKey: .instanceMarketOptions)
        }
        if let instanceRequirements = self.instanceRequirements {
            try encodeContainer.encode(instanceRequirements, forKey: .instanceRequirements)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let kernelId = self.kernelId {
            try encodeContainer.encode(kernelId, forKey: .kernelId)
        }
        if let keyName = self.keyName {
            try encodeContainer.encode(keyName, forKey: .keyName)
        }
        if let licenseSet = licenseSet {
            var licenseSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseSet)
            for awsec2launchtemplatedatalicensesetdetails0 in licenseSet {
                try licenseSetContainer.encode(awsec2launchtemplatedatalicensesetdetails0)
            }
        }
        if let maintenanceOptions = self.maintenanceOptions {
            try encodeContainer.encode(maintenanceOptions, forKey: .maintenanceOptions)
        }
        if let metadataOptions = self.metadataOptions {
            try encodeContainer.encode(metadataOptions, forKey: .metadataOptions)
        }
        if let monitoring = self.monitoring {
            try encodeContainer.encode(monitoring, forKey: .monitoring)
        }
        if let networkInterfaceSet = networkInterfaceSet {
            var networkInterfaceSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaceSet)
            for awsec2launchtemplatedatanetworkinterfacesetdetails0 in networkInterfaceSet {
                try networkInterfaceSetContainer.encode(awsec2launchtemplatedatanetworkinterfacesetdetails0)
            }
        }
        if let placement = self.placement {
            try encodeContainer.encode(placement, forKey: .placement)
        }
        if let privateDnsNameOptions = self.privateDnsNameOptions {
            try encodeContainer.encode(privateDnsNameOptions, forKey: .privateDnsNameOptions)
        }
        if let ramDiskId = self.ramDiskId {
            try encodeContainer.encode(ramDiskId, forKey: .ramDiskId)
        }
        if let securityGroupIdSet = securityGroupIdSet {
            var securityGroupIdSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIdSet)
            for nonemptystring0 in securityGroupIdSet {
                try securityGroupIdSetContainer.encode(nonemptystring0)
            }
        }
        if let securityGroupSet = securityGroupSet {
            var securityGroupSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupSet)
            for nonemptystring0 in securityGroupSet {
                try securityGroupSetContainer.encode(nonemptystring0)
            }
        }
        if let userData = self.userData {
            try encodeContainer.encode(userData, forKey: .userData)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDeviceMappingSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails?].self, forKey: .blockDeviceMappingSet)
        var blockDeviceMappingSetDecoded0:[SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]? = nil
        if let blockDeviceMappingSetContainer = blockDeviceMappingSetContainer {
            blockDeviceMappingSetDecoded0 = [SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]()
            for structure0 in blockDeviceMappingSetContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingSetDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappingSet = blockDeviceMappingSetDecoded0
        let capacityReservationSpecificationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails.self, forKey: .capacityReservationSpecification)
        capacityReservationSpecification = capacityReservationSpecificationDecoded
        let cpuOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails.self, forKey: .cpuOptions)
        cpuOptions = cpuOptionsDecoded
        let creditSpecificationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails.self, forKey: .creditSpecification)
        creditSpecification = creditSpecificationDecoded
        let disableApiStopDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableApiStop) ?? false
        disableApiStop = disableApiStopDecoded
        let disableApiTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableApiTermination) ?? false
        disableApiTermination = disableApiTerminationDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized) ?? false
        ebsOptimized = ebsOptimizedDecoded
        let elasticGpuSpecificationSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails?].self, forKey: .elasticGpuSpecificationSet)
        var elasticGpuSpecificationSetDecoded0:[SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]? = nil
        if let elasticGpuSpecificationSetContainer = elasticGpuSpecificationSetContainer {
            elasticGpuSpecificationSetDecoded0 = [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]()
            for structure0 in elasticGpuSpecificationSetContainer {
                if let structure0 = structure0 {
                    elasticGpuSpecificationSetDecoded0?.append(structure0)
                }
            }
        }
        elasticGpuSpecificationSet = elasticGpuSpecificationSetDecoded0
        let elasticInferenceAcceleratorSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails?].self, forKey: .elasticInferenceAcceleratorSet)
        var elasticInferenceAcceleratorSetDecoded0:[SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]? = nil
        if let elasticInferenceAcceleratorSetContainer = elasticInferenceAcceleratorSetContainer {
            elasticInferenceAcceleratorSetDecoded0 = [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]()
            for structure0 in elasticInferenceAcceleratorSetContainer {
                if let structure0 = structure0 {
                    elasticInferenceAcceleratorSetDecoded0?.append(structure0)
                }
            }
        }
        elasticInferenceAcceleratorSet = elasticInferenceAcceleratorSetDecoded0
        let enclaveOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails.self, forKey: .enclaveOptions)
        enclaveOptions = enclaveOptionsDecoded
        let hibernationOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails.self, forKey: .hibernationOptions)
        hibernationOptions = hibernationOptionsDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceInitiatedShutdownBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceInitiatedShutdownBehavior)
        instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehaviorDecoded
        let instanceMarketOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails.self, forKey: .instanceMarketOptions)
        instanceMarketOptions = instanceMarketOptionsDecoded
        let instanceRequirementsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails.self, forKey: .instanceRequirements)
        instanceRequirements = instanceRequirementsDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let kernelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let licenseSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails?].self, forKey: .licenseSet)
        var licenseSetDecoded0:[SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails]? = nil
        if let licenseSetContainer = licenseSetContainer {
            licenseSetDecoded0 = [SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails]()
            for structure0 in licenseSetContainer {
                if let structure0 = structure0 {
                    licenseSetDecoded0?.append(structure0)
                }
            }
        }
        licenseSet = licenseSetDecoded0
        let maintenanceOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails.self, forKey: .maintenanceOptions)
        maintenanceOptions = maintenanceOptionsDecoded
        let metadataOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails.self, forKey: .metadataOptions)
        metadataOptions = metadataOptionsDecoded
        let monitoringDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails.self, forKey: .monitoring)
        monitoring = monitoringDecoded
        let networkInterfaceSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails?].self, forKey: .networkInterfaceSet)
        var networkInterfaceSetDecoded0:[SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]? = nil
        if let networkInterfaceSetContainer = networkInterfaceSetContainer {
            networkInterfaceSetDecoded0 = [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]()
            for structure0 in networkInterfaceSetContainer {
                if let structure0 = structure0 {
                    networkInterfaceSetDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaceSet = networkInterfaceSetDecoded0
        let placementDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails.self, forKey: .placement)
        placement = placementDecoded
        let privateDnsNameOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails.self, forKey: .privateDnsNameOptions)
        privateDnsNameOptions = privateDnsNameOptionsDecoded
        let ramDiskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ramDiskId)
        ramDiskId = ramDiskIdDecoded
        let securityGroupIdSetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIdSet)
        var securityGroupIdSetDecoded0:[Swift.String]? = nil
        if let securityGroupIdSetContainer = securityGroupIdSetContainer {
            securityGroupIdSetDecoded0 = [Swift.String]()
            for string0 in securityGroupIdSetContainer {
                if let string0 = string0 {
                    securityGroupIdSetDecoded0?.append(string0)
                }
            }
        }
        securityGroupIdSet = securityGroupIdSetDecoded0
        let securityGroupSetContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupSet)
        var securityGroupSetDecoded0:[Swift.String]? = nil
        if let securityGroupSetContainer = securityGroupSetContainer {
            securityGroupSetDecoded0 = [Swift.String]()
            for string0 in securityGroupSetContainer {
                if let string0 = string0 {
                    securityGroupSetDecoded0?.append(string0)
                }
            }
        }
        securityGroupSet = securityGroupSetDecoded0
        let userDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userData)
        userData = userDataDecoded
    }
}

extension SecurityHubClientTypes {
    /// The information to include in an Amazon Elastic Compute Cloud (Amazon EC2) launch template.
    public struct AwsEc2LaunchTemplateDataDetails: Swift.Equatable {
        /// Information about a block device mapping for an Amazon EC2 launch template.
        public var blockDeviceMappingSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]?
        /// Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
        public var capacityReservationSpecification: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails?
        /// Specifies the CPU options for an instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the Amazon Elastic Compute Cloud User Guide.
        public var cpuOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails?
        /// Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
        public var creditSpecification: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails?
        /// Indicates whether to enable the instance for stop protection. For more information, see [Enable stop protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html#Using_StopProtection) in the Amazon EC2 User Guide.
        public var disableApiStop: Swift.Bool
        /// If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API. If set to true, you can.
        public var disableApiTermination: Swift.Bool
        /// Indicates whether the instance is optimized for Amazon EBS I/O.
        public var ebsOptimized: Swift.Bool
        /// Provides details about Elastic Graphics accelerators to associate with the instance.
        public var elasticGpuSpecificationSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]?
        /// The Amazon Elastic Inference accelerator for the instance.
        public var elasticInferenceAcceleratorSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]?
        /// Indicates whether the Amazon EC2 instance is enabled for Amazon Web Services Nitro Enclaves.
        public var enclaveOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails?
        /// Specifies whether your Amazon EC2 instance is configured for hibernation.
        public var hibernationOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails?
        /// The name or Amazon Resource Name (ARN) of an IAM instance profile.
        public var iamInstanceProfile: SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails?
        /// The ID of the Amazon Machine Image (AMI).
        public var imageId: Swift.String?
        /// Provides the options for specifying the instance initiated shutdown behavior.
        public var instanceInitiatedShutdownBehavior: Swift.String?
        /// Specifies the market (purchasing) option for an instance.
        public var instanceMarketOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails?
        /// The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes. If you specify InstanceRequirements, you can't specify InstanceType.
        public var instanceRequirements: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails?
        /// The instance type. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the Amazon EC2 User Guide. If you specify InstanceType, you can't specify InstanceRequirements.
        public var instanceType: Swift.String?
        /// The ID of the kernel.
        public var kernelId: Swift.String?
        /// The name of the key pair that allows users to connect to the instance.
        public var keyName: Swift.String?
        /// Specifies a license configuration for an instance.
        public var licenseSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails]?
        /// The maintenance options of your instance.
        public var maintenanceOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails?
        /// The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the Amazon EC2 User Guide.
        public var metadataOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails?
        /// The monitoring for the instance.
        public var monitoring: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails?
        /// Specifies the parameters for a network interface that is attached to the instance.
        public var networkInterfaceSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]?
        /// Specifies the placement of an instance.
        public var placement: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails?
        /// The options for the instance hostname.
        public var privateDnsNameOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails?
        /// The ID of the RAM disk.
        public var ramDiskId: Swift.String?
        /// One or more security group IDs.
        public var securityGroupIdSet: [Swift.String]?
        /// One or more security group names. For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.
        public var securityGroupSet: [Swift.String]?
        /// The user data to make available to the instance.
        public var userData: Swift.String?

        public init (
            blockDeviceMappingSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails]? = nil,
            capacityReservationSpecification: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails? = nil,
            cpuOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCpuOptionsDetails? = nil,
            creditSpecification: SecurityHubClientTypes.AwsEc2LaunchTemplateDataCreditSpecificationDetails? = nil,
            disableApiStop: Swift.Bool = false,
            disableApiTermination: Swift.Bool = false,
            ebsOptimized: Swift.Bool = false,
            elasticGpuSpecificationSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails]? = nil,
            elasticInferenceAcceleratorSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails]? = nil,
            enclaveOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails? = nil,
            hibernationOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails? = nil,
            iamInstanceProfile: SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails? = nil,
            imageId: Swift.String? = nil,
            instanceInitiatedShutdownBehavior: Swift.String? = nil,
            instanceMarketOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails? = nil,
            instanceRequirements: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails? = nil,
            instanceType: Swift.String? = nil,
            kernelId: Swift.String? = nil,
            keyName: Swift.String? = nil,
            licenseSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails]? = nil,
            maintenanceOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails? = nil,
            metadataOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails? = nil,
            monitoring: SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails? = nil,
            networkInterfaceSet: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails]? = nil,
            placement: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails? = nil,
            privateDnsNameOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails? = nil,
            ramDiskId: Swift.String? = nil,
            securityGroupIdSet: [Swift.String]? = nil,
            securityGroupSet: [Swift.String]? = nil,
            userData: Swift.String? = nil
        )
        {
            self.blockDeviceMappingSet = blockDeviceMappingSet
            self.capacityReservationSpecification = capacityReservationSpecification
            self.cpuOptions = cpuOptions
            self.creditSpecification = creditSpecification
            self.disableApiStop = disableApiStop
            self.disableApiTermination = disableApiTermination
            self.ebsOptimized = ebsOptimized
            self.elasticGpuSpecificationSet = elasticGpuSpecificationSet
            self.elasticInferenceAcceleratorSet = elasticInferenceAcceleratorSet
            self.enclaveOptions = enclaveOptions
            self.hibernationOptions = hibernationOptions
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior
            self.instanceMarketOptions = instanceMarketOptions
            self.instanceRequirements = instanceRequirements
            self.instanceType = instanceType
            self.kernelId = kernelId
            self.keyName = keyName
            self.licenseSet = licenseSet
            self.maintenanceOptions = maintenanceOptions
            self.metadataOptions = metadataOptions
            self.monitoring = monitoring
            self.networkInterfaceSet = networkInterfaceSet
            self.placement = placement
            self.privateDnsNameOptions = privateDnsNameOptions
            self.ramDiskId = ramDiskId
            self.securityGroupIdSet = securityGroupIdSet
            self.securityGroupSet = securityGroupSet
            self.userData = userData
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an Elastic Graphics specification for an Amazon EC2 launch template.
    public struct AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails: Swift.Equatable {
        /// The type of Elastic Graphics accelerator.
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details for an Amazon Elastic Inference accelerator.
    public struct AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails: Swift.Equatable {
        /// The number of Elastic Inference accelerators to attach to the instance.
        public var count: Swift.Int
        /// The type of Elastic Inference accelerator.
        public var type: Swift.String?

        public init (
            count: Swift.Int = 0,
            type: Swift.String? = nil
        )
        {
            self.count = count
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataEnclaveOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// Indicates whether the instance is enabled for Amazon Web Services Nitro Enclaves.
    public struct AwsEc2LaunchTemplateDataEnclaveOptionsDetails: Swift.Equatable {
        /// If this parameter is set to true, the instance is enabled for Amazon Web Services Nitro Enclaves.
        public var enabled: Swift.Bool

        public init (
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataHibernationOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configured = "Configured"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if configured != false {
            try encodeContainer.encode(configured, forKey: .configured)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .configured) ?? false
        configured = configuredDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies whether your Amazon EC2 instance is configured for hibernation.
    public struct AwsEc2LaunchTemplateDataHibernationOptionsDetails: Swift.Equatable {
        /// If you set this parameter to true, the instance is enabled for hibernation.
        public var configured: Swift.Bool

        public init (
            configured: Swift.Bool = false
        )
        {
            self.configured = configured
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataIamInstanceProfileDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details for an Identity and Access Management (IAM) instance profile, which is a container for an IAM role for your instance.
    public struct AwsEc2LaunchTemplateDataIamInstanceProfileDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the instance profile.
        public var arn: Swift.String?
        /// The name of the instance profile.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marketType = "MarketType"
        case spotOptions = "SpotOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let marketType = self.marketType {
            try encodeContainer.encode(marketType, forKey: .marketType)
        }
        if let spotOptions = self.spotOptions {
            try encodeContainer.encode(spotOptions, forKey: .spotOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let marketTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marketType)
        marketType = marketTypeDecoded
        let spotOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails.self, forKey: .spotOptions)
        spotOptions = spotOptionsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the market (purchasing) option for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails: Swift.Equatable {
        /// The market type.
        public var marketType: Swift.String?
        /// The options for Spot Instances.
        public var spotOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails?

        public init (
            marketType: Swift.String? = nil,
            spotOptions: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails? = nil
        )
        {
            self.marketType = marketType
            self.spotOptions = spotOptions
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockDurationMinutes = "BlockDurationMinutes"
        case instanceInterruptionBehavior = "InstanceInterruptionBehavior"
        case maxPrice = "MaxPrice"
        case spotInstanceType = "SpotInstanceType"
        case validUntil = "ValidUntil"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockDurationMinutes != 0 {
            try encodeContainer.encode(blockDurationMinutes, forKey: .blockDurationMinutes)
        }
        if let instanceInterruptionBehavior = self.instanceInterruptionBehavior {
            try encodeContainer.encode(instanceInterruptionBehavior, forKey: .instanceInterruptionBehavior)
        }
        if let maxPrice = self.maxPrice {
            try encodeContainer.encode(maxPrice, forKey: .maxPrice)
        }
        if let spotInstanceType = self.spotInstanceType {
            try encodeContainer.encode(spotInstanceType, forKey: .spotInstanceType)
        }
        if let validUntil = self.validUntil {
            try encodeContainer.encode(validUntil, forKey: .validUntil)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDurationMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .blockDurationMinutes) ?? 0
        blockDurationMinutes = blockDurationMinutesDecoded
        let instanceInterruptionBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceInterruptionBehavior)
        instanceInterruptionBehavior = instanceInterruptionBehaviorDecoded
        let maxPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxPrice)
        maxPrice = maxPriceDecoded
        let spotInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spotInstanceType)
        spotInstanceType = spotInstanceTypeDecoded
        let validUntilDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validUntil)
        validUntil = validUntilDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the market (purchasing) options for Spot Instances.
    public struct AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails: Swift.Equatable {
        /// Deprecated.
        public var blockDurationMinutes: Swift.Int
        /// The behavior when a Spot Instance is interrupted.
        public var instanceInterruptionBehavior: Swift.String?
        /// The maximum hourly price you're willing to pay for the Spot Instances.
        public var maxPrice: Swift.String?
        /// The Spot Instance request type.
        public var spotInstanceType: Swift.String?
        /// The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ), for persistent requests.
        public var validUntil: Swift.String?

        public init (
            blockDurationMinutes: Swift.Int = 0,
            instanceInterruptionBehavior: Swift.String? = nil,
            maxPrice: Swift.String? = nil,
            spotInstanceType: Swift.String? = nil,
            validUntil: Swift.String? = nil
        )
        {
            self.blockDurationMinutes = blockDurationMinutes
            self.instanceInterruptionBehavior = instanceInterruptionBehavior
            self.maxPrice = maxPrice
            self.spotInstanceType = spotInstanceType
            self.validUntil = validUntil
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if min != 0 {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min) ?? 0
        min = minDecoded
    }
}

extension SecurityHubClientTypes {
    /// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails: Swift.Equatable {
        /// The maximum number of accelerators. If this parameter isn't specified, there's no maximum limit. To exclude accelerator-enabled instance types, set Max to 0.
        public var max: Swift.Int
        /// The minimum number of accelerators. If this parameter isn't specified, there's no minimum limit.
        public var min: Swift.Int

        public init (
            max: Swift.Int = 0,
            min: Swift.Int = 0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if min != 0 {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min) ?? 0
        min = minDecoded
    }
}

extension SecurityHubClientTypes {
    /// The minimum and maximum amount of memory, in MiB, for the accelerators on an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails: Swift.Equatable {
        /// The maximum amount of memory, in MiB. If this parameter isn't specified, there's no maximum limit.
        public var max: Swift.Int
        /// The minimum amount of memory, in MiB. If 0 is specified, there's no maximum limit.
        public var min: Swift.Int

        public init (
            max: Swift.Int = 0,
            min: Swift.Int = 0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if min != 0 {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min) ?? 0
        min = minDecoded
    }
}

extension SecurityHubClientTypes {
    /// The minimum and maximum baseline bandwidth to Amazon Elastic Block Store (Amazon EBS), in Mbps. For more information, see [Amazon EBSoptimized instances ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the Amazon EC2 User Guide.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails: Swift.Equatable {
        /// The maximum baseline bandwidth, in Mbps. If this parameter is omitted, there's no maximum limit.
        public var max: Swift.Int
        /// The minimum baseline bandwidth, in Mbps. If this parameter is omitted, there's no minimum limit.
        public var min: Swift.Int

        public init (
            max: Swift.Int = 0,
            min: Swift.Int = 0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorCount = "AcceleratorCount"
        case acceleratorManufacturers = "AcceleratorManufacturers"
        case acceleratorNames = "AcceleratorNames"
        case acceleratorTotalMemoryMiB = "AcceleratorTotalMemoryMiB"
        case acceleratorTypes = "AcceleratorTypes"
        case bareMetal = "BareMetal"
        case baselineEbsBandwidthMbps = "BaselineEbsBandwidthMbps"
        case burstablePerformance = "BurstablePerformance"
        case cpuManufacturers = "CpuManufacturers"
        case excludedInstanceTypes = "ExcludedInstanceTypes"
        case instanceGenerations = "InstanceGenerations"
        case localStorage = "LocalStorage"
        case localStorageTypes = "LocalStorageTypes"
        case memoryGiBPerVCpu = "MemoryGiBPerVCpu"
        case memoryMiB = "MemoryMiB"
        case networkInterfaceCount = "NetworkInterfaceCount"
        case onDemandMaxPricePercentageOverLowestPrice = "OnDemandMaxPricePercentageOverLowestPrice"
        case requireHibernateSupport = "RequireHibernateSupport"
        case spotMaxPricePercentageOverLowestPrice = "SpotMaxPricePercentageOverLowestPrice"
        case totalLocalStorageGB = "TotalLocalStorageGB"
        case vCpuCount = "VCpuCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorCount = self.acceleratorCount {
            try encodeContainer.encode(acceleratorCount, forKey: .acceleratorCount)
        }
        if let acceleratorManufacturers = acceleratorManufacturers {
            var acceleratorManufacturersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorManufacturers)
            for nonemptystring0 in acceleratorManufacturers {
                try acceleratorManufacturersContainer.encode(nonemptystring0)
            }
        }
        if let acceleratorNames = acceleratorNames {
            var acceleratorNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorNames)
            for nonemptystring0 in acceleratorNames {
                try acceleratorNamesContainer.encode(nonemptystring0)
            }
        }
        if let acceleratorTotalMemoryMiB = self.acceleratorTotalMemoryMiB {
            try encodeContainer.encode(acceleratorTotalMemoryMiB, forKey: .acceleratorTotalMemoryMiB)
        }
        if let acceleratorTypes = acceleratorTypes {
            var acceleratorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorTypes)
            for nonemptystring0 in acceleratorTypes {
                try acceleratorTypesContainer.encode(nonemptystring0)
            }
        }
        if let bareMetal = self.bareMetal {
            try encodeContainer.encode(bareMetal, forKey: .bareMetal)
        }
        if let baselineEbsBandwidthMbps = self.baselineEbsBandwidthMbps {
            try encodeContainer.encode(baselineEbsBandwidthMbps, forKey: .baselineEbsBandwidthMbps)
        }
        if let burstablePerformance = self.burstablePerformance {
            try encodeContainer.encode(burstablePerformance, forKey: .burstablePerformance)
        }
        if let cpuManufacturers = cpuManufacturers {
            var cpuManufacturersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cpuManufacturers)
            for nonemptystring0 in cpuManufacturers {
                try cpuManufacturersContainer.encode(nonemptystring0)
            }
        }
        if let excludedInstanceTypes = excludedInstanceTypes {
            var excludedInstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedInstanceTypes)
            for nonemptystring0 in excludedInstanceTypes {
                try excludedInstanceTypesContainer.encode(nonemptystring0)
            }
        }
        if let instanceGenerations = instanceGenerations {
            var instanceGenerationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceGenerations)
            for nonemptystring0 in instanceGenerations {
                try instanceGenerationsContainer.encode(nonemptystring0)
            }
        }
        if let localStorage = self.localStorage {
            try encodeContainer.encode(localStorage, forKey: .localStorage)
        }
        if let localStorageTypes = localStorageTypes {
            var localStorageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .localStorageTypes)
            for nonemptystring0 in localStorageTypes {
                try localStorageTypesContainer.encode(nonemptystring0)
            }
        }
        if let memoryGiBPerVCpu = self.memoryGiBPerVCpu {
            try encodeContainer.encode(memoryGiBPerVCpu, forKey: .memoryGiBPerVCpu)
        }
        if let memoryMiB = self.memoryMiB {
            try encodeContainer.encode(memoryMiB, forKey: .memoryMiB)
        }
        if let networkInterfaceCount = self.networkInterfaceCount {
            try encodeContainer.encode(networkInterfaceCount, forKey: .networkInterfaceCount)
        }
        if onDemandMaxPricePercentageOverLowestPrice != 0 {
            try encodeContainer.encode(onDemandMaxPricePercentageOverLowestPrice, forKey: .onDemandMaxPricePercentageOverLowestPrice)
        }
        if requireHibernateSupport != false {
            try encodeContainer.encode(requireHibernateSupport, forKey: .requireHibernateSupport)
        }
        if spotMaxPricePercentageOverLowestPrice != 0 {
            try encodeContainer.encode(spotMaxPricePercentageOverLowestPrice, forKey: .spotMaxPricePercentageOverLowestPrice)
        }
        if let totalLocalStorageGB = self.totalLocalStorageGB {
            try encodeContainer.encode(totalLocalStorageGB, forKey: .totalLocalStorageGB)
        }
        if let vCpuCount = self.vCpuCount {
            try encodeContainer.encode(vCpuCount, forKey: .vCpuCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorCountDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails.self, forKey: .acceleratorCount)
        acceleratorCount = acceleratorCountDecoded
        let acceleratorManufacturersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .acceleratorManufacturers)
        var acceleratorManufacturersDecoded0:[Swift.String]? = nil
        if let acceleratorManufacturersContainer = acceleratorManufacturersContainer {
            acceleratorManufacturersDecoded0 = [Swift.String]()
            for string0 in acceleratorManufacturersContainer {
                if let string0 = string0 {
                    acceleratorManufacturersDecoded0?.append(string0)
                }
            }
        }
        acceleratorManufacturers = acceleratorManufacturersDecoded0
        let acceleratorNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .acceleratorNames)
        var acceleratorNamesDecoded0:[Swift.String]? = nil
        if let acceleratorNamesContainer = acceleratorNamesContainer {
            acceleratorNamesDecoded0 = [Swift.String]()
            for string0 in acceleratorNamesContainer {
                if let string0 = string0 {
                    acceleratorNamesDecoded0?.append(string0)
                }
            }
        }
        acceleratorNames = acceleratorNamesDecoded0
        let acceleratorTotalMemoryMiBDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails.self, forKey: .acceleratorTotalMemoryMiB)
        acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiBDecoded
        let acceleratorTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .acceleratorTypes)
        var acceleratorTypesDecoded0:[Swift.String]? = nil
        if let acceleratorTypesContainer = acceleratorTypesContainer {
            acceleratorTypesDecoded0 = [Swift.String]()
            for string0 in acceleratorTypesContainer {
                if let string0 = string0 {
                    acceleratorTypesDecoded0?.append(string0)
                }
            }
        }
        acceleratorTypes = acceleratorTypesDecoded0
        let bareMetalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bareMetal)
        bareMetal = bareMetalDecoded
        let baselineEbsBandwidthMbpsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails.self, forKey: .baselineEbsBandwidthMbps)
        baselineEbsBandwidthMbps = baselineEbsBandwidthMbpsDecoded
        let burstablePerformanceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .burstablePerformance)
        burstablePerformance = burstablePerformanceDecoded
        let cpuManufacturersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cpuManufacturers)
        var cpuManufacturersDecoded0:[Swift.String]? = nil
        if let cpuManufacturersContainer = cpuManufacturersContainer {
            cpuManufacturersDecoded0 = [Swift.String]()
            for string0 in cpuManufacturersContainer {
                if let string0 = string0 {
                    cpuManufacturersDecoded0?.append(string0)
                }
            }
        }
        cpuManufacturers = cpuManufacturersDecoded0
        let excludedInstanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .excludedInstanceTypes)
        var excludedInstanceTypesDecoded0:[Swift.String]? = nil
        if let excludedInstanceTypesContainer = excludedInstanceTypesContainer {
            excludedInstanceTypesDecoded0 = [Swift.String]()
            for string0 in excludedInstanceTypesContainer {
                if let string0 = string0 {
                    excludedInstanceTypesDecoded0?.append(string0)
                }
            }
        }
        excludedInstanceTypes = excludedInstanceTypesDecoded0
        let instanceGenerationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceGenerations)
        var instanceGenerationsDecoded0:[Swift.String]? = nil
        if let instanceGenerationsContainer = instanceGenerationsContainer {
            instanceGenerationsDecoded0 = [Swift.String]()
            for string0 in instanceGenerationsContainer {
                if let string0 = string0 {
                    instanceGenerationsDecoded0?.append(string0)
                }
            }
        }
        instanceGenerations = instanceGenerationsDecoded0
        let localStorageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localStorage)
        localStorage = localStorageDecoded
        let localStorageTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .localStorageTypes)
        var localStorageTypesDecoded0:[Swift.String]? = nil
        if let localStorageTypesContainer = localStorageTypesContainer {
            localStorageTypesDecoded0 = [Swift.String]()
            for string0 in localStorageTypesContainer {
                if let string0 = string0 {
                    localStorageTypesDecoded0?.append(string0)
                }
            }
        }
        localStorageTypes = localStorageTypesDecoded0
        let memoryGiBPerVCpuDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails.self, forKey: .memoryGiBPerVCpu)
        memoryGiBPerVCpu = memoryGiBPerVCpuDecoded
        let memoryMiBDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails.self, forKey: .memoryMiB)
        memoryMiB = memoryMiBDecoded
        let networkInterfaceCountDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails.self, forKey: .networkInterfaceCount)
        networkInterfaceCount = networkInterfaceCountDecoded
        let onDemandMaxPricePercentageOverLowestPriceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .onDemandMaxPricePercentageOverLowestPrice) ?? 0
        onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPriceDecoded
        let requireHibernateSupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireHibernateSupport) ?? false
        requireHibernateSupport = requireHibernateSupportDecoded
        let spotMaxPricePercentageOverLowestPriceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .spotMaxPricePercentageOverLowestPrice) ?? 0
        spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPriceDecoded
        let totalLocalStorageGBDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails.self, forKey: .totalLocalStorageGB)
        totalLocalStorageGB = totalLocalStorageGBDecoded
        let vCpuCountDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails.self, forKey: .vCpuCount)
        vCpuCount = vCpuCountDecoded
    }
}

extension SecurityHubClientTypes {
    /// The attributes for the Amazon EC2 instance types.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsDetails: Swift.Equatable {
        /// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web Services Inferentia chips) on an instance.
        public var acceleratorCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails?
        /// Indicates whether instance types must have accelerators by specific manufacturers.
        public var acceleratorManufacturers: [Swift.String]?
        /// The accelerators that must be on the instance type.
        public var acceleratorNames: [Swift.String]?
        /// The minimum and maximum amount of total accelerator memory, in MiB.
        public var acceleratorTotalMemoryMiB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails?
        /// The accelerator types that must be on the instance type.
        public var acceleratorTypes: [Swift.String]?
        /// Indicates whether bare metal instance types must be included, excluded, or required.
        public var bareMetal: Swift.String?
        /// The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBS optimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the Amazon EC2 User Guide.
        public var baselineEbsBandwidthMbps: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails?
        /// Indicates whether burstable performance T instance types are included, excluded, or required. For more information, [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) in the Amazon EC2 User Guide.
        public var burstablePerformance: Swift.String?
        /// The CPU manufacturers to include.
        public var cpuManufacturers: [Swift.String]?
        /// The instance types to exclude.
        public var excludedInstanceTypes: [Swift.String]?
        /// Indicates whether current or previous generation instance types are included.
        public var instanceGenerations: [Swift.String]?
        /// Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, see [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the Amazon EC2 User Guide.
        public var localStorage: Swift.String?
        /// The type of local storage that is required.
        public var localStorageTypes: [Swift.String]?
        /// The minimum and maximum amount of memory per vCPU, in GiB.
        public var memoryGiBPerVCpu: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails?
        /// The minimum and maximum amount of memory, in MiB.
        public var memoryMiB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails?
        /// The minimum and maximum number of network interfaces.
        public var networkInterfaceCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails?
        /// The price protection threshold for On-Demand Instances. This is the maximum youll pay for an On-Demand Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. A high value, such as 999999, turns off price protection.
        public var onDemandMaxPricePercentageOverLowestPrice: Swift.Int
        /// Indicates whether instance types must support hibernation for On-Demand Instances.
        public var requireHibernateSupport: Swift.Bool
        /// The price protection threshold for Spot Instances. This is the maximum youll pay for a Spot Instance, expressed as a percentage above the least expensive current generation M, C, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it excludes instance types priced above your threshold. The parameter accepts an integer, which Amazon EC2 interprets as a percentage. A high value, such as 999999, turns off price protection.
        public var spotMaxPricePercentageOverLowestPrice: Swift.Int
        /// The minimum and maximum amount of total local storage, in GB.
        public var totalLocalStorageGB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails?
        /// The minimum and maximum number of vCPUs.
        public var vCpuCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails?

        public init (
            acceleratorCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails? = nil,
            acceleratorManufacturers: [Swift.String]? = nil,
            acceleratorNames: [Swift.String]? = nil,
            acceleratorTotalMemoryMiB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails? = nil,
            acceleratorTypes: [Swift.String]? = nil,
            bareMetal: Swift.String? = nil,
            baselineEbsBandwidthMbps: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails? = nil,
            burstablePerformance: Swift.String? = nil,
            cpuManufacturers: [Swift.String]? = nil,
            excludedInstanceTypes: [Swift.String]? = nil,
            instanceGenerations: [Swift.String]? = nil,
            localStorage: Swift.String? = nil,
            localStorageTypes: [Swift.String]? = nil,
            memoryGiBPerVCpu: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails? = nil,
            memoryMiB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails? = nil,
            networkInterfaceCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails? = nil,
            onDemandMaxPricePercentageOverLowestPrice: Swift.Int = 0,
            requireHibernateSupport: Swift.Bool = false,
            spotMaxPricePercentageOverLowestPrice: Swift.Int = 0,
            totalLocalStorageGB: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails? = nil,
            vCpuCount: SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails? = nil
        )
        {
            self.acceleratorCount = acceleratorCount
            self.acceleratorManufacturers = acceleratorManufacturers
            self.acceleratorNames = acceleratorNames
            self.acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB
            self.acceleratorTypes = acceleratorTypes
            self.bareMetal = bareMetal
            self.baselineEbsBandwidthMbps = baselineEbsBandwidthMbps
            self.burstablePerformance = burstablePerformance
            self.cpuManufacturers = cpuManufacturers
            self.excludedInstanceTypes = excludedInstanceTypes
            self.instanceGenerations = instanceGenerations
            self.localStorage = localStorage
            self.localStorageTypes = localStorageTypes
            self.memoryGiBPerVCpu = memoryGiBPerVCpu
            self.memoryMiB = memoryMiB
            self.networkInterfaceCount = networkInterfaceCount
            self.onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPrice
            self.requireHibernateSupport = requireHibernateSupport
            self.spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPrice
            self.totalLocalStorageGB = totalLocalStorageGB
            self.vCpuCount = vCpuCount
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0.0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if min != 0.0 {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max) ?? 0.0
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min) ?? 0.0
        min = minDecoded
    }
}

extension SecurityHubClientTypes {
    /// The minimum and maximum amount of memory per vCPU, in GiB.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails: Swift.Equatable {
        /// The maximum amount of memory per vCPU, in GiB. If this parameter is omitted, there's no maximum limit.
        public var max: Swift.Double
        /// The minimum amount of memory per vCPU, in GiB. If this parameter is omitted, there's no maximum limit.
        public var min: Swift.Double

        public init (
            max: Swift.Double = 0.0,
            min: Swift.Double = 0.0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if min != 0 {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min) ?? 0
        min = minDecoded
    }
}

extension SecurityHubClientTypes {
    /// The minimum and maximum amount of memory, in MiB, for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails: Swift.Equatable {
        /// The maximum amount of memory, in MiB.
        public var max: Swift.Int
        /// The minimum amount of memory, in MiB.
        public var min: Swift.Int

        public init (
            max: Swift.Int = 0,
            min: Swift.Int = 0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if min != 0 {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min) ?? 0
        min = minDecoded
    }
}

extension SecurityHubClientTypes {
    /// The minimum and maximum number of network interfaces to be attached to an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails: Swift.Equatable {
        /// The maximum number of network interfaces.
        public var max: Swift.Int
        /// The minimum number of network interfaces.
        public var min: Swift.Int

        public init (
            max: Swift.Int = 0,
            min: Swift.Int = 0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0.0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if min != 0.0 {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max) ?? 0.0
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min) ?? 0.0
        min = minDecoded
    }
}

extension SecurityHubClientTypes {
    /// The minimum and maximum amount of total local storage, in GB, that an Amazon EC2 instance uses.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails: Swift.Equatable {
        /// The maximum amount of total local storage, in GB.
        public var max: Swift.Double
        /// The minimum amount of total local storage, in GB.
        public var min: Swift.Double

        public init (
            max: Swift.Double = 0.0,
            min: Swift.Double = 0.0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case min = "Min"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if min != 0 {
            try encodeContainer.encode(min, forKey: .min)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
        let minDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .min) ?? 0
        min = minDecoded
    }
}

extension SecurityHubClientTypes {
    /// The minimum and maximum number of vCPUs for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails: Swift.Equatable {
        /// The maximum number of vCPUs.
        public var max: Swift.Int
        /// The minimum number of vCPUs.
        public var min: Swift.Int

        public init (
            max: Swift.Int = 0,
            min: Swift.Int = 0
        )
        {
            self.max = max
            self.min = min
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataLicenseSetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseConfigurationArn = "LicenseConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseConfigurationArn = self.licenseConfigurationArn {
            try encodeContainer.encode(licenseConfigurationArn, forKey: .licenseConfigurationArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let licenseConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseConfigurationArn)
        licenseConfigurationArn = licenseConfigurationArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the license configuration for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataLicenseSetDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the license configuration.
        public var licenseConfigurationArn: Swift.String?

        public init (
            licenseConfigurationArn: Swift.String? = nil
        )
        {
            self.licenseConfigurationArn = licenseConfigurationArn
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataMaintenanceOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRecovery = "AutoRecovery"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRecovery = self.autoRecovery {
            try encodeContainer.encode(autoRecovery, forKey: .autoRecovery)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoRecoveryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoRecovery)
        autoRecovery = autoRecoveryDecoded
    }
}

extension SecurityHubClientTypes {
    /// The maintenance options of an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataMaintenanceOptionsDetails: Swift.Equatable {
        /// Disables the automatic recovery behavior of your instance or sets it to default.
        public var autoRecovery: Swift.String?

        public init (
            autoRecovery: Swift.String? = nil
        )
        {
            self.autoRecovery = autoRecovery
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataMetadataOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpEndpoint = "HttpEndpoint"
        case httpProtocolIpv6 = "HttpProtocolIpv6"
        case httpPutResponseHopLimit = "HttpPutResponseHopLimit"
        case httpTokens = "HttpTokens"
        case instanceMetadataTags = "InstanceMetadataTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpEndpoint = self.httpEndpoint {
            try encodeContainer.encode(httpEndpoint, forKey: .httpEndpoint)
        }
        if let httpProtocolIpv6 = self.httpProtocolIpv6 {
            try encodeContainer.encode(httpProtocolIpv6, forKey: .httpProtocolIpv6)
        }
        if httpPutResponseHopLimit != 0 {
            try encodeContainer.encode(httpPutResponseHopLimit, forKey: .httpPutResponseHopLimit)
        }
        if let httpTokens = self.httpTokens {
            try encodeContainer.encode(httpTokens, forKey: .httpTokens)
        }
        if let instanceMetadataTags = self.instanceMetadataTags {
            try encodeContainer.encode(instanceMetadataTags, forKey: .instanceMetadataTags)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpEndpoint)
        httpEndpoint = httpEndpointDecoded
        let httpProtocolIpv6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpProtocolIpv6)
        httpProtocolIpv6 = httpProtocolIpv6Decoded
        let httpTokensDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpTokens)
        httpTokens = httpTokensDecoded
        let httpPutResponseHopLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpPutResponseHopLimit) ?? 0
        httpPutResponseHopLimit = httpPutResponseHopLimitDecoded
        let instanceMetadataTagsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceMetadataTags)
        instanceMetadataTags = instanceMetadataTagsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies the metadata options for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataMetadataOptionsDetails: Swift.Equatable {
        /// Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled, and you wont be able to access your instance metadata.
        public var httpEndpoint: Swift.String?
        /// Enables or disables the IPv6 endpoint for the instance metadata service.
        public var httpProtocolIpv6: Swift.String?
        /// The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        public var httpPutResponseHopLimit: Swift.Int
        /// The state of token usage for your instance metadata requests.
        public var httpTokens: Swift.String?
        /// When set to enabled, this parameter allows access to instance tags from the instance metadata. When set to disabled, it turns off access to instance tags from the instance metadata. For more information, see [Work with instance tags in instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS) in the Amazon EC2 User Guide.
        public var instanceMetadataTags: Swift.String?

        public init (
            httpEndpoint: Swift.String? = nil,
            httpProtocolIpv6: Swift.String? = nil,
            httpPutResponseHopLimit: Swift.Int = 0,
            httpTokens: Swift.String? = nil,
            instanceMetadataTags: Swift.String? = nil
        )
        {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataMonitoringDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// The monitoring for an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataMonitoringDetails: Swift.Equatable {
        /// Enables detailed monitoring when true is specified. Otherwise, basic monitoring is enabled. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the Amazon EC2 User Guide.
        public var enabled: Swift.Bool

        public init (
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateCarrierIpAddress = "AssociateCarrierIpAddress"
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case deleteOnTermination = "DeleteOnTermination"
        case description = "Description"
        case deviceIndex = "DeviceIndex"
        case groups = "Groups"
        case interfaceType = "InterfaceType"
        case ipv4PrefixCount = "Ipv4PrefixCount"
        case ipv4Prefixes = "Ipv4Prefixes"
        case ipv6AddressCount = "Ipv6AddressCount"
        case ipv6Addresses = "Ipv6Addresses"
        case ipv6PrefixCount = "Ipv6PrefixCount"
        case ipv6Prefixes = "Ipv6Prefixes"
        case networkCardIndex = "NetworkCardIndex"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddress = "PrivateIpAddress"
        case privateIpAddresses = "PrivateIpAddresses"
        case secondaryPrivateIpAddressCount = "SecondaryPrivateIpAddressCount"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if associateCarrierIpAddress != false {
            try encodeContainer.encode(associateCarrierIpAddress, forKey: .associateCarrierIpAddress)
        }
        if associatePublicIpAddress != false {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if deleteOnTermination != false {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if deviceIndex != 0 {
            try encodeContainer.encode(deviceIndex, forKey: .deviceIndex)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for nonemptystring0 in groups {
                try groupsContainer.encode(nonemptystring0)
            }
        }
        if let interfaceType = self.interfaceType {
            try encodeContainer.encode(interfaceType, forKey: .interfaceType)
        }
        if ipv4PrefixCount != 0 {
            try encodeContainer.encode(ipv4PrefixCount, forKey: .ipv4PrefixCount)
        }
        if let ipv4Prefixes = ipv4Prefixes {
            var ipv4PrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv4Prefixes)
            for awsec2launchtemplatedatanetworkinterfacesetipv4prefixesdetails0 in ipv4Prefixes {
                try ipv4PrefixesContainer.encode(awsec2launchtemplatedatanetworkinterfacesetipv4prefixesdetails0)
            }
        }
        if ipv6AddressCount != 0 {
            try encodeContainer.encode(ipv6AddressCount, forKey: .ipv6AddressCount)
        }
        if let ipv6Addresses = ipv6Addresses {
            var ipv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Addresses)
            for awsec2launchtemplatedatanetworkinterfacesetipv6addressesdetails0 in ipv6Addresses {
                try ipv6AddressesContainer.encode(awsec2launchtemplatedatanetworkinterfacesetipv6addressesdetails0)
            }
        }
        if ipv6PrefixCount != 0 {
            try encodeContainer.encode(ipv6PrefixCount, forKey: .ipv6PrefixCount)
        }
        if let ipv6Prefixes = ipv6Prefixes {
            var ipv6PrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Prefixes)
            for awsec2launchtemplatedatanetworkinterfacesetipv6prefixesdetails0 in ipv6Prefixes {
                try ipv6PrefixesContainer.encode(awsec2launchtemplatedatanetworkinterfacesetipv6prefixesdetails0)
            }
        }
        if networkCardIndex != 0 {
            try encodeContainer.encode(networkCardIndex, forKey: .networkCardIndex)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for awsec2launchtemplatedatanetworkinterfacesetprivateipaddressesdetails0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(awsec2launchtemplatedatanetworkinterfacesetprivateipaddressesdetails0)
            }
        }
        if secondaryPrivateIpAddressCount != 0 {
            try encodeContainer.encode(secondaryPrivateIpAddressCount, forKey: .secondaryPrivateIpAddressCount)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associateCarrierIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateCarrierIpAddress) ?? false
        associateCarrierIpAddress = associateCarrierIpAddressDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress) ?? false
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination) ?? false
        deleteOnTermination = deleteOnTerminationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deviceIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deviceIndex) ?? 0
        deviceIndex = deviceIndexDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let interfaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceType)
        interfaceType = interfaceTypeDecoded
        let ipv4PrefixCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv4PrefixCount) ?? 0
        ipv4PrefixCount = ipv4PrefixCountDecoded
        let ipv4PrefixesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails?].self, forKey: .ipv4Prefixes)
        var ipv4PrefixesDecoded0:[SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]? = nil
        if let ipv4PrefixesContainer = ipv4PrefixesContainer {
            ipv4PrefixesDecoded0 = [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]()
            for structure0 in ipv4PrefixesContainer {
                if let structure0 = structure0 {
                    ipv4PrefixesDecoded0?.append(structure0)
                }
            }
        }
        ipv4Prefixes = ipv4PrefixesDecoded0
        let ipv6AddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv6AddressCount) ?? 0
        ipv6AddressCount = ipv6AddressCountDecoded
        let ipv6AddressesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails?].self, forKey: .ipv6Addresses)
        var ipv6AddressesDecoded0:[SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]? = nil
        if let ipv6AddressesContainer = ipv6AddressesContainer {
            ipv6AddressesDecoded0 = [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]()
            for structure0 in ipv6AddressesContainer {
                if let structure0 = structure0 {
                    ipv6AddressesDecoded0?.append(structure0)
                }
            }
        }
        ipv6Addresses = ipv6AddressesDecoded0
        let ipv6PrefixCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv6PrefixCount) ?? 0
        ipv6PrefixCount = ipv6PrefixCountDecoded
        let ipv6PrefixesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails?].self, forKey: .ipv6Prefixes)
        var ipv6PrefixesDecoded0:[SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]? = nil
        if let ipv6PrefixesContainer = ipv6PrefixesContainer {
            ipv6PrefixesDecoded0 = [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]()
            for structure0 in ipv6PrefixesContainer {
                if let structure0 = structure0 {
                    ipv6PrefixesDecoded0?.append(structure0)
                }
            }
        }
        ipv6Prefixes = ipv6PrefixesDecoded0
        let networkCardIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkCardIndex) ?? 0
        networkCardIndex = networkCardIndexDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let secondaryPrivateIpAddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondaryPrivateIpAddressCount) ?? 0
        secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCountDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// One or more network interfaces to attach to an Amazon EC2 instance. If you specify a network interface, you must specify security groups and subnets as part of the network interface.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails: Swift.Equatable {
        /// Indicates whether to associate a Carrier IP address with eth0 for a new network interface. You use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information, see [Carrier IP address](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the Wavelength Developer Guide.
        public var associateCarrierIpAddress: Swift.Bool
        /// Associates a public IPv4 address with eth0 for a new network interface.
        public var associatePublicIpAddress: Swift.Bool
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public var deleteOnTermination: Swift.Bool
        /// A description for the network interface.
        public var description: Swift.String?
        /// The device index for the network interface attachment.
        public var deviceIndex: Swift.Int
        /// The IDs of one or more security groups.
        public var groups: [Swift.String]?
        /// The type of network interface.
        public var interfaceType: Swift.String?
        /// The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the Ipv4Prefixes option.
        public var ipv4PrefixCount: Swift.Int
        /// One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the Ipv4PrefixCount option.
        public var ipv4Prefixes: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]?
        /// The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if you use Ipv6Addresses.
        public var ipv6AddressCount: Swift.Int
        /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you use Ipv6AddressCount.
        public var ipv6Addresses: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]?
        /// The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the Ipv6Prefix option.
        public var ipv6PrefixCount: Swift.Int
        /// One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the Ipv6PrefixCount option.
        public var ipv6Prefixes: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]?
        /// The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        public var networkCardIndex: Swift.Int
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The primary private IPv4 address of the network interface.
        public var privateIpAddress: Swift.String?
        /// One or more private IPv4 addresses.
        public var privateIpAddresses: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]?
        /// The number of secondary private IPv4 addresses to assign to a network interface.
        public var secondaryPrivateIpAddressCount: Swift.Int
        /// The ID of the subnet for the network interface.
        public var subnetId: Swift.String?

        public init (
            associateCarrierIpAddress: Swift.Bool = false,
            associatePublicIpAddress: Swift.Bool = false,
            deleteOnTermination: Swift.Bool = false,
            description: Swift.String? = nil,
            deviceIndex: Swift.Int = 0,
            groups: [Swift.String]? = nil,
            interfaceType: Swift.String? = nil,
            ipv4PrefixCount: Swift.Int = 0,
            ipv4Prefixes: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails]? = nil,
            ipv6AddressCount: Swift.Int = 0,
            ipv6Addresses: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails]? = nil,
            ipv6PrefixCount: Swift.Int = 0,
            ipv6Prefixes: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails]? = nil,
            networkCardIndex: Swift.Int = 0,
            networkInterfaceId: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails]? = nil,
            secondaryPrivateIpAddressCount: Swift.Int = 0,
            subnetId: Swift.String? = nil
        )
        {
            self.associateCarrierIpAddress = associateCarrierIpAddress
            self.associatePublicIpAddress = associatePublicIpAddress
            self.deleteOnTermination = deleteOnTermination
            self.description = description
            self.deviceIndex = deviceIndex
            self.groups = groups
            self.interfaceType = interfaceType
            self.ipv4PrefixCount = ipv4PrefixCount
            self.ipv4Prefixes = ipv4Prefixes
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.ipv6PrefixCount = ipv6PrefixCount
            self.ipv6Prefixes = ipv6Prefixes
            self.networkCardIndex = networkCardIndex
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.subnetId = subnetId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv4Prefix = "Ipv4Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv4Prefix = self.ipv4Prefix {
            try encodeContainer.encode(ipv4Prefix, forKey: .ipv4Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv4PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv4Prefix)
        ipv4Prefix = ipv4PrefixDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details on one or more IPv4 prefixes for a network interface.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails: Swift.Equatable {
        /// The IPv4 prefix. For more information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the Amazon Elastic Compute Cloud User Guide.
        public var ipv4Prefix: Swift.String?

        public init (
            ipv4Prefix: Swift.String? = nil
        )
        {
            self.ipv4Prefix = ipv4Prefix
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv6Address = "Ipv6Address"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6Address = self.ipv6Address {
            try encodeContainer.encode(ipv6Address, forKey: .ipv6Address)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv6AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6Address)
        ipv6Address = ipv6AddressDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies an IPv6 address in an Amazon EC2 launch template.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails: Swift.Equatable {
        /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
        public var ipv6Address: Swift.String?

        public init (
            ipv6Address: Swift.String? = nil
        )
        {
            self.ipv6Address = ipv6Address
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv6Prefix = "Ipv6Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6Prefix = self.ipv6Prefix {
            try encodeContainer.encode(ipv6Prefix, forKey: .ipv6Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv6PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6Prefix)
        ipv6Prefix = ipv6PrefixDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details on one or more IPv6 prefixes to be assigned to the network interface.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails: Swift.Equatable {
        /// The IPv6 prefix.
        public var ipv6Prefix: Swift.String?

        public init (
            ipv6Prefix: Swift.String? = nil
        )
        {
            self.ipv6Prefix = ipv6Prefix
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primary = "Primary"
        case privateIpAddress = "PrivateIpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if primary != false {
            try encodeContainer.encode(primary, forKey: .primary)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .primary) ?? false
        primary = primaryDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension SecurityHubClientTypes {
    /// One or more private IPv4 addresses.
    public struct AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails: Swift.Equatable {
        /// Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        public var primary: Swift.Bool
        /// The private IPv4 address.
        public var privateIpAddress: Swift.String?

        public init (
            primary: Swift.Bool = false,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataPlacementDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case affinity = "Affinity"
        case availabilityZone = "AvailabilityZone"
        case groupName = "GroupName"
        case hostId = "HostId"
        case hostResourceGroupArn = "HostResourceGroupArn"
        case partitionNumber = "PartitionNumber"
        case spreadDomain = "SpreadDomain"
        case tenancy = "Tenancy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let affinity = self.affinity {
            try encodeContainer.encode(affinity, forKey: .affinity)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let hostId = self.hostId {
            try encodeContainer.encode(hostId, forKey: .hostId)
        }
        if let hostResourceGroupArn = self.hostResourceGroupArn {
            try encodeContainer.encode(hostResourceGroupArn, forKey: .hostResourceGroupArn)
        }
        if partitionNumber != 0 {
            try encodeContainer.encode(partitionNumber, forKey: .partitionNumber)
        }
        if let spreadDomain = self.spreadDomain {
            try encodeContainer.encode(spreadDomain, forKey: .spreadDomain)
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let affinityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .affinity)
        affinity = affinityDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let hostIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostId)
        hostId = hostIdDecoded
        let hostResourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostResourceGroupArn)
        hostResourceGroupArn = hostResourceGroupArnDecoded
        let partitionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partitionNumber) ?? 0
        partitionNumber = partitionNumberDecoded
        let spreadDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spreadDomain)
        spreadDomain = spreadDomainDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the placement of an Amazon EC2 instance.
    public struct AwsEc2LaunchTemplateDataPlacementDetails: Swift.Equatable {
        /// The affinity setting for an instance on an EC2 Dedicated Host.
        public var affinity: Swift.String?
        /// The Availability Zone for the instance.
        public var availabilityZone: Swift.String?
        /// The name of the placement group for the instance.
        public var groupName: Swift.String?
        /// The ID of the Dedicated Host for the instance.
        public var hostId: Swift.String?
        /// The Amazon Resource Name (ARN) of the host resource group in which to launch the instances.
        public var hostResourceGroupArn: Swift.String?
        /// The number of the partition the instance should launch in.
        public var partitionNumber: Swift.Int
        /// Reserved for future use.
        public var spreadDomain: Swift.String?
        /// The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.
        public var tenancy: Swift.String?

        public init (
            affinity: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            groupName: Swift.String? = nil,
            hostId: Swift.String? = nil,
            hostResourceGroupArn: Swift.String? = nil,
            partitionNumber: Swift.Int = 0,
            spreadDomain: Swift.String? = nil,
            tenancy: Swift.String? = nil
        )
        {
            self.affinity = affinity
            self.availabilityZone = availabilityZone
            self.groupName = groupName
            self.hostId = hostId
            self.hostResourceGroupArn = hostResourceGroupArn
            self.partitionNumber = partitionNumber
            self.spreadDomain = spreadDomain
            self.tenancy = tenancy
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableResourceNameDnsAAAARecord = "EnableResourceNameDnsAAAARecord"
        case enableResourceNameDnsARecord = "EnableResourceNameDnsARecord"
        case hostnameType = "HostnameType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableResourceNameDnsAAAARecord != false {
            try encodeContainer.encode(enableResourceNameDnsAAAARecord, forKey: .enableResourceNameDnsAAAARecord)
        }
        if enableResourceNameDnsARecord != false {
            try encodeContainer.encode(enableResourceNameDnsARecord, forKey: .enableResourceNameDnsARecord)
        }
        if let hostnameType = self.hostnameType {
            try encodeContainer.encode(hostnameType, forKey: .hostnameType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableResourceNameDnsAAAARecordDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableResourceNameDnsAAAARecord) ?? false
        enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecordDecoded
        let enableResourceNameDnsARecordDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableResourceNameDnsARecord) ?? false
        enableResourceNameDnsARecord = enableResourceNameDnsARecordDecoded
        let hostnameTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostnameType)
        hostnameType = hostnameTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Describes the options for Amazon EC2 instance hostnames.
    public struct AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails: Swift.Equatable {
        /// Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        public var enableResourceNameDnsAAAARecord: Swift.Bool
        /// Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        public var enableResourceNameDnsARecord: Swift.Bool
        /// The type of hostname for EC2 instances.
        public var hostnameType: Swift.String?

        public init (
            enableResourceNameDnsAAAARecord: Swift.Bool = false,
            enableResourceNameDnsARecord: Swift.Bool = false,
            hostnameType: Swift.String? = nil
        )
        {
            self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
            self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
            self.hostnameType = hostnameType
        }
    }

}

extension SecurityHubClientTypes.AwsEc2LaunchTemplateDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultVersionNumber = "DefaultVersionNumber"
        case id = "Id"
        case latestVersionNumber = "LatestVersionNumber"
        case launchTemplateData = "LaunchTemplateData"
        case launchTemplateName = "LaunchTemplateName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultVersionNumber != 0 {
            try encodeContainer.encode(defaultVersionNumber, forKey: .defaultVersionNumber)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if latestVersionNumber != 0 {
            try encodeContainer.encode(latestVersionNumber, forKey: .latestVersionNumber)
        }
        if let launchTemplateData = self.launchTemplateData {
            try encodeContainer.encode(launchTemplateData, forKey: .launchTemplateData)
        }
        if let launchTemplateName = self.launchTemplateName {
            try encodeContainer.encode(launchTemplateName, forKey: .launchTemplateName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateName)
        launchTemplateName = launchTemplateNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let launchTemplateDataDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails.self, forKey: .launchTemplateData)
        launchTemplateData = launchTemplateDataDecoded
        let defaultVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultVersionNumber) ?? 0
        defaultVersionNumber = defaultVersionNumberDecoded
        let latestVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersionNumber) ?? 0
        latestVersionNumber = latestVersionNumberDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies the properties for creating an Amazon Elastic Compute Cloud (Amazon EC2) launch template.
    public struct AwsEc2LaunchTemplateDetails: Swift.Equatable {
        /// The default version of the launch template.
        public var defaultVersionNumber: Swift.Int
        /// An ID for the launch template.
        public var id: Swift.String?
        /// The latest version of the launch template.
        public var latestVersionNumber: Swift.Int
        /// The information to include in the launch template.
        public var launchTemplateData: SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails?
        /// A name for the launch template.
        public var launchTemplateName: Swift.String?

        public init (
            defaultVersionNumber: Swift.Int = 0,
            id: Swift.String? = nil,
            latestVersionNumber: Swift.Int = 0,
            launchTemplateData: SecurityHubClientTypes.AwsEc2LaunchTemplateDataDetails? = nil,
            launchTemplateName: Swift.String? = nil
        )
        {
            self.defaultVersionNumber = defaultVersionNumber
            self.id = id
            self.latestVersionNumber = latestVersionNumber
            self.launchTemplateData = launchTemplateData
            self.launchTemplateName = launchTemplateName
        }
    }

}

extension SecurityHubClientTypes.AwsEc2NetworkAclAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkAclAssociationId = "NetworkAclAssociationId"
        case networkAclId = "NetworkAclId"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkAclAssociationId = self.networkAclAssociationId {
            try encodeContainer.encode(networkAclAssociationId, forKey: .networkAclAssociationId)
        }
        if let networkAclId = self.networkAclId {
            try encodeContainer.encode(networkAclId, forKey: .networkAclId)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkAclAssociationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkAclAssociationId)
        networkAclAssociationId = networkAclAssociationIdDecoded
        let networkAclIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkAclId)
        networkAclId = networkAclIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// An association between the network ACL and a subnet.
    public struct AwsEc2NetworkAclAssociation: Swift.Equatable {
        /// The identifier of the association between the network ACL and the subnet.
        public var networkAclAssociationId: Swift.String?
        /// The identifier of the network ACL.
        public var networkAclId: Swift.String?
        /// The identifier of the subnet that is associated with the network ACL.
        public var subnetId: Swift.String?

        public init (
            networkAclAssociationId: Swift.String? = nil,
            networkAclId: Swift.String? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.networkAclAssociationId = networkAclAssociationId
            self.networkAclId = networkAclId
            self.subnetId = subnetId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2NetworkAclDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associations = "Associations"
        case entries = "Entries"
        case isDefault = "IsDefault"
        case networkAclId = "NetworkAclId"
        case ownerId = "OwnerId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associations = associations {
            var associationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associations)
            for awsec2networkaclassociation0 in associations {
                try associationsContainer.encode(awsec2networkaclassociation0)
            }
        }
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for awsec2networkaclentry0 in entries {
                try entriesContainer.encode(awsec2networkaclentry0)
            }
        }
        if isDefault != false {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let networkAclId = self.networkAclId {
            try encodeContainer.encode(networkAclId, forKey: .networkAclId)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault) ?? false
        isDefault = isDefaultDecoded
        let networkAclIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkAclId)
        networkAclId = networkAclIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let associationsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2NetworkAclAssociation?].self, forKey: .associations)
        var associationsDecoded0:[SecurityHubClientTypes.AwsEc2NetworkAclAssociation]? = nil
        if let associationsContainer = associationsContainer {
            associationsDecoded0 = [SecurityHubClientTypes.AwsEc2NetworkAclAssociation]()
            for structure0 in associationsContainer {
                if let structure0 = structure0 {
                    associationsDecoded0?.append(structure0)
                }
            }
        }
        associations = associationsDecoded0
        let entriesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2NetworkAclEntry?].self, forKey: .entries)
        var entriesDecoded0:[SecurityHubClientTypes.AwsEc2NetworkAclEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [SecurityHubClientTypes.AwsEc2NetworkAclEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Contains details about an Amazon EC2 network access control list (ACL).
    public struct AwsEc2NetworkAclDetails: Swift.Equatable {
        /// Associations between the network ACL and subnets.
        public var associations: [SecurityHubClientTypes.AwsEc2NetworkAclAssociation]?
        /// The set of rules in the network ACL.
        public var entries: [SecurityHubClientTypes.AwsEc2NetworkAclEntry]?
        /// Whether this is the default network ACL for the VPC.
        public var isDefault: Swift.Bool
        /// The identifier of the network ACL.
        public var networkAclId: Swift.String?
        /// The identifier of the Amazon Web Services account that owns the network ACL.
        public var ownerId: Swift.String?
        /// The identifier of the VPC for the network ACL.
        public var vpcId: Swift.String?

        public init (
            associations: [SecurityHubClientTypes.AwsEc2NetworkAclAssociation]? = nil,
            entries: [SecurityHubClientTypes.AwsEc2NetworkAclEntry]? = nil,
            isDefault: Swift.Bool = false,
            networkAclId: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.associations = associations
            self.entries = entries
            self.isDefault = isDefault
            self.networkAclId = networkAclId
            self.ownerId = ownerId
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2NetworkAclEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrBlock = "CidrBlock"
        case egress = "Egress"
        case icmpTypeCode = "IcmpTypeCode"
        case ipv6CidrBlock = "Ipv6CidrBlock"
        case portRange = "PortRange"
        case `protocol` = "Protocol"
        case ruleAction = "RuleAction"
        case ruleNumber = "RuleNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrBlock = self.cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if egress != false {
            try encodeContainer.encode(egress, forKey: .egress)
        }
        if let icmpTypeCode = self.icmpTypeCode {
            try encodeContainer.encode(icmpTypeCode, forKey: .icmpTypeCode)
        }
        if let ipv6CidrBlock = self.ipv6CidrBlock {
            try encodeContainer.encode(ipv6CidrBlock, forKey: .ipv6CidrBlock)
        }
        if let portRange = self.portRange {
            try encodeContainer.encode(portRange, forKey: .portRange)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let ruleAction = self.ruleAction {
            try encodeContainer.encode(ruleAction, forKey: .ruleAction)
        }
        if ruleNumber != 0 {
            try encodeContainer.encode(ruleNumber, forKey: .ruleNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let egressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .egress) ?? false
        egress = egressDecoded
        let icmpTypeCodeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.IcmpTypeCode.self, forKey: .icmpTypeCode)
        icmpTypeCode = icmpTypeCodeDecoded
        let ipv6CidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6CidrBlock)
        ipv6CidrBlock = ipv6CidrBlockDecoded
        let portRangeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.PortRangeFromTo.self, forKey: .portRange)
        portRange = portRangeDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let ruleActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleAction)
        ruleAction = ruleActionDecoded
        let ruleNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ruleNumber) ?? 0
        ruleNumber = ruleNumberDecoded
    }
}

extension SecurityHubClientTypes {
    /// A rule for the network ACL. Each rule allows or denies access based on the IP address, traffic direction, port, and protocol.
    public struct AwsEc2NetworkAclEntry: Swift.Equatable {
        /// The IPV4 network range for which to deny or allow access.
        public var cidrBlock: Swift.String?
        /// Whether the rule is an egress rule. An egress rule is a rule that applies to traffic that leaves the subnet.
        public var egress: Swift.Bool
        /// The Internet Control Message Protocol (ICMP) type and code for which to deny or allow access.
        public var icmpTypeCode: SecurityHubClientTypes.IcmpTypeCode?
        /// The IPV6 network range for which to deny or allow access.
        public var ipv6CidrBlock: Swift.String?
        /// For TCP or UDP protocols, the range of ports that the rule applies to.
        public var portRange: SecurityHubClientTypes.PortRangeFromTo?
        /// The protocol that the rule applies to. To deny or allow access to all protocols, use the value -1.
        public var `protocol`: Swift.String?
        /// Whether the rule is used to allow access or deny access.
        public var ruleAction: Swift.String?
        /// The rule number. The rules are processed in order by their number.
        public var ruleNumber: Swift.Int

        public init (
            cidrBlock: Swift.String? = nil,
            egress: Swift.Bool = false,
            icmpTypeCode: SecurityHubClientTypes.IcmpTypeCode? = nil,
            ipv6CidrBlock: Swift.String? = nil,
            portRange: SecurityHubClientTypes.PortRangeFromTo? = nil,
            `protocol`: Swift.String? = nil,
            ruleAction: Swift.String? = nil,
            ruleNumber: Swift.Int = 0
        )
        {
            self.cidrBlock = cidrBlock
            self.egress = egress
            self.icmpTypeCode = icmpTypeCode
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
            self.ruleNumber = ruleNumber
        }
    }

}

extension SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachTime = "AttachTime"
        case attachmentId = "AttachmentId"
        case deleteOnTermination = "DeleteOnTermination"
        case deviceIndex = "DeviceIndex"
        case instanceId = "InstanceId"
        case instanceOwnerId = "InstanceOwnerId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachTime = self.attachTime {
            try encodeContainer.encode(attachTime, forKey: .attachTime)
        }
        if let attachmentId = self.attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if deleteOnTermination != false {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if deviceIndex != 0 {
            try encodeContainer.encode(deviceIndex, forKey: .deviceIndex)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceOwnerId = self.instanceOwnerId {
            try encodeContainer.encode(instanceOwnerId, forKey: .instanceOwnerId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachTime)
        attachTime = attachTimeDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination) ?? false
        deleteOnTermination = deleteOnTerminationDecoded
        let deviceIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deviceIndex) ?? 0
        deviceIndex = deviceIndexDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceOwnerId)
        instanceOwnerId = instanceOwnerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the network interface attachment.
    public struct AwsEc2NetworkInterfaceAttachment: Swift.Equatable {
        /// Indicates when the attachment initiated. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var attachTime: Swift.String?
        /// The identifier of the network interface attachment
        public var attachmentId: Swift.String?
        /// Indicates whether the network interface is deleted when the instance is terminated.
        public var deleteOnTermination: Swift.Bool
        /// The device index of the network interface attachment on the instance.
        public var deviceIndex: Swift.Int
        /// The ID of the instance.
        public var instanceId: Swift.String?
        /// The Amazon Web Services account ID of the owner of the instance.
        public var instanceOwnerId: Swift.String?
        /// The attachment state. Valid values: attaching | attached | detaching | detached
        public var status: Swift.String?

        public init (
            attachTime: Swift.String? = nil,
            attachmentId: Swift.String? = nil,
            deleteOnTermination: Swift.Bool = false,
            deviceIndex: Swift.Int = 0,
            instanceId: Swift.String? = nil,
            instanceOwnerId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.attachTime = attachTime
            self.attachmentId = attachmentId
            self.deleteOnTermination = deleteOnTermination
            self.deviceIndex = deviceIndex
            self.instanceId = instanceId
            self.instanceOwnerId = instanceOwnerId
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachment = "Attachment"
        case ipV6Addresses = "IpV6Addresses"
        case networkInterfaceId = "NetworkInterfaceId"
        case privateIpAddresses = "PrivateIpAddresses"
        case publicDnsName = "PublicDnsName"
        case publicIp = "PublicIp"
        case securityGroups = "SecurityGroups"
        case sourceDestCheck = "SourceDestCheck"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = self.attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let ipV6Addresses = ipV6Addresses {
            var ipV6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipV6Addresses)
            for awsec2networkinterfaceipv6addressdetail0 in ipV6Addresses {
                try ipV6AddressesContainer.encode(awsec2networkinterfaceipv6addressdetail0)
            }
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for awsec2networkinterfaceprivateipaddressdetail0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(awsec2networkinterfaceprivateipaddressdetail0)
            }
        }
        if let publicDnsName = self.publicDnsName {
            try encodeContainer.encode(publicDnsName, forKey: .publicDnsName)
        }
        if let publicIp = self.publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for awsec2networkinterfacesecuritygroup0 in securityGroups {
                try securityGroupsContainer.encode(awsec2networkinterfacesecuritygroup0)
            }
        }
        if sourceDestCheck != false {
            try encodeContainer.encode(sourceDestCheck, forKey: .sourceDestCheck)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let sourceDestCheckDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sourceDestCheck) ?? false
        sourceDestCheck = sourceDestCheckDecoded
        let ipV6AddressesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail?].self, forKey: .ipV6Addresses)
        var ipV6AddressesDecoded0:[SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail]? = nil
        if let ipV6AddressesContainer = ipV6AddressesContainer {
            ipV6AddressesDecoded0 = [SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail]()
            for structure0 in ipV6AddressesContainer {
                if let structure0 = structure0 {
                    ipV6AddressesDecoded0?.append(structure0)
                }
            }
        }
        ipV6Addresses = ipV6AddressesDecoded0
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the network interface
    public struct AwsEc2NetworkInterfaceDetails: Swift.Equatable {
        /// The network interface attachment.
        public var attachment: SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment?
        /// The IPv6 addresses associated with the network interface.
        public var ipV6Addresses: [SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail]?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The private IPv4 addresses associated with the network interface.
        public var privateIpAddresses: [SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail]?
        /// The public DNS name of the network interface.
        public var publicDnsName: Swift.String?
        /// The address of the Elastic IP address bound to the network interface.
        public var publicIp: Swift.String?
        /// Security groups for the network interface.
        public var securityGroups: [SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup]?
        /// Indicates whether traffic to or from the instance is validated.
        public var sourceDestCheck: Swift.Bool

        public init (
            attachment: SecurityHubClientTypes.AwsEc2NetworkInterfaceAttachment? = nil,
            ipV6Addresses: [SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail]? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateIpAddresses: [SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail]? = nil,
            publicDnsName: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            securityGroups: [SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup]? = nil,
            sourceDestCheck: Swift.Bool = false
        )
        {
            self.attachment = attachment
            self.ipV6Addresses = ipV6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.sourceDestCheck = sourceDestCheck
        }
    }

}

extension SecurityHubClientTypes.AwsEc2NetworkInterfaceIpV6AddressDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipV6Address = "IpV6Address"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipV6Address = self.ipV6Address {
            try encodeContainer.encode(ipV6Address, forKey: .ipV6Address)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipV6AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipV6Address)
        ipV6Address = ipV6AddressDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an IPV6 address that is associated with the network interface.
    public struct AwsEc2NetworkInterfaceIpV6AddressDetail: Swift.Equatable {
        /// The IPV6 address.
        public var ipV6Address: Swift.String?

        public init (
            ipV6Address: Swift.String? = nil
        )
        {
            self.ipV6Address = ipV6Address
        }
    }

}

extension SecurityHubClientTypes.AwsEc2NetworkInterfacePrivateIpAddressDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privateDnsName = "PrivateDnsName"
        case privateIpAddress = "PrivateIpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateDnsName = self.privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about a private IPv4 address that is with the network interface.
    public struct AwsEc2NetworkInterfacePrivateIpAddressDetail: Swift.Equatable {
        /// The private DNS name for the IP address.
        public var privateDnsName: Swift.String?
        /// The IP address.
        public var privateIpAddress: Swift.String?

        public init (
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }
    }

}

extension SecurityHubClientTypes.AwsEc2NetworkInterfaceSecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// A security group associated with the network interface.
    public struct AwsEc2NetworkInterfaceSecurityGroup: Swift.Equatable {
        /// The ID of the security group.
        public var groupId: Swift.String?
        /// The name of the security group.
        public var groupName: Swift.String?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension SecurityHubClientTypes.AwsEc2SecurityGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
        case ipPermissions = "IpPermissions"
        case ipPermissionsEgress = "IpPermissionsEgress"
        case ownerId = "OwnerId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let ipPermissions = ipPermissions {
            var ipPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipPermissions)
            for awsec2securitygroupippermission0 in ipPermissions {
                try ipPermissionsContainer.encode(awsec2securitygroupippermission0)
            }
        }
        if let ipPermissionsEgress = ipPermissionsEgress {
            var ipPermissionsEgressContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipPermissionsEgress)
            for awsec2securitygroupippermission0 in ipPermissionsEgress {
                try ipPermissionsEgressContainer.encode(awsec2securitygroupippermission0)
            }
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let ipPermissionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission?].self, forKey: .ipPermissions)
        var ipPermissionsDecoded0:[SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]? = nil
        if let ipPermissionsContainer = ipPermissionsContainer {
            ipPermissionsDecoded0 = [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]()
            for structure0 in ipPermissionsContainer {
                if let structure0 = structure0 {
                    ipPermissionsDecoded0?.append(structure0)
                }
            }
        }
        ipPermissions = ipPermissionsDecoded0
        let ipPermissionsEgressContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission?].self, forKey: .ipPermissionsEgress)
        var ipPermissionsEgressDecoded0:[SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]? = nil
        if let ipPermissionsEgressContainer = ipPermissionsEgressContainer {
            ipPermissionsEgressDecoded0 = [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]()
            for structure0 in ipPermissionsEgressContainer {
                if let structure0 = structure0 {
                    ipPermissionsEgressDecoded0?.append(structure0)
                }
            }
        }
        ipPermissionsEgress = ipPermissionsEgressDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Details about an Amazon EC2 security group.
    public struct AwsEc2SecurityGroupDetails: Swift.Equatable {
        /// The ID of the security group.
        public var groupId: Swift.String?
        /// The name of the security group.
        public var groupName: Swift.String?
        /// The inbound rules associated with the security group.
        public var ipPermissions: [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]?
        /// [VPC only] The outbound rules associated with the security group.
        public var ipPermissionsEgress: [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]?
        /// The Amazon Web Services account ID of the owner of the security group.
        public var ownerId: Swift.String?
        /// [VPC only] The ID of the VPC for the security group.
        public var vpcId: Swift.String?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            ipPermissions: [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]? = nil,
            ipPermissionsEgress: [SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission]? = nil,
            ownerId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
            self.ipPermissions = ipPermissions
            self.ipPermissionsEgress = ipPermissionsEgress
            self.ownerId = ownerId
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2SecurityGroupIpPermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case ipProtocol = "IpProtocol"
        case ipRanges = "IpRanges"
        case ipv6Ranges = "Ipv6Ranges"
        case prefixListIds = "PrefixListIds"
        case toPort = "ToPort"
        case userIdGroupPairs = "UserIdGroupPairs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if fromPort != 0 {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if let ipProtocol = self.ipProtocol {
            try encodeContainer.encode(ipProtocol, forKey: .ipProtocol)
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for awsec2securitygroupiprange0 in ipRanges {
                try ipRangesContainer.encode(awsec2securitygroupiprange0)
            }
        }
        if let ipv6Ranges = ipv6Ranges {
            var ipv6RangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Ranges)
            for awsec2securitygroupipv6range0 in ipv6Ranges {
                try ipv6RangesContainer.encode(awsec2securitygroupipv6range0)
            }
        }
        if let prefixListIds = prefixListIds {
            var prefixListIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .prefixListIds)
            for awsec2securitygroupprefixlistid0 in prefixListIds {
                try prefixListIdsContainer.encode(awsec2securitygroupprefixlistid0)
            }
        }
        if toPort != 0 {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
        if let userIdGroupPairs = userIdGroupPairs {
            var userIdGroupPairsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIdGroupPairs)
            for awsec2securitygroupuseridgrouppair0 in userIdGroupPairs {
                try userIdGroupPairsContainer.encode(awsec2securitygroupuseridgrouppair0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipProtocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipProtocol)
        ipProtocol = ipProtocolDecoded
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort) ?? 0
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort) ?? 0
        toPort = toPortDecoded
        let userIdGroupPairsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair?].self, forKey: .userIdGroupPairs)
        var userIdGroupPairsDecoded0:[SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair]? = nil
        if let userIdGroupPairsContainer = userIdGroupPairsContainer {
            userIdGroupPairsDecoded0 = [SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair]()
            for structure0 in userIdGroupPairsContainer {
                if let structure0 = structure0 {
                    userIdGroupPairsDecoded0?.append(structure0)
                }
            }
        }
        userIdGroupPairs = userIdGroupPairsDecoded0
        let ipRangesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2SecurityGroupIpRange?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[SecurityHubClientTypes.AwsEc2SecurityGroupIpRange]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [SecurityHubClientTypes.AwsEc2SecurityGroupIpRange]()
            for structure0 in ipRangesContainer {
                if let structure0 = structure0 {
                    ipRangesDecoded0?.append(structure0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let ipv6RangesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range?].self, forKey: .ipv6Ranges)
        var ipv6RangesDecoded0:[SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range]? = nil
        if let ipv6RangesContainer = ipv6RangesContainer {
            ipv6RangesDecoded0 = [SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range]()
            for structure0 in ipv6RangesContainer {
                if let structure0 = structure0 {
                    ipv6RangesDecoded0?.append(structure0)
                }
            }
        }
        ipv6Ranges = ipv6RangesDecoded0
        let prefixListIdsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId?].self, forKey: .prefixListIds)
        var prefixListIdsDecoded0:[SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId]? = nil
        if let prefixListIdsContainer = prefixListIdsContainer {
            prefixListIdsDecoded0 = [SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId]()
            for structure0 in prefixListIdsContainer {
                if let structure0 = structure0 {
                    prefixListIdsDecoded0?.append(structure0)
                }
            }
        }
        prefixListIds = prefixListIdsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// An IP permission for an EC2 security group.
    public struct AwsEc2SecurityGroupIpPermission: Swift.Equatable {
        /// The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        public var fromPort: Swift.Int
        /// The IP protocol name (tcp, udp, icmp, icmpv6) or number. [VPC only] Use -1 to specify all protocols. When authorizing security group rules, specifying -1 or a protocol number other than tcp, udp, icmp, or icmpv6 allows traffic on all ports, regardless of any port range you specify. For tcp, udp, and icmp, you must specify a port range. For icmpv6, the port range is optional. If you omit the port range, traffic for all types and codes is allowed.
        public var ipProtocol: Swift.String?
        /// The IPv4 ranges.
        public var ipRanges: [SecurityHubClientTypes.AwsEc2SecurityGroupIpRange]?
        /// The IPv6 ranges.
        public var ipv6Ranges: [SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range]?
        /// [VPC only] The prefix list IDs for an Amazon Web Services service. With outbound rules, this is the Amazon Web Services service to access through a VPC endpoint from instances associated with the security group.
        public var prefixListIds: [SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId]?
        /// The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.
        public var toPort: Swift.Int
        /// The security group and Amazon Web Services account ID pairs.
        public var userIdGroupPairs: [SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair]?

        public init (
            fromPort: Swift.Int = 0,
            ipProtocol: Swift.String? = nil,
            ipRanges: [SecurityHubClientTypes.AwsEc2SecurityGroupIpRange]? = nil,
            ipv6Ranges: [SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range]? = nil,
            prefixListIds: [SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId]? = nil,
            toPort: Swift.Int = 0,
            userIdGroupPairs: [SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair]? = nil
        )
        {
            self.fromPort = fromPort
            self.ipProtocol = ipProtocol
            self.ipRanges = ipRanges
            self.ipv6Ranges = ipv6Ranges
            self.prefixListIds = prefixListIds
            self.toPort = toPort
            self.userIdGroupPairs = userIdGroupPairs
        }
    }

}

extension SecurityHubClientTypes.AwsEc2SecurityGroupIpRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrIp = "CidrIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrIp = self.cidrIp {
            try encodeContainer.encode(cidrIp, forKey: .cidrIp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrIp)
        cidrIp = cidrIpDecoded
    }
}

extension SecurityHubClientTypes {
    /// A range of IPv4 addresses.
    public struct AwsEc2SecurityGroupIpRange: Swift.Equatable {
        /// The IPv4 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv4 address, use the /32 prefix length.
        public var cidrIp: Swift.String?

        public init (
            cidrIp: Swift.String? = nil
        )
        {
            self.cidrIp = cidrIp
        }
    }

}

extension SecurityHubClientTypes.AwsEc2SecurityGroupIpv6Range: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrIpv6 = "CidrIpv6"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrIpv6 = self.cidrIpv6 {
            try encodeContainer.encode(cidrIpv6, forKey: .cidrIpv6)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrIpv6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrIpv6)
        cidrIpv6 = cidrIpv6Decoded
    }
}

extension SecurityHubClientTypes {
    /// A range of IPv6 addresses.
    public struct AwsEc2SecurityGroupIpv6Range: Swift.Equatable {
        /// The IPv6 CIDR range. You can specify either a CIDR range or a source security group, but not both. To specify a single IPv6 address, use the /128 prefix length.
        public var cidrIpv6: Swift.String?

        public init (
            cidrIpv6: Swift.String? = nil
        )
        {
            self.cidrIpv6 = cidrIpv6
        }
    }

}

extension SecurityHubClientTypes.AwsEc2SecurityGroupPrefixListId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case prefixListId = "PrefixListId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prefixListId = self.prefixListId {
            try encodeContainer.encode(prefixListId, forKey: .prefixListId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixListIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefixListId)
        prefixListId = prefixListIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// A prefix list ID.
    public struct AwsEc2SecurityGroupPrefixListId: Swift.Equatable {
        /// The ID of the prefix.
        public var prefixListId: Swift.String?

        public init (
            prefixListId: Swift.String? = nil
        )
        {
            self.prefixListId = prefixListId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2SecurityGroupUserIdGroupPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case groupName = "GroupName"
        case peeringStatus = "PeeringStatus"
        case userId = "UserId"
        case vpcId = "VpcId"
        case vpcPeeringConnectionId = "VpcPeeringConnectionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let peeringStatus = self.peeringStatus {
            try encodeContainer.encode(peeringStatus, forKey: .peeringStatus)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcPeeringConnectionId = self.vpcPeeringConnectionId {
            try encodeContainer.encode(vpcPeeringConnectionId, forKey: .vpcPeeringConnectionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let peeringStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .peeringStatus)
        peeringStatus = peeringStatusDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let vpcPeeringConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcPeeringConnectionId)
        vpcPeeringConnectionId = vpcPeeringConnectionIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// A relationship between a security group and a user.
    public struct AwsEc2SecurityGroupUserIdGroupPair: Swift.Equatable {
        /// The ID of the security group.
        public var groupId: Swift.String?
        /// The name of the security group.
        public var groupName: Swift.String?
        /// The status of a VPC peering connection, if applicable.
        public var peeringStatus: Swift.String?
        /// The ID of an Amazon Web Services account. For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned. [EC2-Classic] Required when adding or removing rules that reference a security group in another VPC.
        public var userId: Swift.String?
        /// The ID of the VPC for the referenced security group, if applicable.
        public var vpcId: Swift.String?
        /// The ID of the VPC peering connection, if applicable.
        public var vpcPeeringConnectionId: Swift.String?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            peeringStatus: Swift.String? = nil,
            userId: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            vpcPeeringConnectionId: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
            self.peeringStatus = peeringStatus
            self.userId = userId
            self.vpcId = vpcId
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2SubnetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignIpv6AddressOnCreation = "AssignIpv6AddressOnCreation"
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneId = "AvailabilityZoneId"
        case availableIpAddressCount = "AvailableIpAddressCount"
        case cidrBlock = "CidrBlock"
        case defaultForAz = "DefaultForAz"
        case ipv6CidrBlockAssociationSet = "Ipv6CidrBlockAssociationSet"
        case mapPublicIpOnLaunch = "MapPublicIpOnLaunch"
        case ownerId = "OwnerId"
        case state = "State"
        case subnetArn = "SubnetArn"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assignIpv6AddressOnCreation != false {
            try encodeContainer.encode(assignIpv6AddressOnCreation, forKey: .assignIpv6AddressOnCreation)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if availableIpAddressCount != 0 {
            try encodeContainer.encode(availableIpAddressCount, forKey: .availableIpAddressCount)
        }
        if let cidrBlock = self.cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if defaultForAz != false {
            try encodeContainer.encode(defaultForAz, forKey: .defaultForAz)
        }
        if let ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet {
            var ipv6CidrBlockAssociationSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6CidrBlockAssociationSet)
            for ipv6cidrblockassociation0 in ipv6CidrBlockAssociationSet {
                try ipv6CidrBlockAssociationSetContainer.encode(ipv6cidrblockassociation0)
            }
        }
        if mapPublicIpOnLaunch != false {
            try encodeContainer.encode(mapPublicIpOnLaunch, forKey: .mapPublicIpOnLaunch)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let subnetArn = self.subnetArn {
            try encodeContainer.encode(subnetArn, forKey: .subnetArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignIpv6AddressOnCreationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assignIpv6AddressOnCreation) ?? false
        assignIpv6AddressOnCreation = assignIpv6AddressOnCreationDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availableIpAddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableIpAddressCount) ?? 0
        availableIpAddressCount = availableIpAddressCountDecoded
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let defaultForAzDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultForAz) ?? false
        defaultForAz = defaultForAzDecoded
        let mapPublicIpOnLaunchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mapPublicIpOnLaunch) ?? false
        mapPublicIpOnLaunch = mapPublicIpOnLaunchDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let subnetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetArn)
        subnetArn = subnetArnDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let ipv6CidrBlockAssociationSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Ipv6CidrBlockAssociation?].self, forKey: .ipv6CidrBlockAssociationSet)
        var ipv6CidrBlockAssociationSetDecoded0:[SecurityHubClientTypes.Ipv6CidrBlockAssociation]? = nil
        if let ipv6CidrBlockAssociationSetContainer = ipv6CidrBlockAssociationSetContainer {
            ipv6CidrBlockAssociationSetDecoded0 = [SecurityHubClientTypes.Ipv6CidrBlockAssociation]()
            for structure0 in ipv6CidrBlockAssociationSetContainer {
                if let structure0 = structure0 {
                    ipv6CidrBlockAssociationSetDecoded0?.append(structure0)
                }
            }
        }
        ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSetDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a subnet in Amazon EC2.
    public struct AwsEc2SubnetDetails: Swift.Equatable {
        /// Whether to assign an IPV6 address to a network interface that is created in this subnet.
        public var assignIpv6AddressOnCreation: Swift.Bool
        /// The Availability Zone for the subnet.
        public var availabilityZone: Swift.String?
        /// The identifier of the Availability Zone for the subnet.
        public var availabilityZoneId: Swift.String?
        /// The number of available IPV4 addresses in the subnet. Does not include addresses for stopped instances.
        public var availableIpAddressCount: Swift.Int
        /// The IPV4 CIDR block that is assigned to the subnet.
        public var cidrBlock: Swift.String?
        /// Whether this subnet is the default subnet for the Availability Zone.
        public var defaultForAz: Swift.Bool
        /// The IPV6 CIDR blocks that are associated with the subnet.
        public var ipv6CidrBlockAssociationSet: [SecurityHubClientTypes.Ipv6CidrBlockAssociation]?
        /// Whether instances in this subnet receive a public IP address.
        public var mapPublicIpOnLaunch: Swift.Bool
        /// The identifier of the Amazon Web Services account that owns the subnet.
        public var ownerId: Swift.String?
        /// The current state of the subnet. Valid values are available or pending.
        public var state: Swift.String?
        /// The ARN of the subnet.
        public var subnetArn: Swift.String?
        /// The identifier of the subnet.
        public var subnetId: Swift.String?
        /// The identifier of the VPC that contains the subnet.
        public var vpcId: Swift.String?

        public init (
            assignIpv6AddressOnCreation: Swift.Bool = false,
            availabilityZone: Swift.String? = nil,
            availabilityZoneId: Swift.String? = nil,
            availableIpAddressCount: Swift.Int = 0,
            cidrBlock: Swift.String? = nil,
            defaultForAz: Swift.Bool = false,
            ipv6CidrBlockAssociationSet: [SecurityHubClientTypes.Ipv6CidrBlockAssociation]? = nil,
            mapPublicIpOnLaunch: Swift.Bool = false,
            ownerId: Swift.String? = nil,
            state: Swift.String? = nil,
            subnetArn: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.assignIpv6AddressOnCreation = assignIpv6AddressOnCreation
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.availableIpAddressCount = availableIpAddressCount
            self.cidrBlock = cidrBlock
            self.defaultForAz = defaultForAz
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.mapPublicIpOnLaunch = mapPublicIpOnLaunch
            self.ownerId = ownerId
            self.state = state
            self.subnetArn = subnetArn
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2TransitGatewayDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonSideAsn = "AmazonSideAsn"
        case associationDefaultRouteTableId = "AssociationDefaultRouteTableId"
        case autoAcceptSharedAttachments = "AutoAcceptSharedAttachments"
        case defaultRouteTableAssociation = "DefaultRouteTableAssociation"
        case defaultRouteTablePropagation = "DefaultRouteTablePropagation"
        case description = "Description"
        case dnsSupport = "DnsSupport"
        case id = "Id"
        case multicastSupport = "MulticastSupport"
        case propagationDefaultRouteTableId = "PropagationDefaultRouteTableId"
        case transitGatewayCidrBlocks = "TransitGatewayCidrBlocks"
        case vpnEcmpSupport = "VpnEcmpSupport"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if amazonSideAsn != 0 {
            try encodeContainer.encode(amazonSideAsn, forKey: .amazonSideAsn)
        }
        if let associationDefaultRouteTableId = self.associationDefaultRouteTableId {
            try encodeContainer.encode(associationDefaultRouteTableId, forKey: .associationDefaultRouteTableId)
        }
        if let autoAcceptSharedAttachments = self.autoAcceptSharedAttachments {
            try encodeContainer.encode(autoAcceptSharedAttachments, forKey: .autoAcceptSharedAttachments)
        }
        if let defaultRouteTableAssociation = self.defaultRouteTableAssociation {
            try encodeContainer.encode(defaultRouteTableAssociation, forKey: .defaultRouteTableAssociation)
        }
        if let defaultRouteTablePropagation = self.defaultRouteTablePropagation {
            try encodeContainer.encode(defaultRouteTablePropagation, forKey: .defaultRouteTablePropagation)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dnsSupport = self.dnsSupport {
            try encodeContainer.encode(dnsSupport, forKey: .dnsSupport)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let multicastSupport = self.multicastSupport {
            try encodeContainer.encode(multicastSupport, forKey: .multicastSupport)
        }
        if let propagationDefaultRouteTableId = self.propagationDefaultRouteTableId {
            try encodeContainer.encode(propagationDefaultRouteTableId, forKey: .propagationDefaultRouteTableId)
        }
        if let transitGatewayCidrBlocks = transitGatewayCidrBlocks {
            var transitGatewayCidrBlocksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .transitGatewayCidrBlocks)
            for nonemptystring0 in transitGatewayCidrBlocks {
                try transitGatewayCidrBlocksContainer.encode(nonemptystring0)
            }
        }
        if let vpnEcmpSupport = self.vpnEcmpSupport {
            try encodeContainer.encode(vpnEcmpSupport, forKey: .vpnEcmpSupport)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRouteTablePropagationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRouteTablePropagation)
        defaultRouteTablePropagation = defaultRouteTablePropagationDecoded
        let autoAcceptSharedAttachmentsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoAcceptSharedAttachments)
        autoAcceptSharedAttachments = autoAcceptSharedAttachmentsDecoded
        let defaultRouteTableAssociationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRouteTableAssociation)
        defaultRouteTableAssociation = defaultRouteTableAssociationDecoded
        let transitGatewayCidrBlocksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .transitGatewayCidrBlocks)
        var transitGatewayCidrBlocksDecoded0:[Swift.String]? = nil
        if let transitGatewayCidrBlocksContainer = transitGatewayCidrBlocksContainer {
            transitGatewayCidrBlocksDecoded0 = [Swift.String]()
            for string0 in transitGatewayCidrBlocksContainer {
                if let string0 = string0 {
                    transitGatewayCidrBlocksDecoded0?.append(string0)
                }
            }
        }
        transitGatewayCidrBlocks = transitGatewayCidrBlocksDecoded0
        let associationDefaultRouteTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationDefaultRouteTableId)
        associationDefaultRouteTableId = associationDefaultRouteTableIdDecoded
        let propagationDefaultRouteTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propagationDefaultRouteTableId)
        propagationDefaultRouteTableId = propagationDefaultRouteTableIdDecoded
        let vpnEcmpSupportDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnEcmpSupport)
        vpnEcmpSupport = vpnEcmpSupportDecoded
        let dnsSupportDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsSupport)
        dnsSupport = dnsSupportDecoded
        let multicastSupportDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .multicastSupport)
        multicastSupport = multicastSupportDecoded
        let amazonSideAsnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amazonSideAsn) ?? 0
        amazonSideAsn = amazonSideAsnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an Amazon Web Services Amazon EC2 Transit Gateway that interconnects virtual private clouds (VPCs) and on-premises networks.
    public struct AwsEc2TransitGatewayDetails: Swift.Equatable {
        /// A private Autonomous System Number (ASN) for the Amazon side of a BGP session.
        public var amazonSideAsn: Swift.Int
        /// The ID of the default association route table.
        public var associationDefaultRouteTableId: Swift.String?
        /// Turn on or turn off automatic acceptance of attachment requests.
        public var autoAcceptSharedAttachments: Swift.String?
        /// Turn on or turn off automatic association with the default association route table.
        public var defaultRouteTableAssociation: Swift.String?
        /// Turn on or turn off automatic propagation of routes to the default propagation route table.
        public var defaultRouteTablePropagation: Swift.String?
        /// The description of the transit gateway.
        public var description: Swift.String?
        /// Turn on or turn off DNS support.
        public var dnsSupport: Swift.String?
        /// The ID of the transit gateway.
        public var id: Swift.String?
        /// Indicates whether multicast is supported on the transit gateway.
        public var multicastSupport: Swift.String?
        /// The ID of the default propagation route table.
        public var propagationDefaultRouteTableId: Swift.String?
        /// The transit gateway Classless Inter-Domain Routing (CIDR) blocks.
        public var transitGatewayCidrBlocks: [Swift.String]?
        /// Turn on or turn off Equal Cost Multipath Protocol (ECMP) support.
        public var vpnEcmpSupport: Swift.String?

        public init (
            amazonSideAsn: Swift.Int = 0,
            associationDefaultRouteTableId: Swift.String? = nil,
            autoAcceptSharedAttachments: Swift.String? = nil,
            defaultRouteTableAssociation: Swift.String? = nil,
            defaultRouteTablePropagation: Swift.String? = nil,
            description: Swift.String? = nil,
            dnsSupport: Swift.String? = nil,
            id: Swift.String? = nil,
            multicastSupport: Swift.String? = nil,
            propagationDefaultRouteTableId: Swift.String? = nil,
            transitGatewayCidrBlocks: [Swift.String]? = nil,
            vpnEcmpSupport: Swift.String? = nil
        )
        {
            self.amazonSideAsn = amazonSideAsn
            self.associationDefaultRouteTableId = associationDefaultRouteTableId
            self.autoAcceptSharedAttachments = autoAcceptSharedAttachments
            self.defaultRouteTableAssociation = defaultRouteTableAssociation
            self.defaultRouteTablePropagation = defaultRouteTablePropagation
            self.description = description
            self.dnsSupport = dnsSupport
            self.id = id
            self.multicastSupport = multicastSupport
            self.propagationDefaultRouteTableId = propagationDefaultRouteTableId
            self.transitGatewayCidrBlocks = transitGatewayCidrBlocks
            self.vpnEcmpSupport = vpnEcmpSupport
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VolumeAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachTime = "AttachTime"
        case deleteOnTermination = "DeleteOnTermination"
        case instanceId = "InstanceId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachTime = self.attachTime {
            try encodeContainer.encode(attachTime, forKey: .attachTime)
        }
        if deleteOnTermination != false {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachTime)
        attachTime = attachTimeDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination) ?? false
        deleteOnTermination = deleteOnTerminationDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// An attachment to an Amazon EC2 volume.
    public struct AwsEc2VolumeAttachment: Swift.Equatable {
        /// The datetime when the attachment initiated.
        public var attachTime: Swift.String?
        /// Whether the EBS volume is deleted when the EC2 instance is terminated.
        public var deleteOnTermination: Swift.Bool
        /// The identifier of the EC2 instance.
        public var instanceId: Swift.String?
        /// The attachment state of the volume. Valid values are as follows:
        ///
        /// * attaching
        ///
        /// * attached
        ///
        /// * busy
        ///
        /// * detaching
        ///
        /// * detached
        public var status: Swift.String?

        public init (
            attachTime: Swift.String? = nil,
            deleteOnTermination: Swift.Bool = false,
            instanceId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.instanceId = instanceId
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VolumeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments = "Attachments"
        case createTime = "CreateTime"
        case deviceName = "DeviceName"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case size = "Size"
        case snapshotId = "SnapshotId"
        case status = "Status"
        case volumeId = "VolumeId"
        case volumeScanStatus = "VolumeScanStatus"
        case volumeType = "VolumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for awsec2volumeattachment0 in attachments {
                try attachmentsContainer.encode(awsec2volumeattachment0)
            }
        }
        if let createTime = self.createTime {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if encrypted != false {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
        if let volumeScanStatus = self.volumeScanStatus {
            try encodeContainer.encode(volumeScanStatus, forKey: .volumeScanStatus)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        createTime = createTimeDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted) ?? false
        encrypted = encryptedDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2VolumeAttachment?].self, forKey: .attachments)
        var attachmentsDecoded0:[SecurityHubClientTypes.AwsEc2VolumeAttachment]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [SecurityHubClientTypes.AwsEc2VolumeAttachment]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let volumeScanStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeScanStatus)
        volumeScanStatus = volumeScanStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an EC2 volume.
    public struct AwsEc2VolumeDetails: Swift.Equatable {
        /// The volume attachments.
        public var attachments: [SecurityHubClientTypes.AwsEc2VolumeAttachment]?
        /// Indicates when the volume was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createTime: Swift.String?
        /// The device name for the volume that is attached to the instance.
        public var deviceName: Swift.String?
        /// Specifies whether the volume is encrypted.
        public var encrypted: Swift.Bool
        /// The ARN of the KMS key that was used to protect the volume encryption key for the volume.
        public var kmsKeyId: Swift.String?
        /// The size of the volume, in GiBs.
        public var size: Swift.Int
        /// The snapshot from which the volume was created.
        public var snapshotId: Swift.String?
        /// The volume state. Valid values are as follows:
        ///
        /// * available
        ///
        /// * creating
        ///
        /// * deleted
        ///
        /// * deleting
        ///
        /// * error
        ///
        /// * in-use
        public var status: Swift.String?
        /// The ID of the volume.
        public var volumeId: Swift.String?
        /// Indicates whether the volume was scanned or skipped.
        public var volumeScanStatus: Swift.String?
        /// The volume type.
        public var volumeType: Swift.String?

        public init (
            attachments: [SecurityHubClientTypes.AwsEc2VolumeAttachment]? = nil,
            createTime: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            encrypted: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil,
            size: Swift.Int = 0,
            snapshotId: Swift.String? = nil,
            status: Swift.String? = nil,
            volumeId: Swift.String? = nil,
            volumeScanStatus: Swift.String? = nil,
            volumeType: Swift.String? = nil
        )
        {
            self.attachments = attachments
            self.createTime = createTime
            self.deviceName = deviceName
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.size = size
            self.snapshotId = snapshotId
            self.status = status
            self.volumeId = volumeId
            self.volumeScanStatus = volumeScanStatus
            self.volumeType = volumeType
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpcDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrBlockAssociationSet = "CidrBlockAssociationSet"
        case dhcpOptionsId = "DhcpOptionsId"
        case ipv6CidrBlockAssociationSet = "Ipv6CidrBlockAssociationSet"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrBlockAssociationSet = cidrBlockAssociationSet {
            var cidrBlockAssociationSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrBlockAssociationSet)
            for cidrblockassociation0 in cidrBlockAssociationSet {
                try cidrBlockAssociationSetContainer.encode(cidrblockassociation0)
            }
        }
        if let dhcpOptionsId = self.dhcpOptionsId {
            try encodeContainer.encode(dhcpOptionsId, forKey: .dhcpOptionsId)
        }
        if let ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet {
            var ipv6CidrBlockAssociationSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6CidrBlockAssociationSet)
            for ipv6cidrblockassociation0 in ipv6CidrBlockAssociationSet {
                try ipv6CidrBlockAssociationSetContainer.encode(ipv6cidrblockassociation0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrBlockAssociationSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.CidrBlockAssociation?].self, forKey: .cidrBlockAssociationSet)
        var cidrBlockAssociationSetDecoded0:[SecurityHubClientTypes.CidrBlockAssociation]? = nil
        if let cidrBlockAssociationSetContainer = cidrBlockAssociationSetContainer {
            cidrBlockAssociationSetDecoded0 = [SecurityHubClientTypes.CidrBlockAssociation]()
            for structure0 in cidrBlockAssociationSetContainer {
                if let structure0 = structure0 {
                    cidrBlockAssociationSetDecoded0?.append(structure0)
                }
            }
        }
        cidrBlockAssociationSet = cidrBlockAssociationSetDecoded0
        let ipv6CidrBlockAssociationSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Ipv6CidrBlockAssociation?].self, forKey: .ipv6CidrBlockAssociationSet)
        var ipv6CidrBlockAssociationSetDecoded0:[SecurityHubClientTypes.Ipv6CidrBlockAssociation]? = nil
        if let ipv6CidrBlockAssociationSetContainer = ipv6CidrBlockAssociationSetContainer {
            ipv6CidrBlockAssociationSetDecoded0 = [SecurityHubClientTypes.Ipv6CidrBlockAssociation]()
            for structure0 in ipv6CidrBlockAssociationSetContainer {
                if let structure0 = structure0 {
                    ipv6CidrBlockAssociationSetDecoded0?.append(structure0)
                }
            }
        }
        ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSetDecoded0
        let dhcpOptionsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dhcpOptionsId)
        dhcpOptionsId = dhcpOptionsIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an EC2 VPC.
    public struct AwsEc2VpcDetails: Swift.Equatable {
        /// Information about the IPv4 CIDR blocks associated with the VPC.
        public var cidrBlockAssociationSet: [SecurityHubClientTypes.CidrBlockAssociation]?
        /// The identifier of the set of Dynamic Host Configuration Protocol (DHCP) options that are associated with the VPC. If the default options are associated with the VPC, then this is default.
        public var dhcpOptionsId: Swift.String?
        /// Information about the IPv6 CIDR blocks associated with the VPC.
        public var ipv6CidrBlockAssociationSet: [SecurityHubClientTypes.Ipv6CidrBlockAssociation]?
        /// The current state of the VPC. Valid values are available or pending.
        public var state: Swift.String?

        public init (
            cidrBlockAssociationSet: [SecurityHubClientTypes.CidrBlockAssociation]? = nil,
            dhcpOptionsId: Swift.String? = nil,
            ipv6CidrBlockAssociationSet: [SecurityHubClientTypes.Ipv6CidrBlockAssociation]? = nil,
            state: Swift.String? = nil
        )
        {
            self.cidrBlockAssociationSet = cidrBlockAssociationSet
            self.dhcpOptionsId = dhcpOptionsId
            self.ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet
            self.state = state
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceRequired = "AcceptanceRequired"
        case availabilityZones = "AvailabilityZones"
        case baseEndpointDnsNames = "BaseEndpointDnsNames"
        case gatewayLoadBalancerArns = "GatewayLoadBalancerArns"
        case managesVpcEndpoints = "ManagesVpcEndpoints"
        case networkLoadBalancerArns = "NetworkLoadBalancerArns"
        case privateDnsName = "PrivateDnsName"
        case serviceId = "ServiceId"
        case serviceName = "ServiceName"
        case serviceState = "ServiceState"
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if acceptanceRequired != false {
            try encodeContainer.encode(acceptanceRequired, forKey: .acceptanceRequired)
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for nonemptystring0 in availabilityZones {
                try availabilityZonesContainer.encode(nonemptystring0)
            }
        }
        if let baseEndpointDnsNames = baseEndpointDnsNames {
            var baseEndpointDnsNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .baseEndpointDnsNames)
            for nonemptystring0 in baseEndpointDnsNames {
                try baseEndpointDnsNamesContainer.encode(nonemptystring0)
            }
        }
        if let gatewayLoadBalancerArns = gatewayLoadBalancerArns {
            var gatewayLoadBalancerArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gatewayLoadBalancerArns)
            for nonemptystring0 in gatewayLoadBalancerArns {
                try gatewayLoadBalancerArnsContainer.encode(nonemptystring0)
            }
        }
        if managesVpcEndpoints != false {
            try encodeContainer.encode(managesVpcEndpoints, forKey: .managesVpcEndpoints)
        }
        if let networkLoadBalancerArns = networkLoadBalancerArns {
            var networkLoadBalancerArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkLoadBalancerArns)
            for nonemptystring0 in networkLoadBalancerArns {
                try networkLoadBalancerArnsContainer.encode(nonemptystring0)
            }
        }
        if let privateDnsName = self.privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let serviceId = self.serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceState = self.serviceState {
            try encodeContainer.encode(serviceState, forKey: .serviceState)
        }
        if let serviceType = serviceType {
            var serviceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceType)
            for awsec2vpcendpointserviceservicetypedetails0 in serviceType {
                try serviceTypeContainer.encode(awsec2vpcendpointserviceservicetypedetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptanceRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .acceptanceRequired) ?? false
        acceptanceRequired = acceptanceRequiredDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let baseEndpointDnsNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .baseEndpointDnsNames)
        var baseEndpointDnsNamesDecoded0:[Swift.String]? = nil
        if let baseEndpointDnsNamesContainer = baseEndpointDnsNamesContainer {
            baseEndpointDnsNamesDecoded0 = [Swift.String]()
            for string0 in baseEndpointDnsNamesContainer {
                if let string0 = string0 {
                    baseEndpointDnsNamesDecoded0?.append(string0)
                }
            }
        }
        baseEndpointDnsNames = baseEndpointDnsNamesDecoded0
        let managesVpcEndpointsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .managesVpcEndpoints) ?? false
        managesVpcEndpoints = managesVpcEndpointsDecoded
        let gatewayLoadBalancerArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .gatewayLoadBalancerArns)
        var gatewayLoadBalancerArnsDecoded0:[Swift.String]? = nil
        if let gatewayLoadBalancerArnsContainer = gatewayLoadBalancerArnsContainer {
            gatewayLoadBalancerArnsDecoded0 = [Swift.String]()
            for string0 in gatewayLoadBalancerArnsContainer {
                if let string0 = string0 {
                    gatewayLoadBalancerArnsDecoded0?.append(string0)
                }
            }
        }
        gatewayLoadBalancerArns = gatewayLoadBalancerArnsDecoded0
        let networkLoadBalancerArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .networkLoadBalancerArns)
        var networkLoadBalancerArnsDecoded0:[Swift.String]? = nil
        if let networkLoadBalancerArnsContainer = networkLoadBalancerArnsContainer {
            networkLoadBalancerArnsDecoded0 = [Swift.String]()
            for string0 in networkLoadBalancerArnsContainer {
                if let string0 = string0 {
                    networkLoadBalancerArnsDecoded0?.append(string0)
                }
            }
        }
        networkLoadBalancerArns = networkLoadBalancerArnsDecoded0
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceState)
        serviceState = serviceStateDecoded
        let serviceTypeContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails?].self, forKey: .serviceType)
        var serviceTypeDecoded0:[SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails]? = nil
        if let serviceTypeContainer = serviceTypeContainer {
            serviceTypeDecoded0 = [SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails]()
            for structure0 in serviceTypeContainer {
                if let structure0 = structure0 {
                    serviceTypeDecoded0?.append(structure0)
                }
            }
        }
        serviceType = serviceTypeDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Contains details about the service configuration for a VPC endpoint service.
    public struct AwsEc2VpcEndpointServiceDetails: Swift.Equatable {
        /// Whether requests from other Amazon Web Services accounts to create an endpoint to the service must first be accepted.
        public var acceptanceRequired: Swift.Bool
        /// The Availability Zones where the service is available.
        public var availabilityZones: [Swift.String]?
        /// The DNS names for the service.
        public var baseEndpointDnsNames: [Swift.String]?
        /// The ARNs of the Gateway Load Balancers for the service.
        public var gatewayLoadBalancerArns: [Swift.String]?
        /// Whether the service manages its VPC endpoints.
        public var managesVpcEndpoints: Swift.Bool
        /// The ARNs of the Network Load Balancers for the service.
        public var networkLoadBalancerArns: [Swift.String]?
        /// The private DNS name for the service.
        public var privateDnsName: Swift.String?
        /// The identifier of the service.
        public var serviceId: Swift.String?
        /// The name of the service.
        public var serviceName: Swift.String?
        /// The current state of the service. Valid values are as follows:
        ///
        /// * Available
        ///
        /// * Deleted
        ///
        /// * Deleting
        ///
        /// * Failed
        ///
        /// * Pending
        public var serviceState: Swift.String?
        /// The types for the service.
        public var serviceType: [SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails]?

        public init (
            acceptanceRequired: Swift.Bool = false,
            availabilityZones: [Swift.String]? = nil,
            baseEndpointDnsNames: [Swift.String]? = nil,
            gatewayLoadBalancerArns: [Swift.String]? = nil,
            managesVpcEndpoints: Swift.Bool = false,
            networkLoadBalancerArns: [Swift.String]? = nil,
            privateDnsName: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceState: Swift.String? = nil,
            serviceType: [SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails]? = nil
        )
        {
            self.acceptanceRequired = acceptanceRequired
            self.availabilityZones = availabilityZones
            self.baseEndpointDnsNames = baseEndpointDnsNames
            self.gatewayLoadBalancerArns = gatewayLoadBalancerArns
            self.managesVpcEndpoints = managesVpcEndpoints
            self.networkLoadBalancerArns = networkLoadBalancerArns
            self.privateDnsName = privateDnsName
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceState = serviceState
            self.serviceType = serviceType
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpcEndpointServiceServiceTypeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceType = "ServiceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceType = self.serviceType {
            try encodeContainer.encode(serviceType, forKey: .serviceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// The service type information for a VPC endpoint service.
    public struct AwsEc2VpcEndpointServiceServiceTypeDetails: Swift.Equatable {
        /// The type of service.
        public var serviceType: Swift.String?

        public init (
            serviceType: Swift.String? = nil
        )
        {
            self.serviceType = serviceType
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accepterVpcInfo = "AccepterVpcInfo"
        case expirationTime = "ExpirationTime"
        case requesterVpcInfo = "RequesterVpcInfo"
        case status = "Status"
        case vpcPeeringConnectionId = "VpcPeeringConnectionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accepterVpcInfo = self.accepterVpcInfo {
            try encodeContainer.encode(accepterVpcInfo, forKey: .accepterVpcInfo)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encode(expirationTime, forKey: .expirationTime)
        }
        if let requesterVpcInfo = self.requesterVpcInfo {
            try encodeContainer.encode(requesterVpcInfo, forKey: .requesterVpcInfo)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcPeeringConnectionId = self.vpcPeeringConnectionId {
            try encodeContainer.encode(vpcPeeringConnectionId, forKey: .vpcPeeringConnectionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accepterVpcInfoDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails.self, forKey: .accepterVpcInfo)
        accepterVpcInfo = accepterVpcInfoDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let requesterVpcInfoDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails.self, forKey: .requesterVpcInfo)
        requesterVpcInfo = requesterVpcInfoDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails.self, forKey: .status)
        status = statusDecoded
        let vpcPeeringConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcPeeringConnectionId)
        vpcPeeringConnectionId = vpcPeeringConnectionIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about a VPC peering connection between two VPCs: a requester VPC that you own and an accepter VPC with which to create the connection.
    public struct AwsEc2VpcPeeringConnectionDetails: Swift.Equatable {
        /// Information about the accepter VPC.
        public var accepterVpcInfo: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails?
        /// The time at which an unaccepted VPC peering connection will expire.
        public var expirationTime: Swift.String?
        /// Information about the requester VPC.
        public var requesterVpcInfo: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails?
        /// The status of the VPC peering connection.
        public var status: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails?
        /// The ID of the VPC peering connection.
        public var vpcPeeringConnectionId: Swift.String?

        public init (
            accepterVpcInfo: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails? = nil,
            expirationTime: Swift.String? = nil,
            requesterVpcInfo: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails? = nil,
            status: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails? = nil,
            vpcPeeringConnectionId: Swift.String? = nil
        )
        {
            self.accepterVpcInfo = accepterVpcInfo
            self.expirationTime = expirationTime
            self.requesterVpcInfo = requesterVpcInfo
            self.status = status
            self.vpcPeeringConnectionId = vpcPeeringConnectionId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpcPeeringConnectionStatusDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the status of the VPC peering connection.
    public struct AwsEc2VpcPeeringConnectionStatusDetails: Swift.Equatable {
        /// The status of the VPC peering connection.
        public var code: Swift.String?
        /// A message that provides more information about the status, if applicable.
        public var message: Swift.String?

        public init (
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpcPeeringConnectionVpcInfoDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrBlock = "CidrBlock"
        case cidrBlockSet = "CidrBlockSet"
        case ipv6CidrBlockSet = "Ipv6CidrBlockSet"
        case ownerId = "OwnerId"
        case peeringOptions = "PeeringOptions"
        case region = "Region"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrBlock = self.cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if let cidrBlockSet = cidrBlockSet {
            var cidrBlockSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrBlockSet)
            for vpcinfocidrblocksetdetails0 in cidrBlockSet {
                try cidrBlockSetContainer.encode(vpcinfocidrblocksetdetails0)
            }
        }
        if let ipv6CidrBlockSet = ipv6CidrBlockSet {
            var ipv6CidrBlockSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6CidrBlockSet)
            for vpcinfoipv6cidrblocksetdetails0 in ipv6CidrBlockSet {
                try ipv6CidrBlockSetContainer.encode(vpcinfoipv6cidrblocksetdetails0)
            }
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let peeringOptions = self.peeringOptions {
            try encodeContainer.encode(peeringOptions, forKey: .peeringOptions)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let cidrBlockSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.VpcInfoCidrBlockSetDetails?].self, forKey: .cidrBlockSet)
        var cidrBlockSetDecoded0:[SecurityHubClientTypes.VpcInfoCidrBlockSetDetails]? = nil
        if let cidrBlockSetContainer = cidrBlockSetContainer {
            cidrBlockSetDecoded0 = [SecurityHubClientTypes.VpcInfoCidrBlockSetDetails]()
            for structure0 in cidrBlockSetContainer {
                if let structure0 = structure0 {
                    cidrBlockSetDecoded0?.append(structure0)
                }
            }
        }
        cidrBlockSet = cidrBlockSetDecoded0
        let ipv6CidrBlockSetContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails?].self, forKey: .ipv6CidrBlockSet)
        var ipv6CidrBlockSetDecoded0:[SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails]? = nil
        if let ipv6CidrBlockSetContainer = ipv6CidrBlockSetContainer {
            ipv6CidrBlockSetDecoded0 = [SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails]()
            for structure0 in ipv6CidrBlockSetContainer {
                if let structure0 = structure0 {
                    ipv6CidrBlockSetDecoded0?.append(structure0)
                }
            }
        }
        ipv6CidrBlockSet = ipv6CidrBlockSetDecoded0
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let peeringOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.VpcInfoPeeringOptionsDetails.self, forKey: .peeringOptions)
        peeringOptions = peeringOptionsDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Describes a VPC in a VPC peering connection.
    public struct AwsEc2VpcPeeringConnectionVpcInfoDetails: Swift.Equatable {
        /// The IPv4 CIDR block for the VPC.
        public var cidrBlock: Swift.String?
        /// Information about the IPv4 CIDR blocks for the VPC.
        public var cidrBlockSet: [SecurityHubClientTypes.VpcInfoCidrBlockSetDetails]?
        /// The IPv6 CIDR block for the VPC.
        public var ipv6CidrBlockSet: [SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails]?
        /// The ID of the Amazon Web Services account that owns the VPC.
        public var ownerId: Swift.String?
        /// Information about the VPC peering connection options for the accepter or requester VPC.
        public var peeringOptions: SecurityHubClientTypes.VpcInfoPeeringOptionsDetails?
        /// The Amazon Web Services Region in which the VPC is located.
        public var region: Swift.String?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init (
            cidrBlock: Swift.String? = nil,
            cidrBlockSet: [SecurityHubClientTypes.VpcInfoCidrBlockSetDetails]? = nil,
            ipv6CidrBlockSet: [SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails]? = nil,
            ownerId: Swift.String? = nil,
            peeringOptions: SecurityHubClientTypes.VpcInfoPeeringOptionsDetails? = nil,
            region: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.cidrBlock = cidrBlock
            self.cidrBlockSet = cidrBlockSet
            self.ipv6CidrBlockSet = ipv6CidrBlockSet
            self.ownerId = ownerId
            self.peeringOptions = peeringOptions
            self.region = region
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpnConnectionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case customerGatewayConfiguration = "CustomerGatewayConfiguration"
        case customerGatewayId = "CustomerGatewayId"
        case options = "Options"
        case routes = "Routes"
        case state = "State"
        case transitGatewayId = "TransitGatewayId"
        case type = "Type"
        case vgwTelemetry = "VgwTelemetry"
        case vpnConnectionId = "VpnConnectionId"
        case vpnGatewayId = "VpnGatewayId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let customerGatewayConfiguration = self.customerGatewayConfiguration {
            try encodeContainer.encode(customerGatewayConfiguration, forKey: .customerGatewayConfiguration)
        }
        if let customerGatewayId = self.customerGatewayId {
            try encodeContainer.encode(customerGatewayId, forKey: .customerGatewayId)
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let routes = routes {
            var routesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routes)
            for awsec2vpnconnectionroutesdetails0 in routes {
                try routesContainer.encode(awsec2vpnconnectionroutesdetails0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let transitGatewayId = self.transitGatewayId {
            try encodeContainer.encode(transitGatewayId, forKey: .transitGatewayId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vgwTelemetry = vgwTelemetry {
            var vgwTelemetryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vgwTelemetry)
            for awsec2vpnconnectionvgwtelemetrydetails0 in vgwTelemetry {
                try vgwTelemetryContainer.encode(awsec2vpnconnectionvgwtelemetrydetails0)
            }
        }
        if let vpnConnectionId = self.vpnConnectionId {
            try encodeContainer.encode(vpnConnectionId, forKey: .vpnConnectionId)
        }
        if let vpnGatewayId = self.vpnGatewayId {
            try encodeContainer.encode(vpnGatewayId, forKey: .vpnGatewayId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpnConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnConnectionId)
        vpnConnectionId = vpnConnectionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let customerGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerGatewayId)
        customerGatewayId = customerGatewayIdDecoded
        let customerGatewayConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerGatewayConfiguration)
        customerGatewayConfiguration = customerGatewayConfigurationDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vpnGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpnGatewayId)
        vpnGatewayId = vpnGatewayIdDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let vgwTelemetryContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails?].self, forKey: .vgwTelemetry)
        var vgwTelemetryDecoded0:[SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails]? = nil
        if let vgwTelemetryContainer = vgwTelemetryContainer {
            vgwTelemetryDecoded0 = [SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails]()
            for structure0 in vgwTelemetryContainer {
                if let structure0 = structure0 {
                    vgwTelemetryDecoded0?.append(structure0)
                }
            }
        }
        vgwTelemetry = vgwTelemetryDecoded0
        let optionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails.self, forKey: .options)
        options = optionsDecoded
        let routesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails?].self, forKey: .routes)
        var routesDecoded0:[SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails]? = nil
        if let routesContainer = routesContainer {
            routesDecoded0 = [SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails]()
            for structure0 in routesContainer {
                if let structure0 = structure0 {
                    routesDecoded0?.append(structure0)
                }
            }
        }
        routes = routesDecoded0
        let transitGatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitGatewayId)
        transitGatewayId = transitGatewayIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an Amazon EC2 VPN connection.
    public struct AwsEc2VpnConnectionDetails: Swift.Equatable {
        /// The category of the VPN connection. VPN indicates an Amazon Web Services VPN connection. VPN-Classic indicates an Amazon Web Services Classic VPN connection.
        public var category: Swift.String?
        /// The configuration information for the VPN connection's customer gateway, in the native XML format.
        public var customerGatewayConfiguration: Swift.String?
        /// The identifier of the customer gateway that is at your end of the VPN connection.
        public var customerGatewayId: Swift.String?
        /// The VPN connection options.
        public var options: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails?
        /// The static routes that are associated with the VPN connection.
        public var routes: [SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails]?
        /// The current state of the VPN connection. Valid values are as follows:
        ///
        /// * available
        ///
        /// * deleted
        ///
        /// * deleting
        ///
        /// * pending
        public var state: Swift.String?
        /// The identifier of the transit gateway that is associated with the VPN connection.
        public var transitGatewayId: Swift.String?
        /// The type of VPN connection.
        public var type: Swift.String?
        /// Information about the VPN tunnel.
        public var vgwTelemetry: [SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails]?
        /// The identifier of the VPN connection.
        public var vpnConnectionId: Swift.String?
        /// The identifier of the virtual private gateway that is at the Amazon Web Services side of the VPN connection.
        public var vpnGatewayId: Swift.String?

        public init (
            category: Swift.String? = nil,
            customerGatewayConfiguration: Swift.String? = nil,
            customerGatewayId: Swift.String? = nil,
            options: SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails? = nil,
            routes: [SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails]? = nil,
            state: Swift.String? = nil,
            transitGatewayId: Swift.String? = nil,
            type: Swift.String? = nil,
            vgwTelemetry: [SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails]? = nil,
            vpnConnectionId: Swift.String? = nil,
            vpnGatewayId: Swift.String? = nil
        )
        {
            self.category = category
            self.customerGatewayConfiguration = customerGatewayConfiguration
            self.customerGatewayId = customerGatewayId
            self.options = options
            self.routes = routes
            self.state = state
            self.transitGatewayId = transitGatewayId
            self.type = type
            self.vgwTelemetry = vgwTelemetry
            self.vpnConnectionId = vpnConnectionId
            self.vpnGatewayId = vpnGatewayId
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpnConnectionOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case staticRoutesOnly = "StaticRoutesOnly"
        case tunnelOptions = "TunnelOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if staticRoutesOnly != false {
            try encodeContainer.encode(staticRoutesOnly, forKey: .staticRoutesOnly)
        }
        if let tunnelOptions = tunnelOptions {
            var tunnelOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tunnelOptions)
            for awsec2vpnconnectionoptionstunneloptionsdetails0 in tunnelOptions {
                try tunnelOptionsContainer.encode(awsec2vpnconnectionoptionstunneloptionsdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let staticRoutesOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .staticRoutesOnly) ?? false
        staticRoutesOnly = staticRoutesOnlyDecoded
        let tunnelOptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails?].self, forKey: .tunnelOptions)
        var tunnelOptionsDecoded0:[SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails]? = nil
        if let tunnelOptionsContainer = tunnelOptionsContainer {
            tunnelOptionsDecoded0 = [SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails]()
            for structure0 in tunnelOptionsContainer {
                if let structure0 = structure0 {
                    tunnelOptionsDecoded0?.append(structure0)
                }
            }
        }
        tunnelOptions = tunnelOptionsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// VPN connection options.
    public struct AwsEc2VpnConnectionOptionsDetails: Swift.Equatable {
        /// Whether the VPN connection uses static routes only.
        public var staticRoutesOnly: Swift.Bool
        /// The VPN tunnel options.
        public var tunnelOptions: [SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails]?

        public init (
            staticRoutesOnly: Swift.Bool = false,
            tunnelOptions: [SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails]? = nil
        )
        {
            self.staticRoutesOnly = staticRoutesOnly
            self.tunnelOptions = tunnelOptions
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dpdTimeoutSeconds = "DpdTimeoutSeconds"
        case ikeVersions = "IkeVersions"
        case outsideIpAddress = "OutsideIpAddress"
        case phase1DhGroupNumbers = "Phase1DhGroupNumbers"
        case phase1EncryptionAlgorithms = "Phase1EncryptionAlgorithms"
        case phase1IntegrityAlgorithms = "Phase1IntegrityAlgorithms"
        case phase1LifetimeSeconds = "Phase1LifetimeSeconds"
        case phase2DhGroupNumbers = "Phase2DhGroupNumbers"
        case phase2EncryptionAlgorithms = "Phase2EncryptionAlgorithms"
        case phase2IntegrityAlgorithms = "Phase2IntegrityAlgorithms"
        case phase2LifetimeSeconds = "Phase2LifetimeSeconds"
        case preSharedKey = "PreSharedKey"
        case rekeyFuzzPercentage = "RekeyFuzzPercentage"
        case rekeyMarginTimeSeconds = "RekeyMarginTimeSeconds"
        case replayWindowSize = "ReplayWindowSize"
        case tunnelInsideCidr = "TunnelInsideCidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dpdTimeoutSeconds != 0 {
            try encodeContainer.encode(dpdTimeoutSeconds, forKey: .dpdTimeoutSeconds)
        }
        if let ikeVersions = ikeVersions {
            var ikeVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ikeVersions)
            for nonemptystring0 in ikeVersions {
                try ikeVersionsContainer.encode(nonemptystring0)
            }
        }
        if let outsideIpAddress = self.outsideIpAddress {
            try encodeContainer.encode(outsideIpAddress, forKey: .outsideIpAddress)
        }
        if let phase1DhGroupNumbers = phase1DhGroupNumbers {
            var phase1DhGroupNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase1DhGroupNumbers)
            for integer0 in phase1DhGroupNumbers {
                try phase1DhGroupNumbersContainer.encode(integer0)
            }
        }
        if let phase1EncryptionAlgorithms = phase1EncryptionAlgorithms {
            var phase1EncryptionAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase1EncryptionAlgorithms)
            for nonemptystring0 in phase1EncryptionAlgorithms {
                try phase1EncryptionAlgorithmsContainer.encode(nonemptystring0)
            }
        }
        if let phase1IntegrityAlgorithms = phase1IntegrityAlgorithms {
            var phase1IntegrityAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase1IntegrityAlgorithms)
            for nonemptystring0 in phase1IntegrityAlgorithms {
                try phase1IntegrityAlgorithmsContainer.encode(nonemptystring0)
            }
        }
        if phase1LifetimeSeconds != 0 {
            try encodeContainer.encode(phase1LifetimeSeconds, forKey: .phase1LifetimeSeconds)
        }
        if let phase2DhGroupNumbers = phase2DhGroupNumbers {
            var phase2DhGroupNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase2DhGroupNumbers)
            for integer0 in phase2DhGroupNumbers {
                try phase2DhGroupNumbersContainer.encode(integer0)
            }
        }
        if let phase2EncryptionAlgorithms = phase2EncryptionAlgorithms {
            var phase2EncryptionAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase2EncryptionAlgorithms)
            for nonemptystring0 in phase2EncryptionAlgorithms {
                try phase2EncryptionAlgorithmsContainer.encode(nonemptystring0)
            }
        }
        if let phase2IntegrityAlgorithms = phase2IntegrityAlgorithms {
            var phase2IntegrityAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase2IntegrityAlgorithms)
            for nonemptystring0 in phase2IntegrityAlgorithms {
                try phase2IntegrityAlgorithmsContainer.encode(nonemptystring0)
            }
        }
        if phase2LifetimeSeconds != 0 {
            try encodeContainer.encode(phase2LifetimeSeconds, forKey: .phase2LifetimeSeconds)
        }
        if let preSharedKey = self.preSharedKey {
            try encodeContainer.encode(preSharedKey, forKey: .preSharedKey)
        }
        if rekeyFuzzPercentage != 0 {
            try encodeContainer.encode(rekeyFuzzPercentage, forKey: .rekeyFuzzPercentage)
        }
        if rekeyMarginTimeSeconds != 0 {
            try encodeContainer.encode(rekeyMarginTimeSeconds, forKey: .rekeyMarginTimeSeconds)
        }
        if replayWindowSize != 0 {
            try encodeContainer.encode(replayWindowSize, forKey: .replayWindowSize)
        }
        if let tunnelInsideCidr = self.tunnelInsideCidr {
            try encodeContainer.encode(tunnelInsideCidr, forKey: .tunnelInsideCidr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dpdTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dpdTimeoutSeconds) ?? 0
        dpdTimeoutSeconds = dpdTimeoutSecondsDecoded
        let ikeVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ikeVersions)
        var ikeVersionsDecoded0:[Swift.String]? = nil
        if let ikeVersionsContainer = ikeVersionsContainer {
            ikeVersionsDecoded0 = [Swift.String]()
            for string0 in ikeVersionsContainer {
                if let string0 = string0 {
                    ikeVersionsDecoded0?.append(string0)
                }
            }
        }
        ikeVersions = ikeVersionsDecoded0
        let outsideIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outsideIpAddress)
        outsideIpAddress = outsideIpAddressDecoded
        let phase1DhGroupNumbersContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .phase1DhGroupNumbers)
        var phase1DhGroupNumbersDecoded0:[Swift.Int]? = nil
        if let phase1DhGroupNumbersContainer = phase1DhGroupNumbersContainer {
            phase1DhGroupNumbersDecoded0 = [Swift.Int]()
            for integer0 in phase1DhGroupNumbersContainer {
                if let integer0 = integer0 {
                    phase1DhGroupNumbersDecoded0?.append(integer0)
                }
            }
        }
        phase1DhGroupNumbers = phase1DhGroupNumbersDecoded0
        let phase1EncryptionAlgorithmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phase1EncryptionAlgorithms)
        var phase1EncryptionAlgorithmsDecoded0:[Swift.String]? = nil
        if let phase1EncryptionAlgorithmsContainer = phase1EncryptionAlgorithmsContainer {
            phase1EncryptionAlgorithmsDecoded0 = [Swift.String]()
            for string0 in phase1EncryptionAlgorithmsContainer {
                if let string0 = string0 {
                    phase1EncryptionAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        phase1EncryptionAlgorithms = phase1EncryptionAlgorithmsDecoded0
        let phase1IntegrityAlgorithmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phase1IntegrityAlgorithms)
        var phase1IntegrityAlgorithmsDecoded0:[Swift.String]? = nil
        if let phase1IntegrityAlgorithmsContainer = phase1IntegrityAlgorithmsContainer {
            phase1IntegrityAlgorithmsDecoded0 = [Swift.String]()
            for string0 in phase1IntegrityAlgorithmsContainer {
                if let string0 = string0 {
                    phase1IntegrityAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        phase1IntegrityAlgorithms = phase1IntegrityAlgorithmsDecoded0
        let phase1LifetimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .phase1LifetimeSeconds) ?? 0
        phase1LifetimeSeconds = phase1LifetimeSecondsDecoded
        let phase2DhGroupNumbersContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .phase2DhGroupNumbers)
        var phase2DhGroupNumbersDecoded0:[Swift.Int]? = nil
        if let phase2DhGroupNumbersContainer = phase2DhGroupNumbersContainer {
            phase2DhGroupNumbersDecoded0 = [Swift.Int]()
            for integer0 in phase2DhGroupNumbersContainer {
                if let integer0 = integer0 {
                    phase2DhGroupNumbersDecoded0?.append(integer0)
                }
            }
        }
        phase2DhGroupNumbers = phase2DhGroupNumbersDecoded0
        let phase2EncryptionAlgorithmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phase2EncryptionAlgorithms)
        var phase2EncryptionAlgorithmsDecoded0:[Swift.String]? = nil
        if let phase2EncryptionAlgorithmsContainer = phase2EncryptionAlgorithmsContainer {
            phase2EncryptionAlgorithmsDecoded0 = [Swift.String]()
            for string0 in phase2EncryptionAlgorithmsContainer {
                if let string0 = string0 {
                    phase2EncryptionAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        phase2EncryptionAlgorithms = phase2EncryptionAlgorithmsDecoded0
        let phase2IntegrityAlgorithmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phase2IntegrityAlgorithms)
        var phase2IntegrityAlgorithmsDecoded0:[Swift.String]? = nil
        if let phase2IntegrityAlgorithmsContainer = phase2IntegrityAlgorithmsContainer {
            phase2IntegrityAlgorithmsDecoded0 = [Swift.String]()
            for string0 in phase2IntegrityAlgorithmsContainer {
                if let string0 = string0 {
                    phase2IntegrityAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        phase2IntegrityAlgorithms = phase2IntegrityAlgorithmsDecoded0
        let phase2LifetimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .phase2LifetimeSeconds) ?? 0
        phase2LifetimeSeconds = phase2LifetimeSecondsDecoded
        let preSharedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSharedKey)
        preSharedKey = preSharedKeyDecoded
        let rekeyFuzzPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rekeyFuzzPercentage) ?? 0
        rekeyFuzzPercentage = rekeyFuzzPercentageDecoded
        let rekeyMarginTimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rekeyMarginTimeSeconds) ?? 0
        rekeyMarginTimeSeconds = rekeyMarginTimeSecondsDecoded
        let replayWindowSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replayWindowSize) ?? 0
        replayWindowSize = replayWindowSizeDecoded
        let tunnelInsideCidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelInsideCidr)
        tunnelInsideCidr = tunnelInsideCidrDecoded
    }
}

extension SecurityHubClientTypes {
    /// The VPN tunnel options.
    public struct AwsEc2VpnConnectionOptionsTunnelOptionsDetails: Swift.Equatable {
        /// The number of seconds after which a Dead Peer Detection (DPD) timeout occurs.
        public var dpdTimeoutSeconds: Swift.Int
        /// The Internet Key Exchange (IKE) versions that are permitted for the VPN tunnel.
        public var ikeVersions: [Swift.String]?
        /// The external IP address of the VPN tunnel.
        public var outsideIpAddress: Swift.String?
        /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.
        public var phase1DhGroupNumbers: [Swift.Int]?
        /// The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.
        public var phase1EncryptionAlgorithms: [Swift.String]?
        /// The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.
        public var phase1IntegrityAlgorithms: [Swift.String]?
        /// The lifetime for phase 1 of the IKE negotiation, in seconds.
        public var phase1LifetimeSeconds: Swift.Int
        /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.
        public var phase2DhGroupNumbers: [Swift.Int]?
        /// The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.
        public var phase2EncryptionAlgorithms: [Swift.String]?
        /// The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.
        public var phase2IntegrityAlgorithms: [Swift.String]?
        /// The lifetime for phase 2 of the IKE negotiation, in seconds.
        public var phase2LifetimeSeconds: Swift.Int
        /// The preshared key to establish initial authentication between the virtual private gateway and the customer gateway.
        public var preSharedKey: Swift.String?
        /// The percentage of the rekey window, which is determined by RekeyMarginTimeSeconds during which the rekey time is randomly selected.
        public var rekeyFuzzPercentage: Swift.Int
        /// The margin time, in seconds, before the phase 2 lifetime expires, during which the Amazon Web Services side of the VPN connection performs an IKE rekey.
        public var rekeyMarginTimeSeconds: Swift.Int
        /// The number of packets in an IKE replay window.
        public var replayWindowSize: Swift.Int
        /// The range of inside IPv4 addresses for the tunnel.
        public var tunnelInsideCidr: Swift.String?

        public init (
            dpdTimeoutSeconds: Swift.Int = 0,
            ikeVersions: [Swift.String]? = nil,
            outsideIpAddress: Swift.String? = nil,
            phase1DhGroupNumbers: [Swift.Int]? = nil,
            phase1EncryptionAlgorithms: [Swift.String]? = nil,
            phase1IntegrityAlgorithms: [Swift.String]? = nil,
            phase1LifetimeSeconds: Swift.Int = 0,
            phase2DhGroupNumbers: [Swift.Int]? = nil,
            phase2EncryptionAlgorithms: [Swift.String]? = nil,
            phase2IntegrityAlgorithms: [Swift.String]? = nil,
            phase2LifetimeSeconds: Swift.Int = 0,
            preSharedKey: Swift.String? = nil,
            rekeyFuzzPercentage: Swift.Int = 0,
            rekeyMarginTimeSeconds: Swift.Int = 0,
            replayWindowSize: Swift.Int = 0,
            tunnelInsideCidr: Swift.String? = nil
        )
        {
            self.dpdTimeoutSeconds = dpdTimeoutSeconds
            self.ikeVersions = ikeVersions
            self.outsideIpAddress = outsideIpAddress
            self.phase1DhGroupNumbers = phase1DhGroupNumbers
            self.phase1EncryptionAlgorithms = phase1EncryptionAlgorithms
            self.phase1IntegrityAlgorithms = phase1IntegrityAlgorithms
            self.phase1LifetimeSeconds = phase1LifetimeSeconds
            self.phase2DhGroupNumbers = phase2DhGroupNumbers
            self.phase2EncryptionAlgorithms = phase2EncryptionAlgorithms
            self.phase2IntegrityAlgorithms = phase2IntegrityAlgorithms
            self.phase2LifetimeSeconds = phase2LifetimeSeconds
            self.preSharedKey = preSharedKey
            self.rekeyFuzzPercentage = rekeyFuzzPercentage
            self.rekeyMarginTimeSeconds = rekeyMarginTimeSeconds
            self.replayWindowSize = replayWindowSize
            self.tunnelInsideCidr = tunnelInsideCidr
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpnConnectionRoutesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationCidrBlock = "DestinationCidrBlock"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationCidrBlock = self.destinationCidrBlock {
            try encodeContainer.encode(destinationCidrBlock, forKey: .destinationCidrBlock)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationCidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationCidrBlock)
        destinationCidrBlock = destinationCidrBlockDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

extension SecurityHubClientTypes {
    /// A static routes associated with the VPN connection.
    public struct AwsEc2VpnConnectionRoutesDetails: Swift.Equatable {
        /// The CIDR block associated with the local subnet of the customer data center.
        public var destinationCidrBlock: Swift.String?
        /// The current state of the static route.
        public var state: Swift.String?

        public init (
            destinationCidrBlock: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.destinationCidrBlock = destinationCidrBlock
            self.state = state
        }
    }

}

extension SecurityHubClientTypes.AwsEc2VpnConnectionVgwTelemetryDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedRouteCount = "AcceptedRouteCount"
        case certificateArn = "CertificateArn"
        case lastStatusChange = "LastStatusChange"
        case outsideIpAddress = "OutsideIpAddress"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if acceptedRouteCount != 0 {
            try encodeContainer.encode(acceptedRouteCount, forKey: .acceptedRouteCount)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let lastStatusChange = self.lastStatusChange {
            try encodeContainer.encode(lastStatusChange, forKey: .lastStatusChange)
        }
        if let outsideIpAddress = self.outsideIpAddress {
            try encodeContainer.encode(outsideIpAddress, forKey: .outsideIpAddress)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptedRouteCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceptedRouteCount) ?? 0
        acceptedRouteCount = acceptedRouteCountDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let lastStatusChangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastStatusChange)
        lastStatusChange = lastStatusChangeDecoded
        let outsideIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outsideIpAddress)
        outsideIpAddress = outsideIpAddressDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the VPN tunnel.
    public struct AwsEc2VpnConnectionVgwTelemetryDetails: Swift.Equatable {
        /// The number of accepted routes.
        public var acceptedRouteCount: Swift.Int
        /// The ARN of the VPN tunnel endpoint certificate.
        public var certificateArn: Swift.String?
        /// The date and time of the last change in status. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastStatusChange: Swift.String?
        /// The Internet-routable IP address of the virtual private gateway's outside interface.
        public var outsideIpAddress: Swift.String?
        /// The status of the VPN tunnel. Valid values are DOWN or UP.
        public var status: Swift.String?
        /// If an error occurs, a description of the error.
        public var statusMessage: Swift.String?

        public init (
            acceptedRouteCount: Swift.Int = 0,
            certificateArn: Swift.String? = nil,
            lastStatusChange: Swift.String? = nil,
            outsideIpAddress: Swift.String? = nil,
            status: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.acceptedRouteCount = acceptedRouteCount
            self.certificateArn = certificateArn
            self.lastStatusChange = lastStatusChange
            self.outsideIpAddress = outsideIpAddress
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension SecurityHubClientTypes.AwsEcrContainerImageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture = "Architecture"
        case imageDigest = "ImageDigest"
        case imagePublishedAt = "ImagePublishedAt"
        case imageTags = "ImageTags"
        case registryId = "RegistryId"
        case repositoryName = "RepositoryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imagePublishedAt = self.imagePublishedAt {
            try encodeContainer.encode(imagePublishedAt, forKey: .imagePublishedAt)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for nonemptystring0 in imageTags {
                try imageTagsContainer.encode(nonemptystring0)
            }
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imagePublishedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePublishedAt)
        imagePublishedAt = imagePublishedAtDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an Amazon ECR image.
    public struct AwsEcrContainerImageDetails: Swift.Equatable {
        /// The architecture of the image. Valid values are as follows:
        ///
        /// * arm64
        ///
        /// * i386
        ///
        /// * x86_64
        public var architecture: Swift.String?
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The date and time when the image was pushed to the repository. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var imagePublishedAt: Swift.String?
        /// The list of tags that are associated with the image.
        public var imageTags: [Swift.String]?
        /// The Amazon Web Services account identifier that is associated with the registry that the image belongs to.
        public var registryId: Swift.String?
        /// The name of the repository that the image belongs to.
        public var repositoryName: Swift.String?

        public init (
            architecture: Swift.String? = nil,
            imageDigest: Swift.String? = nil,
            imagePublishedAt: Swift.String? = nil,
            imageTags: [Swift.String]? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.imageDigest = imageDigest
            self.imagePublishedAt = imagePublishedAt
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension SecurityHubClientTypes.AwsEcrRepositoryDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case imageScanningConfiguration = "ImageScanningConfiguration"
        case imageTagMutability = "ImageTagMutability"
        case lifecyclePolicy = "LifecyclePolicy"
        case repositoryName = "RepositoryName"
        case repositoryPolicyText = "RepositoryPolicyText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let imageScanningConfiguration = self.imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTagMutability = self.imageTagMutability {
            try encodeContainer.encode(imageTagMutability, forKey: .imageTagMutability)
        }
        if let lifecyclePolicy = self.lifecyclePolicy {
            try encodeContainer.encode(lifecyclePolicy, forKey: .lifecyclePolicy)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryPolicyText = self.repositoryPolicyText {
            try encodeContainer.encode(repositoryPolicyText, forKey: .repositoryPolicyText)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
        let lifecyclePolicyDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails.self, forKey: .lifecyclePolicy)
        lifecyclePolicy = lifecyclePolicyDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryPolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryPolicyText)
        repositoryPolicyText = repositoryPolicyTextDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon Elastic Container Registry repository.
    public struct AwsEcrRepositoryDetails: Swift.Equatable {
        /// The ARN of the repository.
        public var arn: Swift.String?
        /// The image scanning configuration for a repository.
        public var imageScanningConfiguration: SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails?
        /// The tag mutability setting for the repository. Valid values are IMMUTABLE or MUTABLE.
        public var imageTagMutability: Swift.String?
        /// Information about the lifecycle policy for the repository.
        public var lifecyclePolicy: SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails?
        /// The name of the repository.
        public var repositoryName: Swift.String?
        /// The text of the repository policy.
        public var repositoryPolicyText: Swift.String?

        public init (
            arn: Swift.String? = nil,
            imageScanningConfiguration: SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails? = nil,
            imageTagMutability: Swift.String? = nil,
            lifecyclePolicy: SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails? = nil,
            repositoryName: Swift.String? = nil,
            repositoryPolicyText: Swift.String? = nil
        )
        {
            self.arn = arn
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.lifecyclePolicy = lifecyclePolicy
            self.repositoryName = repositoryName
            self.repositoryPolicyText = repositoryPolicyText
        }
    }

}

extension SecurityHubClientTypes.AwsEcrRepositoryImageScanningConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanOnPush = "ScanOnPush"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if scanOnPush != false {
            try encodeContainer.encode(scanOnPush, forKey: .scanOnPush)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanOnPushDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .scanOnPush) ?? false
        scanOnPush = scanOnPushDecoded
    }
}

extension SecurityHubClientTypes {
    /// The image scanning configuration for a repository.
    public struct AwsEcrRepositoryImageScanningConfigurationDetails: Swift.Equatable {
        /// Whether to scan images after they are pushed to a repository.
        public var scanOnPush: Swift.Bool

        public init (
            scanOnPush: Swift.Bool = false
        )
        {
            self.scanOnPush = scanOnPush
        }
    }

}

extension SecurityHubClientTypes.AwsEcrRepositoryLifecyclePolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText = "LifecyclePolicyText"
        case registryId = "RegistryId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicyText = self.lifecyclePolicyText {
            try encodeContainer.encode(lifecyclePolicyText, forKey: .lifecyclePolicyText)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the lifecycle policy for the repository.
    public struct AwsEcrRepositoryLifecyclePolicyDetails: Swift.Equatable {
        /// The text of the lifecycle policy.
        public var lifecyclePolicyText: Swift.String?
        /// The Amazon Web Services account identifier that is associated with the registry that contains the repository.
        public var registryId: Swift.String?

        public init (
            lifecyclePolicyText: Swift.String? = nil,
            registryId: Swift.String? = nil
        )
        {
            self.lifecyclePolicyText = lifecyclePolicyText
            self.registryId = registryId
        }
    }

}

extension SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// Indicates whether to enable CloudWatch Container Insights for the ECS cluster.
    public struct AwsEcsClusterClusterSettingsDetails: Swift.Equatable {
        /// The name of the setting. The valid value is containerInsights.
        public var name: Swift.String?
        /// The value of the setting. Valid values are disabled or enabled.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsEcsClusterConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executeCommandConfiguration = "ExecuteCommandConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executeCommandConfiguration = self.executeCommandConfiguration {
            try encodeContainer.encode(executeCommandConfiguration, forKey: .executeCommandConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executeCommandConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails.self, forKey: .executeCommandConfiguration)
        executeCommandConfiguration = executeCommandConfigurationDecoded
    }
}

extension SecurityHubClientTypes {
    /// The run command configuration for the cluster.
    public struct AwsEcsClusterConfigurationDetails: Swift.Equatable {
        /// Contains the run command configuration for the cluster.
        public var executeCommandConfiguration: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails?

        public init (
            executeCommandConfiguration: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails? = nil
        )
        {
            self.executeCommandConfiguration = executeCommandConfiguration
        }
    }

}

extension SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case logConfiguration = "LogConfiguration"
        case logging = "Logging"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logConfiguration = self.logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logging)
        logging = loggingDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains the run command configuration for the cluster.
    public struct AwsEcsClusterConfigurationExecuteCommandConfigurationDetails: Swift.Equatable {
        /// The identifier of the KMS key that is used to encrypt the data between the local client and the container.
        public var kmsKeyId: Swift.String?
        /// The log configuration for the results of the run command actions. Required if Logging is NONE.
        public var logConfiguration: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails?
        /// The log setting to use for redirecting logs for run command results.
        public var logging: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            logConfiguration: SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails? = nil,
            logging: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.logConfiguration = logConfiguration
            self.logging = logging
        }
    }

}

extension SecurityHubClientTypes.AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchEncryptionEnabled = "CloudWatchEncryptionEnabled"
        case cloudWatchLogGroupName = "CloudWatchLogGroupName"
        case s3BucketName = "S3BucketName"
        case s3EncryptionEnabled = "S3EncryptionEnabled"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cloudWatchEncryptionEnabled != false {
            try encodeContainer.encode(cloudWatchEncryptionEnabled, forKey: .cloudWatchEncryptionEnabled)
        }
        if let cloudWatchLogGroupName = self.cloudWatchLogGroupName {
            try encodeContainer.encode(cloudWatchLogGroupName, forKey: .cloudWatchLogGroupName)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if s3EncryptionEnabled != false {
            try encodeContainer.encode(s3EncryptionEnabled, forKey: .s3EncryptionEnabled)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudWatchEncryptionEnabled) ?? false
        cloudWatchEncryptionEnabled = cloudWatchEncryptionEnabledDecoded
        let cloudWatchLogGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupName)
        cloudWatchLogGroupName = cloudWatchLogGroupNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3EncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .s3EncryptionEnabled) ?? false
        s3EncryptionEnabled = s3EncryptionEnabledDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
    }
}

extension SecurityHubClientTypes {
    /// The log configuration for the results of the run command actions.
    public struct AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails: Swift.Equatable {
        /// Whether to enable encryption on the CloudWatch logs.
        public var cloudWatchEncryptionEnabled: Swift.Bool
        /// The name of the CloudWatch log group to send the logs to.
        public var cloudWatchLogGroupName: Swift.String?
        /// The name of the S3 bucket to send logs to.
        public var s3BucketName: Swift.String?
        /// Whether to encrypt the logs that are sent to the S3 bucket.
        public var s3EncryptionEnabled: Swift.Bool
        /// Identifies the folder in the S3 bucket to send the logs to.
        public var s3KeyPrefix: Swift.String?

        public init (
            cloudWatchEncryptionEnabled: Swift.Bool = false,
            cloudWatchLogGroupName: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3EncryptionEnabled: Swift.Bool = false,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.cloudWatchEncryptionEnabled = cloudWatchEncryptionEnabled
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.s3BucketName = s3BucketName
            self.s3EncryptionEnabled = s3EncryptionEnabled
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base = "Base"
        case capacityProvider = "CapacityProvider"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if base != 0 {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let capacityProvider = self.capacityProvider {
            try encodeContainer.encode(capacityProvider, forKey: .capacityProvider)
        }
        if weight != 0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .base) ?? 0
        base = baseDecoded
        let capacityProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityProvider)
        capacityProvider = capacityProviderDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight) ?? 0
        weight = weightDecoded
    }
}

extension SecurityHubClientTypes {
    /// The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.
    public struct AwsEcsClusterDefaultCapacityProviderStrategyDetails: Swift.Equatable {
        /// The minimum number of tasks to run on the specified capacity provider.
        public var base: Swift.Int
        /// The name of the capacity provider.
        public var capacityProvider: Swift.String?
        /// The relative percentage of the total number of tasks launched that should use the capacity provider.
        public var weight: Swift.Int

        public init (
            base: Swift.Int = 0,
            capacityProvider: Swift.String? = nil,
            weight: Swift.Int = 0
        )
        {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }
    }

}

extension SecurityHubClientTypes.AwsEcsClusterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeServicesCount = "ActiveServicesCount"
        case capacityProviders = "CapacityProviders"
        case clusterArn = "ClusterArn"
        case clusterName = "ClusterName"
        case clusterSettings = "ClusterSettings"
        case configuration = "Configuration"
        case defaultCapacityProviderStrategy = "DefaultCapacityProviderStrategy"
        case registeredContainerInstancesCount = "RegisteredContainerInstancesCount"
        case runningTasksCount = "RunningTasksCount"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeServicesCount != 0 {
            try encodeContainer.encode(activeServicesCount, forKey: .activeServicesCount)
        }
        if let capacityProviders = capacityProviders {
            var capacityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capacityProviders)
            for nonemptystring0 in capacityProviders {
                try capacityProvidersContainer.encode(nonemptystring0)
            }
        }
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let clusterSettings = clusterSettings {
            var clusterSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterSettings)
            for awsecsclusterclustersettingsdetails0 in clusterSettings {
                try clusterSettingsContainer.encode(awsecsclusterclustersettingsdetails0)
            }
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let defaultCapacityProviderStrategy = defaultCapacityProviderStrategy {
            var defaultCapacityProviderStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultCapacityProviderStrategy)
            for awsecsclusterdefaultcapacityproviderstrategydetails0 in defaultCapacityProviderStrategy {
                try defaultCapacityProviderStrategyContainer.encode(awsecsclusterdefaultcapacityproviderstrategydetails0)
            }
        }
        if registeredContainerInstancesCount != 0 {
            try encodeContainer.encode(registeredContainerInstancesCount, forKey: .registeredContainerInstancesCount)
        }
        if runningTasksCount != 0 {
            try encodeContainer.encode(runningTasksCount, forKey: .runningTasksCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let activeServicesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeServicesCount) ?? 0
        activeServicesCount = activeServicesCountDecoded
        let capacityProvidersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capacityProviders)
        var capacityProvidersDecoded0:[Swift.String]? = nil
        if let capacityProvidersContainer = capacityProvidersContainer {
            capacityProvidersDecoded0 = [Swift.String]()
            for string0 in capacityProvidersContainer {
                if let string0 = string0 {
                    capacityProvidersDecoded0?.append(string0)
                }
            }
        }
        capacityProviders = capacityProvidersDecoded0
        let clusterSettingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails?].self, forKey: .clusterSettings)
        var clusterSettingsDecoded0:[SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails]? = nil
        if let clusterSettingsContainer = clusterSettingsContainer {
            clusterSettingsDecoded0 = [SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails]()
            for structure0 in clusterSettingsContainer {
                if let structure0 = structure0 {
                    clusterSettingsDecoded0?.append(structure0)
                }
            }
        }
        clusterSettings = clusterSettingsDecoded0
        let configurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsClusterConfigurationDetails.self, forKey: .configuration)
        configuration = configurationDecoded
        let defaultCapacityProviderStrategyContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails?].self, forKey: .defaultCapacityProviderStrategy)
        var defaultCapacityProviderStrategyDecoded0:[SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails]? = nil
        if let defaultCapacityProviderStrategyContainer = defaultCapacityProviderStrategyContainer {
            defaultCapacityProviderStrategyDecoded0 = [SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails]()
            for structure0 in defaultCapacityProviderStrategyContainer {
                if let structure0 = structure0 {
                    defaultCapacityProviderStrategyDecoded0?.append(structure0)
                }
            }
        }
        defaultCapacityProviderStrategy = defaultCapacityProviderStrategyDecoded0
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let registeredContainerInstancesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registeredContainerInstancesCount) ?? 0
        registeredContainerInstancesCount = registeredContainerInstancesCountDecoded
        let runningTasksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningTasksCount) ?? 0
        runningTasksCount = runningTasksCountDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon ECS cluster.
    public struct AwsEcsClusterDetails: Swift.Equatable {
        /// The number of services that are running on the cluster in an ACTIVE state. You can view these services with the Amazon ECS [ListServices](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListServices.html) API operation.
        public var activeServicesCount: Swift.Int
        /// The short name of one or more capacity providers to associate with the cluster.
        public var capacityProviders: [Swift.String]?
        /// The Amazon Resource Name (ARN) that identifies the cluster.
        public var clusterArn: Swift.String?
        /// A name that you use to identify your cluster.
        public var clusterName: Swift.String?
        /// The setting to use to create the cluster. Specifically used to configure whether to enable CloudWatch Container Insights for the cluster.
        public var clusterSettings: [SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails]?
        /// The run command configuration for the cluster.
        public var configuration: SecurityHubClientTypes.AwsEcsClusterConfigurationDetails?
        /// The default capacity provider strategy for the cluster. The default capacity provider strategy is used when services or tasks are run without a specified launch type or capacity provider strategy.
        public var defaultCapacityProviderStrategy: [SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails]?
        /// The number of container instances registered into the cluster. This includes container instances in both ACTIVE and DRAINING status.
        public var registeredContainerInstancesCount: Swift.Int
        /// The number of tasks in the cluster that are in the RUNNING state.
        public var runningTasksCount: Swift.Int
        /// The status of the cluster.
        public var status: Swift.String?

        public init (
            activeServicesCount: Swift.Int = 0,
            capacityProviders: [Swift.String]? = nil,
            clusterArn: Swift.String? = nil,
            clusterName: Swift.String? = nil,
            clusterSettings: [SecurityHubClientTypes.AwsEcsClusterClusterSettingsDetails]? = nil,
            configuration: SecurityHubClientTypes.AwsEcsClusterConfigurationDetails? = nil,
            defaultCapacityProviderStrategy: [SecurityHubClientTypes.AwsEcsClusterDefaultCapacityProviderStrategyDetails]? = nil,
            registeredContainerInstancesCount: Swift.Int = 0,
            runningTasksCount: Swift.Int = 0,
            status: Swift.String? = nil
        )
        {
            self.activeServicesCount = activeServicesCount
            self.capacityProviders = capacityProviders
            self.clusterArn = clusterArn
            self.clusterName = clusterName
            self.clusterSettings = clusterSettings
            self.configuration = configuration
            self.defaultCapacityProviderStrategy = defaultCapacityProviderStrategy
            self.registeredContainerInstancesCount = registeredContainerInstancesCount
            self.runningTasksCount = runningTasksCount
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsEcsContainerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image = "Image"
        case mountPoints = "MountPoints"
        case name = "Name"
        case privileged = "Privileged"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let mountPoints = mountPoints {
            var mountPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mountPoints)
            for awsmountpoint0 in mountPoints {
                try mountPointsContainer.encode(awsmountpoint0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if privileged != false {
            try encodeContainer.encode(privileged, forKey: .privileged)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let mountPointsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsMountPoint?].self, forKey: .mountPoints)
        var mountPointsDecoded0:[SecurityHubClientTypes.AwsMountPoint]? = nil
        if let mountPointsContainer = mountPointsContainer {
            mountPointsDecoded0 = [SecurityHubClientTypes.AwsMountPoint]()
            for structure0 in mountPointsContainer {
                if let structure0 = structure0 {
                    mountPointsDecoded0?.append(structure0)
                }
            }
        }
        mountPoints = mountPointsDecoded0
        let privilegedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privileged) ?? false
        privileged = privilegedDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon ECS container.
    public struct AwsEcsContainerDetails: Swift.Equatable {
        /// The image used for the container.
        public var image: Swift.String?
        /// The mount points for data volumes in your container.
        public var mountPoints: [SecurityHubClientTypes.AwsMountPoint]?
        /// The name of the container.
        public var name: Swift.String?
        /// When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user).
        public var privileged: Swift.Bool

        public init (
            image: Swift.String? = nil,
            mountPoints: [SecurityHubClientTypes.AwsMountPoint]? = nil,
            name: Swift.String? = nil,
            privileged: Swift.Bool = false
        )
        {
            self.image = image
            self.mountPoints = mountPoints
            self.name = name
            self.privileged = privileged
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case base = "Base"
        case capacityProvider = "CapacityProvider"
        case weight = "Weight"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if base != 0 {
            try encodeContainer.encode(base, forKey: .base)
        }
        if let capacityProvider = self.capacityProvider {
            try encodeContainer.encode(capacityProvider, forKey: .capacityProvider)
        }
        if weight != 0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .base) ?? 0
        base = baseDecoded
        let capacityProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityProvider)
        capacityProvider = capacityProviderDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight) ?? 0
        weight = weightDecoded
    }
}

extension SecurityHubClientTypes {
    /// Strategy item for the capacity provider strategy that the service uses.
    public struct AwsEcsServiceCapacityProviderStrategyDetails: Swift.Equatable {
        /// The minimum number of tasks to run on the capacity provider. Only one strategy item can specify a value for Base. The value must be between 0 and 100000.
        public var base: Swift.Int
        /// The short name of the capacity provider.
        public var capacityProvider: Swift.String?
        /// The relative percentage of the total number of tasks that should use the capacity provider. If no weight is specified, the default value is 0. At least one capacity provider must have a weight greater than 0. The value can be between 0 and 1000.
        public var weight: Swift.Int

        public init (
            base: Swift.Int = 0,
            capacityProvider: Swift.String? = nil,
            weight: Swift.Int = 0
        )
        {
            self.base = base
            self.capacityProvider = capacityProvider
            self.weight = weight
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enable = "Enable"
        case rollback = "Rollback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if rollback != false {
            try encodeContainer.encode(rollback, forKey: .rollback)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable) ?? false
        enable = enableDecoded
        let rollbackDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rollback) ?? false
        rollback = rollbackDecoded
    }
}

extension SecurityHubClientTypes {
    /// Determines whether a service deployment fails if a service cannot reach a steady state.
    public struct AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails: Swift.Equatable {
        /// Whether to enable the deployment circuit breaker logic for the service.
        public var enable: Swift.Bool
        /// Whether to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
        public var rollback: Swift.Bool

        public init (
            enable: Swift.Bool = false,
            rollback: Swift.Bool = false
        )
        {
            self.enable = enable
            self.rollback = rollback
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentCircuitBreaker = "DeploymentCircuitBreaker"
        case maximumPercent = "MaximumPercent"
        case minimumHealthyPercent = "MinimumHealthyPercent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentCircuitBreaker = self.deploymentCircuitBreaker {
            try encodeContainer.encode(deploymentCircuitBreaker, forKey: .deploymentCircuitBreaker)
        }
        if maximumPercent != 0 {
            try encodeContainer.encode(maximumPercent, forKey: .maximumPercent)
        }
        if minimumHealthyPercent != 0 {
            try encodeContainer.encode(minimumHealthyPercent, forKey: .minimumHealthyPercent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentCircuitBreakerDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails.self, forKey: .deploymentCircuitBreaker)
        deploymentCircuitBreaker = deploymentCircuitBreakerDecoded
        let maximumPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumPercent) ?? 0
        maximumPercent = maximumPercentDecoded
        let minimumHealthyPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumHealthyPercent) ?? 0
        minimumHealthyPercent = minimumHealthyPercentDecoded
    }
}

extension SecurityHubClientTypes {
    /// Optional deployment parameters for the service.
    public struct AwsEcsServiceDeploymentConfigurationDetails: Swift.Equatable {
        /// Determines whether a service deployment fails if a service cannot reach a steady state.
        public var deploymentCircuitBreaker: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails?
        /// For a service that uses the rolling update (ECS) deployment type, the maximum number of tasks in a service that are allowed in the RUNNING or PENDING state during a deployment, and for tasks that use the EC2 launch type, when any container instances are in the DRAINING state. Provided as a percentage of the desired number of tasks. The default value is 200%. For a service that uses the blue/green (CODE_DEPLOY) or EXTERNAL deployment types, and tasks that use the EC2 launch type, the maximum number of tasks in the service that remain in the RUNNING state while the container instances are in the DRAINING state. For the Fargate launch type, the maximum percent value is not used.
        public var maximumPercent: Swift.Int
        /// For a service that uses the rolling update (ECS) deployment type, the minimum number of tasks in a service that must remain in the RUNNING state during a deployment, and while any container instances are in the DRAINING state if the service contains tasks using the EC2 launch type. Expressed as a percentage of the desired number of tasks. The default value is 100%. For a service that uses the blue/green (CODE_DEPLOY) or EXTERNAL deployment types and tasks that use the EC2 launch type, the minimum number of the tasks in the service that remain in the RUNNING state while the container instances are in the DRAINING state. For the Fargate launch type, the minimum healthy percent value is not used.
        public var minimumHealthyPercent: Swift.Int

        public init (
            deploymentCircuitBreaker: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails? = nil,
            maximumPercent: Swift.Int = 0,
            minimumHealthyPercent: Swift.Int = 0
        )
        {
            self.deploymentCircuitBreaker = deploymentCircuitBreaker
            self.maximumPercent = maximumPercent
            self.minimumHealthyPercent = minimumHealthyPercent
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the deployment controller type that the service uses.
    public struct AwsEcsServiceDeploymentControllerDetails: Swift.Equatable {
        /// The rolling update (ECS) deployment type replaces the current running version of the container with the latest version. The blue/green (CODE_DEPLOY) deployment type uses the blue/green deployment model that is powered by CodeDeploy. This deployment model a new deployment of a service can be verified before production traffic is sent to it. The external (EXTERNAL) deployment type allows the use of any third-party deployment controller for full control over the deployment process for an Amazon ECS service. Valid values: ECS | CODE_DEPLOY | EXTERNAL
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServiceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacityProviderStrategy = "CapacityProviderStrategy"
        case cluster = "Cluster"
        case deploymentConfiguration = "DeploymentConfiguration"
        case deploymentController = "DeploymentController"
        case desiredCount = "DesiredCount"
        case enableEcsManagedTags = "EnableEcsManagedTags"
        case enableExecuteCommand = "EnableExecuteCommand"
        case healthCheckGracePeriodSeconds = "HealthCheckGracePeriodSeconds"
        case launchType = "LaunchType"
        case loadBalancers = "LoadBalancers"
        case name = "Name"
        case networkConfiguration = "NetworkConfiguration"
        case placementConstraints = "PlacementConstraints"
        case placementStrategies = "PlacementStrategies"
        case platformVersion = "PlatformVersion"
        case propagateTags = "PropagateTags"
        case role = "Role"
        case schedulingStrategy = "SchedulingStrategy"
        case serviceArn = "ServiceArn"
        case serviceName = "ServiceName"
        case serviceRegistries = "ServiceRegistries"
        case taskDefinition = "TaskDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacityProviderStrategy = capacityProviderStrategy {
            var capacityProviderStrategyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capacityProviderStrategy)
            for awsecsservicecapacityproviderstrategydetails0 in capacityProviderStrategy {
                try capacityProviderStrategyContainer.encode(awsecsservicecapacityproviderstrategydetails0)
            }
        }
        if let cluster = self.cluster {
            try encodeContainer.encode(cluster, forKey: .cluster)
        }
        if let deploymentConfiguration = self.deploymentConfiguration {
            try encodeContainer.encode(deploymentConfiguration, forKey: .deploymentConfiguration)
        }
        if let deploymentController = self.deploymentController {
            try encodeContainer.encode(deploymentController, forKey: .deploymentController)
        }
        if desiredCount != 0 {
            try encodeContainer.encode(desiredCount, forKey: .desiredCount)
        }
        if enableEcsManagedTags != false {
            try encodeContainer.encode(enableEcsManagedTags, forKey: .enableEcsManagedTags)
        }
        if enableExecuteCommand != false {
            try encodeContainer.encode(enableExecuteCommand, forKey: .enableExecuteCommand)
        }
        if healthCheckGracePeriodSeconds != 0 {
            try encodeContainer.encode(healthCheckGracePeriodSeconds, forKey: .healthCheckGracePeriodSeconds)
        }
        if let launchType = self.launchType {
            try encodeContainer.encode(launchType, forKey: .launchType)
        }
        if let loadBalancers = loadBalancers {
            var loadBalancersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loadBalancers)
            for awsecsserviceloadbalancersdetails0 in loadBalancers {
                try loadBalancersContainer.encode(awsecsserviceloadbalancersdetails0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let placementConstraints = placementConstraints {
            var placementConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementConstraints)
            for awsecsserviceplacementconstraintsdetails0 in placementConstraints {
                try placementConstraintsContainer.encode(awsecsserviceplacementconstraintsdetails0)
            }
        }
        if let placementStrategies = placementStrategies {
            var placementStrategiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementStrategies)
            for awsecsserviceplacementstrategiesdetails0 in placementStrategies {
                try placementStrategiesContainer.encode(awsecsserviceplacementstrategiesdetails0)
            }
        }
        if let platformVersion = self.platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let propagateTags = self.propagateTags {
            try encodeContainer.encode(propagateTags, forKey: .propagateTags)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let schedulingStrategy = self.schedulingStrategy {
            try encodeContainer.encode(schedulingStrategy, forKey: .schedulingStrategy)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceRegistries = serviceRegistries {
            var serviceRegistriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceRegistries)
            for awsecsserviceserviceregistriesdetails0 in serviceRegistries {
                try serviceRegistriesContainer.encode(awsecsserviceserviceregistriesdetails0)
            }
        }
        if let taskDefinition = self.taskDefinition {
            try encodeContainer.encode(taskDefinition, forKey: .taskDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityProviderStrategyContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails?].self, forKey: .capacityProviderStrategy)
        var capacityProviderStrategyDecoded0:[SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails]? = nil
        if let capacityProviderStrategyContainer = capacityProviderStrategyContainer {
            capacityProviderStrategyDecoded0 = [SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails]()
            for structure0 in capacityProviderStrategyContainer {
                if let structure0 = structure0 {
                    capacityProviderStrategyDecoded0?.append(structure0)
                }
            }
        }
        capacityProviderStrategy = capacityProviderStrategyDecoded0
        let clusterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cluster)
        cluster = clusterDecoded
        let deploymentConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails.self, forKey: .deploymentConfiguration)
        deploymentConfiguration = deploymentConfigurationDecoded
        let deploymentControllerDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails.self, forKey: .deploymentController)
        deploymentController = deploymentControllerDecoded
        let desiredCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredCount) ?? 0
        desiredCount = desiredCountDecoded
        let enableEcsManagedTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableEcsManagedTags) ?? false
        enableEcsManagedTags = enableEcsManagedTagsDecoded
        let enableExecuteCommandDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableExecuteCommand) ?? false
        enableExecuteCommand = enableExecuteCommandDecoded
        let healthCheckGracePeriodSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckGracePeriodSeconds) ?? 0
        healthCheckGracePeriodSeconds = healthCheckGracePeriodSecondsDecoded
        let launchTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchType)
        launchType = launchTypeDecoded
        let loadBalancersContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails?].self, forKey: .loadBalancers)
        var loadBalancersDecoded0:[SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails]? = nil
        if let loadBalancersContainer = loadBalancersContainer {
            loadBalancersDecoded0 = [SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails]()
            for structure0 in loadBalancersContainer {
                if let structure0 = structure0 {
                    loadBalancersDecoded0?.append(structure0)
                }
            }
        }
        loadBalancers = loadBalancersDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let placementConstraintsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails?].self, forKey: .placementConstraints)
        var placementConstraintsDecoded0:[SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails]? = nil
        if let placementConstraintsContainer = placementConstraintsContainer {
            placementConstraintsDecoded0 = [SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails]()
            for structure0 in placementConstraintsContainer {
                if let structure0 = structure0 {
                    placementConstraintsDecoded0?.append(structure0)
                }
            }
        }
        placementConstraints = placementConstraintsDecoded0
        let placementStrategiesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails?].self, forKey: .placementStrategies)
        var placementStrategiesDecoded0:[SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails]? = nil
        if let placementStrategiesContainer = placementStrategiesContainer {
            placementStrategiesDecoded0 = [SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails]()
            for structure0 in placementStrategiesContainer {
                if let structure0 = structure0 {
                    placementStrategiesDecoded0?.append(structure0)
                }
            }
        }
        placementStrategies = placementStrategiesDecoded0
        let platformVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let propagateTagsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propagateTags)
        propagateTags = propagateTagsDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let schedulingStrategyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schedulingStrategy)
        schedulingStrategy = schedulingStrategyDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceRegistriesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails?].self, forKey: .serviceRegistries)
        var serviceRegistriesDecoded0:[SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails]? = nil
        if let serviceRegistriesContainer = serviceRegistriesContainer {
            serviceRegistriesDecoded0 = [SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails]()
            for structure0 in serviceRegistriesContainer {
                if let structure0 = structure0 {
                    serviceRegistriesDecoded0?.append(structure0)
                }
            }
        }
        serviceRegistries = serviceRegistriesDecoded0
        let taskDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskDefinition)
        taskDefinition = taskDefinitionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about a service within an ECS cluster.
    public struct AwsEcsServiceDetails: Swift.Equatable {
        /// The capacity provider strategy that the service uses.
        public var capacityProviderStrategy: [SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails]?
        /// The ARN of the cluster that hosts the service.
        public var cluster: Swift.String?
        /// Deployment parameters for the service. Includes the number of tasks that run and the order in which to start and stop tasks.
        public var deploymentConfiguration: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails?
        /// Contains the deployment controller type that the service uses.
        public var deploymentController: SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails?
        /// The number of instantiations of the task definition to run on the service.
        public var desiredCount: Swift.Int
        /// Whether to enable Amazon ECS managed tags for the tasks in the service.
        public var enableEcsManagedTags: Swift.Bool
        /// Whether the execute command functionality is enabled for the service.
        public var enableExecuteCommand: Swift.Bool
        /// After a task starts, the amount of time in seconds that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks.
        public var healthCheckGracePeriodSeconds: Swift.Int
        /// The launch type that the service uses. Valid values: EC2 | FARGATE | EXTERNAL
        public var launchType: Swift.String?
        /// Information about the load balancers that the service uses.
        public var loadBalancers: [SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails]?
        /// The name of the service.
        public var name: Swift.String?
        /// For tasks that use the awsvpc networking mode, the VPC subnet and security group configuration.
        public var networkConfiguration: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails?
        /// The placement constraints for the tasks in the service.
        public var placementConstraints: [SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails]?
        /// Information about how tasks for the service are placed.
        public var placementStrategies: [SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails]?
        /// The platform version on which to run the service. Only specified for tasks that are hosted on Fargate. If a platform version is not specified, the LATEST platform version is used by default.
        public var platformVersion: Swift.String?
        /// Indicates whether to propagate the tags from the task definition to the task or from the service to the task. If no value is provided, then tags are not propagated. Valid values: TASK_DEFINITION | SERVICE
        public var propagateTags: Swift.String?
        /// The ARN of the IAM role that is associated with the service. The role allows the Amazon ECS container agent to register container instances with an Elastic Load Balancing load balancer.
        public var role: Swift.String?
        /// The scheduling strategy to use for the service. The REPLICA scheduling strategy places and maintains the desired number of tasks across the cluster. By default, the service scheduler spreads tasks across Availability Zones. Task placement strategies and constraints are used to customize task placement decisions. The DAEMON scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that are specified in the cluster. The service scheduler also evaluates the task placement constraints for running tasks and stops tasks that do not meet the placement constraints. Valid values: REPLICA | DAEMON
        public var schedulingStrategy: Swift.String?
        /// The ARN of the service.
        public var serviceArn: Swift.String?
        /// The name of the service. The name can contain up to 255 characters. It can use letters, numbers, underscores, and hyphens.
        public var serviceName: Swift.String?
        /// Information about the service discovery registries to assign to the service.
        public var serviceRegistries: [SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails]?
        /// The task definition to use for tasks in the service.
        public var taskDefinition: Swift.String?

        public init (
            capacityProviderStrategy: [SecurityHubClientTypes.AwsEcsServiceCapacityProviderStrategyDetails]? = nil,
            cluster: Swift.String? = nil,
            deploymentConfiguration: SecurityHubClientTypes.AwsEcsServiceDeploymentConfigurationDetails? = nil,
            deploymentController: SecurityHubClientTypes.AwsEcsServiceDeploymentControllerDetails? = nil,
            desiredCount: Swift.Int = 0,
            enableEcsManagedTags: Swift.Bool = false,
            enableExecuteCommand: Swift.Bool = false,
            healthCheckGracePeriodSeconds: Swift.Int = 0,
            launchType: Swift.String? = nil,
            loadBalancers: [SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails]? = nil,
            name: Swift.String? = nil,
            networkConfiguration: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails? = nil,
            placementConstraints: [SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails]? = nil,
            placementStrategies: [SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails]? = nil,
            platformVersion: Swift.String? = nil,
            propagateTags: Swift.String? = nil,
            role: Swift.String? = nil,
            schedulingStrategy: Swift.String? = nil,
            serviceArn: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceRegistries: [SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails]? = nil,
            taskDefinition: Swift.String? = nil
        )
        {
            self.capacityProviderStrategy = capacityProviderStrategy
            self.cluster = cluster
            self.deploymentConfiguration = deploymentConfiguration
            self.deploymentController = deploymentController
            self.desiredCount = desiredCount
            self.enableEcsManagedTags = enableEcsManagedTags
            self.enableExecuteCommand = enableExecuteCommand
            self.healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds
            self.launchType = launchType
            self.loadBalancers = loadBalancers
            self.name = name
            self.networkConfiguration = networkConfiguration
            self.placementConstraints = placementConstraints
            self.placementStrategies = placementStrategies
            self.platformVersion = platformVersion
            self.propagateTags = propagateTags
            self.role = role
            self.schedulingStrategy = schedulingStrategy
            self.serviceArn = serviceArn
            self.serviceName = serviceName
            self.serviceRegistries = serviceRegistries
            self.taskDefinition = taskDefinition
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServiceLoadBalancersDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case containerPort = "ContainerPort"
        case loadBalancerName = "LoadBalancerName"
        case targetGroupArn = "TargetGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if containerPort != 0 {
            try encodeContainer.encode(containerPort, forKey: .containerPort)
        }
        if let loadBalancerName = self.loadBalancerName {
            try encodeContainer.encode(loadBalancerName, forKey: .loadBalancerName)
        }
        if let targetGroupArn = self.targetGroupArn {
            try encodeContainer.encode(targetGroupArn, forKey: .targetGroupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let containerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .containerPort) ?? 0
        containerPort = containerPortDecoded
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a load balancer that the service uses.
    public struct AwsEcsServiceLoadBalancersDetails: Swift.Equatable {
        /// The name of the container to associate with the load balancer.
        public var containerName: Swift.String?
        /// The port on the container to associate with the load balancer. This port must correspond to a containerPort in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the hostPort of the port mapping.
        public var containerPort: Swift.Int
        /// The name of the load balancer to associate with the Amazon ECS service or task set. Only specified when using a Classic Load Balancer. For an Application Load Balancer or a Network Load Balancer, the load balancer name is omitted.
        public var loadBalancerName: Swift.String?
        /// The ARN of the Elastic Load Balancing target group or groups associated with a service or task set. Only specified when using an Application Load Balancer or a Network Load Balancer. For a Classic Load Balancer, the target group ARN is omitted.
        public var targetGroupArn: Swift.String?

        public init (
            containerName: Swift.String? = nil,
            containerPort: Swift.Int = 0,
            loadBalancerName: Swift.String? = nil,
            targetGroupArn: Swift.String? = nil
        )
        {
            self.containerName = containerName
            self.containerPort = containerPort
            self.loadBalancerName = loadBalancerName
            self.targetGroupArn = targetGroupArn
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignPublicIp = "AssignPublicIp"
        case securityGroups = "SecurityGroups"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignPublicIp = self.assignPublicIp {
            try encodeContainer.encode(assignPublicIp, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for nonemptystring0 in securityGroups {
                try securityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for nonemptystring0 in subnets {
                try subnetsContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignPublicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignPublicIp)
        assignPublicIp = assignPublicIpDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// For tasks that use the awsvpc networking mode, the VPC subnet and security group configuration.
    public struct AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails: Swift.Equatable {
        /// Whether the task's elastic network interface receives a public IP address. The default value is DISABLED. Valid values: ENABLED | DISABLED
        public var assignPublicIp: Swift.String?
        /// The IDs of the security groups associated with the task or service. You can provide up to five security groups.
        public var securityGroups: [Swift.String]?
        /// The IDs of the subnets associated with the task or service. You can provide up to 16 subnets.
        public var subnets: [Swift.String]?

        public init (
            assignPublicIp: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.assignPublicIp = assignPublicIp
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsVpcConfiguration = "AwsVpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsVpcConfiguration = self.awsVpcConfiguration {
            try encodeContainer.encode(awsVpcConfiguration, forKey: .awsVpcConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsVpcConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails.self, forKey: .awsVpcConfiguration)
        awsVpcConfiguration = awsVpcConfigurationDecoded
    }
}

extension SecurityHubClientTypes {
    /// For tasks that use the awsvpc networking mode, the VPC subnet and security group configuration.
    public struct AwsEcsServiceNetworkConfigurationDetails: Swift.Equatable {
        /// The VPC subnet and security group configuration.
        public var awsVpcConfiguration: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails?

        public init (
            awsVpcConfiguration: SecurityHubClientTypes.AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails? = nil
        )
        {
            self.awsVpcConfiguration = awsVpcConfiguration
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServicePlacementConstraintsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A placement constraint for the tasks in the service.
    public struct AwsEcsServicePlacementConstraintsDetails: Swift.Equatable {
        /// A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance.
        public var expression: Swift.String?
        /// The type of constraint. Use distinctInstance to run each task in a particular group on a different container instance. Use memberOf to restrict the selection to a group of valid candidates. Valid values: distinctInstance | memberOf
        public var type: Swift.String?

        public init (
            expression: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.expression = expression
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServicePlacementStrategiesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field = "Field"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A placement strategy that determines how to place the tasks for the service.
    public struct AwsEcsServicePlacementStrategiesDetails: Swift.Equatable {
        /// The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this attribute is not used.
        public var field: Swift.String?
        /// The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the value of Field. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified in Field. Valid values: random | spread | binpack
        public var type: Swift.String?

        public init (
            field: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.field = field
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsEcsServiceServiceRegistriesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case containerPort = "ContainerPort"
        case port = "Port"
        case registryArn = "RegistryArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if containerPort != 0 {
            try encodeContainer.encode(containerPort, forKey: .containerPort)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let registryArn = self.registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let containerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .containerPort) ?? 0
        containerPort = containerPortDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a service discovery registry to assign to the service.
    public struct AwsEcsServiceServiceRegistriesDetails: Swift.Equatable {
        /// The container name value to use for the service discovery service. If the task definition uses the bridge or host network mode, you must specify ContainerName and ContainerPort. If the task definition uses the awsvpc network mode and a type SRV DNS record, you must specify either ContainerName and ContainerPort, or Port , but not both.
        public var containerName: Swift.String?
        /// The port value to use for the service discovery service. If the task definition uses the bridge or host network mode, you must specify ContainerName and ContainerPort. If the task definition uses the awsvpc network mode and a type SRV DNS record, you must specify either ContainerName and ContainerPort, or Port , but not both.
        public var containerPort: Swift.Int
        /// The port value to use for a service discovery service that specifies an SRV record. This field can be used if both the awsvpcawsvpc network mode and SRV records are used.
        public var port: Swift.Int
        /// The ARN of the service registry.
        public var registryArn: Swift.String?

        public init (
            containerName: Swift.String? = nil,
            containerPort: Swift.Int = 0,
            port: Swift.Int = 0,
            registryArn: Swift.String? = nil
        )
        {
            self.containerName = containerName
            self.containerPort = containerPort
            self.port = port
            self.registryArn = registryArn
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case containerName = "ContainerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .condition)
        condition = conditionDecoded
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// A dependency that is defined for container startup and shutdown.
    public struct AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails: Swift.Equatable {
        /// The dependency condition of the dependent container. Indicates the required status of the dependent container before the current container can start. Valid values are as follows:
        ///
        /// * COMPLETE
        ///
        /// * HEALTHY
        ///
        /// * SUCCESS
        ///
        /// * START
        public var condition: Swift.String?
        /// The name of the dependent container.
        public var containerName: Swift.String?

        public init (
            condition: Swift.String? = nil,
            containerName: Swift.String? = nil
        )
        {
            self.condition = condition
            self.containerName = containerName
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command = "Command"
        case cpu = "Cpu"
        case dependsOn = "DependsOn"
        case disableNetworking = "DisableNetworking"
        case dnsSearchDomains = "DnsSearchDomains"
        case dnsServers = "DnsServers"
        case dockerLabels = "DockerLabels"
        case dockerSecurityOptions = "DockerSecurityOptions"
        case entryPoint = "EntryPoint"
        case environment = "Environment"
        case environmentFiles = "EnvironmentFiles"
        case essential = "Essential"
        case extraHosts = "ExtraHosts"
        case firelensConfiguration = "FirelensConfiguration"
        case healthCheck = "HealthCheck"
        case hostname = "Hostname"
        case image = "Image"
        case interactive = "Interactive"
        case links = "Links"
        case linuxParameters = "LinuxParameters"
        case logConfiguration = "LogConfiguration"
        case memory = "Memory"
        case memoryReservation = "MemoryReservation"
        case mountPoints = "MountPoints"
        case name = "Name"
        case portMappings = "PortMappings"
        case privileged = "Privileged"
        case pseudoTerminal = "PseudoTerminal"
        case readonlyRootFilesystem = "ReadonlyRootFilesystem"
        case repositoryCredentials = "RepositoryCredentials"
        case resourceRequirements = "ResourceRequirements"
        case secrets = "Secrets"
        case startTimeout = "StartTimeout"
        case stopTimeout = "StopTimeout"
        case systemControls = "SystemControls"
        case ulimits = "Ulimits"
        case user = "User"
        case volumesFrom = "VolumesFrom"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            var commandContainer = encodeContainer.nestedUnkeyedContainer(forKey: .command)
            for nonemptystring0 in command {
                try commandContainer.encode(nonemptystring0)
            }
        }
        if cpu != 0 {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let dependsOn = dependsOn {
            var dependsOnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependsOn)
            for awsecstaskdefinitioncontainerdefinitionsdependsondetails0 in dependsOn {
                try dependsOnContainer.encode(awsecstaskdefinitioncontainerdefinitionsdependsondetails0)
            }
        }
        if disableNetworking != false {
            try encodeContainer.encode(disableNetworking, forKey: .disableNetworking)
        }
        if let dnsSearchDomains = dnsSearchDomains {
            var dnsSearchDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsSearchDomains)
            for nonemptystring0 in dnsSearchDomains {
                try dnsSearchDomainsContainer.encode(nonemptystring0)
            }
        }
        if let dnsServers = dnsServers {
            var dnsServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsServers)
            for nonemptystring0 in dnsServers {
                try dnsServersContainer.encode(nonemptystring0)
            }
        }
        if let dockerLabels = dockerLabels {
            var dockerLabelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .dockerLabels)
            for (dictKey0, fieldMap0) in dockerLabels {
                try dockerLabelsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dockerSecurityOptions = dockerSecurityOptions {
            var dockerSecurityOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dockerSecurityOptions)
            for nonemptystring0 in dockerSecurityOptions {
                try dockerSecurityOptionsContainer.encode(nonemptystring0)
            }
        }
        if let entryPoint = entryPoint {
            var entryPointContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPoint)
            for nonemptystring0 in entryPoint {
                try entryPointContainer.encode(nonemptystring0)
            }
        }
        if let environment = environment {
            var environmentContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environment)
            for awsecstaskdefinitioncontainerdefinitionsenvironmentdetails0 in environment {
                try environmentContainer.encode(awsecstaskdefinitioncontainerdefinitionsenvironmentdetails0)
            }
        }
        if let environmentFiles = environmentFiles {
            var environmentFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentFiles)
            for awsecstaskdefinitioncontainerdefinitionsenvironmentfilesdetails0 in environmentFiles {
                try environmentFilesContainer.encode(awsecstaskdefinitioncontainerdefinitionsenvironmentfilesdetails0)
            }
        }
        if essential != false {
            try encodeContainer.encode(essential, forKey: .essential)
        }
        if let extraHosts = extraHosts {
            var extraHostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extraHosts)
            for awsecstaskdefinitioncontainerdefinitionsextrahostsdetails0 in extraHosts {
                try extraHostsContainer.encode(awsecstaskdefinitioncontainerdefinitionsextrahostsdetails0)
            }
        }
        if let firelensConfiguration = self.firelensConfiguration {
            try encodeContainer.encode(firelensConfiguration, forKey: .firelensConfiguration)
        }
        if let healthCheck = self.healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if interactive != false {
            try encodeContainer.encode(interactive, forKey: .interactive)
        }
        if let links = links {
            var linksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .links)
            for nonemptystring0 in links {
                try linksContainer.encode(nonemptystring0)
            }
        }
        if let linuxParameters = self.linuxParameters {
            try encodeContainer.encode(linuxParameters, forKey: .linuxParameters)
        }
        if let logConfiguration = self.logConfiguration {
            try encodeContainer.encode(logConfiguration, forKey: .logConfiguration)
        }
        if memory != 0 {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if memoryReservation != 0 {
            try encodeContainer.encode(memoryReservation, forKey: .memoryReservation)
        }
        if let mountPoints = mountPoints {
            var mountPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mountPoints)
            for awsecstaskdefinitioncontainerdefinitionsmountpointsdetails0 in mountPoints {
                try mountPointsContainer.encode(awsecstaskdefinitioncontainerdefinitionsmountpointsdetails0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let portMappings = portMappings {
            var portMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portMappings)
            for awsecstaskdefinitioncontainerdefinitionsportmappingsdetails0 in portMappings {
                try portMappingsContainer.encode(awsecstaskdefinitioncontainerdefinitionsportmappingsdetails0)
            }
        }
        if privileged != false {
            try encodeContainer.encode(privileged, forKey: .privileged)
        }
        if pseudoTerminal != false {
            try encodeContainer.encode(pseudoTerminal, forKey: .pseudoTerminal)
        }
        if readonlyRootFilesystem != false {
            try encodeContainer.encode(readonlyRootFilesystem, forKey: .readonlyRootFilesystem)
        }
        if let repositoryCredentials = self.repositoryCredentials {
            try encodeContainer.encode(repositoryCredentials, forKey: .repositoryCredentials)
        }
        if let resourceRequirements = resourceRequirements {
            var resourceRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceRequirements)
            for awsecstaskdefinitioncontainerdefinitionsresourcerequirementsdetails0 in resourceRequirements {
                try resourceRequirementsContainer.encode(awsecstaskdefinitioncontainerdefinitionsresourcerequirementsdetails0)
            }
        }
        if let secrets = secrets {
            var secretsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secrets)
            for awsecstaskdefinitioncontainerdefinitionssecretsdetails0 in secrets {
                try secretsContainer.encode(awsecstaskdefinitioncontainerdefinitionssecretsdetails0)
            }
        }
        if startTimeout != 0 {
            try encodeContainer.encode(startTimeout, forKey: .startTimeout)
        }
        if stopTimeout != 0 {
            try encodeContainer.encode(stopTimeout, forKey: .stopTimeout)
        }
        if let systemControls = systemControls {
            var systemControlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemControls)
            for awsecstaskdefinitioncontainerdefinitionssystemcontrolsdetails0 in systemControls {
                try systemControlsContainer.encode(awsecstaskdefinitioncontainerdefinitionssystemcontrolsdetails0)
            }
        }
        if let ulimits = ulimits {
            var ulimitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ulimits)
            for awsecstaskdefinitioncontainerdefinitionsulimitsdetails0 in ulimits {
                try ulimitsContainer.encode(awsecstaskdefinitioncontainerdefinitionsulimitsdetails0)
            }
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
        if let volumesFrom = volumesFrom {
            var volumesFromContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumesFrom)
            for awsecstaskdefinitioncontainerdefinitionsvolumesfromdetails0 in volumesFrom {
                try volumesFromContainer.encode(awsecstaskdefinitioncontainerdefinitionsvolumesfromdetails0)
            }
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .command)
        var commandDecoded0:[Swift.String]? = nil
        if let commandContainer = commandContainer {
            commandDecoded0 = [Swift.String]()
            for string0 in commandContainer {
                if let string0 = string0 {
                    commandDecoded0?.append(string0)
                }
            }
        }
        command = commandDecoded0
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpu) ?? 0
        cpu = cpuDecoded
        let dependsOnContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails?].self, forKey: .dependsOn)
        var dependsOnDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]? = nil
        if let dependsOnContainer = dependsOnContainer {
            dependsOnDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]()
            for structure0 in dependsOnContainer {
                if let structure0 = structure0 {
                    dependsOnDecoded0?.append(structure0)
                }
            }
        }
        dependsOn = dependsOnDecoded0
        let disableNetworkingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableNetworking) ?? false
        disableNetworking = disableNetworkingDecoded
        let dnsSearchDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsSearchDomains)
        var dnsSearchDomainsDecoded0:[Swift.String]? = nil
        if let dnsSearchDomainsContainer = dnsSearchDomainsContainer {
            dnsSearchDomainsDecoded0 = [Swift.String]()
            for string0 in dnsSearchDomainsContainer {
                if let string0 = string0 {
                    dnsSearchDomainsDecoded0?.append(string0)
                }
            }
        }
        dnsSearchDomains = dnsSearchDomainsDecoded0
        let dnsServersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsServers)
        var dnsServersDecoded0:[Swift.String]? = nil
        if let dnsServersContainer = dnsServersContainer {
            dnsServersDecoded0 = [Swift.String]()
            for string0 in dnsServersContainer {
                if let string0 = string0 {
                    dnsServersDecoded0?.append(string0)
                }
            }
        }
        dnsServers = dnsServersDecoded0
        let dockerLabelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .dockerLabels)
        var dockerLabelsDecoded0: [Swift.String:Swift.String]? = nil
        if let dockerLabelsContainer = dockerLabelsContainer {
            dockerLabelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in dockerLabelsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    dockerLabelsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        dockerLabels = dockerLabelsDecoded0
        let dockerSecurityOptionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dockerSecurityOptions)
        var dockerSecurityOptionsDecoded0:[Swift.String]? = nil
        if let dockerSecurityOptionsContainer = dockerSecurityOptionsContainer {
            dockerSecurityOptionsDecoded0 = [Swift.String]()
            for string0 in dockerSecurityOptionsContainer {
                if let string0 = string0 {
                    dockerSecurityOptionsDecoded0?.append(string0)
                }
            }
        }
        dockerSecurityOptions = dockerSecurityOptionsDecoded0
        let entryPointContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entryPoint)
        var entryPointDecoded0:[Swift.String]? = nil
        if let entryPointContainer = entryPointContainer {
            entryPointDecoded0 = [Swift.String]()
            for string0 in entryPointContainer {
                if let string0 = string0 {
                    entryPointDecoded0?.append(string0)
                }
            }
        }
        entryPoint = entryPointDecoded0
        let environmentContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails?].self, forKey: .environment)
        var environmentDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]? = nil
        if let environmentContainer = environmentContainer {
            environmentDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]()
            for structure0 in environmentContainer {
                if let structure0 = structure0 {
                    environmentDecoded0?.append(structure0)
                }
            }
        }
        environment = environmentDecoded0
        let environmentFilesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails?].self, forKey: .environmentFiles)
        var environmentFilesDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]? = nil
        if let environmentFilesContainer = environmentFilesContainer {
            environmentFilesDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]()
            for structure0 in environmentFilesContainer {
                if let structure0 = structure0 {
                    environmentFilesDecoded0?.append(structure0)
                }
            }
        }
        environmentFiles = environmentFilesDecoded0
        let essentialDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .essential) ?? false
        essential = essentialDecoded
        let extraHostsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails?].self, forKey: .extraHosts)
        var extraHostsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]? = nil
        if let extraHostsContainer = extraHostsContainer {
            extraHostsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]()
            for structure0 in extraHostsContainer {
                if let structure0 = structure0 {
                    extraHostsDecoded0?.append(structure0)
                }
            }
        }
        extraHosts = extraHostsDecoded0
        let firelensConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails.self, forKey: .firelensConfiguration)
        firelensConfiguration = firelensConfigurationDecoded
        let healthCheckDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let interactiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .interactive) ?? false
        interactive = interactiveDecoded
        let linksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .links)
        var linksDecoded0:[Swift.String]? = nil
        if let linksContainer = linksContainer {
            linksDecoded0 = [Swift.String]()
            for string0 in linksContainer {
                if let string0 = string0 {
                    linksDecoded0?.append(string0)
                }
            }
        }
        links = linksDecoded0
        let linuxParametersDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails.self, forKey: .linuxParameters)
        linuxParameters = linuxParametersDecoded
        let logConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails.self, forKey: .logConfiguration)
        logConfiguration = logConfigurationDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memory) ?? 0
        memory = memoryDecoded
        let memoryReservationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memoryReservation) ?? 0
        memoryReservation = memoryReservationDecoded
        let mountPointsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails?].self, forKey: .mountPoints)
        var mountPointsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]? = nil
        if let mountPointsContainer = mountPointsContainer {
            mountPointsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]()
            for structure0 in mountPointsContainer {
                if let structure0 = structure0 {
                    mountPointsDecoded0?.append(structure0)
                }
            }
        }
        mountPoints = mountPointsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let portMappingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails?].self, forKey: .portMappings)
        var portMappingsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]? = nil
        if let portMappingsContainer = portMappingsContainer {
            portMappingsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]()
            for structure0 in portMappingsContainer {
                if let structure0 = structure0 {
                    portMappingsDecoded0?.append(structure0)
                }
            }
        }
        portMappings = portMappingsDecoded0
        let privilegedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privileged) ?? false
        privileged = privilegedDecoded
        let pseudoTerminalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pseudoTerminal) ?? false
        pseudoTerminal = pseudoTerminalDecoded
        let readonlyRootFilesystemDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readonlyRootFilesystem) ?? false
        readonlyRootFilesystem = readonlyRootFilesystemDecoded
        let repositoryCredentialsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails.self, forKey: .repositoryCredentials)
        repositoryCredentials = repositoryCredentialsDecoded
        let resourceRequirementsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails?].self, forKey: .resourceRequirements)
        var resourceRequirementsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]? = nil
        if let resourceRequirementsContainer = resourceRequirementsContainer {
            resourceRequirementsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]()
            for structure0 in resourceRequirementsContainer {
                if let structure0 = structure0 {
                    resourceRequirementsDecoded0?.append(structure0)
                }
            }
        }
        resourceRequirements = resourceRequirementsDecoded0
        let secretsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails?].self, forKey: .secrets)
        var secretsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]? = nil
        if let secretsContainer = secretsContainer {
            secretsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]()
            for structure0 in secretsContainer {
                if let structure0 = structure0 {
                    secretsDecoded0?.append(structure0)
                }
            }
        }
        secrets = secretsDecoded0
        let startTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startTimeout) ?? 0
        startTimeout = startTimeoutDecoded
        let stopTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stopTimeout) ?? 0
        stopTimeout = stopTimeoutDecoded
        let systemControlsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails?].self, forKey: .systemControls)
        var systemControlsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]? = nil
        if let systemControlsContainer = systemControlsContainer {
            systemControlsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]()
            for structure0 in systemControlsContainer {
                if let structure0 = structure0 {
                    systemControlsDecoded0?.append(structure0)
                }
            }
        }
        systemControls = systemControlsDecoded0
        let ulimitsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails?].self, forKey: .ulimits)
        var ulimitsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]? = nil
        if let ulimitsContainer = ulimitsContainer {
            ulimitsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]()
            for structure0 in ulimitsContainer {
                if let structure0 = structure0 {
                    ulimitsDecoded0?.append(structure0)
                }
            }
        }
        ulimits = ulimitsDecoded0
        let userDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .user)
        user = userDecoded
        let volumesFromContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails?].self, forKey: .volumesFrom)
        var volumesFromDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]? = nil
        if let volumesFromContainer = volumesFromContainer {
            volumesFromDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]()
            for structure0 in volumesFromContainer {
                if let structure0 = structure0 {
                    volumesFromDecoded0?.append(structure0)
                }
            }
        }
        volumesFrom = volumesFromDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
    }
}

extension SecurityHubClientTypes {
    /// A container definition that describes a container in the task.
    public struct AwsEcsTaskDefinitionContainerDefinitionsDetails: Swift.Equatable {
        /// The command that is passed to the container.
        public var command: [Swift.String]?
        /// The number of CPU units reserved for the container.
        public var cpu: Swift.Int
        /// The dependencies that are defined for container startup and shutdown.
        public var dependsOn: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]?
        /// Whether to disable networking within the container.
        public var disableNetworking: Swift.Bool
        /// A list of DNS search domains that are presented to the container.
        public var dnsSearchDomains: [Swift.String]?
        /// A list of DNS servers that are presented to the container.
        public var dnsServers: [Swift.String]?
        /// A key-value map of labels to add to the container.
        public var dockerLabels: [Swift.String:Swift.String]?
        /// A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems.
        public var dockerSecurityOptions: [Swift.String]?
        /// The entry point that is passed to the container.
        public var entryPoint: [Swift.String]?
        /// The environment variables to pass to a container.
        public var environment: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]?
        /// A list of files containing the environment variables to pass to a container.
        public var environmentFiles: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]?
        /// Whether the container is essential. All tasks must have at least one essential container.
        public var essential: Swift.Bool
        /// A list of hostnames and IP address mappings to append to the /etc/hosts file on the container.
        public var extraHosts: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]?
        /// The FireLens configuration for the container. Specifies and configures a log router for container logs.
        public var firelensConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails?
        /// The container health check command and associated configuration parameters for the container.
        public var healthCheck: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails?
        /// The hostname to use for the container.
        public var hostname: Swift.String?
        /// The image used to start the container.
        public var image: Swift.String?
        /// If set to true, then containerized applications can be deployed that require stdin or a tty to be allocated.
        public var interactive: Swift.Bool
        /// A list of links for the container in the form  container_name:alias . Allows containers to communicate with each other without the need for port mappings.
        public var links: [Swift.String]?
        /// Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.
        public var linuxParameters: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails?
        /// The log configuration specification for the container.
        public var logConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails?
        /// The amount (in MiB) of memory to present to the container. If the container attempts to exceed the memory specified here, the container is shut down. The total amount of memory reserved for all containers within a task must be lower than the task memory value, if one is specified.
        public var memory: Swift.Int
        /// The soft limit (in MiB) of memory to reserve for the container.
        public var memoryReservation: Swift.Int
        /// The mount points for the data volumes in the container.
        public var mountPoints: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]?
        /// The name of the container.
        public var name: Swift.String?
        /// The list of port mappings for the container.
        public var portMappings: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]?
        /// Whether the container is given elevated privileges on the host container instance. The elevated privileges are similar to the root user.
        public var privileged: Swift.Bool
        /// Whether to allocate a TTY to the container.
        public var pseudoTerminal: Swift.Bool
        /// Whether the container is given read-only access to its root file system.
        public var readonlyRootFilesystem: Swift.Bool
        /// The private repository authentication credentials to use.
        public var repositoryCredentials: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails?
        /// The type and amount of a resource to assign to a container. The only supported resource is a GPU.
        public var resourceRequirements: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]?
        /// The secrets to pass to the container.
        public var secrets: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]?
        /// The number of seconds to wait before giving up on resolving dependencies for a container.
        public var startTimeout: Swift.Int
        /// The number of seconds to wait before the container is stopped if it doesn't shut down normally on its own.
        public var stopTimeout: Swift.Int
        /// A list of namespaced kernel parameters to set in the container.
        public var systemControls: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]?
        /// A list of ulimits to set in the container.
        public var ulimits: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]?
        /// The user to use inside the container. The value can use one of the following formats.
        ///
        /// * user
        ///
        /// * user : group
        ///
        /// * uid
        ///
        /// * uid : gid
        ///
        /// * user : gid
        ///
        /// * uid : group
        public var user: Swift.String?
        /// Data volumes to mount from another container.
        public var volumesFrom: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]?
        /// The working directory in which to run commands inside the container.
        public var workingDirectory: Swift.String?

        public init (
            command: [Swift.String]? = nil,
            cpu: Swift.Int = 0,
            dependsOn: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails]? = nil,
            disableNetworking: Swift.Bool = false,
            dnsSearchDomains: [Swift.String]? = nil,
            dnsServers: [Swift.String]? = nil,
            dockerLabels: [Swift.String:Swift.String]? = nil,
            dockerSecurityOptions: [Swift.String]? = nil,
            entryPoint: [Swift.String]? = nil,
            environment: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails]? = nil,
            environmentFiles: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails]? = nil,
            essential: Swift.Bool = false,
            extraHosts: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails]? = nil,
            firelensConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails? = nil,
            healthCheck: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails? = nil,
            hostname: Swift.String? = nil,
            image: Swift.String? = nil,
            interactive: Swift.Bool = false,
            links: [Swift.String]? = nil,
            linuxParameters: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails? = nil,
            logConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails? = nil,
            memory: Swift.Int = 0,
            memoryReservation: Swift.Int = 0,
            mountPoints: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails]? = nil,
            name: Swift.String? = nil,
            portMappings: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails]? = nil,
            privileged: Swift.Bool = false,
            pseudoTerminal: Swift.Bool = false,
            readonlyRootFilesystem: Swift.Bool = false,
            repositoryCredentials: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails? = nil,
            resourceRequirements: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails]? = nil,
            secrets: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails]? = nil,
            startTimeout: Swift.Int = 0,
            stopTimeout: Swift.Int = 0,
            systemControls: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails]? = nil,
            ulimits: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails]? = nil,
            user: Swift.String? = nil,
            volumesFrom: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails]? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.command = command
            self.cpu = cpu
            self.dependsOn = dependsOn
            self.disableNetworking = disableNetworking
            self.dnsSearchDomains = dnsSearchDomains
            self.dnsServers = dnsServers
            self.dockerLabels = dockerLabels
            self.dockerSecurityOptions = dockerSecurityOptions
            self.entryPoint = entryPoint
            self.environment = environment
            self.environmentFiles = environmentFiles
            self.essential = essential
            self.extraHosts = extraHosts
            self.firelensConfiguration = firelensConfiguration
            self.healthCheck = healthCheck
            self.hostname = hostname
            self.image = image
            self.interactive = interactive
            self.links = links
            self.linuxParameters = linuxParameters
            self.logConfiguration = logConfiguration
            self.memory = memory
            self.memoryReservation = memoryReservation
            self.mountPoints = mountPoints
            self.name = name
            self.portMappings = portMappings
            self.privileged = privileged
            self.pseudoTerminal = pseudoTerminal
            self.readonlyRootFilesystem = readonlyRootFilesystem
            self.repositoryCredentials = repositoryCredentials
            self.resourceRequirements = resourceRequirements
            self.secrets = secrets
            self.startTimeout = startTimeout
            self.stopTimeout = stopTimeout
            self.systemControls = systemControls
            self.ulimits = ulimits
            self.user = user
            self.volumesFrom = volumesFrom
            self.workingDirectory = workingDirectory
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// An environment variable to pass to the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails: Swift.Equatable {
        /// The name of the environment variable.
        public var name: Swift.String?
        /// The value of the environment variable.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A file that contain environment variables to pass to a container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails: Swift.Equatable {
        /// The type of environment file. The valid value is s3.
        public var type: Swift.String?
        /// The ARN of the S3 object that contains the environment variable file.
        public var value: Swift.String?

        public init (
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case ipAddress = "IpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension SecurityHubClientTypes {
    /// A hostname and IP address mapping to append to the /etc/hosts file on the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails: Swift.Equatable {
        /// The hostname to use in the /etc/hosts entry.
        public var hostname: Swift.String?
        /// The IP address to use in the /etc/hosts entry.
        public var ipAddress: Swift.String?

        public init (
            hostname: Swift.String? = nil,
            ipAddress: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.ipAddress = ipAddress
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case options = "Options"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let options = options {
            var optionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .options)
            for (dictKey0, fieldMap0) in options {
                try optionsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .options)
        var optionsDecoded0: [Swift.String:Swift.String]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in optionsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    optionsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        options = optionsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// The FireLens configuration for the container. The configuration specifies and configures a log router for container logs.
    public struct AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails: Swift.Equatable {
        /// The options to use to configure the log router. The valid option keys are as follows:
        ///
        /// * enable-ecs-log-metadata. The value can be true or false.
        ///
        /// * config-file-type. The value can be s3 or file.
        ///
        /// * config-file-value. The value is either an S3 ARN or a file path.
        public var options: [Swift.String:Swift.String]?
        /// The log router to use. Valid values are fluentbit or fluentd.
        public var type: Swift.String?

        public init (
            options: [Swift.String:Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.options = options
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command = "Command"
        case interval = "Interval"
        case retries = "Retries"
        case startPeriod = "StartPeriod"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            var commandContainer = encodeContainer.nestedUnkeyedContainer(forKey: .command)
            for nonemptystring0 in command {
                try commandContainer.encode(nonemptystring0)
            }
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if retries != 0 {
            try encodeContainer.encode(retries, forKey: .retries)
        }
        if startPeriod != 0 {
            try encodeContainer.encode(startPeriod, forKey: .startPeriod)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commandContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .command)
        var commandDecoded0:[Swift.String]? = nil
        if let commandContainer = commandContainer {
            commandDecoded0 = [Swift.String]()
            for string0 in commandContainer {
                if let string0 = string0 {
                    commandDecoded0?.append(string0)
                }
            }
        }
        command = commandDecoded0
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval) ?? 0
        interval = intervalDecoded
        let retriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retries) ?? 0
        retries = retriesDecoded
        let startPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startPeriod) ?? 0
        startPeriod = startPeriodDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout) ?? 0
        timeout = timeoutDecoded
    }
}

extension SecurityHubClientTypes {
    /// The container health check command and associated configuration parameters for the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails: Swift.Equatable {
        /// The command that the container runs to determine whether it is healthy.
        public var command: [Swift.String]?
        /// The time period in seconds between each health check execution. The default value is 30 seconds.
        public var interval: Swift.Int
        /// The number of times to retry a failed health check before the container is considered unhealthy. The default value is 3.
        public var retries: Swift.Int
        /// The optional grace period in seconds that allows containers time to bootstrap before failed health checks count towards the maximum number of retries.
        public var startPeriod: Swift.Int
        /// The time period in seconds to wait for a health check to succeed before it is considered a failure. The default value is 5.
        public var timeout: Swift.Int

        public init (
            command: [Swift.String]? = nil,
            interval: Swift.Int = 0,
            retries: Swift.Int = 0,
            startPeriod: Swift.Int = 0,
            timeout: Swift.Int = 0
        )
        {
            self.command = command
            self.interval = interval
            self.retries = retries
            self.startPeriod = startPeriod
            self.timeout = timeout
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case add = "Add"
        case drop = "Drop"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let add = add {
            var addContainer = encodeContainer.nestedUnkeyedContainer(forKey: .add)
            for nonemptystring0 in add {
                try addContainer.encode(nonemptystring0)
            }
        }
        if let drop = drop {
            var dropContainer = encodeContainer.nestedUnkeyedContainer(forKey: .drop)
            for nonemptystring0 in drop {
                try dropContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .add)
        var addDecoded0:[Swift.String]? = nil
        if let addContainer = addContainer {
            addDecoded0 = [Swift.String]()
            for string0 in addContainer {
                if let string0 = string0 {
                    addDecoded0?.append(string0)
                }
            }
        }
        add = addDecoded0
        let dropContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .drop)
        var dropDecoded0:[Swift.String]? = nil
        if let dropContainer = dropContainer {
            dropDecoded0 = [Swift.String]()
            for string0 in dropContainer {
                if let string0 = string0 {
                    dropDecoded0?.append(string0)
                }
            }
        }
        drop = dropDecoded0
    }
}

extension SecurityHubClientTypes {
    /// The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails: Swift.Equatable {
        /// The Linux capabilities for the container that are added to the default configuration provided by Docker. Valid values are as follows: Valid values: "ALL" | "AUDIT_CONTROL" | "AUDIT_WRITE" | "BLOCK_SUSPEND" | "CHOWN" | "DAC_OVERRIDE" | "DAC_READ_SEARCH" | "FOWNER" | "FSETID" | "IPC_LOCK" | "IPC_OWNER" | "KILL" | "LEASE" | "LINUX_IMMUTABLE" | "MAC_ADMIN" | "MAC_OVERRIDE" | "MKNOD" | "NET_ADMIN" | "NET_BIND_SERVICE" | "NET_BROADCAST" | "NET_RAW" | "SETFCAP" | "SETGID" | "SETPCAP" | "SETUID" | "SYS_ADMIN" | "SYS_BOOT" | "SYS_CHROOT" | "SYS_MODULE" | "SYS_NICE" | "SYS_PACCT" | "SYS_PTRACE" | "SYS_RAWIO" | "SYS_RESOURCE" | "SYS_TIME" | "SYS_TTY_CONFIG" | "SYSLOG" | "WAKE_ALARM"
        public var add: [Swift.String]?
        /// The Linux capabilities for the container that are dropped from the default configuration provided by Docker. Valid values: "ALL" | "AUDIT_CONTROL" | "AUDIT_WRITE" | "BLOCK_SUSPEND" | "CHOWN" | "DAC_OVERRIDE" | "DAC_READ_SEARCH" | "FOWNER" | "FSETID" | "IPC_LOCK" | "IPC_OWNER" | "KILL" | "LEASE" | "LINUX_IMMUTABLE" | "MAC_ADMIN" | "MAC_OVERRIDE" | "MKNOD" | "NET_ADMIN" | "NET_BIND_SERVICE" | "NET_BROADCAST" | "NET_RAW" | "SETFCAP" | "SETGID" | "SETPCAP" | "SETUID" | "SYS_ADMIN" | "SYS_BOOT" | "SYS_CHROOT" | "SYS_MODULE" | "SYS_NICE" | "SYS_PACCT" | "SYS_PTRACE" | "SYS_RAWIO" | "SYS_RESOURCE" | "SYS_TIME" | "SYS_TTY_CONFIG" | "SYSLOG" | "WAKE_ALARM"
        public var drop: [Swift.String]?

        public init (
            add: [Swift.String]? = nil,
            drop: [Swift.String]? = nil
        )
        {
            self.add = add
            self.drop = drop
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "Capabilities"
        case devices = "Devices"
        case initProcessEnabled = "InitProcessEnabled"
        case maxSwap = "MaxSwap"
        case sharedMemorySize = "SharedMemorySize"
        case swappiness = "Swappiness"
        case tmpfs = "Tmpfs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = self.capabilities {
            try encodeContainer.encode(capabilities, forKey: .capabilities)
        }
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for awsecstaskdefinitioncontainerdefinitionslinuxparametersdevicesdetails0 in devices {
                try devicesContainer.encode(awsecstaskdefinitioncontainerdefinitionslinuxparametersdevicesdetails0)
            }
        }
        if initProcessEnabled != false {
            try encodeContainer.encode(initProcessEnabled, forKey: .initProcessEnabled)
        }
        if maxSwap != 0 {
            try encodeContainer.encode(maxSwap, forKey: .maxSwap)
        }
        if sharedMemorySize != 0 {
            try encodeContainer.encode(sharedMemorySize, forKey: .sharedMemorySize)
        }
        if swappiness != 0 {
            try encodeContainer.encode(swappiness, forKey: .swappiness)
        }
        if let tmpfs = tmpfs {
            var tmpfsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tmpfs)
            for awsecstaskdefinitioncontainerdefinitionslinuxparameterstmpfsdetails0 in tmpfs {
                try tmpfsContainer.encode(awsecstaskdefinitioncontainerdefinitionslinuxparameterstmpfsdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails.self, forKey: .capabilities)
        capabilities = capabilitiesDecoded
        let devicesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails?].self, forKey: .devices)
        var devicesDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let initProcessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .initProcessEnabled) ?? false
        initProcessEnabled = initProcessEnabledDecoded
        let maxSwapDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSwap) ?? 0
        maxSwap = maxSwapDecoded
        let sharedMemorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sharedMemorySize) ?? 0
        sharedMemorySize = sharedMemorySizeDecoded
        let swappinessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .swappiness) ?? 0
        swappiness = swappinessDecoded
        let tmpfsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails?].self, forKey: .tmpfs)
        var tmpfsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]? = nil
        if let tmpfsContainer = tmpfsContainer {
            tmpfsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]()
            for structure0 in tmpfsContainer {
                if let structure0 = structure0 {
                    tmpfsDecoded0?.append(structure0)
                }
            }
        }
        tmpfs = tmpfsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// >Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails: Swift.Equatable {
        /// The Linux capabilities for the container that are added to or dropped from the default configuration provided by Docker.
        public var capabilities: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails?
        /// The host devices to expose to the container.
        public var devices: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]?
        /// Whether to run an init process inside the container that forwards signals and reaps processes.
        public var initProcessEnabled: Swift.Bool
        /// The total amount of swap memory (in MiB) that a container can use.
        public var maxSwap: Swift.Int
        /// The value for the size (in MiB) of the /dev/shm volume.
        public var sharedMemorySize: Swift.Int
        /// Configures the container's memory swappiness behavior. Determines how aggressively pages are swapped. The higher the value, the more aggressive the swappiness. The default is 60.
        public var swappiness: Swift.Int
        /// The container path, mount options, and size (in MiB) of the tmpfs mount.
        public var tmpfs: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]?

        public init (
            capabilities: SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails? = nil,
            devices: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails]? = nil,
            initProcessEnabled: Swift.Bool = false,
            maxSwap: Swift.Int = 0,
            sharedMemorySize: Swift.Int = 0,
            swappiness: Swift.Int = 0,
            tmpfs: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails]? = nil
        )
        {
            self.capabilities = capabilities
            self.devices = devices
            self.initProcessEnabled = initProcessEnabled
            self.maxSwap = maxSwap
            self.sharedMemorySize = sharedMemorySize
            self.swappiness = swappiness
            self.tmpfs = tmpfs
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerPath = "ContainerPath"
        case hostPath = "HostPath"
        case permissions = "Permissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerPath = self.containerPath {
            try encodeContainer.encode(containerPath, forKey: .containerPath)
        }
        if let hostPath = self.hostPath {
            try encodeContainer.encode(hostPath, forKey: .hostPath)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for nonemptystring0 in permissions {
                try permissionsContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerPath)
        containerPath = containerPathDecoded
        let hostPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostPath)
        hostPath = hostPathDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissions)
        var permissionsDecoded0:[Swift.String]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Swift.String]()
            for string0 in permissionsContainer {
                if let string0 = string0 {
                    permissionsDecoded0?.append(string0)
                }
            }
        }
        permissions = permissionsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// A host device to expose to the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails: Swift.Equatable {
        /// The path inside the container at which to expose the host device.
        public var containerPath: Swift.String?
        /// The path for the device on the host container instance.
        public var hostPath: Swift.String?
        /// The explicit permissions to provide to the container for the device. By default, the container has permissions for read, write, and mknod for the device.
        public var permissions: [Swift.String]?

        public init (
            containerPath: Swift.String? = nil,
            hostPath: Swift.String? = nil,
            permissions: [Swift.String]? = nil
        )
        {
            self.containerPath = containerPath
            self.hostPath = hostPath
            self.permissions = permissions
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerPath = "ContainerPath"
        case mountOptions = "MountOptions"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerPath = self.containerPath {
            try encodeContainer.encode(containerPath, forKey: .containerPath)
        }
        if let mountOptions = mountOptions {
            var mountOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mountOptions)
            for nonemptystring0 in mountOptions {
                try mountOptionsContainer.encode(nonemptystring0)
            }
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerPath)
        containerPath = containerPathDecoded
        let mountOptionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .mountOptions)
        var mountOptionsDecoded0:[Swift.String]? = nil
        if let mountOptionsContainer = mountOptionsContainer {
            mountOptionsDecoded0 = [Swift.String]()
            for string0 in mountOptionsContainer {
                if let string0 = string0 {
                    mountOptionsDecoded0?.append(string0)
                }
            }
        }
        mountOptions = mountOptionsDecoded0
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size) ?? 0
        size = sizeDecoded
    }
}

extension SecurityHubClientTypes {
    /// The container path, mount options, and size (in MiB) of a tmpfs mount.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails: Swift.Equatable {
        /// The absolute file path where the tmpfs volume is to be mounted.
        public var containerPath: Swift.String?
        /// The list of tmpfs volume mount options. Valid values: "defaults" | "ro" | "rw" | "suid" | "nosuid" | "dev" | "nodev" | "exec" | "noexec" | "sync" | "async" | "dirsync" | "remount" | "mand" | "nomand" | "atime" | "noatime" | "diratime" | "nodiratime" | "bind" | "rbind" | "unbindable" | "runbindable" | "private" | "rprivate" | "shared" | "rshared" | "slave" | "rslave" | "relatime" | "norelatime" | "strictatime" | "nostrictatime" | "mode" | "uid" | "gid" | "nr_inodes" | "nr_blocks" | "mpol"
        public var mountOptions: [Swift.String]?
        /// The maximum size (in MiB) of the tmpfs volume.
        public var size: Swift.Int

        public init (
            containerPath: Swift.String? = nil,
            mountOptions: [Swift.String]? = nil,
            size: Swift.Int = 0
        )
        {
            self.containerPath = containerPath
            self.mountOptions = mountOptions
            self.size = size
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logDriver = "LogDriver"
        case options = "Options"
        case secretOptions = "SecretOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logDriver = self.logDriver {
            try encodeContainer.encode(logDriver, forKey: .logDriver)
        }
        if let options = options {
            var optionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .options)
            for (dictKey0, fieldMap0) in options {
                try optionsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let secretOptions = secretOptions {
            var secretOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secretOptions)
            for awsecstaskdefinitioncontainerdefinitionslogconfigurationsecretoptionsdetails0 in secretOptions {
                try secretOptionsContainer.encode(awsecstaskdefinitioncontainerdefinitionslogconfigurationsecretoptionsdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDriverDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logDriver)
        logDriver = logDriverDecoded
        let optionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .options)
        var optionsDecoded0: [Swift.String:Swift.String]? = nil
        if let optionsContainer = optionsContainer {
            optionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in optionsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    optionsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        options = optionsDecoded0
        let secretOptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails?].self, forKey: .secretOptions)
        var secretOptionsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]? = nil
        if let secretOptionsContainer = secretOptionsContainer {
            secretOptionsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]()
            for structure0 in secretOptionsContainer {
                if let structure0 = structure0 {
                    secretOptionsDecoded0?.append(structure0)
                }
            }
        }
        secretOptions = secretOptionsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// The log configuration specification for the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails: Swift.Equatable {
        /// The log driver to use for the container. Valid values on Fargate are as follows:
        ///
        /// * awsfirelens
        ///
        /// * awslogs
        ///
        /// * splunk
        ///
        ///
        /// Valid values on Amazon EC2 are as follows:
        ///
        /// * awsfirelens
        ///
        /// * awslogs
        ///
        /// * fluentd
        ///
        /// * gelf
        ///
        /// * journald
        ///
        /// * json-file
        ///
        /// * logentries
        ///
        /// * splunk
        ///
        /// * syslog
        public var logDriver: Swift.String?
        /// The configuration options to send to the log driver. Requires version 1.19 of the Docker Remote API or greater on your container instance.
        public var options: [Swift.String:Swift.String]?
        /// The secrets to pass to the log configuration.
        public var secretOptions: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]?

        public init (
            logDriver: Swift.String? = nil,
            options: [Swift.String:Swift.String]? = nil,
            secretOptions: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails]? = nil
        )
        {
            self.logDriver = logDriver
            self.options = options
            self.secretOptions = secretOptions
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case valueFrom = "ValueFrom"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let valueFrom = self.valueFrom {
            try encodeContainer.encode(valueFrom, forKey: .valueFrom)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueFrom)
        valueFrom = valueFromDecoded
    }
}

extension SecurityHubClientTypes {
    /// A secret to pass to the log configuration.
    public struct AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails: Swift.Equatable {
        /// The name of the secret.
        public var name: Swift.String?
        /// The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.
        public var valueFrom: Swift.String?

        public init (
            name: Swift.String? = nil,
            valueFrom: Swift.String? = nil
        )
        {
            self.name = name
            self.valueFrom = valueFrom
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerPath = "ContainerPath"
        case readOnly = "ReadOnly"
        case sourceVolume = "SourceVolume"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerPath = self.containerPath {
            try encodeContainer.encode(containerPath, forKey: .containerPath)
        }
        if readOnly != false {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let sourceVolume = self.sourceVolume {
            try encodeContainer.encode(sourceVolume, forKey: .sourceVolume)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerPath)
        containerPath = containerPathDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly) ?? false
        readOnly = readOnlyDecoded
        let sourceVolumeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVolume)
        sourceVolume = sourceVolumeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A mount point for the data volumes in the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails: Swift.Equatable {
        /// The path on the container to mount the host volume at.
        public var containerPath: Swift.String?
        /// Whether the container has read-only access to the volume.
        public var readOnly: Swift.Bool
        /// The name of the volume to mount. Must match the name of a volume listed in VolumeDetails for the task definition.
        public var sourceVolume: Swift.String?

        public init (
            containerPath: Swift.String? = nil,
            readOnly: Swift.Bool = false,
            sourceVolume: Swift.String? = nil
        )
        {
            self.containerPath = containerPath
            self.readOnly = readOnly
            self.sourceVolume = sourceVolume
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerPort = "ContainerPort"
        case hostPort = "HostPort"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if containerPort != 0 {
            try encodeContainer.encode(containerPort, forKey: .containerPort)
        }
        if hostPort != 0 {
            try encodeContainer.encode(hostPort, forKey: .hostPort)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .containerPort) ?? 0
        containerPort = containerPortDecoded
        let hostPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hostPort) ?? 0
        hostPort = hostPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension SecurityHubClientTypes {
    /// A port mapping for the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails: Swift.Equatable {
        /// The port number on the container that is bound to the user-specified or automatically assigned host port.
        public var containerPort: Swift.Int
        /// The port number on the container instance to reserve for the container.
        public var hostPort: Swift.Int
        /// The protocol used for the port mapping. The default is tcp.
        public var `protocol`: Swift.String?

        public init (
            containerPort: Swift.Int = 0,
            hostPort: Swift.Int = 0,
            `protocol`: Swift.String? = nil
        )
        {
            self.containerPort = containerPort
            self.hostPort = hostPort
            self.`protocol` = `protocol`
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialsParameter = "CredentialsParameter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialsParameter = self.credentialsParameter {
            try encodeContainer.encode(credentialsParameter, forKey: .credentialsParameter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsParameterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsParameter)
        credentialsParameter = credentialsParameterDecoded
    }
}

extension SecurityHubClientTypes {
    /// The private repository authentication credentials to use.
    public struct AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails: Swift.Equatable {
        /// The ARN of the secret that contains the private repository credentials.
        public var credentialsParameter: Swift.String?

        public init (
            credentialsParameter: Swift.String? = nil
        )
        {
            self.credentialsParameter = credentialsParameter
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A resource to assign to a container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails: Swift.Equatable {
        /// The type of resource to assign to a container. Valid values are GPU or InferenceAccelerator.
        public var type: Swift.String?
        /// The value for the specified resource type. For GPU, the value is the number of physical GPUs the Amazon ECS container agent reserves for the container. For InferenceAccelerator, the value should match the DeviceName attribute of an entry in InferenceAccelerators.
        public var value: Swift.String?

        public init (
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case valueFrom = "ValueFrom"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let valueFrom = self.valueFrom {
            try encodeContainer.encode(valueFrom, forKey: .valueFrom)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueFrom)
        valueFrom = valueFromDecoded
    }
}

extension SecurityHubClientTypes {
    /// A secret to pass to the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails: Swift.Equatable {
        /// The name of the secret.
        public var name: Swift.String?
        /// The secret to expose to the container. The value is either the full ARN of the Secrets Manager secret or the full ARN of the parameter in the Systems Manager Parameter Store.
        public var valueFrom: Swift.String?

        public init (
            name: Swift.String? = nil,
            valueFrom: Swift.String? = nil
        )
        {
            self.name = name
            self.valueFrom = valueFrom
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace = "Namespace"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A namespaced kernel parameter to set in the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails: Swift.Equatable {
        /// The namespaced kernel parameter for which to set a value.
        public var namespace: Swift.String?
        /// The value of the parameter.
        public var value: Swift.String?

        public init (
            namespace: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.namespace = namespace
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hardLimit = "HardLimit"
        case name = "Name"
        case softLimit = "SoftLimit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hardLimit != 0 {
            try encodeContainer.encode(hardLimit, forKey: .hardLimit)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if softLimit != 0 {
            try encodeContainer.encode(softLimit, forKey: .softLimit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hardLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hardLimit) ?? 0
        hardLimit = hardLimitDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let softLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .softLimit) ?? 0
        softLimit = softLimitDecoded
    }
}

extension SecurityHubClientTypes {
    /// A ulimit to set in the container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails: Swift.Equatable {
        /// The hard limit for the ulimit type.
        public var hardLimit: Swift.Int
        /// The type of the ulimit. Valid values are as follows:
        ///
        /// * core
        ///
        /// * cpu
        ///
        /// * data
        ///
        /// * fsize
        ///
        /// * locks
        ///
        /// * memlock
        ///
        /// * msgqueue
        ///
        /// * nice
        ///
        /// * nofile
        ///
        /// * nproc
        ///
        /// * rss
        ///
        /// * rtprio
        ///
        /// * rttime
        ///
        /// * sigpending
        ///
        /// * stack
        public var name: Swift.String?
        /// The soft limit for the ulimit type.
        public var softLimit: Swift.Int

        public init (
            hardLimit: Swift.Int = 0,
            name: Swift.String? = nil,
            softLimit: Swift.Int = 0
        )
        {
            self.hardLimit = hardLimit
            self.name = name
            self.softLimit = softLimit
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readOnly = "ReadOnly"
        case sourceContainer = "SourceContainer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if readOnly != false {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let sourceContainer = self.sourceContainer {
            try encodeContainer.encode(sourceContainer, forKey: .sourceContainer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .readOnly) ?? false
        readOnly = readOnlyDecoded
        let sourceContainerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceContainer)
        sourceContainer = sourceContainerDecoded
    }
}

extension SecurityHubClientTypes {
    /// A data volume to mount from another container.
    public struct AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails: Swift.Equatable {
        /// Whether the container has read-only access to the volume.
        public var readOnly: Swift.Bool
        /// The name of another container within the same task definition from which to mount volumes.
        public var sourceContainer: Swift.String?

        public init (
            readOnly: Swift.Bool = false,
            sourceContainer: Swift.String? = nil
        )
        {
            self.readOnly = readOnly
            self.sourceContainer = sourceContainer
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerDefinitions = "ContainerDefinitions"
        case cpu = "Cpu"
        case executionRoleArn = "ExecutionRoleArn"
        case family = "Family"
        case inferenceAccelerators = "InferenceAccelerators"
        case ipcMode = "IpcMode"
        case memory = "Memory"
        case networkMode = "NetworkMode"
        case pidMode = "PidMode"
        case placementConstraints = "PlacementConstraints"
        case proxyConfiguration = "ProxyConfiguration"
        case requiresCompatibilities = "RequiresCompatibilities"
        case taskRoleArn = "TaskRoleArn"
        case volumes = "Volumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerDefinitions = containerDefinitions {
            var containerDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containerDefinitions)
            for awsecstaskdefinitioncontainerdefinitionsdetails0 in containerDefinitions {
                try containerDefinitionsContainer.encode(awsecstaskdefinitioncontainerdefinitionsdetails0)
            }
        }
        if let cpu = self.cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let family = self.family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let inferenceAccelerators = inferenceAccelerators {
            var inferenceAcceleratorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inferenceAccelerators)
            for awsecstaskdefinitioninferenceacceleratorsdetails0 in inferenceAccelerators {
                try inferenceAcceleratorsContainer.encode(awsecstaskdefinitioninferenceacceleratorsdetails0)
            }
        }
        if let ipcMode = self.ipcMode {
            try encodeContainer.encode(ipcMode, forKey: .ipcMode)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let networkMode = self.networkMode {
            try encodeContainer.encode(networkMode, forKey: .networkMode)
        }
        if let pidMode = self.pidMode {
            try encodeContainer.encode(pidMode, forKey: .pidMode)
        }
        if let placementConstraints = placementConstraints {
            var placementConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .placementConstraints)
            for awsecstaskdefinitionplacementconstraintsdetails0 in placementConstraints {
                try placementConstraintsContainer.encode(awsecstaskdefinitionplacementconstraintsdetails0)
            }
        }
        if let proxyConfiguration = self.proxyConfiguration {
            try encodeContainer.encode(proxyConfiguration, forKey: .proxyConfiguration)
        }
        if let requiresCompatibilities = requiresCompatibilities {
            var requiresCompatibilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiresCompatibilities)
            for nonemptystring0 in requiresCompatibilities {
                try requiresCompatibilitiesContainer.encode(nonemptystring0)
            }
        }
        if let taskRoleArn = self.taskRoleArn {
            try encodeContainer.encode(taskRoleArn, forKey: .taskRoleArn)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for awsecstaskdefinitionvolumesdetails0 in volumes {
                try volumesContainer.encode(awsecstaskdefinitionvolumesdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerDefinitionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails?].self, forKey: .containerDefinitions)
        var containerDefinitionsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails]? = nil
        if let containerDefinitionsContainer = containerDefinitionsContainer {
            containerDefinitionsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails]()
            for structure0 in containerDefinitionsContainer {
                if let structure0 = structure0 {
                    containerDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        containerDefinitions = containerDefinitionsDecoded0
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let inferenceAcceleratorsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails?].self, forKey: .inferenceAccelerators)
        var inferenceAcceleratorsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails]? = nil
        if let inferenceAcceleratorsContainer = inferenceAcceleratorsContainer {
            inferenceAcceleratorsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails]()
            for structure0 in inferenceAcceleratorsContainer {
                if let structure0 = structure0 {
                    inferenceAcceleratorsDecoded0?.append(structure0)
                }
            }
        }
        inferenceAccelerators = inferenceAcceleratorsDecoded0
        let ipcModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipcMode)
        ipcMode = ipcModeDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let networkModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkMode)
        networkMode = networkModeDecoded
        let pidModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pidMode)
        pidMode = pidModeDecoded
        let placementConstraintsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails?].self, forKey: .placementConstraints)
        var placementConstraintsDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails]? = nil
        if let placementConstraintsContainer = placementConstraintsContainer {
            placementConstraintsDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails]()
            for structure0 in placementConstraintsContainer {
                if let structure0 = structure0 {
                    placementConstraintsDecoded0?.append(structure0)
                }
            }
        }
        placementConstraints = placementConstraintsDecoded0
        let proxyConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails.self, forKey: .proxyConfiguration)
        proxyConfiguration = proxyConfigurationDecoded
        let requiresCompatibilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .requiresCompatibilities)
        var requiresCompatibilitiesDecoded0:[Swift.String]? = nil
        if let requiresCompatibilitiesContainer = requiresCompatibilitiesContainer {
            requiresCompatibilitiesDecoded0 = [Swift.String]()
            for string0 in requiresCompatibilitiesContainer {
                if let string0 = string0 {
                    requiresCompatibilitiesDecoded0?.append(string0)
                }
            }
        }
        requiresCompatibilities = requiresCompatibilitiesDecoded0
        let taskRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskRoleArn)
        taskRoleArn = taskRoleArnDecoded
        let volumesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails?].self, forKey: .volumes)
        var volumesDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.
    public struct AwsEcsTaskDefinitionDetails: Swift.Equatable {
        /// The container definitions that describe the containers that make up the task.
        public var containerDefinitions: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails]?
        /// The number of CPU units used by the task.Valid values are as follows:
        ///
        /// * 256 (.25 vCPU)
        ///
        /// * 512 (.5 vCPU)
        ///
        /// * 1024 (1 vCPU)
        ///
        /// * 2048 (2 vCPU)
        ///
        /// * 4096 (4 vCPU)
        public var cpu: Swift.String?
        /// The ARN of the task execution role that grants the container agent permission to make API calls on behalf of the container user.
        public var executionRoleArn: Swift.String?
        /// The name of a family that this task definition is registered to.
        public var family: Swift.String?
        /// The Elastic Inference accelerators to use for the containers in the task.
        public var inferenceAccelerators: [SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails]?
        /// The inter-process communication (IPC) resource namespace to use for the containers in the task. Valid values are as follows:
        ///
        /// * host
        ///
        /// * none
        ///
        /// * task
        public var ipcMode: Swift.String?
        /// The amount (in MiB) of memory used by the task. For tasks that are hosted on Amazon EC2, you can provide a task-level memory value or a container-level memory value. For tasks that are hosted on Fargate, you must use one of the [specified values](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#task_size) in the Amazon Elastic Container Service Developer Guide , which determines your range of supported values for the Cpu and Memory parameters.
        public var memory: Swift.String?
        /// The Docker networking mode to use for the containers in the task. Valid values are as follows:
        ///
        /// * awsvpc
        ///
        /// * bridge
        ///
        /// * host
        ///
        /// * none
        public var networkMode: Swift.String?
        /// The process namespace to use for the containers in the task. Valid values are host or task.
        public var pidMode: Swift.String?
        /// The placement constraint objects to use for tasks.
        public var placementConstraints: [SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails]?
        /// The configuration details for the App Mesh proxy.
        public var proxyConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails?
        /// The task launch types that the task definition was validated against.
        public var requiresCompatibilities: [Swift.String]?
        /// The short name or ARN of the IAM role that grants containers in the task permission to call Amazon Web Services API operations on your behalf.
        public var taskRoleArn: Swift.String?
        /// The data volume definitions for the task.
        public var volumes: [SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails]?

        public init (
            containerDefinitions: [SecurityHubClientTypes.AwsEcsTaskDefinitionContainerDefinitionsDetails]? = nil,
            cpu: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            family: Swift.String? = nil,
            inferenceAccelerators: [SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails]? = nil,
            ipcMode: Swift.String? = nil,
            memory: Swift.String? = nil,
            networkMode: Swift.String? = nil,
            pidMode: Swift.String? = nil,
            placementConstraints: [SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails]? = nil,
            proxyConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails? = nil,
            requiresCompatibilities: [Swift.String]? = nil,
            taskRoleArn: Swift.String? = nil,
            volumes: [SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails]? = nil
        )
        {
            self.containerDefinitions = containerDefinitions
            self.cpu = cpu
            self.executionRoleArn = executionRoleArn
            self.family = family
            self.inferenceAccelerators = inferenceAccelerators
            self.ipcMode = ipcMode
            self.memory = memory
            self.networkMode = networkMode
            self.pidMode = pidMode
            self.placementConstraints = placementConstraints
            self.proxyConfiguration = proxyConfiguration
            self.requiresCompatibilities = requiresCompatibilities
            self.taskRoleArn = taskRoleArn
            self.volumes = volumes
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionInferenceAcceleratorsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName = "DeviceName"
        case deviceType = "DeviceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceType = self.deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// An Elastic Inference accelerator to use for the containers in the task.
    public struct AwsEcsTaskDefinitionInferenceAcceleratorsDetails: Swift.Equatable {
        /// The Elastic Inference accelerator device name.
        public var deviceName: Swift.String?
        /// The Elastic Inference accelerator type to use.
        public var deviceType: Swift.String?

        public init (
            deviceName: Swift.String? = nil,
            deviceType: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.deviceType = deviceType
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionPlacementConstraintsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression = "Expression"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A placement constraint object to use for tasks.
    public struct AwsEcsTaskDefinitionPlacementConstraintsDetails: Swift.Equatable {
        /// A cluster query language expression to apply to the constraint.
        public var expression: Swift.String?
        /// The type of constraint.
        public var type: Swift.String?

        public init (
            expression: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.expression = expression
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerName = "ContainerName"
        case proxyConfigurationProperties = "ProxyConfigurationProperties"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerName = self.containerName {
            try encodeContainer.encode(containerName, forKey: .containerName)
        }
        if let proxyConfigurationProperties = proxyConfigurationProperties {
            var proxyConfigurationPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .proxyConfigurationProperties)
            for awsecstaskdefinitionproxyconfigurationproxyconfigurationpropertiesdetails0 in proxyConfigurationProperties {
                try proxyConfigurationPropertiesContainer.encode(awsecstaskdefinitionproxyconfigurationproxyconfigurationpropertiesdetails0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerName)
        containerName = containerNameDecoded
        let proxyConfigurationPropertiesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails?].self, forKey: .proxyConfigurationProperties)
        var proxyConfigurationPropertiesDecoded0:[SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]? = nil
        if let proxyConfigurationPropertiesContainer = proxyConfigurationPropertiesContainer {
            proxyConfigurationPropertiesDecoded0 = [SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]()
            for structure0 in proxyConfigurationPropertiesContainer {
                if let structure0 = structure0 {
                    proxyConfigurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        proxyConfigurationProperties = proxyConfigurationPropertiesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// The configuration details for the App Mesh proxy.
    public struct AwsEcsTaskDefinitionProxyConfigurationDetails: Swift.Equatable {
        /// The name of the container that will serve as the App Mesh proxy.
        public var containerName: Swift.String?
        /// The set of network configuration parameters to provide to the Container Network Interface (CNI) plugin, specified as key-value pairs.
        public var proxyConfigurationProperties: [SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]?
        /// The proxy type.
        public var type: Swift.String?

        public init (
            containerName: Swift.String? = nil,
            proxyConfigurationProperties: [SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails]? = nil,
            type: Swift.String? = nil
        )
        {
            self.containerName = containerName
            self.proxyConfigurationProperties = proxyConfigurationProperties
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A network configuration parameter to provide to the Container Network Interface (CNI) plugin.
    public struct AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails: Swift.Equatable {
        /// The name of the property.
        public var name: Swift.String?
        /// The value of the property.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dockerVolumeConfiguration = "DockerVolumeConfiguration"
        case efsVolumeConfiguration = "EfsVolumeConfiguration"
        case host = "Host"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dockerVolumeConfiguration = self.dockerVolumeConfiguration {
            try encodeContainer.encode(dockerVolumeConfiguration, forKey: .dockerVolumeConfiguration)
        }
        if let efsVolumeConfiguration = self.efsVolumeConfiguration {
            try encodeContainer.encode(efsVolumeConfiguration, forKey: .efsVolumeConfiguration)
        }
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dockerVolumeConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails.self, forKey: .dockerVolumeConfiguration)
        dockerVolumeConfiguration = dockerVolumeConfigurationDecoded
        let efsVolumeConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails.self, forKey: .efsVolumeConfiguration)
        efsVolumeConfiguration = efsVolumeConfigurationDecoded
        let hostDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails.self, forKey: .host)
        host = hostDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SecurityHubClientTypes {
    /// A data volume to mount from another container.
    public struct AwsEcsTaskDefinitionVolumesDetails: Swift.Equatable {
        /// Information about a Docker volume.
        public var dockerVolumeConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails?
        /// Information about the Amazon Elastic File System file system that is used for task storage.
        public var efsVolumeConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails?
        /// Information about a bind mount host volume.
        public var host: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails?
        /// The name of the data volume.
        public var name: Swift.String?

        public init (
            dockerVolumeConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails? = nil,
            efsVolumeConfiguration: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails? = nil,
            host: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails? = nil,
            name: Swift.String? = nil
        )
        {
            self.dockerVolumeConfiguration = dockerVolumeConfiguration
            self.efsVolumeConfiguration = efsVolumeConfiguration
            self.host = host
            self.name = name
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoprovision = "Autoprovision"
        case driver = "Driver"
        case driverOpts = "DriverOpts"
        case labels = "Labels"
        case scope = "Scope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoprovision != false {
            try encodeContainer.encode(autoprovision, forKey: .autoprovision)
        }
        if let driver = self.driver {
            try encodeContainer.encode(driver, forKey: .driver)
        }
        if let driverOpts = driverOpts {
            var driverOptsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .driverOpts)
            for (dictKey0, fieldMap0) in driverOpts {
                try driverOptsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .labels)
            for (dictKey0, fieldMap0) in labels {
                try labelsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoprovisionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoprovision) ?? false
        autoprovision = autoprovisionDecoded
        let driverDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .driver)
        driver = driverDecoded
        let driverOptsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .driverOpts)
        var driverOptsDecoded0: [Swift.String:Swift.String]? = nil
        if let driverOptsContainer = driverOptsContainer {
            driverOptsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in driverOptsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    driverOptsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        driverOpts = driverOptsDecoded0
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .labels)
        var labelsDecoded0: [Swift.String:Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in labelsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    labelsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        labels = labelsDecoded0
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a Docker volume.
    public struct AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails: Swift.Equatable {
        /// Whether to create the Docker volume automatically if it does not already exist.
        public var autoprovision: Swift.Bool
        /// The Docker volume driver to use.
        public var driver: Swift.String?
        /// A map of Docker driver-specific options that are passed through.
        public var driverOpts: [Swift.String:Swift.String]?
        /// Custom metadata to add to the Docker volume.
        public var labels: [Swift.String:Swift.String]?
        /// The scope for the Docker volume that determines its lifecycle. Docker volumes that are scoped to a task are provisioned automatically when the task starts and destroyed when the task stops. Docker volumes that are shared persist after the task stops. Valid values are shared or task.
        public var scope: Swift.String?

        public init (
            autoprovision: Swift.Bool = false,
            driver: Swift.String? = nil,
            driverOpts: [Swift.String:Swift.String]? = nil,
            labels: [Swift.String:Swift.String]? = nil,
            scope: Swift.String? = nil
        )
        {
            self.autoprovision = autoprovision
            self.driver = driver
            self.driverOpts = driverOpts
            self.labels = labels
            self.scope = scope
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointId = "AccessPointId"
        case iam = "Iam"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointId = self.accessPointId {
            try encodeContainer.encode(accessPointId, forKey: .accessPointId)
        }
        if let iam = self.iam {
            try encodeContainer.encode(iam, forKey: .iam)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
        let iamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iam)
        iam = iamDecoded
    }
}

extension SecurityHubClientTypes {
    ///
    public struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails: Swift.Equatable {
        /// The Amazon EFS access point identifier to use.
        public var accessPointId: Swift.String?
        /// Whether to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system.
        public var iam: Swift.String?

        public init (
            accessPointId: Swift.String? = nil,
            iam: Swift.String? = nil
        )
        {
            self.accessPointId = accessPointId
            self.iam = iam
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationConfig = "AuthorizationConfig"
        case filesystemId = "FilesystemId"
        case rootDirectory = "RootDirectory"
        case transitEncryption = "TransitEncryption"
        case transitEncryptionPort = "TransitEncryptionPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationConfig = self.authorizationConfig {
            try encodeContainer.encode(authorizationConfig, forKey: .authorizationConfig)
        }
        if let filesystemId = self.filesystemId {
            try encodeContainer.encode(filesystemId, forKey: .filesystemId)
        }
        if let rootDirectory = self.rootDirectory {
            try encodeContainer.encode(rootDirectory, forKey: .rootDirectory)
        }
        if let transitEncryption = self.transitEncryption {
            try encodeContainer.encode(transitEncryption, forKey: .transitEncryption)
        }
        if transitEncryptionPort != 0 {
            try encodeContainer.encode(transitEncryptionPort, forKey: .transitEncryptionPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails.self, forKey: .authorizationConfig)
        authorizationConfig = authorizationConfigDecoded
        let filesystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filesystemId)
        filesystemId = filesystemIdDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
        let transitEncryptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transitEncryption)
        transitEncryption = transitEncryptionDecoded
        let transitEncryptionPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transitEncryptionPort) ?? 0
        transitEncryptionPort = transitEncryptionPortDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the Amazon Elastic File System file system that is used for task storage.
    public struct AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails: Swift.Equatable {
        /// The authorization configuration details for the Amazon EFS file system.
        public var authorizationConfig: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails?
        /// The Amazon EFS file system identifier to use.
        public var filesystemId: Swift.String?
        /// The directory within the Amazon EFS file system to mount as the root directory inside the host.
        public var rootDirectory: Swift.String?
        /// Whether to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server.
        public var transitEncryption: Swift.String?
        /// The port to use when sending encrypted data between the Amazon ECS host and the Amazon EFS server.
        public var transitEncryptionPort: Swift.Int

        public init (
            authorizationConfig: SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails? = nil,
            filesystemId: Swift.String? = nil,
            rootDirectory: Swift.String? = nil,
            transitEncryption: Swift.String? = nil,
            transitEncryptionPort: Swift.Int = 0
        )
        {
            self.authorizationConfig = authorizationConfig
            self.filesystemId = filesystemId
            self.rootDirectory = rootDirectory
            self.transitEncryption = transitEncryption
            self.transitEncryptionPort = transitEncryptionPort
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDefinitionVolumesHostDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a bind mount host volume.
    public struct AwsEcsTaskDefinitionVolumesHostDetails: Swift.Equatable {
        /// The path on the host container instance that is presented to the container.
        public var sourcePath: Swift.String?

        public init (
            sourcePath: Swift.String? = nil
        )
        {
            self.sourcePath = sourcePath
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterArn = "ClusterArn"
        case containers = "Containers"
        case createdAt = "CreatedAt"
        case group = "Group"
        case startedAt = "StartedAt"
        case startedBy = "StartedBy"
        case taskDefinitionArn = "TaskDefinitionArn"
        case version = "Version"
        case volumes = "Volumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for awsecscontainerdetails0 in containers {
                try containersContainer.encode(awsecscontainerdetails0)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encode(startedAt, forKey: .startedAt)
        }
        if let startedBy = self.startedBy {
            try encodeContainer.encode(startedBy, forKey: .startedBy)
        }
        if let taskDefinitionArn = self.taskDefinitionArn {
            try encodeContainer.encode(taskDefinitionArn, forKey: .taskDefinitionArn)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for awsecstaskvolumedetails0 in volumes {
                try volumesContainer.encode(awsecstaskvolumedetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let taskDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskDefinitionArn)
        taskDefinitionArn = taskDefinitionArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let volumesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsTaskVolumeDetails?].self, forKey: .volumes)
        var volumesDecoded0:[SecurityHubClientTypes.AwsEcsTaskVolumeDetails]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [SecurityHubClientTypes.AwsEcsTaskVolumeDetails]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let containersContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEcsContainerDetails?].self, forKey: .containers)
        var containersDecoded0:[SecurityHubClientTypes.AwsEcsContainerDetails]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [SecurityHubClientTypes.AwsEcsContainerDetails]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Provides details about a task in a cluster.
    public struct AwsEcsTaskDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the cluster that hosts the task.
        public var clusterArn: Swift.String?
        /// The containers that are associated with the task.
        public var containers: [SecurityHubClientTypes.AwsEcsContainerDetails]?
        /// The Unix timestamp for the time when the task was created. More specifically, it's for the time when the task entered the PENDING state.
        public var createdAt: Swift.String?
        /// The name of the task group that's associated with the task.
        public var group: Swift.String?
        /// The Unix timestamp for the time when the task started. More specifically, it's for the time when the task transitioned from the PENDING state to the RUNNING state.
        public var startedAt: Swift.String?
        /// The tag specified when a task is started. If an Amazon ECS service started the task, the startedBy parameter contains the deployment ID of that service.
        public var startedBy: Swift.String?
        /// The ARN of the task definition that creates the task.
        public var taskDefinitionArn: Swift.String?
        /// The version counter for the task.
        public var version: Swift.String?
        /// Details about the data volume that is used in a task definition.
        public var volumes: [SecurityHubClientTypes.AwsEcsTaskVolumeDetails]?

        public init (
            clusterArn: Swift.String? = nil,
            containers: [SecurityHubClientTypes.AwsEcsContainerDetails]? = nil,
            createdAt: Swift.String? = nil,
            group: Swift.String? = nil,
            startedAt: Swift.String? = nil,
            startedBy: Swift.String? = nil,
            taskDefinitionArn: Swift.String? = nil,
            version: Swift.String? = nil,
            volumes: [SecurityHubClientTypes.AwsEcsTaskVolumeDetails]? = nil
        )
        {
            self.clusterArn = clusterArn
            self.containers = containers
            self.createdAt = createdAt
            self.group = group
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.taskDefinitionArn = taskDefinitionArn
            self.version = version
            self.volumes = volumes
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskVolumeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case host = "Host"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let host = self.host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let hostDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails.self, forKey: .host)
        host = hostDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about a data volume that's used in a task definition.
    public struct AwsEcsTaskVolumeDetails: Swift.Equatable {
        /// This parameter is specified when you use bind mount host volumes. The contents of the host parameter determine whether your bind mount host volume persists on the host container instance and where it's stored.
        public var host: SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails?
        /// The name of the volume. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are allowed. This name is referenced in the sourceVolume parameter of container definition mountPoints.
        public var name: Swift.String?

        public init (
            host: SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails? = nil,
            name: Swift.String? = nil
        )
        {
            self.host = host
            self.name = name
        }
    }

}

extension SecurityHubClientTypes.AwsEcsTaskVolumeHostDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details on a container instance bind mount host volume.
    public struct AwsEcsTaskVolumeHostDetails: Swift.Equatable {
        /// When the host parameter is used, specify a sourcePath to declare the path on the host container instance that's presented to the container.
        public var sourcePath: Swift.String?

        public init (
            sourcePath: Swift.String? = nil
        )
        {
            self.sourcePath = sourcePath
        }
    }

}

extension SecurityHubClientTypes.AwsEfsAccessPointDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointId = "AccessPointId"
        case arn = "Arn"
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointId = self.accessPointId {
            try encodeContainer.encode(accessPointId, forKey: .accessPointId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let posixUser = self.posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
        if let rootDirectory = self.rootDirectory {
            try encodeContainer.encode(rootDirectory, forKey: .rootDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon EFS access point.
    public struct AwsEfsAccessPointDetails: Swift.Equatable {
        /// The ID of the Amazon EFS access point.
        public var accessPointId: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon EFS access point.
        public var arn: Swift.String?
        /// The opaque string specified in the request to ensure idempotent creation.
        public var clientToken: Swift.String?
        /// The ID of the Amazon EFS file system that the access point applies to.
        public var fileSystemId: Swift.String?
        /// The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point, that is used for all file operations by NFS clients using the access point.
        public var posixUser: SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails?
        /// The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.
        public var rootDirectory: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails?

        public init (
            accessPointId: Swift.String? = nil,
            arn: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            posixUser: SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails? = nil,
            rootDirectory: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails? = nil
        )
        {
            self.accessPointId = accessPointId
            self.arn = arn
            self.clientToken = clientToken
            self.fileSystemId = fileSystemId
            self.posixUser = posixUser
            self.rootDirectory = rootDirectory
        }
    }

}

extension SecurityHubClientTypes.AwsEfsAccessPointPosixUserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gid = "Gid"
        case secondaryGids = "SecondaryGids"
        case uid = "Uid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = self.gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let secondaryGids = secondaryGids {
            var secondaryGidsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryGids)
            for nonemptystring0 in secondaryGids {
                try secondaryGidsContainer.encode(nonemptystring0)
            }
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gid)
        gid = gidDecoded
        let secondaryGidsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .secondaryGids)
        var secondaryGidsDecoded0:[Swift.String]? = nil
        if let secondaryGidsContainer = secondaryGidsContainer {
            secondaryGidsDecoded0 = [Swift.String]()
            for string0 in secondaryGidsContainer {
                if let string0 = string0 {
                    secondaryGidsDecoded0?.append(string0)
                }
            }
        }
        secondaryGids = secondaryGidsDecoded0
        let uidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uid)
        uid = uidDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details for all file system operations using this Amazon EFS access point.
    public struct AwsEfsAccessPointPosixUserDetails: Swift.Equatable {
        /// The POSIX group ID used for all file system operations using this access point.
        public var gid: Swift.String?
        /// Secondary POSIX group IDs used for all file system operations using this access point.
        public var secondaryGids: [Swift.String]?
        /// The POSIX user ID used for all file system operations using this access point.
        public var uid: Swift.String?

        public init (
            gid: Swift.String? = nil,
            secondaryGids: [Swift.String]? = nil,
            uid: Swift.String? = nil
        )
        {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }
    }

}

extension SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerGid = "OwnerGid"
        case ownerUid = "OwnerUid"
        case permissions = "Permissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ownerGid = self.ownerGid {
            try encodeContainer.encode(ownerGid, forKey: .ownerGid)
        }
        if let ownerUid = self.ownerUid {
            try encodeContainer.encode(ownerUid, forKey: .ownerUid)
        }
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerGidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerGid)
        ownerGid = ownerGidDecoded
        let ownerUidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerUid)
        ownerUid = ownerUidDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissions)
        permissions = permissionsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the settings that Amazon EFS uses to create the root directory when a client connects to an access point.
    public struct AwsEfsAccessPointRootDirectoryCreationInfoDetails: Swift.Equatable {
        /// Specifies the POSIX group ID to apply to the root directory.
        public var ownerGid: Swift.String?
        /// Specifies the POSIX user ID to apply to the root directory.
        public var ownerUid: Swift.String?
        /// Specifies the POSIX permissions to apply to the root directory, in the format of an octal number representing the file's mode bits.
        public var permissions: Swift.String?

        public init (
            ownerGid: Swift.String? = nil,
            ownerUid: Swift.String? = nil,
            permissions: Swift.String? = nil
        )
        {
            self.ownerGid = ownerGid
            self.ownerUid = ownerUid
            self.permissions = permissions
        }
    }

}

extension SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationInfo = "CreationInfo"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationInfo = self.creationInfo {
            try encodeContainer.encode(creationInfo, forKey: .creationInfo)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationInfoDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails.self, forKey: .creationInfo)
        creationInfo = creationInfoDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.
    public struct AwsEfsAccessPointRootDirectoryDetails: Swift.Equatable {
        /// Specifies the POSIX IDs and permissions to apply to the access point's root directory.
        public var creationInfo: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails?
        /// Specifies the path on the Amazon EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide CreationInfo.
        public var path: Swift.String?

        public init (
            creationInfo: SecurityHubClientTypes.AwsEfsAccessPointRootDirectoryCreationInfoDetails? = nil,
            path: Swift.String? = nil
        )
        {
            self.creationInfo = creationInfo
            self.path = path
        }
    }

}

extension SecurityHubClientTypes.AwsEksClusterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case certificateAuthorityData = "CertificateAuthorityData"
        case clusterStatus = "ClusterStatus"
        case endpoint = "Endpoint"
        case logging = "Logging"
        case name = "Name"
        case resourcesVpcConfig = "ResourcesVpcConfig"
        case roleArn = "RoleArn"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificateAuthorityData = self.certificateAuthorityData {
            try encodeContainer.encode(certificateAuthorityData, forKey: .certificateAuthorityData)
        }
        if let clusterStatus = self.clusterStatus {
            try encodeContainer.encode(clusterStatus, forKey: .clusterStatus)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourcesVpcConfig = self.resourcesVpcConfig {
            try encodeContainer.encode(resourcesVpcConfig, forKey: .resourcesVpcConfig)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let certificateAuthorityDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityData)
        certificateAuthorityData = certificateAuthorityDataDecoded
        let clusterStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourcesVpcConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails.self, forKey: .resourcesVpcConfig)
        resourcesVpcConfig = resourcesVpcConfigDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEksClusterLoggingDetails.self, forKey: .logging)
        logging = loggingDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon EKS cluster.
    public struct AwsEksClusterDetails: Swift.Equatable {
        /// The ARN of the cluster.
        public var arn: Swift.String?
        /// The certificate authority data for the cluster.
        public var certificateAuthorityData: Swift.String?
        /// The status of the cluster. Valid values are as follows:
        ///
        /// * ACTIVE
        ///
        /// * CREATING
        ///
        /// * DELETING
        ///
        /// * FAILED
        ///
        /// * PENDING
        ///
        /// * UPDATING
        public var clusterStatus: Swift.String?
        /// The endpoint for the Amazon EKS API server.
        public var endpoint: Swift.String?
        /// The logging configuration for the cluster.
        public var logging: SecurityHubClientTypes.AwsEksClusterLoggingDetails?
        /// The name of the cluster.
        public var name: Swift.String?
        /// The VPC configuration used by the cluster control plane.
        public var resourcesVpcConfig: SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails?
        /// The ARN of the IAM role that provides permissions for the Amazon EKS control plane to make calls to Amazon Web Services API operations on your behalf.
        public var roleArn: Swift.String?
        /// The Amazon EKS server version for the cluster.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            certificateAuthorityData: Swift.String? = nil,
            clusterStatus: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            logging: SecurityHubClientTypes.AwsEksClusterLoggingDetails? = nil,
            name: Swift.String? = nil,
            resourcesVpcConfig: SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails? = nil,
            roleArn: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.certificateAuthorityData = certificateAuthorityData
            self.clusterStatus = clusterStatus
            self.endpoint = endpoint
            self.logging = logging
            self.name = name
            self.resourcesVpcConfig = resourcesVpcConfig
            self.roleArn = roleArn
            self.version = version
        }
    }

}

extension SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case types = "Types"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for nonemptystring0 in types {
                try typesContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let typesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .types)
        var typesDecoded0:[Swift.String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [Swift.String]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Details for a cluster logging configuration.
    public struct AwsEksClusterLoggingClusterLoggingDetails: Swift.Equatable {
        /// Whether the logging types that are listed in Types are enabled.
        public var enabled: Swift.Bool
        /// A list of logging types. Valid values are as follows:
        ///
        /// * api
        ///
        /// * audit
        ///
        /// * authenticator
        ///
        /// * controllerManager
        ///
        /// * scheduler
        public var types: [Swift.String]?

        public init (
            enabled: Swift.Bool = false,
            types: [Swift.String]? = nil
        )
        {
            self.enabled = enabled
            self.types = types
        }
    }

}

extension SecurityHubClientTypes.AwsEksClusterLoggingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterLogging = "ClusterLogging"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterLogging = clusterLogging {
            var clusterLoggingContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterLogging)
            for awseksclusterloggingclusterloggingdetails0 in clusterLogging {
                try clusterLoggingContainer.encode(awseksclusterloggingclusterloggingdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterLoggingContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails?].self, forKey: .clusterLogging)
        var clusterLoggingDecoded0:[SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails]? = nil
        if let clusterLoggingContainer = clusterLoggingContainer {
            clusterLoggingDecoded0 = [SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails]()
            for structure0 in clusterLoggingContainer {
                if let structure0 = structure0 {
                    clusterLoggingDecoded0?.append(structure0)
                }
            }
        }
        clusterLogging = clusterLoggingDecoded0
    }
}

extension SecurityHubClientTypes {
    /// The logging configuration for an Amazon EKS cluster.
    public struct AwsEksClusterLoggingDetails: Swift.Equatable {
        /// Cluster logging configurations.
        public var clusterLogging: [SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails]?

        public init (
            clusterLogging: [SecurityHubClientTypes.AwsEksClusterLoggingClusterLoggingDetails]? = nil
        )
        {
            self.clusterLogging = clusterLogging
        }
    }

}

extension SecurityHubClientTypes.AwsEksClusterResourcesVpcConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for nonemptystring0 in subnetIds {
                try subnetIdsContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Information about the VPC configuration used by the cluster control plane.
    public struct AwsEksClusterResourcesVpcConfigDetails: Swift.Equatable {
        /// The security groups that are associated with the cross-account elastic network interfaces that are used to allow communication between your nodes and the Amazon EKS control plane.
        public var securityGroupIds: [Swift.String]?
        /// The subnets that are associated with the cluster.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationName = "ApplicationName"
        case cname = "Cname"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case endpointUrl = "EndpointUrl"
        case environmentArn = "EnvironmentArn"
        case environmentId = "EnvironmentId"
        case environmentLinks = "EnvironmentLinks"
        case environmentName = "EnvironmentName"
        case optionSettings = "OptionSettings"
        case platformArn = "PlatformArn"
        case solutionStackName = "SolutionStackName"
        case status = "Status"
        case tier = "Tier"
        case versionLabel = "VersionLabel"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationName = self.applicationName {
            try encodeContainer.encode(applicationName, forKey: .applicationName)
        }
        if let cname = self.cname {
            try encodeContainer.encode(cname, forKey: .cname)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endpointUrl = self.endpointUrl {
            try encodeContainer.encode(endpointUrl, forKey: .endpointUrl)
        }
        if let environmentArn = self.environmentArn {
            try encodeContainer.encode(environmentArn, forKey: .environmentArn)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let environmentLinks = environmentLinks {
            var environmentLinksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentLinks)
            for awselasticbeanstalkenvironmentenvironmentlink0 in environmentLinks {
                try environmentLinksContainer.encode(awselasticbeanstalkenvironmentenvironmentlink0)
            }
        }
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let optionSettings = optionSettings {
            var optionSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .optionSettings)
            for awselasticbeanstalkenvironmentoptionsetting0 in optionSettings {
                try optionSettingsContainer.encode(awselasticbeanstalkenvironmentoptionsetting0)
            }
        }
        if let platformArn = self.platformArn {
            try encodeContainer.encode(platformArn, forKey: .platformArn)
        }
        if let solutionStackName = self.solutionStackName {
            try encodeContainer.encode(solutionStackName, forKey: .solutionStackName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tier = self.tier {
            try encodeContainer.encode(tier, forKey: .tier)
        }
        if let versionLabel = self.versionLabel {
            try encodeContainer.encode(versionLabel, forKey: .versionLabel)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let cnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cname)
        cname = cnameDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let endpointUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointUrl)
        endpointUrl = endpointUrlDecoded
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let environmentLinksContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink?].self, forKey: .environmentLinks)
        var environmentLinksDecoded0:[SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink]? = nil
        if let environmentLinksContainer = environmentLinksContainer {
            environmentLinksDecoded0 = [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink]()
            for structure0 in environmentLinksContainer {
                if let structure0 = structure0 {
                    environmentLinksDecoded0?.append(structure0)
                }
            }
        }
        environmentLinks = environmentLinksDecoded0
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let optionSettingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting?].self, forKey: .optionSettings)
        var optionSettingsDecoded0:[SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting]? = nil
        if let optionSettingsContainer = optionSettingsContainer {
            optionSettingsDecoded0 = [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting]()
            for structure0 in optionSettingsContainer {
                if let structure0 = structure0 {
                    optionSettingsDecoded0?.append(structure0)
                }
            }
        }
        optionSettings = optionSettingsDecoded0
        let platformArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let tierDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier.self, forKey: .tier)
        tier = tierDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains details about an Elastic Beanstalk environment.
    public struct AwsElasticBeanstalkEnvironmentDetails: Swift.Equatable {
        /// The name of the application that is associated with the environment.
        public var applicationName: Swift.String?
        /// The URL to the CNAME for this environment.
        public var cname: Swift.String?
        /// The creation date for this environment.
        public var dateCreated: Swift.String?
        /// The date when this environment was last modified.
        public var dateUpdated: Swift.String?
        /// A description of the environment.
        public var description: Swift.String?
        /// For load-balanced, autoscaling environments, the URL to the load balancer. For single-instance environments, the IP address of the instance.
        public var endpointUrl: Swift.String?
        /// The ARN of the environment.
        public var environmentArn: Swift.String?
        /// The identifier of the environment.
        public var environmentId: Swift.String?
        /// Links to other environments in the same group.
        public var environmentLinks: [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink]?
        /// The name of the environment.
        public var environmentName: Swift.String?
        /// The configuration setting for the environment.
        public var optionSettings: [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting]?
        /// The ARN of the platform version for the environment.
        public var platformArn: Swift.String?
        /// The name of the solution stack that is deployed with the environment.
        public var solutionStackName: Swift.String?
        /// The current operational status of the environment. Valid values are as follows:
        ///
        /// * Aborting
        ///
        /// * Launching
        ///
        /// * LinkingFrom
        ///
        /// * LinkingTo
        ///
        /// * Ready
        ///
        /// * Terminated
        ///
        /// * Terminating
        ///
        /// * Updating
        public var status: Swift.String?
        /// The tier of the environment.
        public var tier: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier?
        /// The application version of the environment.
        public var versionLabel: Swift.String?

        public init (
            applicationName: Swift.String? = nil,
            cname: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            endpointUrl: Swift.String? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            environmentLinks: [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink]? = nil,
            environmentName: Swift.String? = nil,
            optionSettings: [SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting]? = nil,
            platformArn: Swift.String? = nil,
            solutionStackName: Swift.String? = nil,
            status: Swift.String? = nil,
            tier: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier? = nil,
            versionLabel: Swift.String? = nil
        )
        {
            self.applicationName = applicationName
            self.cname = cname
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.endpointUrl = endpointUrl
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentLinks = environmentLinks
            self.environmentName = environmentName
            self.optionSettings = optionSettings
            self.platformArn = platformArn
            self.solutionStackName = solutionStackName
            self.status = status
            self.tier = tier
            self.versionLabel = versionLabel
        }
    }

}

extension SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentEnvironmentLink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentName = "EnvironmentName"
        case linkName = "LinkName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentName = self.environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let linkName = self.linkName {
            try encodeContainer.encode(linkName, forKey: .linkName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let linkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkName)
        linkName = linkNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a link to another environment that is in the same group.
    public struct AwsElasticBeanstalkEnvironmentEnvironmentLink: Swift.Equatable {
        /// The name of the linked environment.
        public var environmentName: Swift.String?
        /// The name of the environment link.
        public var linkName: Swift.String?

        public init (
            environmentName: Swift.String? = nil,
            linkName: Swift.String? = nil
        )
        {
            self.environmentName = environmentName
            self.linkName = linkName
        }
    }

}

extension SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentOptionSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace = "Namespace"
        case optionName = "OptionName"
        case resourceName = "ResourceName"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let optionName = self.optionName {
            try encodeContainer.encode(optionName, forKey: .optionName)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let optionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionName)
        optionName = optionNameDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A configuration option setting for the environment.
    public struct AwsElasticBeanstalkEnvironmentOptionSetting: Swift.Equatable {
        /// The type of resource that the configuration option is associated with.
        public var namespace: Swift.String?
        /// The name of the option.
        public var optionName: Swift.String?
        /// The name of the resource.
        public var resourceName: Swift.String?
        /// The value of the configuration setting.
        public var value: Swift.String?

        public init (
            namespace: Swift.String? = nil,
            optionName: Swift.String? = nil,
            resourceName: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.namespace = namespace
            self.optionName = optionName
            self.resourceName = resourceName
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentTier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the tier of the environment.
    public struct AwsElasticBeanstalkEnvironmentTier: Swift.Equatable {
        /// The name of the environment tier. Valid values are WebServer or Worker.
        public var name: Swift.String?
        /// The type of environment tier. Valid values are Standard or SQS/HTTP.
        public var type: Swift.String?
        /// The version of the environment tier.
        public var version: Swift.String?

        public init (
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
            self.version = version
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
        case domainEndpointOptions = "DomainEndpointOptions"
        case domainId = "DomainId"
        case domainName = "DomainName"
        case elasticsearchClusterConfig = "ElasticsearchClusterConfig"
        case elasticsearchVersion = "ElasticsearchVersion"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case endpoint = "Endpoint"
        case endpoints = "Endpoints"
        case logPublishingOptions = "LogPublishingOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case serviceSoftwareOptions = "ServiceSoftwareOptions"
        case vpcOptions = "VPCOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicies = self.accessPolicies {
            try encodeContainer.encode(accessPolicies, forKey: .accessPolicies)
        }
        if let domainEndpointOptions = self.domainEndpointOptions {
            try encodeContainer.encode(domainEndpointOptions, forKey: .domainEndpointOptions)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let elasticsearchClusterConfig = self.elasticsearchClusterConfig {
            try encodeContainer.encode(elasticsearchClusterConfig, forKey: .elasticsearchClusterConfig)
        }
        if let elasticsearchVersion = self.elasticsearchVersion {
            try encodeContainer.encode(elasticsearchVersion, forKey: .elasticsearchVersion)
        }
        if let encryptionAtRestOptions = self.encryptionAtRestOptions {
            try encodeContainer.encode(encryptionAtRestOptions, forKey: .encryptionAtRestOptions)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .endpoints)
            for (dictKey0, fieldMap0) in endpoints {
                try endpointsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let logPublishingOptions = self.logPublishingOptions {
            try encodeContainer.encode(logPublishingOptions, forKey: .logPublishingOptions)
        }
        if let nodeToNodeEncryptionOptions = self.nodeToNodeEncryptionOptions {
            try encodeContainer.encode(nodeToNodeEncryptionOptions, forKey: .nodeToNodeEncryptionOptions)
        }
        if let serviceSoftwareOptions = self.serviceSoftwareOptions {
            try encodeContainer.encode(serviceSoftwareOptions, forKey: .serviceSoftwareOptions)
        }
        if let vpcOptions = self.vpcOptions {
            try encodeContainer.encode(vpcOptions, forKey: .vpcOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .endpoints)
        var endpointsDecoded0: [Swift.String:Swift.String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in endpointsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    endpointsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        endpoints = endpointsDecoded0
        let elasticsearchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticsearchVersion)
        elasticsearchVersion = elasticsearchVersionDecoded
        let elasticsearchClusterConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails.self, forKey: .elasticsearchClusterConfig)
        elasticsearchClusterConfig = elasticsearchClusterConfigDecoded
        let encryptionAtRestOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions.self, forKey: .encryptionAtRestOptions)
        encryptionAtRestOptions = encryptionAtRestOptionsDecoded
        let logPublishingOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions.self, forKey: .logPublishingOptions)
        logPublishingOptions = logPublishingOptionsDecoded
        let nodeToNodeEncryptionOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions.self, forKey: .nodeToNodeEncryptionOptions)
        nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptionsDecoded
        let serviceSoftwareOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions.self, forKey: .serviceSoftwareOptions)
        serviceSoftwareOptions = serviceSoftwareOptionsDecoded
        let vpcOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions.self, forKey: .vpcOptions)
        vpcOptions = vpcOptionsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an Elasticsearch domain.
    public struct AwsElasticsearchDomainDetails: Swift.Equatable {
        /// IAM policy document specifying the access policies for the new Elasticsearch domain.
        public var accessPolicies: Swift.String?
        /// Additional options for the domain endpoint.
        public var domainEndpointOptions: SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions?
        /// Unique identifier for an Elasticsearch domain.
        public var domainId: Swift.String?
        /// Name of an Elasticsearch domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region. Domain names must start with a lowercase letter and must be between 3 and 28 characters. Valid characters are a-z (lowercase only), 0-9, and  (hyphen).
        public var domainName: Swift.String?
        /// Information about an OpenSearch cluster configuration.
        public var elasticsearchClusterConfig: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails?
        /// OpenSearch version.
        public var elasticsearchVersion: Swift.String?
        /// Details about the configuration for encryption at rest.
        public var encryptionAtRestOptions: SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions?
        /// Domain-specific endpoint used to submit index, search, and data upload requests to an Elasticsearch domain. The endpoint is a service URL.
        public var endpoint: Swift.String?
        /// The key-value pair that exists if the Elasticsearch domain uses VPC endpoints.
        public var endpoints: [Swift.String:Swift.String]?
        /// Configures the CloudWatch Logs to publish for the Elasticsearch domain.
        public var logPublishingOptions: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions?
        /// Details about the configuration for node-to-node encryption.
        public var nodeToNodeEncryptionOptions: SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions?
        /// Information about the status of a domain relative to the latest service software.
        public var serviceSoftwareOptions: SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions?
        /// Information that OpenSearch derives based on VPCOptions for the domain.
        public var vpcOptions: SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions?

        public init (
            accessPolicies: Swift.String? = nil,
            domainEndpointOptions: SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions? = nil,
            domainId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            elasticsearchClusterConfig: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails? = nil,
            elasticsearchVersion: Swift.String? = nil,
            encryptionAtRestOptions: SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions? = nil,
            endpoint: Swift.String? = nil,
            endpoints: [Swift.String:Swift.String]? = nil,
            logPublishingOptions: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions? = nil,
            nodeToNodeEncryptionOptions: SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions? = nil,
            serviceSoftwareOptions: SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions? = nil,
            vpcOptions: SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions? = nil
        )
        {
            self.accessPolicies = accessPolicies
            self.domainEndpointOptions = domainEndpointOptions
            self.domainId = domainId
            self.domainName = domainName
            self.elasticsearchClusterConfig = elasticsearchClusterConfig
            self.elasticsearchVersion = elasticsearchVersion
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.endpoint = endpoint
            self.endpoints = endpoints
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.vpcOptions = vpcOptions
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainDomainEndpointOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enforceHTTPS = "EnforceHTTPS"
        case tlsSecurityPolicy = "TLSSecurityPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enforceHTTPS != false {
            try encodeContainer.encode(enforceHTTPS, forKey: .enforceHTTPS)
        }
        if let tlsSecurityPolicy = self.tlsSecurityPolicy {
            try encodeContainer.encode(tlsSecurityPolicy, forKey: .tlsSecurityPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceHTTPSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceHTTPS) ?? false
        enforceHTTPS = enforceHTTPSDecoded
        let tlsSecurityPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tlsSecurityPolicy)
        tlsSecurityPolicy = tlsSecurityPolicyDecoded
    }
}

extension SecurityHubClientTypes {
    /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
    public struct AwsElasticsearchDomainDomainEndpointOptions: Swift.Equatable {
        /// Whether to require that all traffic to the domain arrive over HTTPS.
        public var enforceHTTPS: Swift.Bool
        /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain. Valid values:
        ///
        /// * Policy-Min-TLS-1-0-2019-07, which supports TLSv1.0 and higher
        ///
        /// * Policy-Min-TLS-1-2-2019-07, which only supports TLSv1.2
        public var tlsSecurityPolicy: Swift.String?

        public init (
            enforceHTTPS: Swift.Bool = false,
            tlsSecurityPolicy: Swift.String? = nil
        )
        {
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedMasterCount = "DedicatedMasterCount"
        case dedicatedMasterEnabled = "DedicatedMasterEnabled"
        case dedicatedMasterType = "DedicatedMasterType"
        case instanceCount = "InstanceCount"
        case instanceType = "InstanceType"
        case zoneAwarenessConfig = "ZoneAwarenessConfig"
        case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dedicatedMasterCount != 0 {
            try encodeContainer.encode(dedicatedMasterCount, forKey: .dedicatedMasterCount)
        }
        if dedicatedMasterEnabled != false {
            try encodeContainer.encode(dedicatedMasterEnabled, forKey: .dedicatedMasterEnabled)
        }
        if let dedicatedMasterType = self.dedicatedMasterType {
            try encodeContainer.encode(dedicatedMasterType, forKey: .dedicatedMasterType)
        }
        if instanceCount != 0 {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let zoneAwarenessConfig = self.zoneAwarenessConfig {
            try encodeContainer.encode(zoneAwarenessConfig, forKey: .zoneAwarenessConfig)
        }
        if zoneAwarenessEnabled != false {
            try encodeContainer.encode(zoneAwarenessEnabled, forKey: .zoneAwarenessEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dedicatedMasterCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dedicatedMasterCount) ?? 0
        dedicatedMasterCount = dedicatedMasterCountDecoded
        let dedicatedMasterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dedicatedMasterEnabled) ?? false
        dedicatedMasterEnabled = dedicatedMasterEnabledDecoded
        let dedicatedMasterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedMasterType)
        dedicatedMasterType = dedicatedMasterTypeDecoded
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount) ?? 0
        instanceCount = instanceCountDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let zoneAwarenessConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails.self, forKey: .zoneAwarenessConfig)
        zoneAwarenessConfig = zoneAwarenessConfigDecoded
        let zoneAwarenessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .zoneAwarenessEnabled) ?? false
        zoneAwarenessEnabled = zoneAwarenessEnabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// details about the configuration of an OpenSearch cluster.
    public struct AwsElasticsearchDomainElasticsearchClusterConfigDetails: Swift.Equatable {
        /// The number of instances to use for the master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public var dedicatedMasterCount: Swift.Int
        /// Whether to use a dedicated master node for the Elasticsearch domain. A dedicated master node performs cluster management tasks, but doesn't hold data or respond to data upload requests.
        public var dedicatedMasterEnabled: Swift.Bool
        /// The hardware configuration of the computer that hosts the dedicated master node. A sample value is m3.medium.elasticsearch. If this attribute is specified, then DedicatedMasterEnabled must be true. For a list of valid values, see [Supported instance types in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html) in the Amazon OpenSearch Service Developer Guide.
        public var dedicatedMasterType: Swift.String?
        /// The number of data nodes to use in the Elasticsearch domain.
        public var instanceCount: Swift.Int
        /// The instance type for your data nodes. For example, m3.medium.elasticsearch. For a list of valid values, see [Supported instance types in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html) in the Amazon OpenSearch Service Developer Guide.
        public var instanceType: Swift.String?
        /// Configuration options for zone awareness. Provided if ZoneAwarenessEnabled is true.
        public var zoneAwarenessConfig: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails?
        /// Whether to enable zone awareness for the Elasticsearch domain. When zone awareness is enabled, OpenSearch allocates the cluster's nodes and replica index shards across Availability Zones in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.
        public var zoneAwarenessEnabled: Swift.Bool

        public init (
            dedicatedMasterCount: Swift.Int = 0,
            dedicatedMasterEnabled: Swift.Bool = false,
            dedicatedMasterType: Swift.String? = nil,
            instanceCount: Swift.Int = 0,
            instanceType: Swift.String? = nil,
            zoneAwarenessConfig: SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails? = nil,
            zoneAwarenessEnabled: Swift.Bool = false
        )
        {
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneCount = "AvailabilityZoneCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if availabilityZoneCount != 0 {
            try encodeContainer.encode(availabilityZoneCount, forKey: .availabilityZoneCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availabilityZoneCount) ?? 0
        availabilityZoneCount = availabilityZoneCountDecoded
    }
}

extension SecurityHubClientTypes {
    /// Configuration options for zone awareness.
    public struct AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails: Swift.Equatable {
        /// he number of Availability Zones that the domain uses. Valid values are 2 and 3. The default is 2.
        public var availabilityZoneCount: Swift.Int

        public init (
            availabilityZoneCount: Swift.Int = 0
        )
        {
            self.availabilityZoneCount = availabilityZoneCount
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainEncryptionAtRestOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the configuration for encryption at rest.
    public struct AwsElasticsearchDomainEncryptionAtRestOptions: Swift.Equatable {
        /// Whether encryption at rest is enabled.
        public var enabled: Swift.Bool
        /// The KMS key ID. Takes the form 1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a.
        public var kmsKeyId: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "AuditLogs"
        case indexSlowLogs = "IndexSlowLogs"
        case searchSlowLogs = "SearchSlowLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
        if let indexSlowLogs = self.indexSlowLogs {
            try encodeContainer.encode(indexSlowLogs, forKey: .indexSlowLogs)
        }
        if let searchSlowLogs = self.searchSlowLogs {
            try encodeContainer.encode(searchSlowLogs, forKey: .searchSlowLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexSlowLogsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig.self, forKey: .indexSlowLogs)
        indexSlowLogs = indexSlowLogsDecoded
        let searchSlowLogsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig.self, forKey: .searchSlowLogs)
        searchSlowLogs = searchSlowLogsDecoded
        let auditLogsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension SecurityHubClientTypes {
    /// configures the CloudWatch Logs to publish for the Elasticsearch domain.
    public struct AwsElasticsearchDomainLogPublishingOptions: Swift.Equatable {
        /// The log configuration.
        public var auditLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig?
        /// Configures the OpenSearch index logs publishing.
        public var indexSlowLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig?
        /// Configures the OpenSearch search slow log publishing.
        public var searchSlowLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig?

        public init (
            auditLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil,
            indexSlowLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil,
            searchSlowLogs: SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig? = nil
        )
        {
            self.auditLogs = auditLogs
            self.indexSlowLogs = indexSlowLogs
            self.searchSlowLogs = searchSlowLogs
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainLogPublishingOptionsLogConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// The log configuration.
    public struct AwsElasticsearchDomainLogPublishingOptionsLogConfig: Swift.Equatable {
        /// The ARN of the CloudWatch Logs group to publish the logs to.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Whether the log publishing is enabled.
        public var enabled: Swift.Bool

        public init (
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            enabled: Swift.Bool = false
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainNodeToNodeEncryptionOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the configuration for node-to-node encryption.
    public struct AwsElasticsearchDomainNodeToNodeEncryptionOptions: Swift.Equatable {
        /// Whether node-to-node encryption is enabled.
        public var enabled: Swift.Bool

        public init (
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainServiceSoftwareOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedUpdateDate = "AutomatedUpdateDate"
        case cancellable = "Cancellable"
        case currentVersion = "CurrentVersion"
        case description = "Description"
        case newVersion = "NewVersion"
        case updateAvailable = "UpdateAvailable"
        case updateStatus = "UpdateStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automatedUpdateDate = self.automatedUpdateDate {
            try encodeContainer.encode(automatedUpdateDate, forKey: .automatedUpdateDate)
        }
        if cancellable != false {
            try encodeContainer.encode(cancellable, forKey: .cancellable)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let newVersion = self.newVersion {
            try encodeContainer.encode(newVersion, forKey: .newVersion)
        }
        if updateAvailable != false {
            try encodeContainer.encode(updateAvailable, forKey: .updateAvailable)
        }
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus, forKey: .updateStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automatedUpdateDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automatedUpdateDate)
        automatedUpdateDate = automatedUpdateDateDecoded
        let cancellableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cancellable) ?? false
        cancellable = cancellableDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let newVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newVersion)
        newVersion = newVersionDecoded
        let updateAvailableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .updateAvailable) ?? false
        updateAvailable = updateAvailableDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the state of the domain relative to the latest service software.
    public struct AwsElasticsearchDomainServiceSoftwareOptions: Swift.Equatable {
        /// The epoch time when the deployment window closes for required updates. After this time, Amazon OpenSearch Service schedules the software upgrade automatically.
        public var automatedUpdateDate: Swift.String?
        /// Whether a request to update the domain can be canceled.
        public var cancellable: Swift.Bool
        /// The version of the service software that is currently installed on the domain.
        public var currentVersion: Swift.String?
        /// A more detailed description of the service software status.
        public var description: Swift.String?
        /// The most recent version of the service software.
        public var newVersion: Swift.String?
        /// Whether a service software update is available for the domain.
        public var updateAvailable: Swift.Bool
        /// The status of the service software update. Valid values are as follows:
        ///
        /// * COMPLETED
        ///
        /// * ELIGIBLE
        ///
        /// * IN_PROGRESS
        ///
        /// * NOT_ELIGIBLE
        ///
        /// * PENDING_UPDATE
        public var updateStatus: Swift.String?

        public init (
            automatedUpdateDate: Swift.String? = nil,
            cancellable: Swift.Bool = false,
            currentVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            newVersion: Swift.String? = nil,
            updateAvailable: Swift.Bool = false,
            updateStatus: Swift.String? = nil
        )
        {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }
    }

}

extension SecurityHubClientTypes.AwsElasticsearchDomainVPCOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VPCId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for nonemptystring0 in availabilityZones {
                try availabilityZonesContainer.encode(nonemptystring0)
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for nonemptystring0 in subnetIds {
                try subnetIdsContainer.encode(nonemptystring0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information that OpenSearch derives based on VPCOptions for the domain.
    public struct AwsElasticsearchDomainVPCOptions: Swift.Equatable {
        /// The list of Availability Zones associated with the VPC subnets.
        public var availabilityZones: [Swift.String]?
        /// The list of security group IDs associated with the VPC endpoints for the domain.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs associated with the VPC endpoints for the domain.
        public var subnetIds: [Swift.String]?
        /// ID for the VPC.
        public var vpcId: Swift.String?

        public init (
            availabilityZones: [Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieName = "CookieName"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cookieName = self.cookieName {
            try encodeContainer.encode(cookieName, forKey: .cookieName)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cookieName)
        cookieName = cookieNameDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a stickiness policy that was created using CreateAppCookieStickinessPolicy.
    public struct AwsElbAppCookieStickinessPolicy: Swift.Equatable {
        /// The name of the application cookie used for stickiness.
        public var cookieName: Swift.String?
        /// The mnemonic name for the policy being created. The name must be unique within the set of policies for the load balancer.
        public var policyName: Swift.String?

        public init (
            cookieName: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.cookieName = cookieName
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cookieExpirationPeriod = "CookieExpirationPeriod"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cookieExpirationPeriod != 0 {
            try encodeContainer.encode(cookieExpirationPeriod, forKey: .cookieExpirationPeriod)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieExpirationPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cookieExpirationPeriod) ?? 0
        cookieExpirationPeriod = cookieExpirationPeriodDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a stickiness policy that was created using CreateLBCookieStickinessPolicy.
    public struct AwsElbLbCookieStickinessPolicy: Swift.Equatable {
        /// The amount of time, in seconds, after which the cookie is considered stale. If an expiration period is not specified, the stickiness session lasts for the duration of the browser session.
        public var cookieExpirationPeriod: Swift.Int
        /// The name of the policy. The name must be unique within the set of policies for the load balancer.
        public var policyName: Swift.String?

        public init (
            cookieExpirationPeriod: Swift.Int = 0,
            policyName: Swift.String? = nil
        )
        {
            self.cookieExpirationPeriod = cookieExpirationPeriod
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerAccessLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emitInterval = "EmitInterval"
        case enabled = "Enabled"
        case s3BucketName = "S3BucketName"
        case s3BucketPrefix = "S3BucketPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if emitInterval != 0 {
            try encodeContainer.encode(emitInterval, forKey: .emitInterval)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3BucketPrefix = self.s3BucketPrefix {
            try encodeContainer.encode(s3BucketPrefix, forKey: .s3BucketPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emitIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .emitInterval) ?? 0
        emitInterval = emitIntervalDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3BucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketPrefix)
        s3BucketPrefix = s3BucketPrefixDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the access log configuration for the load balancer.
    public struct AwsElbLoadBalancerAccessLog: Swift.Equatable {
        /// The interval in minutes for publishing the access logs. You can publish access logs either every 5 minutes or every 60 minutes.
        public var emitInterval: Swift.Int
        /// Indicates whether access logs are enabled for the load balancer.
        public var enabled: Swift.Bool
        /// The name of the S3 bucket where the access logs are stored.
        public var s3BucketName: Swift.String?
        /// The logical hierarchy that was created for the S3 bucket. If a prefix is not provided, the log is placed at the root level of the bucket.
        public var s3BucketPrefix: Swift.String?

        public init (
            emitInterval: Swift.Int = 0,
            enabled: Swift.Bool = false,
            s3BucketName: Swift.String? = nil,
            s3BucketPrefix: Swift.String? = nil
        )
        {
            self.emitInterval = emitInterval
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.s3BucketPrefix = s3BucketPrefix
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about additional attributes for the load balancer.
    public struct AwsElbLoadBalancerAdditionalAttribute: Swift.Equatable {
        /// The name of the attribute.
        public var key: Swift.String?
        /// The value of the attribute.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLog = "AccessLog"
        case additionalAttributes = "AdditionalAttributes"
        case connectionDraining = "ConnectionDraining"
        case connectionSettings = "ConnectionSettings"
        case crossZoneLoadBalancing = "CrossZoneLoadBalancing"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLog = self.accessLog {
            try encodeContainer.encode(accessLog, forKey: .accessLog)
        }
        if let additionalAttributes = additionalAttributes {
            var additionalAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAttributes)
            for awselbloadbalanceradditionalattribute0 in additionalAttributes {
                try additionalAttributesContainer.encode(awselbloadbalanceradditionalattribute0)
            }
        }
        if let connectionDraining = self.connectionDraining {
            try encodeContainer.encode(connectionDraining, forKey: .connectionDraining)
        }
        if let connectionSettings = self.connectionSettings {
            try encodeContainer.encode(connectionSettings, forKey: .connectionSettings)
        }
        if let crossZoneLoadBalancing = self.crossZoneLoadBalancing {
            try encodeContainer.encode(crossZoneLoadBalancing, forKey: .crossZoneLoadBalancing)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerAccessLog.self, forKey: .accessLog)
        accessLog = accessLogDecoded
        let connectionDrainingDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining.self, forKey: .connectionDraining)
        connectionDraining = connectionDrainingDecoded
        let connectionSettingsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings.self, forKey: .connectionSettings)
        connectionSettings = connectionSettingsDecoded
        let crossZoneLoadBalancingDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing.self, forKey: .crossZoneLoadBalancing)
        crossZoneLoadBalancing = crossZoneLoadBalancingDecoded
        let additionalAttributesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute?].self, forKey: .additionalAttributes)
        var additionalAttributesDecoded0:[SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute]? = nil
        if let additionalAttributesContainer = additionalAttributesContainer {
            additionalAttributesDecoded0 = [SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute]()
            for structure0 in additionalAttributesContainer {
                if let structure0 = structure0 {
                    additionalAttributesDecoded0?.append(structure0)
                }
            }
        }
        additionalAttributes = additionalAttributesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Contains attributes for the load balancer.
    public struct AwsElbLoadBalancerAttributes: Swift.Equatable {
        /// Information about the access log configuration for the load balancer. If the access log is enabled, the load balancer captures detailed information about all requests. It delivers the information to a specified S3 bucket.
        public var accessLog: SecurityHubClientTypes.AwsElbLoadBalancerAccessLog?
        /// Any additional attributes for a load balancer.
        public var additionalAttributes: [SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute]?
        /// Information about the connection draining configuration for the load balancer. If connection draining is enabled, the load balancer allows existing requests to complete before it shifts traffic away from a deregistered or unhealthy instance.
        public var connectionDraining: SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining?
        /// Connection settings for the load balancer. If an idle timeout is configured, the load balancer allows connections to remain idle for the specified duration. When a connection is idle, no data is sent over the connection.
        public var connectionSettings: SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings?
        /// Cross-zone load balancing settings for the load balancer. If cross-zone load balancing is enabled, the load balancer routes the request traffic evenly across all instances regardless of the Availability Zones.
        public var crossZoneLoadBalancing: SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing?

        public init (
            accessLog: SecurityHubClientTypes.AwsElbLoadBalancerAccessLog? = nil,
            additionalAttributes: [SecurityHubClientTypes.AwsElbLoadBalancerAdditionalAttribute]? = nil,
            connectionDraining: SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining? = nil,
            connectionSettings: SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings? = nil,
            crossZoneLoadBalancing: SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing? = nil
        )
        {
            self.accessLog = accessLog
            self.additionalAttributes = additionalAttributes
            self.connectionDraining = connectionDraining
            self.connectionSettings = connectionSettings
            self.crossZoneLoadBalancing = crossZoneLoadBalancing
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePort = "InstancePort"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if instancePort != 0 {
            try encodeContainer.encode(instancePort, forKey: .instancePort)
        }
        if let policyNames = policyNames {
            var policyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyNames)
            for nonemptystring0 in policyNames {
                try policyNamesContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instancePort) ?? 0
        instancePort = instancePortDecoded
        let policyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .policyNames)
        var policyNamesDecoded0:[Swift.String]? = nil
        if let policyNamesContainer = policyNamesContainer {
            policyNamesDecoded0 = [Swift.String]()
            for string0 in policyNamesContainer {
                if let string0 = string0 {
                    policyNamesDecoded0?.append(string0)
                }
            }
        }
        policyNames = policyNamesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the configuration of an EC2 instance for the load balancer.
    public struct AwsElbLoadBalancerBackendServerDescription: Swift.Equatable {
        /// The port on which the EC2 instance is listening.
        public var instancePort: Swift.Int
        /// The names of the policies that are enabled for the EC2 instance.
        public var policyNames: [Swift.String]?

        public init (
            instancePort: Swift.Int = 0,
            policyNames: [Swift.String]? = nil
        )
        {
            self.instancePort = instancePort
            self.policyNames = policyNames
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerConnectionDraining: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout) ?? 0
        timeout = timeoutDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the connection draining configuration for the load balancer.
    public struct AwsElbLoadBalancerConnectionDraining: Swift.Equatable {
        /// Indicates whether connection draining is enabled for the load balancer.
        public var enabled: Swift.Bool
        /// The maximum time, in seconds, to keep the existing connections open before deregistering the instances.
        public var timeout: Swift.Int

        public init (
            enabled: Swift.Bool = false,
            timeout: Swift.Int = 0
        )
        {
            self.enabled = enabled
            self.timeout = timeout
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerConnectionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case idleTimeout = "IdleTimeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if idleTimeout != 0 {
            try encodeContainer.encode(idleTimeout, forKey: .idleTimeout)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idleTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleTimeout) ?? 0
        idleTimeout = idleTimeoutDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains connection settings for the load balancer.
    public struct AwsElbLoadBalancerConnectionSettings: Swift.Equatable {
        /// The time, in seconds, that the connection can be idle (no data is sent over the connection) before it is closed by the load balancer.
        public var idleTimeout: Swift.Int

        public init (
            idleTimeout: Swift.Int = 0
        )
        {
            self.idleTimeout = idleTimeout
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerCrossZoneLoadBalancing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains cross-zone load balancing settings for the load balancer.
    public struct AwsElbLoadBalancerCrossZoneLoadBalancing: Swift.Equatable {
        /// Indicates whether cross-zone load balancing is enabled for the load balancer.
        public var enabled: Swift.Bool

        public init (
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case backendServerDescriptions = "BackendServerDescriptions"
        case canonicalHostedZoneName = "CanonicalHostedZoneName"
        case canonicalHostedZoneNameID = "CanonicalHostedZoneNameID"
        case createdTime = "CreatedTime"
        case dnsName = "DnsName"
        case healthCheck = "HealthCheck"
        case instances = "Instances"
        case listenerDescriptions = "ListenerDescriptions"
        case loadBalancerAttributes = "LoadBalancerAttributes"
        case loadBalancerName = "LoadBalancerName"
        case policies = "Policies"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case sourceSecurityGroup = "SourceSecurityGroup"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for nonemptystring0 in availabilityZones {
                try availabilityZonesContainer.encode(nonemptystring0)
            }
        }
        if let backendServerDescriptions = backendServerDescriptions {
            var backendServerDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backendServerDescriptions)
            for awselbloadbalancerbackendserverdescription0 in backendServerDescriptions {
                try backendServerDescriptionsContainer.encode(awselbloadbalancerbackendserverdescription0)
            }
        }
        if let canonicalHostedZoneName = self.canonicalHostedZoneName {
            try encodeContainer.encode(canonicalHostedZoneName, forKey: .canonicalHostedZoneName)
        }
        if let canonicalHostedZoneNameID = self.canonicalHostedZoneNameID {
            try encodeContainer.encode(canonicalHostedZoneNameID, forKey: .canonicalHostedZoneNameID)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let dnsName = self.dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let healthCheck = self.healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for awselbloadbalancerinstance0 in instances {
                try instancesContainer.encode(awselbloadbalancerinstance0)
            }
        }
        if let listenerDescriptions = listenerDescriptions {
            var listenerDescriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listenerDescriptions)
            for awselbloadbalancerlistenerdescription0 in listenerDescriptions {
                try listenerDescriptionsContainer.encode(awselbloadbalancerlistenerdescription0)
            }
        }
        if let loadBalancerAttributes = self.loadBalancerAttributes {
            try encodeContainer.encode(loadBalancerAttributes, forKey: .loadBalancerAttributes)
        }
        if let loadBalancerName = self.loadBalancerName {
            try encodeContainer.encode(loadBalancerName, forKey: .loadBalancerName)
        }
        if let policies = self.policies {
            try encodeContainer.encode(policies, forKey: .policies)
        }
        if let scheme = self.scheme {
            try encodeContainer.encode(scheme, forKey: .scheme)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for nonemptystring0 in securityGroups {
                try securityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let sourceSecurityGroup = self.sourceSecurityGroup {
            try encodeContainer.encode(sourceSecurityGroup, forKey: .sourceSecurityGroup)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for nonemptystring0 in subnets {
                try subnetsContainer.encode(nonemptystring0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let backendServerDescriptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription?].self, forKey: .backendServerDescriptions)
        var backendServerDescriptionsDecoded0:[SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription]? = nil
        if let backendServerDescriptionsContainer = backendServerDescriptionsContainer {
            backendServerDescriptionsDecoded0 = [SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription]()
            for structure0 in backendServerDescriptionsContainer {
                if let structure0 = structure0 {
                    backendServerDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        backendServerDescriptions = backendServerDescriptionsDecoded0
        let canonicalHostedZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .canonicalHostedZoneName)
        canonicalHostedZoneName = canonicalHostedZoneNameDecoded
        let canonicalHostedZoneNameIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .canonicalHostedZoneNameID)
        canonicalHostedZoneNameID = canonicalHostedZoneNameIDDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let healthCheckDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let instancesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsElbLoadBalancerInstance?].self, forKey: .instances)
        var instancesDecoded0:[SecurityHubClientTypes.AwsElbLoadBalancerInstance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [SecurityHubClientTypes.AwsElbLoadBalancerInstance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let listenerDescriptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription?].self, forKey: .listenerDescriptions)
        var listenerDescriptionsDecoded0:[SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription]? = nil
        if let listenerDescriptionsContainer = listenerDescriptionsContainer {
            listenerDescriptionsDecoded0 = [SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription]()
            for structure0 in listenerDescriptionsContainer {
                if let structure0 = structure0 {
                    listenerDescriptionsDecoded0?.append(structure0)
                }
            }
        }
        listenerDescriptions = listenerDescriptionsDecoded0
        let loadBalancerAttributesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerAttributes.self, forKey: .loadBalancerAttributes)
        loadBalancerAttributes = loadBalancerAttributesDecoded
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let policiesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerPolicies.self, forKey: .policies)
        policies = policiesDecoded
        let schemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheme)
        scheme = schemeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let sourceSecurityGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup.self, forKey: .sourceSecurityGroup)
        sourceSecurityGroup = sourceSecurityGroupDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains details about a Classic Load Balancer.
    public struct AwsElbLoadBalancerDetails: Swift.Equatable {
        /// The list of Availability Zones for the load balancer.
        public var availabilityZones: [Swift.String]?
        /// Information about the configuration of the EC2 instances.
        public var backendServerDescriptions: [SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription]?
        /// The name of the Amazon Route 53 hosted zone for the load balancer.
        public var canonicalHostedZoneName: Swift.String?
        /// The ID of the Amazon Route 53 hosted zone for the load balancer.
        public var canonicalHostedZoneNameID: Swift.String?
        /// Indicates when the load balancer was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdTime: Swift.String?
        /// The DNS name of the load balancer.
        public var dnsName: Swift.String?
        /// Information about the health checks that are conducted on the load balancer.
        public var healthCheck: SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck?
        /// List of EC2 instances for the load balancer.
        public var instances: [SecurityHubClientTypes.AwsElbLoadBalancerInstance]?
        /// The policies that are enabled for the load balancer listeners.
        public var listenerDescriptions: [SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription]?
        /// The attributes for a load balancer.
        public var loadBalancerAttributes: SecurityHubClientTypes.AwsElbLoadBalancerAttributes?
        /// The name of the load balancer.
        public var loadBalancerName: Swift.String?
        /// The policies for a load balancer.
        public var policies: SecurityHubClientTypes.AwsElbLoadBalancerPolicies?
        /// The type of load balancer. Only provided if the load balancer is in a VPC. If Scheme is internet-facing, the load balancer has a public DNS name that resolves to a public IP address. If Scheme is internal, the load balancer has a public DNS name that resolves to a private IP address.
        public var scheme: Swift.String?
        /// The security groups for the load balancer. Only provided if the load balancer is in a VPC.
        public var securityGroups: [Swift.String]?
        /// Information about the security group for the load balancer. This is the security group that is used for inbound rules.
        public var sourceSecurityGroup: SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup?
        /// The list of subnet identifiers for the load balancer.
        public var subnets: [Swift.String]?
        /// The identifier of the VPC for the load balancer.
        public var vpcId: Swift.String?

        public init (
            availabilityZones: [Swift.String]? = nil,
            backendServerDescriptions: [SecurityHubClientTypes.AwsElbLoadBalancerBackendServerDescription]? = nil,
            canonicalHostedZoneName: Swift.String? = nil,
            canonicalHostedZoneNameID: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            dnsName: Swift.String? = nil,
            healthCheck: SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck? = nil,
            instances: [SecurityHubClientTypes.AwsElbLoadBalancerInstance]? = nil,
            listenerDescriptions: [SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription]? = nil,
            loadBalancerAttributes: SecurityHubClientTypes.AwsElbLoadBalancerAttributes? = nil,
            loadBalancerName: Swift.String? = nil,
            policies: SecurityHubClientTypes.AwsElbLoadBalancerPolicies? = nil,
            scheme: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            sourceSecurityGroup: SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup? = nil,
            subnets: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.backendServerDescriptions = backendServerDescriptions
            self.canonicalHostedZoneName = canonicalHostedZoneName
            self.canonicalHostedZoneNameID = canonicalHostedZoneNameID
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.healthCheck = healthCheck
            self.instances = instances
            self.listenerDescriptions = listenerDescriptions
            self.loadBalancerAttributes = loadBalancerAttributes
            self.loadBalancerName = loadBalancerName
            self.policies = policies
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.sourceSecurityGroup = sourceSecurityGroup
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerHealthCheck: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthyThreshold = "HealthyThreshold"
        case interval = "Interval"
        case target = "Target"
        case timeout = "Timeout"
        case unhealthyThreshold = "UnhealthyThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if healthyThreshold != 0 {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if unhealthyThreshold != 0 {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyThreshold) ?? 0
        healthyThreshold = healthyThresholdDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval) ?? 0
        interval = intervalDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout) ?? 0
        timeout = timeoutDecoded
        let unhealthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyThreshold) ?? 0
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the health checks that are conducted on the load balancer.
    public struct AwsElbLoadBalancerHealthCheck: Swift.Equatable {
        /// The number of consecutive health check successes required before the instance is moved to the Healthy state.
        public var healthyThreshold: Swift.Int
        /// The approximate interval, in seconds, between health checks of an individual instance.
        public var interval: Swift.Int
        /// The instance that is being checked. The target specifies the protocol and port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of valid ports is 1 through 65535. For the HTTP and HTTPS protocols, the target also specifies the ping path. For the TCP protocol, the target is specified as TCP: . For the SSL protocol, the target is specified as SSL. . For the HTTP and HTTPS protocols, the target is specified as  :/ .
        public var target: Swift.String?
        /// The amount of time, in seconds, during which no response means a failed health check.
        public var timeout: Swift.Int
        /// The number of consecutive health check failures that must occur before the instance is moved to the Unhealthy state.
        public var unhealthyThreshold: Swift.Int

        public init (
            healthyThreshold: Swift.Int = 0,
            interval: Swift.Int = 0,
            target: Swift.String? = nil,
            timeout: Swift.Int = 0,
            unhealthyThreshold: Swift.Int = 0
        )
        {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.target = target
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId = "InstanceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an EC2 instance for a load balancer.
    public struct AwsElbLoadBalancerInstance: Swift.Equatable {
        /// The instance identifier.
        public var instanceId: Swift.String?

        public init (
            instanceId: Swift.String? = nil
        )
        {
            self.instanceId = instanceId
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerListener: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instancePort = "InstancePort"
        case instanceProtocol = "InstanceProtocol"
        case loadBalancerPort = "LoadBalancerPort"
        case `protocol` = "Protocol"
        case sslCertificateId = "SslCertificateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if instancePort != 0 {
            try encodeContainer.encode(instancePort, forKey: .instancePort)
        }
        if let instanceProtocol = self.instanceProtocol {
            try encodeContainer.encode(instanceProtocol, forKey: .instanceProtocol)
        }
        if loadBalancerPort != 0 {
            try encodeContainer.encode(loadBalancerPort, forKey: .loadBalancerPort)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let sslCertificateId = self.sslCertificateId {
            try encodeContainer.encode(sslCertificateId, forKey: .sslCertificateId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instancePort) ?? 0
        instancePort = instancePortDecoded
        let instanceProtocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProtocol)
        instanceProtocol = instanceProtocolDecoded
        let loadBalancerPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .loadBalancerPort) ?? 0
        loadBalancerPort = loadBalancerPortDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let sslCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslCertificateId)
        sslCertificateId = sslCertificateIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a load balancer listener.
    public struct AwsElbLoadBalancerListener: Swift.Equatable {
        /// The port on which the instance is listening.
        public var instancePort: Swift.Int
        /// The protocol to use to route traffic to instances. Valid values: HTTP | HTTPS | TCP | SSL
        public var instanceProtocol: Swift.String?
        /// The port on which the load balancer is listening. On EC2-VPC, you can specify any port from the range 1-65535. On EC2-Classic, you can specify any port from the following list: 25, 80, 443, 465, 587, 1024-65535.
        public var loadBalancerPort: Swift.Int
        /// The load balancer transport protocol to use for routing. Valid values: HTTP | HTTPS | TCP | SSL
        public var `protocol`: Swift.String?
        /// The ARN of the server certificate.
        public var sslCertificateId: Swift.String?

        public init (
            instancePort: Swift.Int = 0,
            instanceProtocol: Swift.String? = nil,
            loadBalancerPort: Swift.Int = 0,
            `protocol`: Swift.String? = nil,
            sslCertificateId: Swift.String? = nil
        )
        {
            self.instancePort = instancePort
            self.instanceProtocol = instanceProtocol
            self.loadBalancerPort = loadBalancerPort
            self.`protocol` = `protocol`
            self.sslCertificateId = sslCertificateId
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerListenerDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case listener = "Listener"
        case policyNames = "PolicyNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listener = self.listener {
            try encodeContainer.encode(listener, forKey: .listener)
        }
        if let policyNames = policyNames {
            var policyNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyNames)
            for nonemptystring0 in policyNames {
                try policyNamesContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerListener.self, forKey: .listener)
        listener = listenerDecoded
        let policyNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .policyNames)
        var policyNamesDecoded0:[Swift.String]? = nil
        if let policyNamesContainer = policyNamesContainer {
            policyNamesDecoded0 = [Swift.String]()
            for string0 in policyNamesContainer {
                if let string0 = string0 {
                    policyNamesDecoded0?.append(string0)
                }
            }
        }
        policyNames = policyNamesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Lists the policies that are enabled for a load balancer listener.
    public struct AwsElbLoadBalancerListenerDescription: Swift.Equatable {
        /// Information about the listener.
        public var listener: SecurityHubClientTypes.AwsElbLoadBalancerListener?
        /// The policies enabled for the listener.
        public var policyNames: [Swift.String]?

        public init (
            listener: SecurityHubClientTypes.AwsElbLoadBalancerListener? = nil,
            policyNames: [Swift.String]? = nil
        )
        {
            self.listener = listener
            self.policyNames = policyNames
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerPolicies: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appCookieStickinessPolicies = "AppCookieStickinessPolicies"
        case lbCookieStickinessPolicies = "LbCookieStickinessPolicies"
        case otherPolicies = "OtherPolicies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appCookieStickinessPolicies = appCookieStickinessPolicies {
            var appCookieStickinessPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appCookieStickinessPolicies)
            for awselbappcookiestickinesspolicy0 in appCookieStickinessPolicies {
                try appCookieStickinessPoliciesContainer.encode(awselbappcookiestickinesspolicy0)
            }
        }
        if let lbCookieStickinessPolicies = lbCookieStickinessPolicies {
            var lbCookieStickinessPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lbCookieStickinessPolicies)
            for awselblbcookiestickinesspolicy0 in lbCookieStickinessPolicies {
                try lbCookieStickinessPoliciesContainer.encode(awselblbcookiestickinesspolicy0)
            }
        }
        if let otherPolicies = otherPolicies {
            var otherPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .otherPolicies)
            for nonemptystring0 in otherPolicies {
                try otherPoliciesContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appCookieStickinessPoliciesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy?].self, forKey: .appCookieStickinessPolicies)
        var appCookieStickinessPoliciesDecoded0:[SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy]? = nil
        if let appCookieStickinessPoliciesContainer = appCookieStickinessPoliciesContainer {
            appCookieStickinessPoliciesDecoded0 = [SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy]()
            for structure0 in appCookieStickinessPoliciesContainer {
                if let structure0 = structure0 {
                    appCookieStickinessPoliciesDecoded0?.append(structure0)
                }
            }
        }
        appCookieStickinessPolicies = appCookieStickinessPoliciesDecoded0
        let lbCookieStickinessPoliciesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy?].self, forKey: .lbCookieStickinessPolicies)
        var lbCookieStickinessPoliciesDecoded0:[SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy]? = nil
        if let lbCookieStickinessPoliciesContainer = lbCookieStickinessPoliciesContainer {
            lbCookieStickinessPoliciesDecoded0 = [SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy]()
            for structure0 in lbCookieStickinessPoliciesContainer {
                if let structure0 = structure0 {
                    lbCookieStickinessPoliciesDecoded0?.append(structure0)
                }
            }
        }
        lbCookieStickinessPolicies = lbCookieStickinessPoliciesDecoded0
        let otherPoliciesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .otherPolicies)
        var otherPoliciesDecoded0:[Swift.String]? = nil
        if let otherPoliciesContainer = otherPoliciesContainer {
            otherPoliciesDecoded0 = [Swift.String]()
            for string0 in otherPoliciesContainer {
                if let string0 = string0 {
                    otherPoliciesDecoded0?.append(string0)
                }
            }
        }
        otherPolicies = otherPoliciesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the policies for a load balancer.
    public struct AwsElbLoadBalancerPolicies: Swift.Equatable {
        /// The stickiness policies that are created using CreateAppCookieStickinessPolicy.
        public var appCookieStickinessPolicies: [SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy]?
        /// The stickiness policies that are created using CreateLBCookieStickinessPolicy.
        public var lbCookieStickinessPolicies: [SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy]?
        /// The policies other than the stickiness policies.
        public var otherPolicies: [Swift.String]?

        public init (
            appCookieStickinessPolicies: [SecurityHubClientTypes.AwsElbAppCookieStickinessPolicy]? = nil,
            lbCookieStickinessPolicies: [SecurityHubClientTypes.AwsElbLbCookieStickinessPolicy]? = nil,
            otherPolicies: [Swift.String]? = nil
        )
        {
            self.appCookieStickinessPolicies = appCookieStickinessPolicies
            self.lbCookieStickinessPolicies = lbCookieStickinessPolicies
            self.otherPolicies = otherPolicies
        }
    }

}

extension SecurityHubClientTypes.AwsElbLoadBalancerSourceSecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupName = "GroupName"
        case ownerAlias = "OwnerAlias"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let ownerAlias = self.ownerAlias {
            try encodeContainer.encode(ownerAlias, forKey: .ownerAlias)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let ownerAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAlias)
        ownerAlias = ownerAliasDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about the security group for the load balancer.
    public struct AwsElbLoadBalancerSourceSecurityGroup: Swift.Equatable {
        /// The name of the security group.
        public var groupName: Swift.String?
        /// The owner of the security group.
        public var ownerAlias: Swift.String?

        public init (
            groupName: Swift.String? = nil,
            ownerAlias: Swift.String? = nil
        )
        {
            self.groupName = groupName
            self.ownerAlias = ownerAlias
        }
    }

}

extension SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A load balancer attribute.
    public struct AwsElbv2LoadBalancerAttribute: Swift.Equatable {
        /// The name of the load balancer attribute.
        public var key: Swift.String?
        /// The value of the load balancer attribute.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsElbv2LoadBalancerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case canonicalHostedZoneId = "CanonicalHostedZoneId"
        case createdTime = "CreatedTime"
        case dnsName = "DNSName"
        case ipAddressType = "IpAddressType"
        case loadBalancerAttributes = "LoadBalancerAttributes"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case state = "State"
        case type = "Type"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzone0)
            }
        }
        if let canonicalHostedZoneId = self.canonicalHostedZoneId {
            try encodeContainer.encode(canonicalHostedZoneId, forKey: .canonicalHostedZoneId)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let dnsName = self.dnsName {
            try encodeContainer.encode(dnsName, forKey: .dnsName)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType, forKey: .ipAddressType)
        }
        if let loadBalancerAttributes = loadBalancerAttributes {
            var loadBalancerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loadBalancerAttributes)
            for awselbv2loadbalancerattribute0 in loadBalancerAttributes {
                try loadBalancerAttributesContainer.encode(awselbv2loadbalancerattribute0)
            }
        }
        if let scheme = self.scheme {
            try encodeContainer.encode(scheme, forKey: .scheme)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for nonemptystring0 in securityGroups {
                try securityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AvailabilityZone?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[SecurityHubClientTypes.AvailabilityZone]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [SecurityHubClientTypes.AvailabilityZone]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let canonicalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .canonicalHostedZoneId)
        canonicalHostedZoneId = canonicalHostedZoneIdDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let dnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsName)
        dnsName = dnsNameDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let schemeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheme)
        scheme = schemeDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.LoadBalancerState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let loadBalancerAttributesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute?].self, forKey: .loadBalancerAttributes)
        var loadBalancerAttributesDecoded0:[SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute]? = nil
        if let loadBalancerAttributesContainer = loadBalancerAttributesContainer {
            loadBalancerAttributesDecoded0 = [SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute]()
            for structure0 in loadBalancerAttributesContainer {
                if let structure0 = structure0 {
                    loadBalancerAttributesDecoded0?.append(structure0)
                }
            }
        }
        loadBalancerAttributes = loadBalancerAttributesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Information about a load balancer.
    public struct AwsElbv2LoadBalancerDetails: Swift.Equatable {
        /// The Availability Zones for the load balancer.
        public var availabilityZones: [SecurityHubClientTypes.AvailabilityZone]?
        /// The ID of the Amazon Route 53 hosted zone associated with the load balancer.
        public var canonicalHostedZoneId: Swift.String?
        /// Indicates when the load balancer was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdTime: Swift.String?
        /// The public DNS name of the load balancer.
        public var dnsName: Swift.String?
        /// The type of IP addresses used by the subnets for your load balancer. The possible values are ipv4 (for IPv4 addresses) and dualstack (for IPv4 and IPv6 addresses).
        public var ipAddressType: Swift.String?
        /// Attributes of the load balancer.
        public var loadBalancerAttributes: [SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute]?
        /// The nodes of an Internet-facing load balancer have public IP addresses.
        public var scheme: Swift.String?
        /// The IDs of the security groups for the load balancer.
        public var securityGroups: [Swift.String]?
        /// The state of the load balancer.
        public var state: SecurityHubClientTypes.LoadBalancerState?
        /// The type of load balancer.
        public var type: Swift.String?
        /// The ID of the VPC for the load balancer.
        public var vpcId: Swift.String?

        public init (
            availabilityZones: [SecurityHubClientTypes.AvailabilityZone]? = nil,
            canonicalHostedZoneId: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            dnsName: Swift.String? = nil,
            ipAddressType: Swift.String? = nil,
            loadBalancerAttributes: [SecurityHubClientTypes.AwsElbv2LoadBalancerAttribute]? = nil,
            scheme: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            state: SecurityHubClientTypes.LoadBalancerState? = nil,
            type: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.canonicalHostedZoneId = canonicalHostedZoneId
            self.createdTime = createdTime
            self.dnsName = dnsName
            self.ipAddressType = ipAddressType
            self.loadBalancerAttributes = loadBalancerAttributes
            self.scheme = scheme
            self.securityGroups = securityGroups
            self.state = state
            self.type = type
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsIamAccessKeyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "AccessKeyId"
        case accountId = "AccountId"
        case createdAt = "CreatedAt"
        case principalId = "PrincipalId"
        case principalName = "PrincipalName"
        case principalType = "PrincipalType"
        case sessionContext = "SessionContext"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalName = self.principalName {
            try encodeContainer.encode(principalName, forKey: .principalName)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType, forKey: .principalType)
        }
        if let sessionContext = self.sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamAccessKeyStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalName)
        principalName = principalNameDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamAccessKeySessionContext.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension SecurityHubClientTypes {
    /// IAM access key details related to a finding.
    public struct AwsIamAccessKeyDetails: Swift.Equatable {
        /// The identifier of the access key.
        public var accessKeyId: Swift.String?
        /// The Amazon Web Services account ID of the account for the key.
        public var accountId: Swift.String?
        /// Indicates when the IAM access key was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdAt: Swift.String?
        /// The ID of the principal associated with an access key.
        public var principalId: Swift.String?
        /// The name of the principal.
        public var principalName: Swift.String?
        /// The type of principal associated with an access key.
        public var principalType: Swift.String?
        /// Information about the session that the key was used for.
        public var sessionContext: SecurityHubClientTypes.AwsIamAccessKeySessionContext?
        /// The status of the IAM access key related to a finding.
        public var status: SecurityHubClientTypes.AwsIamAccessKeyStatus?
        /// The user associated with the IAM access key related to a finding. The UserName parameter has been replaced with the PrincipalName parameter because access keys can also be assigned to principals that are not IAM users.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use PrincipalName.")
        public var userName: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            accountId: Swift.String? = nil,
            createdAt: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalName: Swift.String? = nil,
            principalType: Swift.String? = nil,
            sessionContext: SecurityHubClientTypes.AwsIamAccessKeySessionContext? = nil,
            status: SecurityHubClientTypes.AwsIamAccessKeyStatus? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.createdAt = createdAt
            self.principalId = principalId
            self.principalName = principalName
            self.principalType = principalType
            self.sessionContext = sessionContext
            self.status = status
            self.userName = userName
        }
    }

}

extension SecurityHubClientTypes.AwsIamAccessKeySessionContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case sessionIssuer = "SessionIssuer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = self.attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let sessionIssuer = self.sessionIssuer {
            try encodeContainer.encode(sessionIssuer, forKey: .sessionIssuer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
        let sessionIssuerDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer.self, forKey: .sessionIssuer)
        sessionIssuer = sessionIssuerDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the session that the key was used for.
    public struct AwsIamAccessKeySessionContext: Swift.Equatable {
        /// Attributes of the session that the key was used for.
        public var attributes: SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes?
        /// Information about the entity that created the session.
        public var sessionIssuer: SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer?

        public init (
            attributes: SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes? = nil,
            sessionIssuer: SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer? = nil
        )
        {
            self.attributes = attributes
            self.sessionIssuer = sessionIssuer
        }
    }

}

extension SecurityHubClientTypes.AwsIamAccessKeySessionContextAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case mfaAuthenticated = "MfaAuthenticated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if mfaAuthenticated != false {
            try encodeContainer.encode(mfaAuthenticated, forKey: .mfaAuthenticated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mfaAuthenticatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mfaAuthenticated) ?? false
        mfaAuthenticated = mfaAuthenticatedDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
    }
}

extension SecurityHubClientTypes {
    /// Attributes of the session that the key was used for.
    public struct AwsIamAccessKeySessionContextAttributes: Swift.Equatable {
        /// Indicates when the session was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var creationDate: Swift.String?
        /// Indicates whether the session used multi-factor authentication (MFA).
        public var mfaAuthenticated: Swift.Bool

        public init (
            creationDate: Swift.String? = nil,
            mfaAuthenticated: Swift.Bool = false
        )
        {
            self.creationDate = creationDate
            self.mfaAuthenticated = mfaAuthenticated
        }
    }

}

extension SecurityHubClientTypes.AwsIamAccessKeySessionContextSessionIssuer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case arn = "Arn"
        case principalId = "PrincipalId"
        case type = "Type"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the entity that created the session.
    public struct AwsIamAccessKeySessionContextSessionIssuer: Swift.Equatable {
        /// The identifier of the Amazon Web Services account that created the session.
        public var accountId: Swift.String?
        /// The ARN of the session.
        public var arn: Swift.String?
        /// The principal ID of the principal (user, role, or group) that created the session.
        public var principalId: Swift.String?
        /// The type of principal (user, role, or group) that created the session.
        public var type: Swift.String?
        /// The name of the principal that created the session.
        public var userName: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            type: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.type = type
            self.userName = userName
        }
    }

}

extension SecurityHubClientTypes {
    public enum AwsIamAccessKeyStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsIamAccessKeyStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsIamAccessKeyStatus(rawValue: rawValue) ?? AwsIamAccessKeyStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.AwsIamAttachedManagedPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyArn = "PolicyArn"
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// A managed policy that is attached to an IAM principal.
    public struct AwsIamAttachedManagedPolicy: Swift.Equatable {
        /// The ARN of the policy.
        public var policyArn: Swift.String?
        /// The name of the policy.
        public var policyName: Swift.String?

        public init (
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil
        )
        {
            self.policyArn = policyArn
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes.AwsIamGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupId = "GroupId"
        case groupName = "GroupName"
        case groupPolicyList = "GroupPolicyList"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedManagedPolicies = attachedManagedPolicies {
            var attachedManagedPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedManagedPolicies)
            for awsiamattachedmanagedpolicy0 in attachedManagedPolicies {
                try attachedManagedPoliciesContainer.encode(awsiamattachedmanagedpolicy0)
            }
        }
        if let createDate = self.createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let groupPolicyList = groupPolicyList {
            var groupPolicyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupPolicyList)
            for awsiamgrouppolicy0 in groupPolicyList {
                try groupPolicyListContainer.encode(awsiamgrouppolicy0)
            }
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsIamAttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[SecurityHubClientTypes.AwsIamAttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let createDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createDate)
        createDate = createDateDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupPolicyListContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsIamGroupPolicy?].self, forKey: .groupPolicyList)
        var groupPolicyListDecoded0:[SecurityHubClientTypes.AwsIamGroupPolicy]? = nil
        if let groupPolicyListContainer = groupPolicyListContainer {
            groupPolicyListDecoded0 = [SecurityHubClientTypes.AwsIamGroupPolicy]()
            for structure0 in groupPolicyListContainer {
                if let structure0 = structure0 {
                    groupPolicyListDecoded0?.append(structure0)
                }
            }
        }
        groupPolicyList = groupPolicyListDecoded0
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains details about an IAM group.
    public struct AwsIamGroupDetails: Swift.Equatable {
        /// A list of the managed policies that are attached to the IAM group.
        public var attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]?
        /// Indicates when the IAM group was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createDate: Swift.String?
        /// The identifier of the IAM group.
        public var groupId: Swift.String?
        /// The name of the IAM group.
        public var groupName: Swift.String?
        /// The list of inline policies that are embedded in the group.
        public var groupPolicyList: [SecurityHubClientTypes.AwsIamGroupPolicy]?
        /// The path to the group.
        public var path: Swift.String?

        public init (
            attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]? = nil,
            createDate: Swift.String? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            groupPolicyList: [SecurityHubClientTypes.AwsIamGroupPolicy]? = nil,
            path: Swift.String? = nil
        )
        {
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupId = groupId
            self.groupName = groupName
            self.groupPolicyList = groupPolicyList
            self.path = path
        }
    }

}

extension SecurityHubClientTypes.AwsIamGroupPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// A managed policy that is attached to the IAM group.
    public struct AwsIamGroupPolicy: Swift.Equatable {
        /// The name of the policy.
        public var policyName: Swift.String?

        public init (
            policyName: Swift.String? = nil
        )
        {
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes.AwsIamInstanceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createDate = "CreateDate"
        case instanceProfileId = "InstanceProfileId"
        case instanceProfileName = "InstanceProfileName"
        case path = "Path"
        case roles = "Roles"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createDate = self.createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let instanceProfileId = self.instanceProfileId {
            try encodeContainer.encode(instanceProfileId, forKey: .instanceProfileId)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for awsiaminstanceprofilerole0 in roles {
                try rolesContainer.encode(awsiaminstanceprofilerole0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createDate)
        createDate = createDateDecoded
        let instanceProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileId)
        instanceProfileId = instanceProfileIdDecoded
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let rolesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsIamInstanceProfileRole?].self, forKey: .roles)
        var rolesDecoded0:[SecurityHubClientTypes.AwsIamInstanceProfileRole]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [SecurityHubClientTypes.AwsIamInstanceProfileRole]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Information about an instance profile.
    public struct AwsIamInstanceProfile: Swift.Equatable {
        /// The ARN of the instance profile.
        public var arn: Swift.String?
        /// Indicates when the instance profile was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createDate: Swift.String?
        /// The identifier of the instance profile.
        public var instanceProfileId: Swift.String?
        /// The name of the instance profile.
        public var instanceProfileName: Swift.String?
        /// The path to the instance profile.
        public var path: Swift.String?
        /// The roles associated with the instance profile.
        public var roles: [SecurityHubClientTypes.AwsIamInstanceProfileRole]?

        public init (
            arn: Swift.String? = nil,
            createDate: Swift.String? = nil,
            instanceProfileId: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            path: Swift.String? = nil,
            roles: [SecurityHubClientTypes.AwsIamInstanceProfileRole]? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.instanceProfileId = instanceProfileId
            self.instanceProfileName = instanceProfileName
            self.path = path
            self.roles = roles
        }
    }

}

extension SecurityHubClientTypes.AwsIamInstanceProfileRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case createDate = "CreateDate"
        case path = "Path"
        case roleId = "RoleId"
        case roleName = "RoleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assumeRolePolicyDocument = self.assumeRolePolicyDocument {
            try encodeContainer.encode(assumeRolePolicyDocument, forKey: .assumeRolePolicyDocument)
        }
        if let createDate = self.createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let roleId = self.roleId {
            try encodeContainer.encode(roleId, forKey: .roleId)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createDate)
        createDate = createDateDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a role associated with an instance profile.
    public struct AwsIamInstanceProfileRole: Swift.Equatable {
        /// The ARN of the role.
        public var arn: Swift.String?
        /// The policy that grants an entity permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// Indicates when the role was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createDate: Swift.String?
        /// The path to the role.
        public var path: Swift.String?
        /// The identifier of the role.
        public var roleId: Swift.String?
        /// The name of the role.
        public var roleName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            assumeRolePolicyDocument: Swift.String? = nil,
            createDate: Swift.String? = nil,
            path: Swift.String? = nil,
            roleId: Swift.String? = nil,
            roleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.createDate = createDate
            self.path = path
            self.roleId = roleId
            self.roleName = roleName
        }
    }

}

extension SecurityHubClientTypes.AwsIamPermissionsBoundary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundaryArn = "PermissionsBoundaryArn"
        case permissionsBoundaryType = "PermissionsBoundaryType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionsBoundaryArn = self.permissionsBoundaryArn {
            try encodeContainer.encode(permissionsBoundaryArn, forKey: .permissionsBoundaryArn)
        }
        if let permissionsBoundaryType = self.permissionsBoundaryType {
            try encodeContainer.encode(permissionsBoundaryType, forKey: .permissionsBoundaryType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsBoundaryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundaryArn)
        permissionsBoundaryArn = permissionsBoundaryArnDecoded
        let permissionsBoundaryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionsBoundaryType)
        permissionsBoundaryType = permissionsBoundaryTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the policy used to set the permissions boundary for an IAM principal.
    public struct AwsIamPermissionsBoundary: Swift.Equatable {
        /// The ARN of the policy used to set the permissions boundary.
        public var permissionsBoundaryArn: Swift.String?
        /// The usage type for the permissions boundary.
        public var permissionsBoundaryType: Swift.String?

        public init (
            permissionsBoundaryArn: Swift.String? = nil,
            permissionsBoundaryType: Swift.String? = nil
        )
        {
            self.permissionsBoundaryArn = permissionsBoundaryArn
            self.permissionsBoundaryType = permissionsBoundaryType
        }
    }

}

extension SecurityHubClientTypes.AwsIamPolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentCount = "AttachmentCount"
        case createDate = "CreateDate"
        case defaultVersionId = "DefaultVersionId"
        case description = "Description"
        case isAttachable = "IsAttachable"
        case path = "Path"
        case permissionsBoundaryUsageCount = "PermissionsBoundaryUsageCount"
        case policyId = "PolicyId"
        case policyName = "PolicyName"
        case policyVersionList = "PolicyVersionList"
        case updateDate = "UpdateDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attachmentCount != 0 {
            try encodeContainer.encode(attachmentCount, forKey: .attachmentCount)
        }
        if let createDate = self.createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let defaultVersionId = self.defaultVersionId {
            try encodeContainer.encode(defaultVersionId, forKey: .defaultVersionId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isAttachable != false {
            try encodeContainer.encode(isAttachable, forKey: .isAttachable)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if permissionsBoundaryUsageCount != 0 {
            try encodeContainer.encode(permissionsBoundaryUsageCount, forKey: .permissionsBoundaryUsageCount)
        }
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
        if let policyVersionList = policyVersionList {
            var policyVersionListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .policyVersionList)
            for awsiampolicyversion0 in policyVersionList {
                try policyVersionListContainer.encode(awsiampolicyversion0)
            }
        }
        if let updateDate = self.updateDate {
            try encodeContainer.encode(updateDate, forKey: .updateDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentCount) ?? 0
        attachmentCount = attachmentCountDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createDate)
        createDate = createDateDecoded
        let defaultVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultVersionId)
        defaultVersionId = defaultVersionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isAttachableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isAttachable) ?? false
        isAttachable = isAttachableDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let permissionsBoundaryUsageCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionsBoundaryUsageCount) ?? 0
        permissionsBoundaryUsageCount = permissionsBoundaryUsageCountDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
        let policyVersionListContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsIamPolicyVersion?].self, forKey: .policyVersionList)
        var policyVersionListDecoded0:[SecurityHubClientTypes.AwsIamPolicyVersion]? = nil
        if let policyVersionListContainer = policyVersionListContainer {
            policyVersionListDecoded0 = [SecurityHubClientTypes.AwsIamPolicyVersion]()
            for structure0 in policyVersionListContainer {
                if let structure0 = structure0 {
                    policyVersionListDecoded0?.append(structure0)
                }
            }
        }
        policyVersionList = policyVersionListDecoded0
        let updateDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateDate)
        updateDate = updateDateDecoded
    }
}

extension SecurityHubClientTypes {
    /// Represents an IAM permissions policy.
    public struct AwsIamPolicyDetails: Swift.Equatable {
        /// The number of users, groups, and roles that the policy is attached to.
        public var attachmentCount: Swift.Int
        /// When the policy was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createDate: Swift.String?
        /// The identifier of the default version of the policy.
        public var defaultVersionId: Swift.String?
        /// A description of the policy.
        public var description: Swift.String?
        /// Whether the policy can be attached to a user, group, or role.
        public var isAttachable: Swift.Bool
        /// The path to the policy.
        public var path: Swift.String?
        /// The number of users and roles that use the policy to set the permissions boundary.
        public var permissionsBoundaryUsageCount: Swift.Int
        /// The unique identifier of the policy.
        public var policyId: Swift.String?
        /// The name of the policy.
        public var policyName: Swift.String?
        /// List of versions of the policy.
        public var policyVersionList: [SecurityHubClientTypes.AwsIamPolicyVersion]?
        /// When the policy was most recently updated. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var updateDate: Swift.String?

        public init (
            attachmentCount: Swift.Int = 0,
            createDate: Swift.String? = nil,
            defaultVersionId: Swift.String? = nil,
            description: Swift.String? = nil,
            isAttachable: Swift.Bool = false,
            path: Swift.String? = nil,
            permissionsBoundaryUsageCount: Swift.Int = 0,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyVersionList: [SecurityHubClientTypes.AwsIamPolicyVersion]? = nil,
            updateDate: Swift.String? = nil
        )
        {
            self.attachmentCount = attachmentCount
            self.createDate = createDate
            self.defaultVersionId = defaultVersionId
            self.description = description
            self.isAttachable = isAttachable
            self.path = path
            self.permissionsBoundaryUsageCount = permissionsBoundaryUsageCount
            self.policyId = policyId
            self.policyName = policyName
            self.policyVersionList = policyVersionList
            self.updateDate = updateDate
        }
    }

}

extension SecurityHubClientTypes.AwsIamPolicyVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createDate = "CreateDate"
        case isDefaultVersion = "IsDefaultVersion"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDate = self.createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if isDefaultVersion != false {
            try encodeContainer.encode(isDefaultVersion, forKey: .isDefaultVersion)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let isDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultVersion) ?? false
        isDefaultVersion = isDefaultVersionDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createDate)
        createDate = createDateDecoded
    }
}

extension SecurityHubClientTypes {
    /// A version of an IAM policy.
    public struct AwsIamPolicyVersion: Swift.Equatable {
        /// Indicates when the version was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createDate: Swift.String?
        /// Whether the version is the default version.
        public var isDefaultVersion: Swift.Bool
        /// The identifier of the policy version.
        public var versionId: Swift.String?

        public init (
            createDate: Swift.String? = nil,
            isDefaultVersion: Swift.Bool = false,
            versionId: Swift.String? = nil
        )
        {
            self.createDate = createDate
            self.isDefaultVersion = isDefaultVersion
            self.versionId = versionId
        }
    }

}

extension SecurityHubClientTypes.AwsIamRoleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assumeRolePolicyDocument = "AssumeRolePolicyDocument"
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case instanceProfileList = "InstanceProfileList"
        case maxSessionDuration = "MaxSessionDuration"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case roleId = "RoleId"
        case roleName = "RoleName"
        case rolePolicyList = "RolePolicyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assumeRolePolicyDocument = self.assumeRolePolicyDocument {
            try encodeContainer.encode(assumeRolePolicyDocument, forKey: .assumeRolePolicyDocument)
        }
        if let attachedManagedPolicies = attachedManagedPolicies {
            var attachedManagedPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedManagedPolicies)
            for awsiamattachedmanagedpolicy0 in attachedManagedPolicies {
                try attachedManagedPoliciesContainer.encode(awsiamattachedmanagedpolicy0)
            }
        }
        if let createDate = self.createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let instanceProfileList = instanceProfileList {
            var instanceProfileListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceProfileList)
            for awsiaminstanceprofile0 in instanceProfileList {
                try instanceProfileListContainer.encode(awsiaminstanceprofile0)
            }
        }
        if maxSessionDuration != 0 {
            try encodeContainer.encode(maxSessionDuration, forKey: .maxSessionDuration)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let permissionsBoundary = self.permissionsBoundary {
            try encodeContainer.encode(permissionsBoundary, forKey: .permissionsBoundary)
        }
        if let roleId = self.roleId {
            try encodeContainer.encode(roleId, forKey: .roleId)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let rolePolicyList = rolePolicyList {
            var rolePolicyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rolePolicyList)
            for awsiamrolepolicy0 in rolePolicyList {
                try rolePolicyListContainer.encode(awsiamrolepolicy0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assumeRolePolicyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assumeRolePolicyDocument)
        assumeRolePolicyDocument = assumeRolePolicyDocumentDecoded
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsIamAttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[SecurityHubClientTypes.AwsIamAttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let createDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createDate)
        createDate = createDateDecoded
        let instanceProfileListContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsIamInstanceProfile?].self, forKey: .instanceProfileList)
        var instanceProfileListDecoded0:[SecurityHubClientTypes.AwsIamInstanceProfile]? = nil
        if let instanceProfileListContainer = instanceProfileListContainer {
            instanceProfileListDecoded0 = [SecurityHubClientTypes.AwsIamInstanceProfile]()
            for structure0 in instanceProfileListContainer {
                if let structure0 = structure0 {
                    instanceProfileListDecoded0?.append(structure0)
                }
            }
        }
        instanceProfileList = instanceProfileListDecoded0
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        let roleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleId)
        roleId = roleIdDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let rolePolicyListContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsIamRolePolicy?].self, forKey: .rolePolicyList)
        var rolePolicyListDecoded0:[SecurityHubClientTypes.AwsIamRolePolicy]? = nil
        if let rolePolicyListContainer = rolePolicyListContainer {
            rolePolicyListDecoded0 = [SecurityHubClientTypes.AwsIamRolePolicy]()
            for structure0 in rolePolicyListContainer {
                if let structure0 = structure0 {
                    rolePolicyListDecoded0?.append(structure0)
                }
            }
        }
        rolePolicyList = rolePolicyListDecoded0
        let maxSessionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionDuration) ?? 0
        maxSessionDuration = maxSessionDurationDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about an IAM role, including all of the role's policies.
    public struct AwsIamRoleDetails: Swift.Equatable {
        /// The trust policy that grants permission to assume the role.
        public var assumeRolePolicyDocument: Swift.String?
        /// The list of the managed policies that are attached to the role.
        public var attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]?
        /// Indicates when the role was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createDate: Swift.String?
        /// The list of instance profiles that contain this role.
        public var instanceProfileList: [SecurityHubClientTypes.AwsIamInstanceProfile]?
        /// The maximum session duration (in seconds) that you want to set for the specified role.
        public var maxSessionDuration: Swift.Int
        /// The path to the role.
        public var path: Swift.String?
        /// Information about the policy used to set the permissions boundary for an IAM principal.
        public var permissionsBoundary: SecurityHubClientTypes.AwsIamPermissionsBoundary?
        /// The stable and unique string identifying the role.
        public var roleId: Swift.String?
        /// The friendly name that identifies the role.
        public var roleName: Swift.String?
        /// The list of inline policies that are embedded in the role.
        public var rolePolicyList: [SecurityHubClientTypes.AwsIamRolePolicy]?

        public init (
            assumeRolePolicyDocument: Swift.String? = nil,
            attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]? = nil,
            createDate: Swift.String? = nil,
            instanceProfileList: [SecurityHubClientTypes.AwsIamInstanceProfile]? = nil,
            maxSessionDuration: Swift.Int = 0,
            path: Swift.String? = nil,
            permissionsBoundary: SecurityHubClientTypes.AwsIamPermissionsBoundary? = nil,
            roleId: Swift.String? = nil,
            roleName: Swift.String? = nil,
            rolePolicyList: [SecurityHubClientTypes.AwsIamRolePolicy]? = nil
        )
        {
            self.assumeRolePolicyDocument = assumeRolePolicyDocument
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.instanceProfileList = instanceProfileList
            self.maxSessionDuration = maxSessionDuration
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.roleId = roleId
            self.roleName = roleName
            self.rolePolicyList = rolePolicyList
        }
    }

}

extension SecurityHubClientTypes.AwsIamRolePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// An inline policy that is embedded in the role.
    public struct AwsIamRolePolicy: Swift.Equatable {
        /// The name of the policy.
        public var policyName: Swift.String?

        public init (
            policyName: Swift.String? = nil
        )
        {
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes.AwsIamUserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case createDate = "CreateDate"
        case groupList = "GroupList"
        case path = "Path"
        case permissionsBoundary = "PermissionsBoundary"
        case userId = "UserId"
        case userName = "UserName"
        case userPolicyList = "UserPolicyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachedManagedPolicies = attachedManagedPolicies {
            var attachedManagedPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedManagedPolicies)
            for awsiamattachedmanagedpolicy0 in attachedManagedPolicies {
                try attachedManagedPoliciesContainer.encode(awsiamattachedmanagedpolicy0)
            }
        }
        if let createDate = self.createDate {
            try encodeContainer.encode(createDate, forKey: .createDate)
        }
        if let groupList = groupList {
            var groupListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupList)
            for nonemptystring0 in groupList {
                try groupListContainer.encode(nonemptystring0)
            }
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let permissionsBoundary = self.permissionsBoundary {
            try encodeContainer.encode(permissionsBoundary, forKey: .permissionsBoundary)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userPolicyList = userPolicyList {
            var userPolicyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userPolicyList)
            for awsiamuserpolicy0 in userPolicyList {
                try userPolicyListContainer.encode(awsiamuserpolicy0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsIamAttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[SecurityHubClientTypes.AwsIamAttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let createDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createDate)
        createDate = createDateDecoded
        let groupListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groupList)
        var groupListDecoded0:[Swift.String]? = nil
        if let groupListContainer = groupListContainer {
            groupListDecoded0 = [Swift.String]()
            for string0 in groupListContainer {
                if let string0 = string0 {
                    groupListDecoded0?.append(string0)
                }
            }
        }
        groupList = groupListDecoded0
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamPermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userPolicyListContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsIamUserPolicy?].self, forKey: .userPolicyList)
        var userPolicyListDecoded0:[SecurityHubClientTypes.AwsIamUserPolicy]? = nil
        if let userPolicyListContainer = userPolicyListContainer {
            userPolicyListDecoded0 = [SecurityHubClientTypes.AwsIamUserPolicy]()
            for structure0 in userPolicyListContainer {
                if let structure0 = structure0 {
                    userPolicyListDecoded0?.append(structure0)
                }
            }
        }
        userPolicyList = userPolicyListDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Information about an IAM user.
    public struct AwsIamUserDetails: Swift.Equatable {
        /// A list of the managed policies that are attached to the user.
        public var attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]?
        /// Indicates when the user was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createDate: Swift.String?
        /// A list of IAM groups that the user belongs to.
        public var groupList: [Swift.String]?
        /// The path to the user.
        public var path: Swift.String?
        /// The permissions boundary for the user.
        public var permissionsBoundary: SecurityHubClientTypes.AwsIamPermissionsBoundary?
        /// The unique identifier for the user.
        public var userId: Swift.String?
        /// The name of the user.
        public var userName: Swift.String?
        /// The list of inline policies that are embedded in the user.
        public var userPolicyList: [SecurityHubClientTypes.AwsIamUserPolicy]?

        public init (
            attachedManagedPolicies: [SecurityHubClientTypes.AwsIamAttachedManagedPolicy]? = nil,
            createDate: Swift.String? = nil,
            groupList: [Swift.String]? = nil,
            path: Swift.String? = nil,
            permissionsBoundary: SecurityHubClientTypes.AwsIamPermissionsBoundary? = nil,
            userId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userPolicyList: [SecurityHubClientTypes.AwsIamUserPolicy]? = nil
        )
        {
            self.attachedManagedPolicies = attachedManagedPolicies
            self.createDate = createDate
            self.groupList = groupList
            self.path = path
            self.permissionsBoundary = permissionsBoundary
            self.userId = userId
            self.userName = userName
            self.userPolicyList = userPolicyList
        }
    }

}

extension SecurityHubClientTypes.AwsIamUserPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyName = "PolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyName = self.policyName {
            try encodeContainer.encode(policyName, forKey: .policyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyName)
        policyName = policyNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an inline policy that is embedded in the user.
    public struct AwsIamUserPolicy: Swift.Equatable {
        /// The name of the policy.
        public var policyName: Swift.String?

        public init (
            policyName: Swift.String? = nil
        )
        {
            self.policyName = policyName
        }
    }

}

extension SecurityHubClientTypes.AwsKinesisStreamDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
        case retentionPeriodHours = "RetentionPeriodHours"
        case shardCount = "ShardCount"
        case streamEncryption = "StreamEncryption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if retentionPeriodHours != 0 {
            try encodeContainer.encode(retentionPeriodHours, forKey: .retentionPeriodHours)
        }
        if shardCount != 0 {
            try encodeContainer.encode(shardCount, forKey: .shardCount)
        }
        if let streamEncryption = self.streamEncryption {
            try encodeContainer.encode(streamEncryption, forKey: .streamEncryption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let streamEncryptionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails.self, forKey: .streamEncryption)
        streamEncryption = streamEncryptionDecoded
        let shardCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .shardCount) ?? 0
        shardCount = shardCountDecoded
        let retentionPeriodHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriodHours) ?? 0
        retentionPeriodHours = retentionPeriodHoursDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon Kinesis data stream.
    public struct AwsKinesisStreamDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Kinesis data stream.
        public var arn: Swift.String?
        /// The name of the Kinesis stream. If you don't specify a name, CloudFront generates a unique physical ID and uses that ID for the stream name.
        public var name: Swift.String?
        /// The number of hours for the data records that are stored in shards to remain accessible.
        public var retentionPeriodHours: Swift.Int
        /// The number of shards that the stream uses.
        public var shardCount: Swift.Int
        /// When specified, enables or updates server-side encryption using an KMS key for a specified stream. Removing this property from your stack template and updating your stack disables encryption.
        public var streamEncryption: SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            retentionPeriodHours: Swift.Int = 0,
            shardCount: Swift.Int = 0,
            streamEncryption: SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.retentionPeriodHours = retentionPeriodHours
            self.shardCount = shardCount
            self.streamEncryption = streamEncryption
        }
    }

}

extension SecurityHubClientTypes.AwsKinesisStreamStreamEncryptionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "EncryptionType"
        case keyId = "KeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType, forKey: .encryptionType)
        }
        if let keyId = self.keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about stream encryption.
    public struct AwsKinesisStreamStreamEncryptionDetails: Swift.Equatable {
        /// The encryption type to use.
        public var encryptionType: Swift.String?
        /// The globally unique identifier for the customer-managed KMS key to use for encryption.
        public var keyId: Swift.String?

        public init (
            encryptionType: Swift.String? = nil,
            keyId: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.keyId = keyId
        }
    }

}

extension SecurityHubClientTypes.AwsKmsKeyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AWSAccountId"
        case creationDate = "CreationDate"
        case description = "Description"
        case keyId = "KeyId"
        case keyManager = "KeyManager"
        case keyRotationStatus = "KeyRotationStatus"
        case keyState = "KeyState"
        case origin = "Origin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if creationDate != 0.0 {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let keyId = self.keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyManager = self.keyManager {
            try encodeContainer.encode(keyManager, forKey: .keyManager)
        }
        if keyRotationStatus != false {
            try encodeContainer.encode(keyRotationStatus, forKey: .keyRotationStatus)
        }
        if let keyState = self.keyState {
            try encodeContainer.encode(keyState, forKey: .keyState)
        }
        if let origin = self.origin {
            try encodeContainer.encode(origin, forKey: .origin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .creationDate) ?? 0.0
        creationDate = creationDateDecoded
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyManagerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyManager)
        keyManager = keyManagerDecoded
        let keyStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyState)
        keyState = keyStateDecoded
        let originDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .origin)
        origin = originDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let keyRotationStatusDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .keyRotationStatus) ?? false
        keyRotationStatus = keyRotationStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains metadata about an KMS key.
    public struct AwsKmsKeyDetails: Swift.Equatable {
        /// The twelve-digit account ID of the Amazon Web Services account that owns the KMS key.
        public var awsAccountId: Swift.String?
        /// Indicates when the KMS key was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var creationDate: Swift.Double
        /// A description of the KMS key.
        public var description: Swift.String?
        /// The globally unique identifier for the KMS key.
        public var keyId: Swift.String?
        /// The manager of the KMS key. KMS keys in your Amazon Web Services account are either customer managed or Amazon Web Services managed.
        public var keyManager: Swift.String?
        /// Whether the key has key rotation enabled.
        public var keyRotationStatus: Swift.Bool
        /// The state of the KMS key. Valid values are as follows:
        ///
        /// * Disabled
        ///
        /// * Enabled
        ///
        /// * PendingDeletion
        ///
        /// * PendingImport
        ///
        /// * Unavailable
        public var keyState: Swift.String?
        /// The source of the KMS key material. When this value is AWS_KMS, KMS created the key material. When this value is EXTERNAL, the key material was imported from your existing key management infrastructure or the KMS key lacks key material. When this value is AWS_CLOUDHSM, the key material was created in the CloudHSM cluster associated with a custom key store.
        public var origin: Swift.String?

        public init (
            awsAccountId: Swift.String? = nil,
            creationDate: Swift.Double = 0.0,
            description: Swift.String? = nil,
            keyId: Swift.String? = nil,
            keyManager: Swift.String? = nil,
            keyRotationStatus: Swift.Bool = false,
            keyState: Swift.String? = nil,
            origin: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.creationDate = creationDate
            self.description = description
            self.keyId = keyId
            self.keyManager = keyManager
            self.keyRotationStatus = keyRotationStatus
            self.keyState = keyState
            self.origin = origin
        }
    }

}

extension SecurityHubClientTypes.AwsLambdaFunctionCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = self.s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = self.zipFile {
            try encodeContainer.encode(zipFile, forKey: .zipFile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let zipFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .zipFile)
        zipFile = zipFileDecoded
    }
}

extension SecurityHubClientTypes {
    /// The code for the Lambda function. You can specify either an object in Amazon S3, or upload a deployment package directly.
    public struct AwsLambdaFunctionCode: Swift.Equatable {
        /// An Amazon S3 bucket in the same Amazon Web Services Region as your function. The bucket can be in a different Amazon Web Services account.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key of the deployment package.
        public var s3Key: Swift.String?
        /// For versioned objects, the version of the deployment package object to use.
        public var s3ObjectVersion: Swift.String?
        /// The base64-encoded contents of the deployment package. Amazon Web Services SDK and Amazon Web Services CLI clients handle the encoding for you.
        public var zipFile: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil,
            s3ObjectVersion: Swift.String? = nil,
            zipFile: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
            self.s3ObjectVersion = s3ObjectVersion
            self.zipFile = zipFile
        }
    }

}

extension SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// The dead-letter queue for failed asynchronous invocations.
    public struct AwsLambdaFunctionDeadLetterConfig: Swift.Equatable {
        /// The ARN of an SQS queue or SNS topic.
        public var targetArn: Swift.String?

        public init (
            targetArn: Swift.String? = nil
        )
        {
            self.targetArn = targetArn
        }
    }

}

extension SecurityHubClientTypes.AwsLambdaFunctionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectures = "Architectures"
        case code = "Code"
        case codeSha256 = "CodeSha256"
        case deadLetterConfig = "DeadLetterConfig"
        case environment = "Environment"
        case functionName = "FunctionName"
        case handler = "Handler"
        case kmsKeyArn = "KmsKeyArn"
        case lastModified = "LastModified"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for nonemptystring0 in architectures {
                try architecturesContainer.encode(nonemptystring0)
            }
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let codeSha256 = self.codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if let deadLetterConfig = self.deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = self.handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for awslambdafunctionlayer0 in layers {
                try layersContainer.encode(awslambdafunctionlayer0)
            }
        }
        if let masterArn = self.masterArn {
            try encodeContainer.encode(masterArn, forKey: .masterArn)
        }
        if memorySize != 0 {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let packageType = self.packageType {
            try encodeContainer.encode(packageType, forKey: .packageType)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime, forKey: .runtime)
        }
        if timeout != 0 {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = self.tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsLambdaFunctionCode.self, forKey: .code)
        code = codeDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsLambdaFunctionEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .handler)
        handler = handlerDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let layersContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsLambdaFunctionLayer?].self, forKey: .layers)
        var layersDecoded0:[SecurityHubClientTypes.AwsLambdaFunctionLayer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [SecurityHubClientTypes.AwsLambdaFunctionLayer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let masterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize) ?? 0
        memorySize = memorySizeDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtime)
        runtime = runtimeDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout) ?? 0
        timeout = timeoutDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsLambdaFunctionTracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsLambdaFunctionVpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .architectures)
        var architecturesDecoded0:[Swift.String]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [Swift.String]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageType)
        packageType = packageTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an Lambda function's configuration.
    public struct AwsLambdaFunctionDetails: Swift.Equatable {
        /// The instruction set architecture that the function uses. Valid values are x86_64 or arm64.
        public var architectures: [Swift.String]?
        /// An AwsLambdaFunctionCode object.
        public var code: SecurityHubClientTypes.AwsLambdaFunctionCode?
        /// The SHA256 hash of the function's deployment package.
        public var codeSha256: Swift.String?
        /// The function's dead letter queue.
        public var deadLetterConfig: SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig?
        /// The function's environment variables.
        public var environment: SecurityHubClientTypes.AwsLambdaFunctionEnvironment?
        /// The name of the function.
        public var functionName: Swift.String?
        /// The function that Lambda calls to begin executing your function.
        public var handler: Swift.String?
        /// The KMS key that is used to encrypt the function's environment variables. This key is only returned if you've configured a customer managed customer managed key.
        public var kmsKeyArn: Swift.String?
        /// Indicates when the function was last updated. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastModified: Swift.String?
        /// The function's layers.
        public var layers: [SecurityHubClientTypes.AwsLambdaFunctionLayer]?
        /// For Lambda@Edge functions, the ARN of the master function.
        public var masterArn: Swift.String?
        /// The memory that is allocated to the function.
        public var memorySize: Swift.Int
        /// The type of deployment package that's used to deploy the function code to Lambda. Set to Image for a container image and Zip for a .zip file archive.
        public var packageType: Swift.String?
        /// The latest updated revision of the function or alias.
        public var revisionId: Swift.String?
        /// The function's execution role.
        public var role: Swift.String?
        /// The runtime environment for the Lambda function.
        public var runtime: Swift.String?
        /// The amount of time that Lambda allows a function to run before stopping it.
        public var timeout: Swift.Int
        /// The function's X-Ray tracing configuration.
        public var tracingConfig: SecurityHubClientTypes.AwsLambdaFunctionTracingConfig?
        /// The version of the Lambda function.
        public var version: Swift.String?
        /// The function's networking configuration.
        public var vpcConfig: SecurityHubClientTypes.AwsLambdaFunctionVpcConfig?

        public init (
            architectures: [Swift.String]? = nil,
            code: SecurityHubClientTypes.AwsLambdaFunctionCode? = nil,
            codeSha256: Swift.String? = nil,
            deadLetterConfig: SecurityHubClientTypes.AwsLambdaFunctionDeadLetterConfig? = nil,
            environment: SecurityHubClientTypes.AwsLambdaFunctionEnvironment? = nil,
            functionName: Swift.String? = nil,
            handler: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            layers: [SecurityHubClientTypes.AwsLambdaFunctionLayer]? = nil,
            masterArn: Swift.String? = nil,
            memorySize: Swift.Int = 0,
            packageType: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            role: Swift.String? = nil,
            runtime: Swift.String? = nil,
            timeout: Swift.Int = 0,
            tracingConfig: SecurityHubClientTypes.AwsLambdaFunctionTracingConfig? = nil,
            version: Swift.String? = nil,
            vpcConfig: SecurityHubClientTypes.AwsLambdaFunctionVpcConfig? = nil
        )
        {
            self.architectures = architectures
            self.code = code
            self.codeSha256 = codeSha256
            self.deadLetterConfig = deadLetterConfig
            self.environment = environment
            self.functionName = functionName
            self.handler = handler
            self.kmsKeyArn = kmsKeyArn
            self.lastModified = lastModified
            self.layers = layers
            self.masterArn = masterArn
            self.memorySize = memorySize
            self.packageType = packageType
            self.revisionId = revisionId
            self.role = role
            self.runtime = runtime
            self.timeout = timeout
            self.tracingConfig = tracingConfig
            self.version = version
            self.vpcConfig = vpcConfig
        }
    }

}

extension SecurityHubClientTypes.AwsLambdaFunctionEnvironment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error = "Error"
        case variables = "Variables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, fieldMap0) in variables {
                try variablesContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in variablesContainer {
                if let nonemptystring0 = nonemptystring0 {
                    variablesDecoded0?[key0] = nonemptystring0
                }
            }
        }
        variables = variablesDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError.self, forKey: .error)
        error = errorDecoded
    }
}

extension SecurityHubClientTypes {
    /// A function's environment variable settings.
    public struct AwsLambdaFunctionEnvironment: Swift.Equatable {
        /// An AwsLambdaFunctionEnvironmentError object.
        public var error: SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError?
        /// Environment variable key-value pairs.
        public var variables: [Swift.String:Swift.String]?

        public init (
            error: SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError? = nil,
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.error = error
            self.variables = variables
        }
    }

}

extension SecurityHubClientTypes.AwsLambdaFunctionEnvironmentError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityHubClientTypes {
    /// Error messages for environment variables that could not be applied.
    public struct AwsLambdaFunctionEnvironmentError: Swift.Equatable {
        /// The error code.
        public var errorCode: Swift.String?
        /// The error message.
        public var message: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.message = message
        }
    }

}

extension SecurityHubClientTypes.AwsLambdaFunctionLayer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case codeSize = "CodeSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let codeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .codeSize) ?? 0
        codeSize = codeSizeDecoded
    }
}

extension SecurityHubClientTypes {
    /// An Lambda layer.
    public struct AwsLambdaFunctionLayer: Swift.Equatable {
        /// The ARN of the function layer.
        public var arn: Swift.String?
        /// The size of the layer archive in bytes.
        public var codeSize: Swift.Int

        public init (
            arn: Swift.String? = nil,
            codeSize: Swift.Int = 0
        )
        {
            self.arn = arn
            self.codeSize = codeSize
        }
    }

}

extension SecurityHubClientTypes.AwsLambdaFunctionTracingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = self.mode {
            try encodeContainer.encode(mode, forKey: .mode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension SecurityHubClientTypes {
    /// The function's X-Ray tracing configuration.
    public struct AwsLambdaFunctionTracingConfig: Swift.Equatable {
        /// The tracing mode.
        public var mode: Swift.String?

        public init (
            mode: Swift.String? = nil
        )
        {
            self.mode = mode
        }
    }

}

extension SecurityHubClientTypes.AwsLambdaFunctionVpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for nonemptystring0 in subnetIds {
                try subnetIdsContainer.encode(nonemptystring0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// The VPC security groups and subnets that are attached to a Lambda function.
    public struct AwsLambdaFunctionVpcConfig: Swift.Equatable {
        /// A list of VPC security groups IDs.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsLambdaLayerVersionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleRuntimes = "CompatibleRuntimes"
        case createdDate = "CreatedDate"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for nonemptystring0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(nonemptystring0)
            }
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[Swift.String]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [Swift.String]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about a Lambda layer version.
    public struct AwsLambdaLayerVersionDetails: Swift.Equatable {
        /// The layer's compatible runtimes. Maximum number of five items. Valid values: nodejs10.x | nodejs12.x | java8 | java11 | python2.7 | python3.6 | python3.7 | python3.8 | dotnetcore1.0 | dotnetcore2.1 | go1.x | ruby2.5 | provided
        public var compatibleRuntimes: [Swift.String]?
        /// Indicates when the version was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdDate: Swift.String?
        /// The version number.
        public var version: Swift.Int

        public init (
            compatibleRuntimes: [Swift.String]? = nil,
            createdDate: Swift.String? = nil,
            version: Swift.Int = 0
        )
        {
            self.compatibleRuntimes = compatibleRuntimes
            self.createdDate = createdDate
            self.version = version
        }
    }

}

extension SecurityHubClientTypes.AwsMountPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerPath = "ContainerPath"
        case sourceVolume = "SourceVolume"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerPath = self.containerPath {
            try encodeContainer.encode(containerPath, forKey: .containerPath)
        }
        if let sourceVolume = self.sourceVolume {
            try encodeContainer.encode(sourceVolume, forKey: .sourceVolume)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceVolumeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVolume)
        sourceVolume = sourceVolumeDecoded
        let containerPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerPath)
        containerPath = containerPathDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details for a volume mount point that's used in a container definition.
    public struct AwsMountPoint: Swift.Equatable {
        /// The path on the container to mount the host volume at.
        public var containerPath: Swift.String?
        /// The name of the volume to mount. Must be a volume name referenced in the name parameter of task definition volume.
        public var sourceVolume: Swift.String?

        public init (
            containerPath: Swift.String? = nil,
            sourceVolume: Swift.String? = nil
        )
        {
            self.containerPath = containerPath
            self.sourceVolume = sourceVolume
        }
    }

}

extension SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteProtection = "DeleteProtection"
        case description = "Description"
        case firewallArn = "FirewallArn"
        case firewallId = "FirewallId"
        case firewallName = "FirewallName"
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyChangeProtection = "FirewallPolicyChangeProtection"
        case subnetChangeProtection = "SubnetChangeProtection"
        case subnetMappings = "SubnetMappings"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteProtection != false {
            try encodeContainer.encode(deleteProtection, forKey: .deleteProtection)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firewallArn = self.firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallId = self.firewallId {
            try encodeContainer.encode(firewallId, forKey: .firewallId)
        }
        if let firewallName = self.firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if let firewallPolicyArn = self.firewallPolicyArn {
            try encodeContainer.encode(firewallPolicyArn, forKey: .firewallPolicyArn)
        }
        if firewallPolicyChangeProtection != false {
            try encodeContainer.encode(firewallPolicyChangeProtection, forKey: .firewallPolicyChangeProtection)
        }
        if subnetChangeProtection != false {
            try encodeContainer.encode(subnetChangeProtection, forKey: .subnetChangeProtection)
        }
        if let subnetMappings = subnetMappings {
            var subnetMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetMappings)
            for awsnetworkfirewallfirewallsubnetmappingsdetails0 in subnetMappings {
                try subnetMappingsContainer.encode(awsnetworkfirewallfirewallsubnetmappingsdetails0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deleteProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteProtection) ?? false
        deleteProtection = deleteProtectionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallId)
        firewallId = firewallIdDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
        let firewallPolicyChangeProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .firewallPolicyChangeProtection) ?? false
        firewallPolicyChangeProtection = firewallPolicyChangeProtectionDecoded
        let subnetChangeProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .subnetChangeProtection) ?? false
        subnetChangeProtection = subnetChangeProtectionDecoded
        let subnetMappingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails?].self, forKey: .subnetMappings)
        var subnetMappingsDecoded0:[SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails]? = nil
        if let subnetMappingsContainer = subnetMappingsContainer {
            subnetMappingsDecoded0 = [SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails]()
            for structure0 in subnetMappingsContainer {
                if let structure0 = structure0 {
                    subnetMappingsDecoded0?.append(structure0)
                }
            }
        }
        subnetMappings = subnetMappingsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an Network Firewall firewall.
    public struct AwsNetworkFirewallFirewallDetails: Swift.Equatable {
        /// Whether the firewall is protected from deletion. If set to true, then the firewall cannot be deleted.
        public var deleteProtection: Swift.Bool
        /// A description of the firewall.
        public var description: Swift.String?
        /// The ARN of the firewall.
        public var firewallArn: Swift.String?
        /// The identifier of the firewall.
        public var firewallId: Swift.String?
        /// A descriptive name of the firewall.
        public var firewallName: Swift.String?
        /// The ARN of the firewall policy.
        public var firewallPolicyArn: Swift.String?
        /// Whether the firewall is protected from a change to the firewall policy. If set to true, you cannot associate a different policy with the firewall.
        public var firewallPolicyChangeProtection: Swift.Bool
        /// Whether the firewall is protected from a change to the subnet associations. If set to true, you cannot map different subnets to the firewall.
        public var subnetChangeProtection: Swift.Bool
        /// The public subnets that Network Firewall uses for the firewall. Each subnet must belong to a different Availability Zone.
        public var subnetMappings: [SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails]?
        /// The identifier of the VPC where the firewall is used.
        public var vpcId: Swift.String?

        public init (
            deleteProtection: Swift.Bool = false,
            description: Swift.String? = nil,
            firewallArn: Swift.String? = nil,
            firewallId: Swift.String? = nil,
            firewallName: Swift.String? = nil,
            firewallPolicyArn: Swift.String? = nil,
            firewallPolicyChangeProtection: Swift.Bool = false,
            subnetChangeProtection: Swift.Bool = false,
            subnetMappings: [SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.deleteProtection = deleteProtection
            self.description = description
            self.firewallArn = firewallArn
            self.firewallId = firewallId
            self.firewallName = firewallName
            self.firewallPolicyArn = firewallPolicyArn
            self.firewallPolicyChangeProtection = firewallPolicyChangeProtection
            self.subnetChangeProtection = subnetChangeProtection
            self.subnetMappings = subnetMappings
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case firewallPolicy = "FirewallPolicy"
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyId = "FirewallPolicyId"
        case firewallPolicyName = "FirewallPolicyName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firewallPolicy = self.firewallPolicy {
            try encodeContainer.encode(firewallPolicy, forKey: .firewallPolicy)
        }
        if let firewallPolicyArn = self.firewallPolicyArn {
            try encodeContainer.encode(firewallPolicyArn, forKey: .firewallPolicyArn)
        }
        if let firewallPolicyId = self.firewallPolicyId {
            try encodeContainer.encode(firewallPolicyId, forKey: .firewallPolicyId)
        }
        if let firewallPolicyName = self.firewallPolicyName {
            try encodeContainer.encode(firewallPolicyName, forKey: .firewallPolicyName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallPolicyDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.FirewallPolicyDetails.self, forKey: .firewallPolicy)
        firewallPolicy = firewallPolicyDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
        let firewallPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallPolicyId)
        firewallPolicyId = firewallPolicyIdDecoded
        let firewallPolicyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firewallPolicyName)
        firewallPolicyName = firewallPolicyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about a firewall policy. A firewall policy defines the behavior of a network firewall.
    public struct AwsNetworkFirewallFirewallPolicyDetails: Swift.Equatable {
        /// A description of the firewall policy.
        public var description: Swift.String?
        /// The firewall policy configuration.
        public var firewallPolicy: SecurityHubClientTypes.FirewallPolicyDetails?
        /// The ARN of the firewall policy.
        public var firewallPolicyArn: Swift.String?
        /// The identifier of the firewall policy.
        public var firewallPolicyId: Swift.String?
        /// The name of the firewall policy.
        public var firewallPolicyName: Swift.String?

        public init (
            description: Swift.String? = nil,
            firewallPolicy: SecurityHubClientTypes.FirewallPolicyDetails? = nil,
            firewallPolicyArn: Swift.String? = nil,
            firewallPolicyId: Swift.String? = nil,
            firewallPolicyName: Swift.String? = nil
        )
        {
            self.description = description
            self.firewallPolicy = firewallPolicy
            self.firewallPolicyArn = firewallPolicyArn
            self.firewallPolicyId = firewallPolicyId
            self.firewallPolicyName = firewallPolicyName
        }
    }

}

extension SecurityHubClientTypes.AwsNetworkFirewallFirewallSubnetMappingsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// A public subnet that Network Firewall uses for the firewall.
    public struct AwsNetworkFirewallFirewallSubnetMappingsDetails: Swift.Equatable {
        /// The identifier of the subnet
        public var subnetId: Swift.String?

        public init (
            subnetId: Swift.String? = nil
        )
        {
            self.subnetId = subnetId
        }
    }

}

extension SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capacity = "Capacity"
        case description = "Description"
        case ruleGroup = "RuleGroup"
        case ruleGroupArn = "RuleGroupArn"
        case ruleGroupId = "RuleGroupId"
        case ruleGroupName = "RuleGroupName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if capacity != 0 {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ruleGroup = self.ruleGroup {
            try encodeContainer.encode(ruleGroup, forKey: .ruleGroup)
        }
        if let ruleGroupArn = self.ruleGroupArn {
            try encodeContainer.encode(ruleGroupArn, forKey: .ruleGroupArn)
        }
        if let ruleGroupId = self.ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
        if let ruleGroupName = self.ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .capacity) ?? 0
        capacity = capacityDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ruleGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupDetails.self, forKey: .ruleGroup)
        ruleGroup = ruleGroupDecoded
        let ruleGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleGroupArn)
        ruleGroupArn = ruleGroupArnDecoded
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an Network Firewall rule group. Rule groups are used to inspect and control network traffic. Stateless rule groups apply to individual packets. Stateful rule groups apply to packets in the context of their traffic flow. Rule groups are referenced in firewall policies.
    public struct AwsNetworkFirewallRuleGroupDetails: Swift.Equatable {
        /// The maximum number of operating resources that this rule group can use.
        public var capacity: Swift.Int
        /// A description of the rule group.
        public var description: Swift.String?
        /// Details about the rule group.
        public var ruleGroup: SecurityHubClientTypes.RuleGroupDetails?
        /// The ARN of the rule group.
        public var ruleGroupArn: Swift.String?
        /// The identifier of the rule group.
        public var ruleGroupId: Swift.String?
        /// The descriptive name of the rule group.
        public var ruleGroupName: Swift.String?
        /// The type of rule group. A rule group can be stateful or stateless.
        public var type: Swift.String?

        public init (
            capacity: Swift.Int = 0,
            description: Swift.String? = nil,
            ruleGroup: SecurityHubClientTypes.RuleGroupDetails? = nil,
            ruleGroupArn: Swift.String? = nil,
            ruleGroupId: Swift.String? = nil,
            ruleGroupName: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.capacity = capacity
            self.description = description
            self.ruleGroup = ruleGroup
            self.ruleGroupArn = ruleGroupArn
            self.ruleGroupId = ruleGroupId
            self.ruleGroupName = ruleGroupName
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
        case masterUserOptions = "MasterUserOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if internalUserDatabaseEnabled != false {
            try encodeContainer.encode(internalUserDatabaseEnabled, forKey: .internalUserDatabaseEnabled)
        }
        if let masterUserOptions = self.masterUserOptions {
            try encodeContainer.encode(masterUserOptions, forKey: .masterUserOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let internalUserDatabaseEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .internalUserDatabaseEnabled) ?? false
        internalUserDatabaseEnabled = internalUserDatabaseEnabledDecoded
        let masterUserOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails.self, forKey: .masterUserOptions)
        masterUserOptions = masterUserOptionsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about domain access control options.
    public struct AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails: Swift.Equatable {
        /// Enables fine-grained access control.
        public var enabled: Swift.Bool
        /// Enables the internal user database.
        public var internalUserDatabaseEnabled: Swift.Bool
        /// Specifies information about the master user of the domain.
        public var masterUserOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails?

        public init (
            enabled: Swift.Bool = false,
            internalUserDatabaseEnabled: Swift.Bool = false,
            masterUserOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails? = nil
        )
        {
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.masterUserOptions = masterUserOptions
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dedicatedMasterCount = "DedicatedMasterCount"
        case dedicatedMasterEnabled = "DedicatedMasterEnabled"
        case dedicatedMasterType = "DedicatedMasterType"
        case instanceCount = "InstanceCount"
        case instanceType = "InstanceType"
        case warmCount = "WarmCount"
        case warmEnabled = "WarmEnabled"
        case warmType = "WarmType"
        case zoneAwarenessConfig = "ZoneAwarenessConfig"
        case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dedicatedMasterCount != 0 {
            try encodeContainer.encode(dedicatedMasterCount, forKey: .dedicatedMasterCount)
        }
        if dedicatedMasterEnabled != false {
            try encodeContainer.encode(dedicatedMasterEnabled, forKey: .dedicatedMasterEnabled)
        }
        if let dedicatedMasterType = self.dedicatedMasterType {
            try encodeContainer.encode(dedicatedMasterType, forKey: .dedicatedMasterType)
        }
        if instanceCount != 0 {
            try encodeContainer.encode(instanceCount, forKey: .instanceCount)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if warmCount != 0 {
            try encodeContainer.encode(warmCount, forKey: .warmCount)
        }
        if warmEnabled != false {
            try encodeContainer.encode(warmEnabled, forKey: .warmEnabled)
        }
        if let warmType = self.warmType {
            try encodeContainer.encode(warmType, forKey: .warmType)
        }
        if let zoneAwarenessConfig = self.zoneAwarenessConfig {
            try encodeContainer.encode(zoneAwarenessConfig, forKey: .zoneAwarenessConfig)
        }
        if zoneAwarenessEnabled != false {
            try encodeContainer.encode(zoneAwarenessEnabled, forKey: .zoneAwarenessEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instanceCount) ?? 0
        instanceCount = instanceCountDecoded
        let warmEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .warmEnabled) ?? false
        warmEnabled = warmEnabledDecoded
        let warmCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .warmCount) ?? 0
        warmCount = warmCountDecoded
        let dedicatedMasterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dedicatedMasterEnabled) ?? false
        dedicatedMasterEnabled = dedicatedMasterEnabledDecoded
        let zoneAwarenessConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails.self, forKey: .zoneAwarenessConfig)
        zoneAwarenessConfig = zoneAwarenessConfigDecoded
        let dedicatedMasterCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dedicatedMasterCount) ?? 0
        dedicatedMasterCount = dedicatedMasterCountDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let warmTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warmType)
        warmType = warmTypeDecoded
        let zoneAwarenessEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .zoneAwarenessEnabled) ?? false
        zoneAwarenessEnabled = zoneAwarenessEnabledDecoded
        let dedicatedMasterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dedicatedMasterType)
        dedicatedMasterType = dedicatedMasterTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the configuration of an OpenSearch cluster.
    public struct AwsOpenSearchServiceDomainClusterConfigDetails: Swift.Equatable {
        /// The number of instances to use for the master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public var dedicatedMasterCount: Swift.Int
        /// Whether to use a dedicated master node for the OpenSearch domain. A dedicated master node performs cluster management tasks, but does not hold data or respond to data upload requests.
        public var dedicatedMasterEnabled: Swift.Bool
        /// The hardware configuration of the computer that hosts the dedicated master node. If this attribute is specified, then DedicatedMasterEnabled must be true.
        public var dedicatedMasterType: Swift.String?
        /// The number of data nodes to use in the OpenSearch domain.
        public var instanceCount: Swift.Int
        /// The instance type for your data nodes. For a list of valid values, see [Supported instance types in Amazon OpenSearch Service](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html) in the Amazon OpenSearch Service Developer Guide.
        public var instanceType: Swift.String?
        /// The number of UltraWarm instances.
        public var warmCount: Swift.Int
        /// Whether UltraWarm is enabled.
        public var warmEnabled: Swift.Bool
        /// The type of UltraWarm instance.
        public var warmType: Swift.String?
        /// Configuration options for zone awareness. Provided if ZoneAwarenessEnabled is true.
        public var zoneAwarenessConfig: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails?
        /// Whether to enable zone awareness for the OpenSearch domain. When zone awareness is enabled, OpenSearch Service allocates the cluster's nodes and replica index shards across Availability Zones (AZs) in the same Region. This prevents data loss and minimizes downtime if a node or data center fails.
        public var zoneAwarenessEnabled: Swift.Bool

        public init (
            dedicatedMasterCount: Swift.Int = 0,
            dedicatedMasterEnabled: Swift.Bool = false,
            dedicatedMasterType: Swift.String? = nil,
            instanceCount: Swift.Int = 0,
            instanceType: Swift.String? = nil,
            warmCount: Swift.Int = 0,
            warmEnabled: Swift.Bool = false,
            warmType: Swift.String? = nil,
            zoneAwarenessConfig: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails? = nil,
            zoneAwarenessEnabled: Swift.Bool = false
        )
        {
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.warmCount = warmCount
            self.warmEnabled = warmEnabled
            self.warmType = warmType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneCount = "AvailabilityZoneCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if availabilityZoneCount != 0 {
            try encodeContainer.encode(availabilityZoneCount, forKey: .availabilityZoneCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availabilityZoneCount) ?? 0
        availabilityZoneCount = availabilityZoneCountDecoded
    }
}

extension SecurityHubClientTypes {
    /// Configuration options for zone awareness.
    public struct AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails: Swift.Equatable {
        /// The number of Availability Zones that the domain uses. Valid values are 2 or 3. The default is 2.
        public var availabilityZoneCount: Swift.Int

        public init (
            availabilityZoneCount: Swift.Int = 0
        )
        {
            self.availabilityZoneCount = availabilityZoneCount
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicies = "AccessPolicies"
        case advancedSecurityOptions = "AdvancedSecurityOptions"
        case arn = "Arn"
        case clusterConfig = "ClusterConfig"
        case domainEndpoint = "DomainEndpoint"
        case domainEndpointOptions = "DomainEndpointOptions"
        case domainEndpoints = "DomainEndpoints"
        case domainName = "DomainName"
        case encryptionAtRestOptions = "EncryptionAtRestOptions"
        case engineVersion = "EngineVersion"
        case id = "Id"
        case logPublishingOptions = "LogPublishingOptions"
        case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
        case serviceSoftwareOptions = "ServiceSoftwareOptions"
        case vpcOptions = "VpcOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicies = self.accessPolicies {
            try encodeContainer.encode(accessPolicies, forKey: .accessPolicies)
        }
        if let advancedSecurityOptions = self.advancedSecurityOptions {
            try encodeContainer.encode(advancedSecurityOptions, forKey: .advancedSecurityOptions)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clusterConfig = self.clusterConfig {
            try encodeContainer.encode(clusterConfig, forKey: .clusterConfig)
        }
        if let domainEndpoint = self.domainEndpoint {
            try encodeContainer.encode(domainEndpoint, forKey: .domainEndpoint)
        }
        if let domainEndpointOptions = self.domainEndpointOptions {
            try encodeContainer.encode(domainEndpointOptions, forKey: .domainEndpointOptions)
        }
        if let domainEndpoints = domainEndpoints {
            var domainEndpointsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .domainEndpoints)
            for (dictKey0, fieldMap0) in domainEndpoints {
                try domainEndpointsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let encryptionAtRestOptions = self.encryptionAtRestOptions {
            try encodeContainer.encode(encryptionAtRestOptions, forKey: .encryptionAtRestOptions)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let logPublishingOptions = self.logPublishingOptions {
            try encodeContainer.encode(logPublishingOptions, forKey: .logPublishingOptions)
        }
        if let nodeToNodeEncryptionOptions = self.nodeToNodeEncryptionOptions {
            try encodeContainer.encode(nodeToNodeEncryptionOptions, forKey: .nodeToNodeEncryptionOptions)
        }
        if let serviceSoftwareOptions = self.serviceSoftwareOptions {
            try encodeContainer.encode(serviceSoftwareOptions, forKey: .serviceSoftwareOptions)
        }
        if let vpcOptions = self.vpcOptions {
            try encodeContainer.encode(vpcOptions, forKey: .vpcOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let accessPoliciesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicies)
        accessPolicies = accessPoliciesDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let domainEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainEndpoint)
        domainEndpoint = domainEndpointDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let encryptionAtRestOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails.self, forKey: .encryptionAtRestOptions)
        encryptionAtRestOptions = encryptionAtRestOptionsDecoded
        let nodeToNodeEncryptionOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails.self, forKey: .nodeToNodeEncryptionOptions)
        nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptionsDecoded
        let serviceSoftwareOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails.self, forKey: .serviceSoftwareOptions)
        serviceSoftwareOptions = serviceSoftwareOptionsDecoded
        let clusterConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails.self, forKey: .clusterConfig)
        clusterConfig = clusterConfigDecoded
        let domainEndpointOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails.self, forKey: .domainEndpointOptions)
        domainEndpointOptions = domainEndpointOptionsDecoded
        let vpcOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails.self, forKey: .vpcOptions)
        vpcOptions = vpcOptionsDecoded
        let logPublishingOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails.self, forKey: .logPublishingOptions)
        logPublishingOptions = logPublishingOptionsDecoded
        let domainEndpointsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .domainEndpoints)
        var domainEndpointsDecoded0: [Swift.String:Swift.String]? = nil
        if let domainEndpointsContainer = domainEndpointsContainer {
            domainEndpointsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in domainEndpointsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    domainEndpointsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        domainEndpoints = domainEndpointsDecoded0
        let advancedSecurityOptionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails.self, forKey: .advancedSecurityOptions)
        advancedSecurityOptions = advancedSecurityOptionsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an Amazon OpenSearch Service domain.
    public struct AwsOpenSearchServiceDomainDetails: Swift.Equatable {
        /// IAM policy document that specifies the access policies for the OpenSearch Service domain.
        public var accessPolicies: Swift.String?
        /// Specifies options for fine-grained access control.
        public var advancedSecurityOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails?
        /// The ARN of the OpenSearch Service domain.
        public var arn: Swift.String?
        /// Details about the configuration of an OpenSearch cluster.
        public var clusterConfig: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails?
        /// The domain endpoint.
        public var domainEndpoint: Swift.String?
        /// Additional options for the domain endpoint.
        public var domainEndpointOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails?
        /// The domain endpoints. Used if the OpenSearch domain resides in a VPC. This is a map of key-value pairs. The key is always vpc. The value is the endpoint.
        public var domainEndpoints: [Swift.String:Swift.String]?
        /// The name of the endpoint.
        public var domainName: Swift.String?
        /// Details about the configuration for encryption at rest.
        public var encryptionAtRestOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails?
        /// The version of the domain engine.
        public var engineVersion: Swift.String?
        /// The identifier of the domain.
        public var id: Swift.String?
        /// Configures the CloudWatch Logs to publish for the OpenSearch domain.
        public var logPublishingOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails?
        /// Details about the configuration for node-to-node encryption.
        public var nodeToNodeEncryptionOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails?
        /// Information about the status of a domain relative to the latest service software.
        public var serviceSoftwareOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails?
        /// Information that OpenSearch Service derives based on VPCOptions for the domain.
        public var vpcOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails?

        public init (
            accessPolicies: Swift.String? = nil,
            advancedSecurityOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails? = nil,
            arn: Swift.String? = nil,
            clusterConfig: SecurityHubClientTypes.AwsOpenSearchServiceDomainClusterConfigDetails? = nil,
            domainEndpoint: Swift.String? = nil,
            domainEndpointOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails? = nil,
            domainEndpoints: [Swift.String:Swift.String]? = nil,
            domainName: Swift.String? = nil,
            encryptionAtRestOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails? = nil,
            engineVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            logPublishingOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails? = nil,
            nodeToNodeEncryptionOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails? = nil,
            serviceSoftwareOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails? = nil,
            vpcOptions: SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails? = nil
        )
        {
            self.accessPolicies = accessPolicies
            self.advancedSecurityOptions = advancedSecurityOptions
            self.arn = arn
            self.clusterConfig = clusterConfig
            self.domainEndpoint = domainEndpoint
            self.domainEndpointOptions = domainEndpointOptions
            self.domainEndpoints = domainEndpoints
            self.domainName = domainName
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.id = id
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.vpcOptions = vpcOptions
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainDomainEndpointOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customEndpoint = "CustomEndpoint"
        case customEndpointCertificateArn = "CustomEndpointCertificateArn"
        case customEndpointEnabled = "CustomEndpointEnabled"
        case enforceHTTPS = "EnforceHTTPS"
        case tlsSecurityPolicy = "TLSSecurityPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customEndpoint = self.customEndpoint {
            try encodeContainer.encode(customEndpoint, forKey: .customEndpoint)
        }
        if let customEndpointCertificateArn = self.customEndpointCertificateArn {
            try encodeContainer.encode(customEndpointCertificateArn, forKey: .customEndpointCertificateArn)
        }
        if customEndpointEnabled != false {
            try encodeContainer.encode(customEndpointEnabled, forKey: .customEndpointEnabled)
        }
        if enforceHTTPS != false {
            try encodeContainer.encode(enforceHTTPS, forKey: .enforceHTTPS)
        }
        if let tlsSecurityPolicy = self.tlsSecurityPolicy {
            try encodeContainer.encode(tlsSecurityPolicy, forKey: .tlsSecurityPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customEndpointCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpointCertificateArn)
        customEndpointCertificateArn = customEndpointCertificateArnDecoded
        let customEndpointEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .customEndpointEnabled) ?? false
        customEndpointEnabled = customEndpointEnabledDecoded
        let enforceHTTPSDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enforceHTTPS) ?? false
        enforceHTTPS = enforceHTTPSDecoded
        let customEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customEndpoint)
        customEndpoint = customEndpointDecoded
        let tlsSecurityPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tlsSecurityPolicy)
        tlsSecurityPolicy = tlsSecurityPolicyDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about additional options for the domain endpoint.
    public struct AwsOpenSearchServiceDomainDomainEndpointOptionsDetails: Swift.Equatable {
        /// The fully qualified URL for the custom endpoint.
        public var customEndpoint: Swift.String?
        /// The ARN for the security certificate. The certificate is managed in ACM.
        public var customEndpointCertificateArn: Swift.String?
        /// Whether to enable a custom endpoint for the domain.
        public var customEndpointEnabled: Swift.Bool
        /// Whether to require that all traffic to the domain arrive over HTTPS.
        public var enforceHTTPS: Swift.Bool
        /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch domain.
        public var tlsSecurityPolicy: Swift.String?

        public init (
            customEndpoint: Swift.String? = nil,
            customEndpointCertificateArn: Swift.String? = nil,
            customEndpointEnabled: Swift.Bool = false,
            enforceHTTPS: Swift.Bool = false,
            tlsSecurityPolicy: Swift.String? = nil
        )
        {
            self.customEndpoint = customEndpoint
            self.customEndpointCertificateArn = customEndpointCertificateArn
            self.customEndpointEnabled = customEndpointEnabled
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the configuration for encryption at rest for the OpenSearch domain.
    public struct AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails: Swift.Equatable {
        /// Whether encryption at rest is enabled.
        public var enabled: Swift.Bool
        /// The KMS key ID.
        public var kmsKeyId: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = self.cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// Configuration details for a log publishing option.
    public struct AwsOpenSearchServiceDomainLogPublishingOption: Swift.Equatable {
        /// The ARN of the CloudWatch Logs group to publish the logs to.
        public var cloudWatchLogsLogGroupArn: Swift.String?
        /// Whether the log publishing is enabled.
        public var enabled: Swift.Bool

        public init (
            cloudWatchLogsLogGroupArn: Swift.String? = nil,
            enabled: Swift.Bool = false
        )
        {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "AuditLogs"
        case indexSlowLogs = "IndexSlowLogs"
        case searchSlowLogs = "SearchSlowLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
        if let indexSlowLogs = self.indexSlowLogs {
            try encodeContainer.encode(indexSlowLogs, forKey: .indexSlowLogs)
        }
        if let searchSlowLogs = self.searchSlowLogs {
            try encodeContainer.encode(searchSlowLogs, forKey: .searchSlowLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indexSlowLogsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption.self, forKey: .indexSlowLogs)
        indexSlowLogs = indexSlowLogsDecoded
        let searchSlowLogsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption.self, forKey: .searchSlowLogs)
        searchSlowLogs = searchSlowLogsDecoded
        let auditLogsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Configures the CloudWatch Logs to publish for the OpenSearch domain.
    public struct AwsOpenSearchServiceDomainLogPublishingOptionsDetails: Swift.Equatable {
        /// Configures the OpenSearch audit logs publishing.
        public var auditLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption?
        /// Configures the OpenSearch index logs publishing.
        public var indexSlowLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption?
        /// Configures the OpenSearch search slow log publishing.
        public var searchSlowLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption?

        public init (
            auditLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption? = nil,
            indexSlowLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption? = nil,
            searchSlowLogs: SecurityHubClientTypes.AwsOpenSearchServiceDomainLogPublishingOption? = nil
        )
        {
            self.auditLogs = auditLogs
            self.indexSlowLogs = indexSlowLogs
            self.searchSlowLogs = searchSlowLogs
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainMasterUserOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case masterUserArn = "MasterUserArn"
        case masterUserName = "MasterUserName"
        case masterUserPassword = "MasterUserPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let masterUserArn = self.masterUserArn {
            try encodeContainer.encode(masterUserArn, forKey: .masterUserArn)
        }
        if let masterUserName = self.masterUserName {
            try encodeContainer.encode(masterUserName, forKey: .masterUserName)
        }
        if let masterUserPassword = self.masterUserPassword {
            try encodeContainer.encode(masterUserPassword, forKey: .masterUserPassword)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserArn)
        masterUserArn = masterUserArnDecoded
        let masterUserNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserName)
        masterUserName = masterUserNameDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies information about the master user of the domain.
    public struct AwsOpenSearchServiceDomainMasterUserOptionsDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the master user.
        public var masterUserArn: Swift.String?
        /// The username for the master user.
        public var masterUserName: Swift.String?
        /// The password for the master user.
        public var masterUserPassword: Swift.String?

        public init (
            masterUserArn: Swift.String? = nil,
            masterUserName: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil
        )
        {
            self.masterUserArn = masterUserArn
            self.masterUserName = masterUserName
            self.masterUserPassword = masterUserPassword
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the configuration for node-to-node encryption.
    public struct AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails: Swift.Equatable {
        /// Whether node-to-node encryption is enabled.
        public var enabled: Swift.Bool

        public init (
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedUpdateDate = "AutomatedUpdateDate"
        case cancellable = "Cancellable"
        case currentVersion = "CurrentVersion"
        case description = "Description"
        case newVersion = "NewVersion"
        case optionalDeployment = "OptionalDeployment"
        case updateAvailable = "UpdateAvailable"
        case updateStatus = "UpdateStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automatedUpdateDate = self.automatedUpdateDate {
            try encodeContainer.encode(automatedUpdateDate, forKey: .automatedUpdateDate)
        }
        if cancellable != false {
            try encodeContainer.encode(cancellable, forKey: .cancellable)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let newVersion = self.newVersion {
            try encodeContainer.encode(newVersion, forKey: .newVersion)
        }
        if optionalDeployment != false {
            try encodeContainer.encode(optionalDeployment, forKey: .optionalDeployment)
        }
        if updateAvailable != false {
            try encodeContainer.encode(updateAvailable, forKey: .updateAvailable)
        }
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus, forKey: .updateStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automatedUpdateDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automatedUpdateDate)
        automatedUpdateDate = automatedUpdateDateDecoded
        let cancellableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cancellable) ?? false
        cancellable = cancellableDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let newVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newVersion)
        newVersion = newVersionDecoded
        let updateAvailableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .updateAvailable) ?? false
        updateAvailable = updateAvailableDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let optionalDeploymentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optionalDeployment) ?? false
        optionalDeployment = optionalDeploymentDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the state of the domain relative to the latest service software.
    public struct AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails: Swift.Equatable {
        /// The epoch time when the deployment window closes for required updates. After this time, OpenSearch Service schedules the software upgrade automatically.
        public var automatedUpdateDate: Swift.String?
        /// Whether a request to update the domain can be canceled.
        public var cancellable: Swift.Bool
        /// The version of the service software that is currently installed on the domain.
        public var currentVersion: Swift.String?
        /// A more detailed description of the service software status.
        public var description: Swift.String?
        /// The most recent version of the service software.
        public var newVersion: Swift.String?
        /// Whether the service software update is optional.
        public var optionalDeployment: Swift.Bool
        /// Whether a service software update is available for the domain.
        public var updateAvailable: Swift.Bool
        /// The status of the service software update. Valid values are as follows:
        ///
        /// * COMPLETED
        ///
        /// * ELIGIBLE
        ///
        /// * IN_PROGRESS
        ///
        /// * NOT_ELIGIBLE
        ///
        /// * PENDING_UPDATE
        public var updateStatus: Swift.String?

        public init (
            automatedUpdateDate: Swift.String? = nil,
            cancellable: Swift.Bool = false,
            currentVersion: Swift.String? = nil,
            description: Swift.String? = nil,
            newVersion: Swift.String? = nil,
            optionalDeployment: Swift.Bool = false,
            updateAvailable: Swift.Bool = false,
            updateStatus: Swift.String? = nil
        )
        {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.optionalDeployment = optionalDeployment
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }
    }

}

extension SecurityHubClientTypes.AwsOpenSearchServiceDomainVpcOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for nonemptystring0 in subnetIds {
                try subnetIdsContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Contains information that OpenSearch Service derives based on the VPCOptions for the domain.
    public struct AwsOpenSearchServiceDomainVpcOptionsDetails: Swift.Equatable {
        /// The list of security group IDs that are associated with the VPC endpoints for the domain.
        public var securityGroupIds: [Swift.String]?
        /// A list of subnet IDs that are associated with the VPC endpoints for the domain.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// An IAM role that is associated with the Amazon RDS DB cluster.
    public struct AwsRdsDbClusterAssociatedRole: Swift.Equatable {
        /// The ARN of the IAM role.
        public var roleArn: Swift.String?
        /// The status of the association between the IAM role and the DB cluster. Valid values are as follows:
        ///
        /// * ACTIVE
        ///
        /// * INVALID
        ///
        /// * PENDING
        public var status: Swift.String?

        public init (
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbClusterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityStreamStatus = "ActivityStreamStatus"
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case availabilityZones = "AvailabilityZones"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case clusterCreateTime = "ClusterCreateTime"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case crossAccountClone = "CrossAccountClone"
        case customEndpoints = "CustomEndpoints"
        case databaseName = "DatabaseName"
        case dbClusterIdentifier = "DbClusterIdentifier"
        case dbClusterMembers = "DbClusterMembers"
        case dbClusterOptionGroupMemberships = "DbClusterOptionGroupMemberships"
        case dbClusterParameterGroup = "DbClusterParameterGroup"
        case dbClusterResourceId = "DbClusterResourceId"
        case dbSubnetGroup = "DbSubnetGroup"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case enabledCloudWatchLogsExports = "EnabledCloudWatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case hostedZoneId = "HostedZoneId"
        case httpEndpointEnabled = "HttpEndpointEnabled"
        case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case masterUsername = "MasterUsername"
        case multiAz = "MultiAz"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case readReplicaIdentifiers = "ReadReplicaIdentifiers"
        case readerEndpoint = "ReaderEndpoint"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityStreamStatus = self.activityStreamStatus {
            try encodeContainer.encode(activityStreamStatus, forKey: .activityStreamStatus)
        }
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedRoles)
            for awsrdsdbclusterassociatedrole0 in associatedRoles {
                try associatedRolesContainer.encode(awsrdsdbclusterassociatedrole0)
            }
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for nonemptystring0 in availabilityZones {
                try availabilityZonesContainer.encode(nonemptystring0)
            }
        }
        if backupRetentionPeriod != 0 {
            try encodeContainer.encode(backupRetentionPeriod, forKey: .backupRetentionPeriod)
        }
        if let clusterCreateTime = self.clusterCreateTime {
            try encodeContainer.encode(clusterCreateTime, forKey: .clusterCreateTime)
        }
        if copyTagsToSnapshot != false {
            try encodeContainer.encode(copyTagsToSnapshot, forKey: .copyTagsToSnapshot)
        }
        if crossAccountClone != false {
            try encodeContainer.encode(crossAccountClone, forKey: .crossAccountClone)
        }
        if let customEndpoints = customEndpoints {
            var customEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customEndpoints)
            for nonemptystring0 in customEndpoints {
                try customEndpointsContainer.encode(nonemptystring0)
            }
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dbClusterIdentifier = self.dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let dbClusterMembers = dbClusterMembers {
            var dbClusterMembersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbClusterMembers)
            for awsrdsdbclustermember0 in dbClusterMembers {
                try dbClusterMembersContainer.encode(awsrdsdbclustermember0)
            }
        }
        if let dbClusterOptionGroupMemberships = dbClusterOptionGroupMemberships {
            var dbClusterOptionGroupMembershipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbClusterOptionGroupMemberships)
            for awsrdsdbclusteroptiongroupmembership0 in dbClusterOptionGroupMemberships {
                try dbClusterOptionGroupMembershipsContainer.encode(awsrdsdbclusteroptiongroupmembership0)
            }
        }
        if let dbClusterParameterGroup = self.dbClusterParameterGroup {
            try encodeContainer.encode(dbClusterParameterGroup, forKey: .dbClusterParameterGroup)
        }
        if let dbClusterResourceId = self.dbClusterResourceId {
            try encodeContainer.encode(dbClusterResourceId, forKey: .dbClusterResourceId)
        }
        if let dbSubnetGroup = self.dbSubnetGroup {
            try encodeContainer.encode(dbSubnetGroup, forKey: .dbSubnetGroup)
        }
        if deletionProtection != false {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainMemberships)
            for awsrdsdbdomainmembership0 in domainMemberships {
                try domainMembershipsContainer.encode(awsrdsdbdomainmembership0)
            }
        }
        if let enabledCloudWatchLogsExports = enabledCloudWatchLogsExports {
            var enabledCloudWatchLogsExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enabledCloudWatchLogsExports)
            for nonemptystring0 in enabledCloudWatchLogsExports {
                try enabledCloudWatchLogsExportsContainer.encode(nonemptystring0)
            }
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineMode = self.engineMode {
            try encodeContainer.encode(engineMode, forKey: .engineMode)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostedZoneId = self.hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
        if httpEndpointEnabled != false {
            try encodeContainer.encode(httpEndpointEnabled, forKey: .httpEndpointEnabled)
        }
        if iamDatabaseAuthenticationEnabled != false {
            try encodeContainer.encode(iamDatabaseAuthenticationEnabled, forKey: .iamDatabaseAuthenticationEnabled)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let masterUsername = self.masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if multiAz != false {
            try encodeContainer.encode(multiAz, forKey: .multiAz)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let preferredBackupWindow = self.preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let readReplicaIdentifiers = readReplicaIdentifiers {
            var readReplicaIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readReplicaIdentifiers)
            for nonemptystring0 in readReplicaIdentifiers {
                try readReplicaIdentifiersContainer.encode(nonemptystring0)
            }
        }
        if let readerEndpoint = self.readerEndpoint {
            try encodeContainer.encode(readerEndpoint, forKey: .readerEndpoint)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if storageEncrypted != false {
            try encodeContainer.encode(storageEncrypted, forKey: .storageEncrypted)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for awsrdsdbinstancevpcsecuritygroup0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(awsrdsdbinstancevpcsecuritygroup0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage) ?? 0
        allocatedStorage = allocatedStorageDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod) ?? 0
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let readerEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readerEndpoint)
        readerEndpoint = readerEndpointDecoded
        let customEndpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .customEndpoints)
        var customEndpointsDecoded0:[Swift.String]? = nil
        if let customEndpointsContainer = customEndpointsContainer {
            customEndpointsDecoded0 = [Swift.String]()
            for string0 in customEndpointsContainer {
                if let string0 = string0 {
                    customEndpointsDecoded0?.append(string0)
                }
            }
        }
        customEndpoints = customEndpointsDecoded0
        let multiAzDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAz) ?? false
        multiAz = multiAzDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let readReplicaIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .readReplicaIdentifiers)
        var readReplicaIdentifiersDecoded0:[Swift.String]? = nil
        if let readReplicaIdentifiersContainer = readReplicaIdentifiersContainer {
            readReplicaIdentifiersDecoded0 = [Swift.String]()
            for string0 in readReplicaIdentifiersContainer {
                if let string0 = string0 {
                    readReplicaIdentifiersDecoded0?.append(string0)
                }
            }
        }
        readReplicaIdentifiers = readReplicaIdentifiersDecoded0
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted) ?? false
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterResourceId)
        dbClusterResourceId = dbClusterResourceIdDecoded
        let associatedRolesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole?].self, forKey: .associatedRoles)
        var associatedRolesDecoded0:[SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole]? = nil
        if let associatedRolesContainer = associatedRolesContainer {
            associatedRolesDecoded0 = [SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole]()
            for structure0 in associatedRolesContainer {
                if let structure0 = structure0 {
                    associatedRolesDecoded0?.append(structure0)
                }
            }
        }
        associatedRoles = associatedRolesDecoded0
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        clusterCreateTime = clusterCreateTimeDecoded
        let enabledCloudWatchLogsExportsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enabledCloudWatchLogsExports)
        var enabledCloudWatchLogsExportsDecoded0:[Swift.String]? = nil
        if let enabledCloudWatchLogsExportsContainer = enabledCloudWatchLogsExportsContainer {
            enabledCloudWatchLogsExportsDecoded0 = [Swift.String]()
            for string0 in enabledCloudWatchLogsExportsContainer {
                if let string0 = string0 {
                    enabledCloudWatchLogsExportsDecoded0?.append(string0)
                }
            }
        }
        enabledCloudWatchLogsExports = enabledCloudWatchLogsExportsDecoded0
        let engineModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection) ?? false
        deletionProtection = deletionProtectionDecoded
        let httpEndpointEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .httpEndpointEnabled) ?? false
        httpEndpointEnabled = httpEndpointEnabledDecoded
        let activityStreamStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamStatus)
        activityStreamStatus = activityStreamStatusDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot) ?? false
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let crossAccountCloneDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccountClone) ?? false
        crossAccountClone = crossAccountCloneDecoded
        let domainMembershipsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbDomainMembership?].self, forKey: .domainMemberships)
        var domainMembershipsDecoded0:[SecurityHubClientTypes.AwsRdsDbDomainMembership]? = nil
        if let domainMembershipsContainer = domainMembershipsContainer {
            domainMembershipsDecoded0 = [SecurityHubClientTypes.AwsRdsDbDomainMembership]()
            for structure0 in domainMembershipsContainer {
                if let structure0 = structure0 {
                    domainMembershipsDecoded0?.append(structure0)
                }
            }
        }
        domainMemberships = domainMembershipsDecoded0
        let dbClusterParameterGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterParameterGroup)
        dbClusterParameterGroup = dbClusterParameterGroupDecoded
        let dbSubnetGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbSubnetGroup)
        dbSubnetGroup = dbSubnetGroupDecoded
        let dbClusterOptionGroupMembershipsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership?].self, forKey: .dbClusterOptionGroupMemberships)
        var dbClusterOptionGroupMembershipsDecoded0:[SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership]? = nil
        if let dbClusterOptionGroupMembershipsContainer = dbClusterOptionGroupMembershipsContainer {
            dbClusterOptionGroupMembershipsDecoded0 = [SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership]()
            for structure0 in dbClusterOptionGroupMembershipsContainer {
                if let structure0 = structure0 {
                    dbClusterOptionGroupMembershipsDecoded0?.append(structure0)
                }
            }
        }
        dbClusterOptionGroupMemberships = dbClusterOptionGroupMembershipsDecoded0
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let dbClusterMembersContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbClusterMember?].self, forKey: .dbClusterMembers)
        var dbClusterMembersDecoded0:[SecurityHubClientTypes.AwsRdsDbClusterMember]? = nil
        if let dbClusterMembersContainer = dbClusterMembersContainer {
            dbClusterMembersDecoded0 = [SecurityHubClientTypes.AwsRdsDbClusterMember]()
            for structure0 in dbClusterMembersContainer {
                if let structure0 = structure0 {
                    dbClusterMembersDecoded0?.append(structure0)
                }
            }
        }
        dbClusterMembers = dbClusterMembersDecoded0
        let iamDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iamDatabaseAuthenticationEnabled) ?? false
        iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an Amazon RDS DB cluster.
    public struct AwsRdsDbClusterDetails: Swift.Equatable {
        /// The status of the database activity stream. Valid values are as follows:
        ///
        /// * started
        ///
        /// * starting
        ///
        /// * stopped
        ///
        /// * stopping
        public var activityStreamStatus: Swift.String?
        /// For all database engines except Aurora, specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        /// A list of the IAM roles that are associated with the DB cluster.
        public var associatedRoles: [SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole]?
        /// A list of Availability Zones (AZs) where instances in the DB cluster can be created.
        public var availabilityZones: [Swift.String]?
        /// The number of days for which automated backups are retained.
        public var backupRetentionPeriod: Swift.Int
        /// Indicates when the DB cluster was created, in Universal Coordinated Time (UTC). Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var clusterCreateTime: Swift.String?
        /// Whether tags are copied from the DB cluster to snapshots of the DB cluster.
        public var copyTagsToSnapshot: Swift.Bool
        /// Whether the DB cluster is a clone of a DB cluster owned by a different Amazon Web Services account.
        public var crossAccountClone: Swift.Bool
        /// A list of custom endpoints for the DB cluster.
        public var customEndpoints: [Swift.String]?
        /// The name of the database.
        public var databaseName: Swift.String?
        /// The DB cluster identifier that the user assigned to the cluster. This identifier is the unique key that identifies a DB cluster.
        public var dbClusterIdentifier: Swift.String?
        /// The list of instances that make up the DB cluster.
        public var dbClusterMembers: [SecurityHubClientTypes.AwsRdsDbClusterMember]?
        /// The list of option group memberships for this DB cluster.
        public var dbClusterOptionGroupMemberships: [SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership]?
        /// The name of the DB cluster parameter group for the DB cluster.
        public var dbClusterParameterGroup: Swift.String?
        /// The identifier of the DB cluster. The identifier must be unique within each Amazon Web Services Region and is immutable.
        public var dbClusterResourceId: Swift.String?
        /// The subnet group that is associated with the DB cluster, including the name, description, and subnets in the subnet group.
        public var dbSubnetGroup: Swift.String?
        /// Whether the DB cluster has deletion protection enabled.
        public var deletionProtection: Swift.Bool
        /// The Active Directory domain membership records that are associated with the DB cluster.
        public var domainMemberships: [SecurityHubClientTypes.AwsRdsDbDomainMembership]?
        /// A list of log types that this DB cluster is configured to export to CloudWatch Logs.
        public var enabledCloudWatchLogsExports: [Swift.String]?
        /// The connection endpoint for the primary instance of the DB cluster.
        public var endpoint: Swift.String?
        /// The name of the database engine to use for this DB cluster. Valid values are as follows:
        ///
        /// * aurora
        ///
        /// * aurora-mysql
        ///
        /// * aurora-postgresql
        public var engine: Swift.String?
        /// The database engine mode of the DB cluster.Valid values are as follows:
        ///
        /// * global
        ///
        /// * multimaster
        ///
        /// * parallelquery
        ///
        /// * provisioned
        ///
        /// * serverless
        public var engineMode: Swift.String?
        /// The version number of the database engine to use.
        public var engineVersion: Swift.String?
        /// Specifies the identifier that Amazon Route 53 assigns when you create a hosted zone.
        public var hostedZoneId: Swift.String?
        /// Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.
        public var httpEndpointEnabled: Swift.Bool
        /// Whether the mapping of IAM accounts to database accounts is enabled.
        public var iamDatabaseAuthenticationEnabled: Swift.Bool
        /// The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.
        public var kmsKeyId: Swift.String?
        /// The name of the master user for the DB cluster.
        public var masterUsername: Swift.String?
        /// Whether the DB cluster has instances in multiple Availability Zones.
        public var multiAz: Swift.Bool
        /// The port number on which the DB instances in the DB cluster accept connections.
        public var port: Swift.Int
        /// The range of time each day when automated backups are created, if automated backups are enabled. Uses the format HH:MM-HH:MM. For example, 04:52-05:22.
        public var preferredBackupWindow: Swift.String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Uses the format :HH:MM-:HH:MM. For the day values, use mon|tue|wed|thu|fri|sat|sun. For example, sun:09:32-sun:10:02.
        public var preferredMaintenanceWindow: Swift.String?
        /// The identifiers of the read replicas that are associated with this DB cluster.
        public var readReplicaIdentifiers: [Swift.String]?
        /// The reader endpoint for the DB cluster.
        public var readerEndpoint: Swift.String?
        /// The current status of this DB cluster.
        public var status: Swift.String?
        /// Whether the DB cluster is encrypted.
        public var storageEncrypted: Swift.Bool
        /// A list of VPC security groups that the DB cluster belongs to.
        public var vpcSecurityGroups: [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]?

        public init (
            activityStreamStatus: Swift.String? = nil,
            allocatedStorage: Swift.Int = 0,
            associatedRoles: [SecurityHubClientTypes.AwsRdsDbClusterAssociatedRole]? = nil,
            availabilityZones: [Swift.String]? = nil,
            backupRetentionPeriod: Swift.Int = 0,
            clusterCreateTime: Swift.String? = nil,
            copyTagsToSnapshot: Swift.Bool = false,
            crossAccountClone: Swift.Bool = false,
            customEndpoints: [Swift.String]? = nil,
            databaseName: Swift.String? = nil,
            dbClusterIdentifier: Swift.String? = nil,
            dbClusterMembers: [SecurityHubClientTypes.AwsRdsDbClusterMember]? = nil,
            dbClusterOptionGroupMemberships: [SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership]? = nil,
            dbClusterParameterGroup: Swift.String? = nil,
            dbClusterResourceId: Swift.String? = nil,
            dbSubnetGroup: Swift.String? = nil,
            deletionProtection: Swift.Bool = false,
            domainMemberships: [SecurityHubClientTypes.AwsRdsDbDomainMembership]? = nil,
            enabledCloudWatchLogsExports: [Swift.String]? = nil,
            endpoint: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineMode: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            httpEndpointEnabled: Swift.Bool = false,
            iamDatabaseAuthenticationEnabled: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            multiAz: Swift.Bool = false,
            port: Swift.Int = 0,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            readReplicaIdentifiers: [Swift.String]? = nil,
            readerEndpoint: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool = false,
            vpcSecurityGroups: [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]? = nil
        )
        {
            self.activityStreamStatus = activityStreamStatus
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.availabilityZones = availabilityZones
            self.backupRetentionPeriod = backupRetentionPeriod
            self.clusterCreateTime = clusterCreateTime
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.crossAccountClone = crossAccountClone
            self.customEndpoints = customEndpoints
            self.databaseName = databaseName
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterMembers = dbClusterMembers
            self.dbClusterOptionGroupMemberships = dbClusterOptionGroupMemberships
            self.dbClusterParameterGroup = dbClusterParameterGroup
            self.dbClusterResourceId = dbClusterResourceId
            self.dbSubnetGroup = dbSubnetGroup
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineMode = engineMode
            self.engineVersion = engineVersion
            self.hostedZoneId = hostedZoneId
            self.httpEndpointEnabled = httpEndpointEnabled
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.masterUsername = masterUsername
            self.multiAz = multiAz
            self.port = port
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.readReplicaIdentifiers = readReplicaIdentifiers
            self.readerEndpoint = readerEndpoint
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbClusterMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbClusterParameterGroupStatus = "DbClusterParameterGroupStatus"
        case dbInstanceIdentifier = "DbInstanceIdentifier"
        case isClusterWriter = "IsClusterWriter"
        case promotionTier = "PromotionTier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbClusterParameterGroupStatus = self.dbClusterParameterGroupStatus {
            try encodeContainer.encode(dbClusterParameterGroupStatus, forKey: .dbClusterParameterGroupStatus)
        }
        if let dbInstanceIdentifier = self.dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if isClusterWriter != false {
            try encodeContainer.encode(isClusterWriter, forKey: .isClusterWriter)
        }
        if promotionTier != 0 {
            try encodeContainer.encode(promotionTier, forKey: .promotionTier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isClusterWriterDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isClusterWriter) ?? false
        isClusterWriter = isClusterWriterDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier) ?? 0
        promotionTier = promotionTierDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let dbClusterParameterGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterParameterGroupStatus)
        dbClusterParameterGroupStatus = dbClusterParameterGroupStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an instance in the DB cluster.
    public struct AwsRdsDbClusterMember: Swift.Equatable {
        /// The status of the DB cluster parameter group for this member of the DB cluster.
        public var dbClusterParameterGroupStatus: Swift.String?
        /// The instance identifier for this member of the DB cluster.
        public var dbInstanceIdentifier: Swift.String?
        /// Whether the cluster member is the primary instance for the DB cluster.
        public var isClusterWriter: Swift.Bool
        /// Specifies the order in which an Aurora replica is promoted to the primary instance when the existing primary instance fails.
        public var promotionTier: Swift.Int

        public init (
            dbClusterParameterGroupStatus: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            isClusterWriter: Swift.Bool = false,
            promotionTier: Swift.Int = 0
        )
        {
            self.dbClusterParameterGroupStatus = dbClusterParameterGroupStatus
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.isClusterWriter = isClusterWriter
            self.promotionTier = promotionTier
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbClusterOptionGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbClusterOptionGroupName = "DbClusterOptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbClusterOptionGroupName = self.dbClusterOptionGroupName {
            try encodeContainer.encode(dbClusterOptionGroupName, forKey: .dbClusterOptionGroupName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbClusterOptionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterOptionGroupName)
        dbClusterOptionGroupName = dbClusterOptionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an option group membership for a DB cluster.
    public struct AwsRdsDbClusterOptionGroupMembership: Swift.Equatable {
        /// The name of the DB cluster option group.
        public var dbClusterOptionGroupName: Swift.String?
        /// The status of the DB cluster option group.
        public var status: Swift.String?

        public init (
            dbClusterOptionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.dbClusterOptionGroupName = dbClusterOptionGroupName
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZones = "AvailabilityZones"
        case clusterCreateTime = "ClusterCreateTime"
        case dbClusterIdentifier = "DbClusterIdentifier"
        case dbClusterSnapshotIdentifier = "DbClusterSnapshotIdentifier"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for nonemptystring0 in availabilityZones {
                try availabilityZonesContainer.encode(nonemptystring0)
            }
        }
        if let clusterCreateTime = self.clusterCreateTime {
            try encodeContainer.encode(clusterCreateTime, forKey: .clusterCreateTime)
        }
        if let dbClusterIdentifier = self.dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let dbClusterSnapshotIdentifier = self.dbClusterSnapshotIdentifier {
            try encodeContainer.encode(dbClusterSnapshotIdentifier, forKey: .dbClusterSnapshotIdentifier)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if iamDatabaseAuthenticationEnabled != false {
            try encodeContainer.encode(iamDatabaseAuthenticationEnabled, forKey: .iamDatabaseAuthenticationEnabled)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseModel = self.licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let masterUsername = self.masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if percentProgress != 0 {
            try encodeContainer.encode(percentProgress, forKey: .percentProgress)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let snapshotCreateTime = self.snapshotCreateTime {
            try encodeContainer.encode(snapshotCreateTime, forKey: .snapshotCreateTime)
        }
        if let snapshotType = self.snapshotType {
            try encodeContainer.encode(snapshotType, forKey: .snapshotType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if storageEncrypted != false {
            try encodeContainer.encode(storageEncrypted, forKey: .storageEncrypted)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage) ?? 0
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        clusterCreateTime = clusterCreateTimeDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let percentProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentProgress) ?? 0
        percentProgress = percentProgressDecoded
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted) ?? false
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let dbClusterSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterSnapshotIdentifier)
        dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifierDecoded
        let iamDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iamDatabaseAuthenticationEnabled) ?? false
        iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an Amazon RDS DB cluster snapshot.
    public struct AwsRdsDbClusterSnapshotDetails: Swift.Equatable {
        /// Specifies the allocated storage size in gibibytes (GiB).
        public var allocatedStorage: Swift.Int
        /// A list of Availability Zones where instances in the DB cluster can be created.
        public var availabilityZones: [Swift.String]?
        /// Indicates when the DB cluster was created, in Universal Coordinated Time (UTC). Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var clusterCreateTime: Swift.String?
        /// The DB cluster identifier.
        public var dbClusterIdentifier: Swift.String?
        /// The identifier of the DB cluster snapshot.
        public var dbClusterSnapshotIdentifier: Swift.String?
        /// The name of the database engine that you want to use for this DB instance.
        public var engine: Swift.String?
        /// The version of the database engine to use.
        public var engineVersion: Swift.String?
        /// Whether mapping of IAM accounts to database accounts is enabled.
        public var iamDatabaseAuthenticationEnabled: Swift.Bool
        /// The ARN of the KMS master key that is used to encrypt the database instances in the DB cluster.
        public var kmsKeyId: Swift.String?
        /// The license model information for this DB cluster snapshot.
        public var licenseModel: Swift.String?
        /// The name of the master user for the DB cluster.
        public var masterUsername: Swift.String?
        /// Specifies the percentage of the estimated data that has been transferred.
        public var percentProgress: Swift.Int
        /// The port number on which the DB instances in the DB cluster accept connections.
        public var port: Swift.Int
        /// Indicates when the snapshot was taken. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var snapshotCreateTime: Swift.String?
        /// The type of DB cluster snapshot.
        public var snapshotType: Swift.String?
        /// The status of this DB cluster snapshot.
        public var status: Swift.String?
        /// Whether the DB cluster is encrypted.
        public var storageEncrypted: Swift.Bool
        /// The VPC ID that is associated with the DB cluster snapshot.
        public var vpcId: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            availabilityZones: [Swift.String]? = nil,
            clusterCreateTime: Swift.String? = nil,
            dbClusterIdentifier: Swift.String? = nil,
            dbClusterSnapshotIdentifier: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iamDatabaseAuthenticationEnabled: Swift.Bool = false,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            percentProgress: Swift.Int = 0,
            port: Swift.Int = 0,
            snapshotCreateTime: Swift.String? = nil,
            snapshotType: Swift.String? = nil,
            status: Swift.String? = nil,
            storageEncrypted: Swift.Bool = false,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZones = availabilityZones
            self.clusterCreateTime = clusterCreateTime
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbClusterSnapshotIdentifier = dbClusterSnapshotIdentifier
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.percentProgress = percentProgress
            self.port = port
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.status = status
            self.storageEncrypted = storageEncrypted
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbDomainMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
        case fqdn = "Fqdn"
        case iamRoleName = "IamRoleName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let fqdn = self.fqdn {
            try encodeContainer.encode(fqdn, forKey: .fqdn)
        }
        if let iamRoleName = self.iamRoleName {
            try encodeContainer.encode(iamRoleName, forKey: .iamRoleName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let fqdnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdn)
        fqdn = fqdnDecoded
        let iamRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleName)
        iamRoleName = iamRoleNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about an Active Directory domain membership record associated with the DB instance.
    public struct AwsRdsDbDomainMembership: Swift.Equatable {
        /// The identifier of the Active Directory domain.
        public var domain: Swift.String?
        /// The fully qualified domain name of the Active Directory domain.
        public var fqdn: Swift.String?
        /// The name of the IAM role to use when making API calls to the Directory Service.
        public var iamRoleName: Swift.String?
        /// The status of the Active Directory Domain membership for the DB instance.
        public var status: Swift.String?

        public init (
            domain: Swift.String? = nil,
            fqdn: Swift.String? = nil,
            iamRoleName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.domain = domain
            self.fqdn = fqdn
            self.iamRoleName = iamRoleName
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case featureName = "FeatureName"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featureName = self.featureName {
            try encodeContainer.encode(featureName, forKey: .featureName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// An IAM role associated with the DB instance.
    public struct AwsRdsDbInstanceAssociatedRole: Swift.Equatable {
        /// The name of the feature associated with the IAM role.
        public var featureName: Swift.String?
        /// The ARN of the IAM role that is associated with the DB instance.
        public var roleArn: Swift.String?
        /// Describes the state of the association between the IAM role and the DB instance. The Status property returns one of the following values:
        ///
        /// * ACTIVE - The IAM role ARN is associated with the DB instance and can be used to access other Amazon Web Services services on your behalf.
        ///
        /// * PENDING - The IAM role ARN is being associated with the DB instance.
        ///
        /// * INVALID - The IAM role ARN is associated with the DB instance. But the DB instance is unable to assume the IAM role in order to access other Amazon Web Services services on your behalf.
        public var status: Swift.String?

        public init (
            featureName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.featureName = featureName
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case availabilityZone = "AvailabilityZone"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case caCertificateIdentifier = "CACertificateIdentifier"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dbClusterIdentifier = "DBClusterIdentifier"
        case dbInstanceClass = "DBInstanceClass"
        case dbInstanceIdentifier = "DBInstanceIdentifier"
        case dbName = "DBName"
        case dbInstancePort = "DbInstancePort"
        case dbInstanceStatus = "DbInstanceStatus"
        case dbParameterGroups = "DbParameterGroups"
        case dbSecurityGroups = "DbSecurityGroups"
        case dbSubnetGroup = "DbSubnetGroup"
        case dbiResourceId = "DbiResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case enabledCloudWatchLogsExports = "EnabledCloudWatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case enhancedMonitoringResourceArn = "EnhancedMonitoringResourceArn"
        case iamDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case licenseModel = "LicenseModel"
        case listenerEndpoint = "ListenerEndpoint"
        case masterUsername = "MasterUsername"
        case maxAllocatedStorage = "MaxAllocatedStorage"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAz = "MultiAz"
        case optionGroupMemberships = "OptionGroupMemberships"
        case pendingModifiedValues = "PendingModifiedValues"
        case performanceInsightsEnabled = "PerformanceInsightsEnabled"
        case performanceInsightsKmsKeyId = "PerformanceInsightsKmsKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case processorFeatures = "ProcessorFeatures"
        case promotionTier = "PromotionTier"
        case publiclyAccessible = "PubliclyAccessible"
        case readReplicaDBClusterIdentifiers = "ReadReplicaDBClusterIdentifiers"
        case readReplicaDBInstanceIdentifiers = "ReadReplicaDBInstanceIdentifiers"
        case readReplicaSourceDBInstanceIdentifier = "ReadReplicaSourceDBInstanceIdentifier"
        case secondaryAvailabilityZone = "SecondaryAvailabilityZone"
        case statusInfos = "StatusInfos"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .associatedRoles)
            for awsrdsdbinstanceassociatedrole0 in associatedRoles {
                try associatedRolesContainer.encode(awsrdsdbinstanceassociatedrole0)
            }
        }
        if autoMinorVersionUpgrade != false {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if backupRetentionPeriod != 0 {
            try encodeContainer.encode(backupRetentionPeriod, forKey: .backupRetentionPeriod)
        }
        if let caCertificateIdentifier = self.caCertificateIdentifier {
            try encodeContainer.encode(caCertificateIdentifier, forKey: .caCertificateIdentifier)
        }
        if let characterSetName = self.characterSetName {
            try encodeContainer.encode(characterSetName, forKey: .characterSetName)
        }
        if copyTagsToSnapshot != false {
            try encodeContainer.encode(copyTagsToSnapshot, forKey: .copyTagsToSnapshot)
        }
        if let dbClusterIdentifier = self.dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let dbInstanceClass = self.dbInstanceClass {
            try encodeContainer.encode(dbInstanceClass, forKey: .dbInstanceClass)
        }
        if let dbInstanceIdentifier = self.dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let dbName = self.dbName {
            try encodeContainer.encode(dbName, forKey: .dbName)
        }
        if dbInstancePort != 0 {
            try encodeContainer.encode(dbInstancePort, forKey: .dbInstancePort)
        }
        if let dbInstanceStatus = self.dbInstanceStatus {
            try encodeContainer.encode(dbInstanceStatus, forKey: .dbInstanceStatus)
        }
        if let dbParameterGroups = dbParameterGroups {
            var dbParameterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbParameterGroups)
            for awsrdsdbparametergroup0 in dbParameterGroups {
                try dbParameterGroupsContainer.encode(awsrdsdbparametergroup0)
            }
        }
        if let dbSecurityGroups = dbSecurityGroups {
            var dbSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dbSecurityGroups)
            for nonemptystring0 in dbSecurityGroups {
                try dbSecurityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let dbSubnetGroup = self.dbSubnetGroup {
            try encodeContainer.encode(dbSubnetGroup, forKey: .dbSubnetGroup)
        }
        if let dbiResourceId = self.dbiResourceId {
            try encodeContainer.encode(dbiResourceId, forKey: .dbiResourceId)
        }
        if deletionProtection != false {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainMemberships)
            for awsrdsdbdomainmembership0 in domainMemberships {
                try domainMembershipsContainer.encode(awsrdsdbdomainmembership0)
            }
        }
        if let enabledCloudWatchLogsExports = enabledCloudWatchLogsExports {
            var enabledCloudWatchLogsExportsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enabledCloudWatchLogsExports)
            for nonemptystring0 in enabledCloudWatchLogsExports {
                try enabledCloudWatchLogsExportsContainer.encode(nonemptystring0)
            }
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let enhancedMonitoringResourceArn = self.enhancedMonitoringResourceArn {
            try encodeContainer.encode(enhancedMonitoringResourceArn, forKey: .enhancedMonitoringResourceArn)
        }
        if iamDatabaseAuthenticationEnabled != false {
            try encodeContainer.encode(iamDatabaseAuthenticationEnabled, forKey: .iamDatabaseAuthenticationEnabled)
        }
        if let instanceCreateTime = self.instanceCreateTime {
            try encodeContainer.encode(instanceCreateTime, forKey: .instanceCreateTime)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let latestRestorableTime = self.latestRestorableTime {
            try encodeContainer.encode(latestRestorableTime, forKey: .latestRestorableTime)
        }
        if let licenseModel = self.licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let listenerEndpoint = self.listenerEndpoint {
            try encodeContainer.encode(listenerEndpoint, forKey: .listenerEndpoint)
        }
        if let masterUsername = self.masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if maxAllocatedStorage != 0 {
            try encodeContainer.encode(maxAllocatedStorage, forKey: .maxAllocatedStorage)
        }
        if monitoringInterval != 0 {
            try encodeContainer.encode(monitoringInterval, forKey: .monitoringInterval)
        }
        if let monitoringRoleArn = self.monitoringRoleArn {
            try encodeContainer.encode(monitoringRoleArn, forKey: .monitoringRoleArn)
        }
        if multiAz != false {
            try encodeContainer.encode(multiAz, forKey: .multiAz)
        }
        if let optionGroupMemberships = optionGroupMemberships {
            var optionGroupMembershipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .optionGroupMemberships)
            for awsrdsdboptiongroupmembership0 in optionGroupMemberships {
                try optionGroupMembershipsContainer.encode(awsrdsdboptiongroupmembership0)
            }
        }
        if let pendingModifiedValues = self.pendingModifiedValues {
            try encodeContainer.encode(pendingModifiedValues, forKey: .pendingModifiedValues)
        }
        if performanceInsightsEnabled != false {
            try encodeContainer.encode(performanceInsightsEnabled, forKey: .performanceInsightsEnabled)
        }
        if let performanceInsightsKmsKeyId = self.performanceInsightsKmsKeyId {
            try encodeContainer.encode(performanceInsightsKmsKeyId, forKey: .performanceInsightsKmsKeyId)
        }
        if performanceInsightsRetentionPeriod != 0 {
            try encodeContainer.encode(performanceInsightsRetentionPeriod, forKey: .performanceInsightsRetentionPeriod)
        }
        if let preferredBackupWindow = self.preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processorFeatures)
            for awsrdsdbprocessorfeature0 in processorFeatures {
                try processorFeaturesContainer.encode(awsrdsdbprocessorfeature0)
            }
        }
        if promotionTier != 0 {
            try encodeContainer.encode(promotionTier, forKey: .promotionTier)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers {
            var readReplicaDBClusterIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readReplicaDBClusterIdentifiers)
            for nonemptystring0 in readReplicaDBClusterIdentifiers {
                try readReplicaDBClusterIdentifiersContainer.encode(nonemptystring0)
            }
        }
        if let readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers {
            var readReplicaDBInstanceIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .readReplicaDBInstanceIdentifiers)
            for nonemptystring0 in readReplicaDBInstanceIdentifiers {
                try readReplicaDBInstanceIdentifiersContainer.encode(nonemptystring0)
            }
        }
        if let readReplicaSourceDBInstanceIdentifier = self.readReplicaSourceDBInstanceIdentifier {
            try encodeContainer.encode(readReplicaSourceDBInstanceIdentifier, forKey: .readReplicaSourceDBInstanceIdentifier)
        }
        if let secondaryAvailabilityZone = self.secondaryAvailabilityZone {
            try encodeContainer.encode(secondaryAvailabilityZone, forKey: .secondaryAvailabilityZone)
        }
        if let statusInfos = statusInfos {
            var statusInfosContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusInfos)
            for awsrdsdbstatusinfo0 in statusInfos {
                try statusInfosContainer.encode(awsrdsdbstatusinfo0)
            }
        }
        if storageEncrypted != false {
            try encodeContainer.encode(storageEncrypted, forKey: .storageEncrypted)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
        if let tdeCredentialArn = self.tdeCredentialArn {
            try encodeContainer.encode(tdeCredentialArn, forKey: .tdeCredentialArn)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for awsrdsdbinstancevpcsecuritygroup0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(awsrdsdbinstancevpcsecuritygroup0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedRolesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole?].self, forKey: .associatedRoles)
        var associatedRolesDecoded0:[SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole]? = nil
        if let associatedRolesContainer = associatedRolesContainer {
            associatedRolesDecoded0 = [SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole]()
            for structure0 in associatedRolesContainer {
                if let structure0 = structure0 {
                    associatedRolesDecoded0?.append(structure0)
                }
            }
        }
        associatedRoles = associatedRolesDecoded0
        let caCertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caCertificateIdentifier)
        caCertificateIdentifier = caCertificateIdentifierDecoded
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let dbInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceClass)
        dbInstanceClass = dbInstanceClassDecoded
        let dbInstancePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dbInstancePort) ?? 0
        dbInstancePort = dbInstancePortDecoded
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
        let dbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbName)
        dbName = dbNameDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection) ?? false
        deletionProtection = deletionProtectionDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbInstanceEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let iamDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iamDatabaseAuthenticationEnabled) ?? false
        iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabledDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceCreateTime)
        instanceCreateTime = instanceCreateTimeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible) ?? false
        publiclyAccessible = publiclyAccessibleDecoded
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted) ?? false
        storageEncrypted = storageEncryptedDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let multiAzDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAz) ?? false
        multiAz = multiAzDecoded
        let enhancedMonitoringResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enhancedMonitoringResourceArn)
        enhancedMonitoringResourceArn = enhancedMonitoringResourceArnDecoded
        let dbInstanceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceStatus)
        dbInstanceStatus = dbInstanceStatusDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage) ?? 0
        allocatedStorage = allocatedStorageDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod) ?? 0
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let dbSecurityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dbSecurityGroups)
        var dbSecurityGroupsDecoded0:[Swift.String]? = nil
        if let dbSecurityGroupsContainer = dbSecurityGroupsContainer {
            dbSecurityGroupsDecoded0 = [Swift.String]()
            for string0 in dbSecurityGroupsContainer {
                if let string0 = string0 {
                    dbSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        dbSecurityGroups = dbSecurityGroupsDecoded0
        let dbParameterGroupsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbParameterGroup?].self, forKey: .dbParameterGroups)
        var dbParameterGroupsDecoded0:[SecurityHubClientTypes.AwsRdsDbParameterGroup]? = nil
        if let dbParameterGroupsContainer = dbParameterGroupsContainer {
            dbParameterGroupsDecoded0 = [SecurityHubClientTypes.AwsRdsDbParameterGroup]()
            for structure0 in dbParameterGroupsContainer {
                if let structure0 = structure0 {
                    dbParameterGroupsDecoded0?.append(structure0)
                }
            }
        }
        dbParameterGroups = dbParameterGroupsDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let dbSubnetGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbSubnetGroup.self, forKey: .dbSubnetGroup)
        dbSubnetGroup = dbSubnetGroupDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestRestorableTime)
        latestRestorableTime = latestRestorableTimeDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade) ?? false
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let readReplicaSourceDBInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readReplicaSourceDBInstanceIdentifier)
        readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifierDecoded
        let readReplicaDBInstanceIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .readReplicaDBInstanceIdentifiers)
        var readReplicaDBInstanceIdentifiersDecoded0:[Swift.String]? = nil
        if let readReplicaDBInstanceIdentifiersContainer = readReplicaDBInstanceIdentifiersContainer {
            readReplicaDBInstanceIdentifiersDecoded0 = [Swift.String]()
            for string0 in readReplicaDBInstanceIdentifiersContainer {
                if let string0 = string0 {
                    readReplicaDBInstanceIdentifiersDecoded0?.append(string0)
                }
            }
        }
        readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiersDecoded0
        let readReplicaDBClusterIdentifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .readReplicaDBClusterIdentifiers)
        var readReplicaDBClusterIdentifiersDecoded0:[Swift.String]? = nil
        if let readReplicaDBClusterIdentifiersContainer = readReplicaDBClusterIdentifiersContainer {
            readReplicaDBClusterIdentifiersDecoded0 = [Swift.String]()
            for string0 in readReplicaDBClusterIdentifiersContainer {
                if let string0 = string0 {
                    readReplicaDBClusterIdentifiersDecoded0?.append(string0)
                }
            }
        }
        readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiersDecoded0
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops) ?? 0
        iops = iopsDecoded
        let optionGroupMembershipsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbOptionGroupMembership?].self, forKey: .optionGroupMemberships)
        var optionGroupMembershipsDecoded0:[SecurityHubClientTypes.AwsRdsDbOptionGroupMembership]? = nil
        if let optionGroupMembershipsContainer = optionGroupMembershipsContainer {
            optionGroupMembershipsDecoded0 = [SecurityHubClientTypes.AwsRdsDbOptionGroupMembership]()
            for structure0 in optionGroupMembershipsContainer {
                if let structure0 = structure0 {
                    optionGroupMembershipsDecoded0?.append(structure0)
                }
            }
        }
        optionGroupMemberships = optionGroupMembershipsDecoded0
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let secondaryAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secondaryAvailabilityZone)
        secondaryAvailabilityZone = secondaryAvailabilityZoneDecoded
        let statusInfosContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbStatusInfo?].self, forKey: .statusInfos)
        var statusInfosDecoded0:[SecurityHubClientTypes.AwsRdsDbStatusInfo]? = nil
        if let statusInfosContainer = statusInfosContainer {
            statusInfosDecoded0 = [SecurityHubClientTypes.AwsRdsDbStatusInfo]()
            for structure0 in statusInfosContainer {
                if let structure0 = structure0 {
                    statusInfosDecoded0?.append(structure0)
                }
            }
        }
        statusInfos = statusInfosDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let domainMembershipsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbDomainMembership?].self, forKey: .domainMemberships)
        var domainMembershipsDecoded0:[SecurityHubClientTypes.AwsRdsDbDomainMembership]? = nil
        if let domainMembershipsContainer = domainMembershipsContainer {
            domainMembershipsDecoded0 = [SecurityHubClientTypes.AwsRdsDbDomainMembership]()
            for structure0 in domainMembershipsContainer {
                if let structure0 = structure0 {
                    domainMembershipsDecoded0?.append(structure0)
                }
            }
        }
        domainMemberships = domainMembershipsDecoded0
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot) ?? false
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval) ?? 0
        monitoringInterval = monitoringIntervalDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let promotionTierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .promotionTier) ?? 0
        promotionTier = promotionTierDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let performanceInsightsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performanceInsightsEnabled) ?? false
        performanceInsightsEnabled = performanceInsightsEnabledDecoded
        let performanceInsightsKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKmsKeyId)
        performanceInsightsKmsKeyId = performanceInsightsKmsKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod) ?? 0
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        let enabledCloudWatchLogsExportsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .enabledCloudWatchLogsExports)
        var enabledCloudWatchLogsExportsDecoded0:[Swift.String]? = nil
        if let enabledCloudWatchLogsExportsContainer = enabledCloudWatchLogsExportsContainer {
            enabledCloudWatchLogsExportsDecoded0 = [Swift.String]()
            for string0 in enabledCloudWatchLogsExportsContainer {
                if let string0 = string0 {
                    enabledCloudWatchLogsExportsDecoded0?.append(string0)
                }
            }
        }
        enabledCloudWatchLogsExports = enabledCloudWatchLogsExportsDecoded0
        let processorFeaturesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbProcessorFeature?].self, forKey: .processorFeatures)
        var processorFeaturesDecoded0:[SecurityHubClientTypes.AwsRdsDbProcessorFeature]? = nil
        if let processorFeaturesContainer = processorFeaturesContainer {
            processorFeaturesDecoded0 = [SecurityHubClientTypes.AwsRdsDbProcessorFeature]()
            for structure0 in processorFeaturesContainer {
                if let structure0 = structure0 {
                    processorFeaturesDecoded0?.append(structure0)
                }
            }
        }
        processorFeatures = processorFeaturesDecoded0
        let listenerEndpointDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbInstanceEndpoint.self, forKey: .listenerEndpoint)
        listenerEndpoint = listenerEndpointDecoded
        let maxAllocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAllocatedStorage) ?? 0
        maxAllocatedStorage = maxAllocatedStorageDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains the details of an Amazon RDS DB instance.
    public struct AwsRdsDbInstanceDetails: Swift.Equatable {
        /// The amount of storage (in gigabytes) to initially allocate for the DB instance.
        public var allocatedStorage: Swift.Int
        /// The IAM roles associated with the DB instance.
        public var associatedRoles: [SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole]?
        /// Indicates whether minor version patches are applied automatically.
        public var autoMinorVersionUpgrade: Swift.Bool
        /// The Availability Zone where the DB instance will be created.
        public var availabilityZone: Swift.String?
        /// The number of days for which to retain automated backups.
        public var backupRetentionPeriod: Swift.Int
        /// The identifier of the CA certificate for this DB instance.
        public var caCertificateIdentifier: Swift.String?
        /// The name of the character set that this DB instance is associated with.
        public var characterSetName: Swift.String?
        /// Whether to copy resource tags to snapshots of the DB instance.
        public var copyTagsToSnapshot: Swift.Bool
        /// If the DB instance is a member of a DB cluster, contains the name of the DB cluster that the DB instance is a member of.
        public var dbClusterIdentifier: Swift.String?
        /// Contains the name of the compute and memory capacity class of the DB instance.
        public var dbInstanceClass: Swift.String?
        /// Contains a user-supplied database identifier. This identifier is the unique key that identifies a DB instance.
        public var dbInstanceIdentifier: Swift.String?
        /// Specifies the port that the DB instance listens on. If the DB instance is part of a DB cluster, this can be a different port than the DB cluster port.
        public var dbInstancePort: Swift.Int
        /// The current status of the DB instance.
        public var dbInstanceStatus: Swift.String?
        /// The meaning of this parameter differs according to the database engine you use. MySQL, MariaDB, SQL Server, PostgreSQL Contains the name of the initial database of this instance that was provided at create time, if one was specified when the DB instance was created. This same name is returned for the life of the DB instance. Oracle Contains the Oracle System ID (SID) of the created DB instance. Not shown when the returned parameters do not apply to an Oracle DB instance.
        public var dbName: Swift.String?
        /// A list of the DB parameter groups to assign to the DB instance.
        public var dbParameterGroups: [SecurityHubClientTypes.AwsRdsDbParameterGroup]?
        /// A list of the DB security groups to assign to the DB instance.
        public var dbSecurityGroups: [Swift.String]?
        /// Information about the subnet group that is associated with the DB instance.
        public var dbSubnetGroup: SecurityHubClientTypes.AwsRdsDbSubnetGroup?
        /// The Amazon Web Services Region-unique, immutable identifier for the DB instance. This identifier is found in CloudTrail log entries whenever the KMS key for the DB instance is accessed.
        public var dbiResourceId: Swift.String?
        /// Indicates whether the DB instance has deletion protection enabled. When deletion protection is enabled, the database cannot be deleted.
        public var deletionProtection: Swift.Bool
        /// The Active Directory domain membership records associated with the DB instance.
        public var domainMemberships: [SecurityHubClientTypes.AwsRdsDbDomainMembership]?
        /// A list of log types that this DB instance is configured to export to CloudWatch Logs.
        public var enabledCloudWatchLogsExports: [Swift.String]?
        /// Specifies the connection endpoint.
        public var endpoint: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint?
        /// Provides the name of the database engine to use for this DB instance.
        public var engine: Swift.String?
        /// Indicates the database engine version.
        public var engineVersion: Swift.String?
        /// The ARN of the CloudWatch Logs log stream that receives the enhanced monitoring metrics data for the DB instance.
        public var enhancedMonitoringResourceArn: Swift.String?
        /// True if mapping of IAM accounts to database accounts is enabled, and otherwise false. IAM database authentication can be enabled for the following database engines.
        ///
        /// * For MySQL 5.6, minor version 5.6.34 or higher
        ///
        /// * For MySQL 5.7, minor version 5.7.16 or higher
        ///
        /// * Aurora 5.6 or higher
        public var iamDatabaseAuthenticationEnabled: Swift.Bool
        /// Indicates when the DB instance was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var instanceCreateTime: Swift.String?
        /// Specifies the provisioned IOPS (I/O operations per second) for this DB instance.
        public var iops: Swift.Int
        /// If StorageEncrypted is true, the KMS key identifier for the encrypted DB instance.
        public var kmsKeyId: Swift.String?
        /// Specifies the latest time to which a database can be restored with point-in-time restore. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var latestRestorableTime: Swift.String?
        /// License model information for this DB instance.
        public var licenseModel: Swift.String?
        /// Specifies the connection endpoint.
        public var listenerEndpoint: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint?
        /// The master user name of the DB instance.
        public var masterUsername: Swift.String?
        /// The upper limit to which Amazon RDS can automatically scale the storage of the DB instance.
        public var maxAllocatedStorage: Swift.Int
        /// The interval, in seconds, between points when enhanced monitoring metrics are collected for the DB instance.
        public var monitoringInterval: Swift.Int
        /// The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring metrics to CloudWatch Logs.
        public var monitoringRoleArn: Swift.String?
        /// Whether the DB instance is a multiple Availability Zone deployment.
        public var multiAz: Swift.Bool
        /// The list of option group memberships for this DB instance.
        public var optionGroupMemberships: [SecurityHubClientTypes.AwsRdsDbOptionGroupMembership]?
        /// Changes to the DB instance that are currently pending.
        public var pendingModifiedValues: SecurityHubClientTypes.AwsRdsDbPendingModifiedValues?
        /// Indicates whether Performance Insights is enabled for the DB instance.
        public var performanceInsightsEnabled: Swift.Bool
        /// The identifier of the KMS key used to encrypt the Performance Insights data.
        public var performanceInsightsKmsKeyId: Swift.String?
        /// The number of days to retain Performance Insights data.
        public var performanceInsightsRetentionPeriod: Swift.Int
        /// The range of time each day when automated backups are created, if automated backups are enabled. Uses the format HH:MM-HH:MM. For example, 04:52-05:22.
        public var preferredBackupWindow: Swift.String?
        /// The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC). Uses the format :HH:MM-:HH:MM. For the day values, use mon|tue|wed|thu|fri|sat|sun. For example, sun:09:32-sun:10:02.
        public var preferredMaintenanceWindow: Swift.String?
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public var processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]?
        /// The order in which to promote an Aurora replica to the primary instance after a failure of the existing primary instance.
        public var promotionTier: Swift.Int
        /// Specifies the accessibility options for the DB instance. A value of true specifies an Internet-facing instance with a publicly resolvable DNS name, which resolves to a public IP address. A value of false specifies an internal instance with a DNS name that resolves to a private IP address.
        public var publiclyAccessible: Swift.Bool
        /// List of identifiers of Aurora DB clusters to which the RDS DB instance is replicated as a read replica.
        public var readReplicaDBClusterIdentifiers: [Swift.String]?
        /// List of identifiers of the read replicas associated with this DB instance.
        public var readReplicaDBInstanceIdentifiers: [Swift.String]?
        /// If this DB instance is a read replica, contains the identifier of the source DB instance.
        public var readReplicaSourceDBInstanceIdentifier: Swift.String?
        /// For a DB instance with multi-Availability Zone support, the name of the secondary Availability Zone.
        public var secondaryAvailabilityZone: Swift.String?
        /// The status of a read replica. If the instance isn't a read replica, this is empty.
        public var statusInfos: [SecurityHubClientTypes.AwsRdsDbStatusInfo]?
        /// Specifies whether the DB instance is encrypted.
        public var storageEncrypted: Swift.Bool
        /// The storage type for the DB instance.
        public var storageType: Swift.String?
        /// The ARN from the key store with which the instance is associated for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the DB instance.
        public var timezone: Swift.String?
        /// A list of VPC security groups that the DB instance belongs to.
        public var vpcSecurityGroups: [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]?

        public init (
            allocatedStorage: Swift.Int = 0,
            associatedRoles: [SecurityHubClientTypes.AwsRdsDbInstanceAssociatedRole]? = nil,
            autoMinorVersionUpgrade: Swift.Bool = false,
            availabilityZone: Swift.String? = nil,
            backupRetentionPeriod: Swift.Int = 0,
            caCertificateIdentifier: Swift.String? = nil,
            characterSetName: Swift.String? = nil,
            copyTagsToSnapshot: Swift.Bool = false,
            dbClusterIdentifier: Swift.String? = nil,
            dbInstanceClass: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            dbInstancePort: Swift.Int = 0,
            dbInstanceStatus: Swift.String? = nil,
            dbName: Swift.String? = nil,
            dbParameterGroups: [SecurityHubClientTypes.AwsRdsDbParameterGroup]? = nil,
            dbSecurityGroups: [Swift.String]? = nil,
            dbSubnetGroup: SecurityHubClientTypes.AwsRdsDbSubnetGroup? = nil,
            dbiResourceId: Swift.String? = nil,
            deletionProtection: Swift.Bool = false,
            domainMemberships: [SecurityHubClientTypes.AwsRdsDbDomainMembership]? = nil,
            enabledCloudWatchLogsExports: [Swift.String]? = nil,
            endpoint: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            enhancedMonitoringResourceArn: Swift.String? = nil,
            iamDatabaseAuthenticationEnabled: Swift.Bool = false,
            instanceCreateTime: Swift.String? = nil,
            iops: Swift.Int = 0,
            kmsKeyId: Swift.String? = nil,
            latestRestorableTime: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            listenerEndpoint: SecurityHubClientTypes.AwsRdsDbInstanceEndpoint? = nil,
            masterUsername: Swift.String? = nil,
            maxAllocatedStorage: Swift.Int = 0,
            monitoringInterval: Swift.Int = 0,
            monitoringRoleArn: Swift.String? = nil,
            multiAz: Swift.Bool = false,
            optionGroupMemberships: [SecurityHubClientTypes.AwsRdsDbOptionGroupMembership]? = nil,
            pendingModifiedValues: SecurityHubClientTypes.AwsRdsDbPendingModifiedValues? = nil,
            performanceInsightsEnabled: Swift.Bool = false,
            performanceInsightsKmsKeyId: Swift.String? = nil,
            performanceInsightsRetentionPeriod: Swift.Int = 0,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]? = nil,
            promotionTier: Swift.Int = 0,
            publiclyAccessible: Swift.Bool = false,
            readReplicaDBClusterIdentifiers: [Swift.String]? = nil,
            readReplicaDBInstanceIdentifiers: [Swift.String]? = nil,
            readReplicaSourceDBInstanceIdentifier: Swift.String? = nil,
            secondaryAvailabilityZone: Swift.String? = nil,
            statusInfos: [SecurityHubClientTypes.AwsRdsDbStatusInfo]? = nil,
            storageEncrypted: Swift.Bool = false,
            storageType: Swift.String? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcSecurityGroups: [SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup]? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.associatedRoles = associatedRoles
            self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
            self.availabilityZone = availabilityZone
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.characterSetName = characterSetName
            self.copyTagsToSnapshot = copyTagsToSnapshot
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbInstancePort = dbInstancePort
            self.dbInstanceStatus = dbInstanceStatus
            self.dbName = dbName
            self.dbParameterGroups = dbParameterGroups
            self.dbSecurityGroups = dbSecurityGroups
            self.dbSubnetGroup = dbSubnetGroup
            self.dbiResourceId = dbiResourceId
            self.deletionProtection = deletionProtection
            self.domainMemberships = domainMemberships
            self.enabledCloudWatchLogsExports = enabledCloudWatchLogsExports
            self.endpoint = endpoint
            self.engine = engine
            self.engineVersion = engineVersion
            self.enhancedMonitoringResourceArn = enhancedMonitoringResourceArn
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.latestRestorableTime = latestRestorableTime
            self.licenseModel = licenseModel
            self.listenerEndpoint = listenerEndpoint
            self.masterUsername = masterUsername
            self.maxAllocatedStorage = maxAllocatedStorage
            self.monitoringInterval = monitoringInterval
            self.monitoringRoleArn = monitoringRoleArn
            self.multiAz = multiAz
            self.optionGroupMemberships = optionGroupMemberships
            self.pendingModifiedValues = pendingModifiedValues
            self.performanceInsightsEnabled = performanceInsightsEnabled
            self.performanceInsightsKmsKeyId = performanceInsightsKmsKeyId
            self.performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.processorFeatures = processorFeatures
            self.promotionTier = promotionTier
            self.publiclyAccessible = publiclyAccessible
            self.readReplicaDBClusterIdentifiers = readReplicaDBClusterIdentifiers
            self.readReplicaDBInstanceIdentifiers = readReplicaDBInstanceIdentifiers
            self.readReplicaSourceDBInstanceIdentifier = readReplicaSourceDBInstanceIdentifier
            self.secondaryAvailabilityZone = secondaryAvailabilityZone
            self.statusInfos = statusInfos
            self.storageEncrypted = storageEncrypted
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbInstanceEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case hostedZoneId = "HostedZoneId"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let hostedZoneId = self.hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies the connection endpoint.
    public struct AwsRdsDbInstanceEndpoint: Swift.Equatable {
        /// Specifies the DNS address of the DB instance.
        public var address: Swift.String?
        /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
        public var hostedZoneId: Swift.String?
        /// Specifies the port that the database engine is listening on.
        public var port: Swift.Int

        public init (
            address: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.address = address
            self.hostedZoneId = hostedZoneId
            self.port = port
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbInstanceVpcSecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = self.vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// A VPC security groups that the DB instance belongs to.
    public struct AwsRdsDbInstanceVpcSecurityGroup: Swift.Equatable {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The name of the VPC security group.
        public var vpcSecurityGroupId: Swift.String?

        public init (
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbOptionGroupMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case optionGroupName = "OptionGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let optionGroupName = self.optionGroupName {
            try encodeContainer.encode(optionGroupName, forKey: .optionGroupName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// An option group membership.
    public struct AwsRdsDbOptionGroupMembership: Swift.Equatable {
        /// The name of the option group.
        public var optionGroupName: Swift.String?
        /// The status of the option group membership.
        public var status: Swift.String?

        public init (
            optionGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.optionGroupName = optionGroupName
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbParameterGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbParameterGroupName = "DbParameterGroupName"
        case parameterApplyStatus = "ParameterApplyStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbParameterGroupName = self.dbParameterGroupName {
            try encodeContainer.encode(dbParameterGroupName, forKey: .dbParameterGroupName)
        }
        if let parameterApplyStatus = self.parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbParameterGroupName)
        dbParameterGroupName = dbParameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about a parameter group for a DB instance.
    public struct AwsRdsDbParameterGroup: Swift.Equatable {
        /// The name of the parameter group.
        public var dbParameterGroupName: Swift.String?
        /// The status of parameter updates.
        public var parameterApplyStatus: Swift.String?

        public init (
            dbParameterGroupName: Swift.String? = nil,
            parameterApplyStatus: Swift.String? = nil
        )
        {
            self.dbParameterGroupName = dbParameterGroupName
            self.parameterApplyStatus = parameterApplyStatus
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbPendingModifiedValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case caCertificateIdentifier = "CaCertificateIdentifier"
        case dbInstanceClass = "DbInstanceClass"
        case dbInstanceIdentifier = "DbInstanceIdentifier"
        case dbSubnetGroupName = "DbSubnetGroupName"
        case engineVersion = "EngineVersion"
        case iops = "Iops"
        case licenseModel = "LicenseModel"
        case masterUserPassword = "MasterUserPassword"
        case multiAZ = "MultiAZ"
        case pendingCloudWatchLogsExports = "PendingCloudWatchLogsExports"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if backupRetentionPeriod != 0 {
            try encodeContainer.encode(backupRetentionPeriod, forKey: .backupRetentionPeriod)
        }
        if let caCertificateIdentifier = self.caCertificateIdentifier {
            try encodeContainer.encode(caCertificateIdentifier, forKey: .caCertificateIdentifier)
        }
        if let dbInstanceClass = self.dbInstanceClass {
            try encodeContainer.encode(dbInstanceClass, forKey: .dbInstanceClass)
        }
        if let dbInstanceIdentifier = self.dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let dbSubnetGroupName = self.dbSubnetGroupName {
            try encodeContainer.encode(dbSubnetGroupName, forKey: .dbSubnetGroupName)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let licenseModel = self.licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let masterUserPassword = self.masterUserPassword {
            try encodeContainer.encode(masterUserPassword, forKey: .masterUserPassword)
        }
        if multiAZ != false {
            try encodeContainer.encode(multiAZ, forKey: .multiAZ)
        }
        if let pendingCloudWatchLogsExports = self.pendingCloudWatchLogsExports {
            try encodeContainer.encode(pendingCloudWatchLogsExports, forKey: .pendingCloudWatchLogsExports)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processorFeatures)
            for awsrdsdbprocessorfeature0 in processorFeatures {
                try processorFeaturesContainer.encode(awsrdsdbprocessorfeature0)
            }
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceClass)
        dbInstanceClass = dbInstanceClassDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage) ?? 0
        allocatedStorage = allocatedStorageDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod) ?? 0
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ) ?? false
        multiAZ = multiAZDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops) ?? 0
        iops = iopsDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let caCertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .caCertificateIdentifier)
        caCertificateIdentifier = caCertificateIdentifierDecoded
        let dbSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbSubnetGroupName)
        dbSubnetGroupName = dbSubnetGroupNameDecoded
        let pendingCloudWatchLogsExportsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports.self, forKey: .pendingCloudWatchLogsExports)
        pendingCloudWatchLogsExports = pendingCloudWatchLogsExportsDecoded
        let processorFeaturesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbProcessorFeature?].self, forKey: .processorFeatures)
        var processorFeaturesDecoded0:[SecurityHubClientTypes.AwsRdsDbProcessorFeature]? = nil
        if let processorFeaturesContainer = processorFeaturesContainer {
            processorFeaturesDecoded0 = [SecurityHubClientTypes.AwsRdsDbProcessorFeature]()
            for structure0 in processorFeaturesContainer {
                if let structure0 = structure0 {
                    processorFeaturesDecoded0?.append(structure0)
                }
            }
        }
        processorFeatures = processorFeaturesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Changes to a DB instance that are currently pending.
    public struct AwsRdsDbPendingModifiedValues: Swift.Equatable {
        /// The new value of the allocated storage for the DB instance.
        public var allocatedStorage: Swift.Int
        /// The new backup retention period for the DB instance.
        public var backupRetentionPeriod: Swift.Int
        /// The new CA certificate identifier for the DB instance.
        public var caCertificateIdentifier: Swift.String?
        /// The new DB instance class for the DB instance.
        public var dbInstanceClass: Swift.String?
        /// The new DB instance identifier for the DB instance.
        public var dbInstanceIdentifier: Swift.String?
        /// The name of the new subnet group for the DB instance.
        public var dbSubnetGroupName: Swift.String?
        /// The new engine version for the DB instance.
        public var engineVersion: Swift.String?
        /// The new provisioned IOPS value for the DB instance.
        public var iops: Swift.Int
        /// The new license model value for the DB instance.
        public var licenseModel: Swift.String?
        /// The new master user password for the DB instance.
        public var masterUserPassword: Swift.String?
        /// Indicates that a single Availability Zone DB instance is changing to a multiple Availability Zone deployment.
        public var multiAZ: Swift.Bool
        /// A list of log types that are being enabled or disabled.
        public var pendingCloudWatchLogsExports: SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports?
        /// The new port for the DB instance.
        public var port: Swift.Int
        /// Processor features that are being updated.
        public var processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]?
        /// The new storage type for the DB instance.
        public var storageType: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            backupRetentionPeriod: Swift.Int = 0,
            caCertificateIdentifier: Swift.String? = nil,
            dbInstanceClass: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            dbSubnetGroupName: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iops: Swift.Int = 0,
            licenseModel: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil,
            multiAZ: Swift.Bool = false,
            pendingCloudWatchLogsExports: SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports? = nil,
            port: Swift.Int = 0,
            processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]? = nil,
            storageType: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.backupRetentionPeriod = backupRetentionPeriod
            self.caCertificateIdentifier = caCertificateIdentifier
            self.dbInstanceClass = dbInstanceClass
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbSubnetGroupName = dbSubnetGroupName
            self.engineVersion = engineVersion
            self.iops = iops
            self.licenseModel = licenseModel
            self.masterUserPassword = masterUserPassword
            self.multiAZ = multiAZ
            self.pendingCloudWatchLogsExports = pendingCloudWatchLogsExports
            self.port = port
            self.processorFeatures = processorFeatures
            self.storageType = storageType
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbProcessorFeature: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A processor feature.
    public struct AwsRdsDbProcessorFeature: Swift.Equatable {
        /// The name of the processor feature. Valid values are coreCount or threadsPerCore.
        public var name: Swift.String?
        /// The value of the processor feature.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbSecurityGroupArn = "DbSecurityGroupArn"
        case dbSecurityGroupDescription = "DbSecurityGroupDescription"
        case dbSecurityGroupName = "DbSecurityGroupName"
        case ec2SecurityGroups = "Ec2SecurityGroups"
        case ipRanges = "IpRanges"
        case ownerId = "OwnerId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbSecurityGroupArn = self.dbSecurityGroupArn {
            try encodeContainer.encode(dbSecurityGroupArn, forKey: .dbSecurityGroupArn)
        }
        if let dbSecurityGroupDescription = self.dbSecurityGroupDescription {
            try encodeContainer.encode(dbSecurityGroupDescription, forKey: .dbSecurityGroupDescription)
        }
        if let dbSecurityGroupName = self.dbSecurityGroupName {
            try encodeContainer.encode(dbSecurityGroupName, forKey: .dbSecurityGroupName)
        }
        if let ec2SecurityGroups = ec2SecurityGroups {
            var ec2SecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroups)
            for awsrdsdbsecuritygroupec2securitygroup0 in ec2SecurityGroups {
                try ec2SecurityGroupsContainer.encode(awsrdsdbsecuritygroupec2securitygroup0)
            }
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for awsrdsdbsecuritygroupiprange0 in ipRanges {
                try ipRangesContainer.encode(awsrdsdbsecuritygroupiprange0)
            }
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbSecurityGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbSecurityGroupArn)
        dbSecurityGroupArn = dbSecurityGroupArnDecoded
        let dbSecurityGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbSecurityGroupDescription)
        dbSecurityGroupDescription = dbSecurityGroupDescriptionDecoded
        let dbSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbSecurityGroupName)
        dbSecurityGroupName = dbSecurityGroupNameDecoded
        let ec2SecurityGroupsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup?].self, forKey: .ec2SecurityGroups)
        var ec2SecurityGroupsDecoded0:[SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup]? = nil
        if let ec2SecurityGroupsContainer = ec2SecurityGroupsContainer {
            ec2SecurityGroupsDecoded0 = [SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup]()
            for structure0 in ec2SecurityGroupsContainer {
                if let structure0 = structure0 {
                    ec2SecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        ec2SecurityGroups = ec2SecurityGroupsDecoded0
        let ipRangesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange]()
            for structure0 in ipRangesContainer {
                if let structure0 = structure0 {
                    ipRangesDecoded0?.append(structure0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon RDS DB security group.
    public struct AwsRdsDbSecurityGroupDetails: Swift.Equatable {
        /// The ARN for the DB security group.
        public var dbSecurityGroupArn: Swift.String?
        /// Provides the description of the DB security group.
        public var dbSecurityGroupDescription: Swift.String?
        /// Specifies the name of the DB security group.
        public var dbSecurityGroupName: Swift.String?
        /// Contains a list of EC2 security groups.
        public var ec2SecurityGroups: [SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup]?
        /// Contains a list of IP ranges.
        public var ipRanges: [SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange]?
        /// Provides the Amazon Web Services ID of the owner of a specific DB security group.
        public var ownerId: Swift.String?
        /// Provides VPC ID associated with the DB security group.
        public var vpcId: Swift.String?

        public init (
            dbSecurityGroupArn: Swift.String? = nil,
            dbSecurityGroupDescription: Swift.String? = nil,
            dbSecurityGroupName: Swift.String? = nil,
            ec2SecurityGroups: [SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup]? = nil,
            ipRanges: [SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange]? = nil,
            ownerId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.dbSecurityGroupArn = dbSecurityGroupArn
            self.dbSecurityGroupDescription = dbSecurityGroupDescription
            self.dbSecurityGroupName = dbSecurityGroupName
            self.ec2SecurityGroups = ec2SecurityGroups
            self.ipRanges = ipRanges
            self.ownerId = ownerId
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbSecurityGroupEc2SecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2SecurityGroupId = "Ec2SecurityGroupId"
        case ec2SecurityGroupName = "Ec2SecurityGroupName"
        case ec2SecurityGroupOwnerId = "Ec2SecurityGroupOwnerId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2SecurityGroupId = self.ec2SecurityGroupId {
            try encodeContainer.encode(ec2SecurityGroupId, forKey: .ec2SecurityGroupId)
        }
        if let ec2SecurityGroupName = self.ec2SecurityGroupName {
            try encodeContainer.encode(ec2SecurityGroupName, forKey: .ec2SecurityGroupName)
        }
        if let ec2SecurityGroupOwnerId = self.ec2SecurityGroupOwnerId {
            try encodeContainer.encode(ec2SecurityGroupOwnerId, forKey: .ec2SecurityGroupOwnerId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2SecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2SecurityGroupId)
        ec2SecurityGroupId = ec2SecurityGroupIdDecoded
        let ec2SecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2SecurityGroupName)
        ec2SecurityGroupName = ec2SecurityGroupNameDecoded
        let ec2SecurityGroupOwnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2SecurityGroupOwnerId)
        ec2SecurityGroupOwnerId = ec2SecurityGroupOwnerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// EC2 security group information for an RDS DB security group.
    public struct AwsRdsDbSecurityGroupEc2SecurityGroup: Swift.Equatable {
        /// Specifies the ID for the EC2 security group.
        public var ec2SecurityGroupId: Swift.String?
        /// Specifies the name of the EC2 security group.
        public var ec2SecurityGroupName: Swift.String?
        /// Provides the Amazon Web Services ID of the owner of the EC2 security group.
        public var ec2SecurityGroupOwnerId: Swift.String?
        /// Provides the status of the EC2 security group.
        public var status: Swift.String?

        public init (
            ec2SecurityGroupId: Swift.String? = nil,
            ec2SecurityGroupName: Swift.String? = nil,
            ec2SecurityGroupOwnerId: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.ec2SecurityGroupId = ec2SecurityGroupId
            self.ec2SecurityGroupName = ec2SecurityGroupName
            self.ec2SecurityGroupOwnerId = ec2SecurityGroupOwnerId
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbSecurityGroupIpRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrIp = "CidrIp"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrIp = self.cidrIp {
            try encodeContainer.encode(cidrIp, forKey: .cidrIp)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrIp)
        cidrIp = cidrIpDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// IP range information for an RDS DB security group.
    public struct AwsRdsDbSecurityGroupIpRange: Swift.Equatable {
        /// Specifies the IP range.
        public var cidrIp: Swift.String?
        /// Specifies the status of the IP range.
        public var status: Swift.String?

        public init (
            cidrIp: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.cidrIp = cidrIp
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbSnapshotDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocatedStorage = "AllocatedStorage"
        case availabilityZone = "AvailabilityZone"
        case dbInstanceIdentifier = "DbInstanceIdentifier"
        case dbSnapshotIdentifier = "DbSnapshotIdentifier"
        case dbiResourceId = "DbiResourceId"
        case encrypted = "Encrypted"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case iamDatabaseAuthenticationEnabled = "IamDatabaseAuthenticationEnabled"
        case instanceCreateTime = "InstanceCreateTime"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case licenseModel = "LicenseModel"
        case masterUsername = "MasterUsername"
        case optionGroupName = "OptionGroupName"
        case percentProgress = "PercentProgress"
        case port = "Port"
        case processorFeatures = "ProcessorFeatures"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotType = "SnapshotType"
        case sourceDbSnapshotIdentifier = "SourceDbSnapshotIdentifier"
        case sourceRegion = "SourceRegion"
        case status = "Status"
        case storageType = "StorageType"
        case tdeCredentialArn = "TdeCredentialArn"
        case timezone = "Timezone"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allocatedStorage != 0 {
            try encodeContainer.encode(allocatedStorage, forKey: .allocatedStorage)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let dbInstanceIdentifier = self.dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let dbSnapshotIdentifier = self.dbSnapshotIdentifier {
            try encodeContainer.encode(dbSnapshotIdentifier, forKey: .dbSnapshotIdentifier)
        }
        if let dbiResourceId = self.dbiResourceId {
            try encodeContainer.encode(dbiResourceId, forKey: .dbiResourceId)
        }
        if encrypted != false {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if iamDatabaseAuthenticationEnabled != false {
            try encodeContainer.encode(iamDatabaseAuthenticationEnabled, forKey: .iamDatabaseAuthenticationEnabled)
        }
        if let instanceCreateTime = self.instanceCreateTime {
            try encodeContainer.encode(instanceCreateTime, forKey: .instanceCreateTime)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseModel = self.licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let masterUsername = self.masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if let optionGroupName = self.optionGroupName {
            try encodeContainer.encode(optionGroupName, forKey: .optionGroupName)
        }
        if percentProgress != 0 {
            try encodeContainer.encode(percentProgress, forKey: .percentProgress)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let processorFeatures = processorFeatures {
            var processorFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processorFeatures)
            for awsrdsdbprocessorfeature0 in processorFeatures {
                try processorFeaturesContainer.encode(awsrdsdbprocessorfeature0)
            }
        }
        if let snapshotCreateTime = self.snapshotCreateTime {
            try encodeContainer.encode(snapshotCreateTime, forKey: .snapshotCreateTime)
        }
        if let snapshotType = self.snapshotType {
            try encodeContainer.encode(snapshotType, forKey: .snapshotType)
        }
        if let sourceDbSnapshotIdentifier = self.sourceDbSnapshotIdentifier {
            try encodeContainer.encode(sourceDbSnapshotIdentifier, forKey: .sourceDbSnapshotIdentifier)
        }
        if let sourceRegion = self.sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType, forKey: .storageType)
        }
        if let tdeCredentialArn = self.tdeCredentialArn {
            try encodeContainer.encode(tdeCredentialArn, forKey: .tdeCredentialArn)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbSnapshotIdentifier)
        dbSnapshotIdentifier = dbSnapshotIdentifierDecoded
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreateTime)
        snapshotCreateTime = snapshotCreateTimeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage) ?? 0
        allocatedStorage = allocatedStorageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let instanceCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceCreateTime)
        instanceCreateTime = instanceCreateTimeDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops) ?? 0
        iops = iopsDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let percentProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentProgress) ?? 0
        percentProgress = percentProgressDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceDbSnapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDbSnapshotIdentifier)
        sourceDbSnapshotIdentifier = sourceDbSnapshotIdentifierDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let tdeCredentialArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tdeCredentialArn)
        tdeCredentialArn = tdeCredentialArnDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted) ?? false
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let iamDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iamDatabaseAuthenticationEnabled) ?? false
        iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabledDecoded
        let processorFeaturesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbProcessorFeature?].self, forKey: .processorFeatures)
        var processorFeaturesDecoded0:[SecurityHubClientTypes.AwsRdsDbProcessorFeature]? = nil
        if let processorFeaturesContainer = processorFeaturesContainer {
            processorFeaturesDecoded0 = [SecurityHubClientTypes.AwsRdsDbProcessorFeature]()
            for structure0 in processorFeaturesContainer {
                if let structure0 = structure0 {
                    processorFeaturesDecoded0?.append(structure0)
                }
            }
        }
        processorFeatures = processorFeaturesDecoded0
        let dbiResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbiResourceId)
        dbiResourceId = dbiResourceIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon RDS DB cluster snapshot.
    public struct AwsRdsDbSnapshotDetails: Swift.Equatable {
        /// The amount of storage (in gigabytes) to be initially allocated for the database instance.
        public var allocatedStorage: Swift.Int
        /// Specifies the name of the Availability Zone in which the DB instance was located at the time of the DB snapshot.
        public var availabilityZone: Swift.String?
        /// A name for the DB instance.
        public var dbInstanceIdentifier: Swift.String?
        /// The name or ARN of the DB snapshot that is used to restore the DB instance.
        public var dbSnapshotIdentifier: Swift.String?
        /// The identifier for the source DB instance.
        public var dbiResourceId: Swift.String?
        /// Whether the DB snapshot is encrypted.
        public var encrypted: Swift.Bool
        /// The name of the database engine to use for this DB instance. Valid values are as follows:
        ///
        /// * aurora
        ///
        /// * aurora-mysql
        ///
        /// * aurora-postgresql
        ///
        /// * c
        ///
        /// * mariadb
        ///
        /// * mysql
        ///
        /// * oracle-ee
        ///
        /// * oracle-se
        ///
        /// * oracle-se1
        ///
        /// * oracle-se2
        ///
        /// * sqlserver-ee
        ///
        /// * sqlserver-ex
        ///
        /// * sqlserver-se
        ///
        /// * sqlserver-web
        public var engine: Swift.String?
        /// The version of the database engine.
        public var engineVersion: Swift.String?
        /// Whether mapping of IAM accounts to database accounts is enabled.
        public var iamDatabaseAuthenticationEnabled: Swift.Bool
        /// Specifies the time in Coordinated Universal Time (UTC) when the DB instance, from which the snapshot was taken, was created.
        public var instanceCreateTime: Swift.String?
        /// The provisioned IOPS (I/O operations per second) value of the DB instance at the time of the snapshot.
        public var iops: Swift.Int
        /// If Encrypted is true, the KMS key identifier for the encrypted DB snapshot.
        public var kmsKeyId: Swift.String?
        /// License model information for the restored DB instance.
        public var licenseModel: Swift.String?
        /// The master user name for the DB snapshot.
        public var masterUsername: Swift.String?
        /// The option group name for the DB snapshot.
        public var optionGroupName: Swift.String?
        /// The percentage of the estimated data that has been transferred.
        public var percentProgress: Swift.Int
        /// The port that the database engine was listening on at the time of the snapshot.
        public var port: Swift.Int
        /// The number of CPU cores and the number of threads per core for the DB instance class of the DB instance.
        public var processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]?
        /// When the snapshot was taken in Coordinated Universal Time (UTC).
        public var snapshotCreateTime: Swift.String?
        /// The type of the DB snapshot.
        public var snapshotType: Swift.String?
        /// The DB snapshot ARN that the DB snapshot was copied from.
        public var sourceDbSnapshotIdentifier: Swift.String?
        /// The Amazon Web Services Region that the DB snapshot was created in or copied from.
        public var sourceRegion: Swift.String?
        /// The status of this DB snapshot.
        public var status: Swift.String?
        /// The storage type associated with the DB snapshot. Valid values are as follows:
        ///
        /// * gp2
        ///
        /// * io1
        ///
        /// * standard
        public var storageType: Swift.String?
        /// The ARN from the key store with which to associate the instance for TDE encryption.
        public var tdeCredentialArn: Swift.String?
        /// The time zone of the DB snapshot.
        public var timezone: Swift.String?
        /// The VPC ID associated with the DB snapshot.
        public var vpcId: Swift.String?

        public init (
            allocatedStorage: Swift.Int = 0,
            availabilityZone: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            dbSnapshotIdentifier: Swift.String? = nil,
            dbiResourceId: Swift.String? = nil,
            encrypted: Swift.Bool = false,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            iamDatabaseAuthenticationEnabled: Swift.Bool = false,
            instanceCreateTime: Swift.String? = nil,
            iops: Swift.Int = 0,
            kmsKeyId: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            masterUsername: Swift.String? = nil,
            optionGroupName: Swift.String? = nil,
            percentProgress: Swift.Int = 0,
            port: Swift.Int = 0,
            processorFeatures: [SecurityHubClientTypes.AwsRdsDbProcessorFeature]? = nil,
            snapshotCreateTime: Swift.String? = nil,
            snapshotType: Swift.String? = nil,
            sourceDbSnapshotIdentifier: Swift.String? = nil,
            sourceRegion: Swift.String? = nil,
            status: Swift.String? = nil,
            storageType: Swift.String? = nil,
            tdeCredentialArn: Swift.String? = nil,
            timezone: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.allocatedStorage = allocatedStorage
            self.availabilityZone = availabilityZone
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.dbSnapshotIdentifier = dbSnapshotIdentifier
            self.dbiResourceId = dbiResourceId
            self.encrypted = encrypted
            self.engine = engine
            self.engineVersion = engineVersion
            self.iamDatabaseAuthenticationEnabled = iamDatabaseAuthenticationEnabled
            self.instanceCreateTime = instanceCreateTime
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.licenseModel = licenseModel
            self.masterUsername = masterUsername
            self.optionGroupName = optionGroupName
            self.percentProgress = percentProgress
            self.port = port
            self.processorFeatures = processorFeatures
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotType = snapshotType
            self.sourceDbSnapshotIdentifier = sourceDbSnapshotIdentifier
            self.sourceRegion = sourceRegion
            self.status = status
            self.storageType = storageType
            self.tdeCredentialArn = tdeCredentialArn
            self.timezone = timezone
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbStatusInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case normal = "Normal"
        case status = "Status"
        case statusType = "StatusType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if normal != false {
            try encodeContainer.encode(normal, forKey: .normal)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let statusType = self.statusType {
            try encodeContainer.encode(statusType, forKey: .statusType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusType)
        statusType = statusTypeDecoded
        let normalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .normal) ?? false
        normal = normalDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the status of a read replica.
    public struct AwsRdsDbStatusInfo: Swift.Equatable {
        /// If the read replica is currently in an error state, provides the error details.
        public var message: Swift.String?
        /// Whether the read replica instance is operating normally.
        public var normal: Swift.Bool
        /// The status of the read replica instance.
        public var status: Swift.String?
        /// The type of status. For a read replica, the status type is read replication.
        public var statusType: Swift.String?

        public init (
            message: Swift.String? = nil,
            normal: Swift.Bool = false,
            status: Swift.String? = nil,
            statusType: Swift.String? = nil
        )
        {
            self.message = message
            self.normal = normal
            self.status = status
            self.statusType = statusType
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbSubnetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbSubnetGroupArn = "DbSubnetGroupArn"
        case dbSubnetGroupDescription = "DbSubnetGroupDescription"
        case dbSubnetGroupName = "DbSubnetGroupName"
        case subnetGroupStatus = "SubnetGroupStatus"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbSubnetGroupArn = self.dbSubnetGroupArn {
            try encodeContainer.encode(dbSubnetGroupArn, forKey: .dbSubnetGroupArn)
        }
        if let dbSubnetGroupDescription = self.dbSubnetGroupDescription {
            try encodeContainer.encode(dbSubnetGroupDescription, forKey: .dbSubnetGroupDescription)
        }
        if let dbSubnetGroupName = self.dbSubnetGroupName {
            try encodeContainer.encode(dbSubnetGroupName, forKey: .dbSubnetGroupName)
        }
        if let subnetGroupStatus = self.subnetGroupStatus {
            try encodeContainer.encode(subnetGroupStatus, forKey: .subnetGroupStatus)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for awsrdsdbsubnetgroupsubnet0 in subnets {
                try subnetsContainer.encode(awsrdsdbsubnetgroupsubnet0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbSubnetGroupName)
        dbSubnetGroupName = dbSubnetGroupNameDecoded
        let dbSubnetGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbSubnetGroupDescription)
        dbSubnetGroupDescription = dbSubnetGroupDescriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetGroupStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetGroupStatus)
        subnetGroupStatus = subnetGroupStatusDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet?].self, forKey: .subnets)
        var subnetsDecoded0:[SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
        let dbSubnetGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbSubnetGroupArn)
        dbSubnetGroupArn = dbSubnetGroupArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the subnet group for the database instance.
    public struct AwsRdsDbSubnetGroup: Swift.Equatable {
        /// The ARN of the subnet group.
        public var dbSubnetGroupArn: Swift.String?
        /// The description of the subnet group.
        public var dbSubnetGroupDescription: Swift.String?
        /// The name of the subnet group.
        public var dbSubnetGroupName: Swift.String?
        /// The status of the subnet group.
        public var subnetGroupStatus: Swift.String?
        /// A list of subnets in the subnet group.
        public var subnets: [SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet]?
        /// The VPC ID of the subnet group.
        public var vpcId: Swift.String?

        public init (
            dbSubnetGroupArn: Swift.String? = nil,
            dbSubnetGroupDescription: Swift.String? = nil,
            dbSubnetGroupName: Swift.String? = nil,
            subnetGroupStatus: Swift.String? = nil,
            subnets: [SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.dbSubnetGroupArn = dbSubnetGroupArn
            self.dbSubnetGroupDescription = dbSubnetGroupDescription
            self.dbSubnetGroupName = dbSubnetGroupName
            self.subnetGroupStatus = subnetGroupStatus
            self.subnets = subnets
            self.vpcId = vpcId
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
        case subnetStatus = "SubnetStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = self.subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = self.subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
        if let subnetStatus = self.subnetStatus {
            try encodeContainer.encode(subnetStatus, forKey: .subnetStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
        let subnetStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetStatus)
        subnetStatus = subnetStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a subnet in a subnet group.
    public struct AwsRdsDbSubnetGroupSubnet: Swift.Equatable {
        /// Information about the Availability Zone for a subnet in the subnet group.
        public var subnetAvailabilityZone: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone?
        /// The identifier of a subnet in the subnet group.
        public var subnetIdentifier: Swift.String?
        /// The status of a subnet in the subnet group.
        public var subnetStatus: Swift.String?

        public init (
            subnetAvailabilityZone: SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone? = nil,
            subnetIdentifier: Swift.String? = nil,
            subnetStatus: Swift.String? = nil
        )
        {
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetIdentifier = subnetIdentifier
            self.subnetStatus = subnetStatus
        }
    }

}

extension SecurityHubClientTypes.AwsRdsDbSubnetGroupSubnetAvailabilityZone: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SecurityHubClientTypes {
    /// An Availability Zone for a subnet in a subnet group.
    public struct AwsRdsDbSubnetGroupSubnetAvailabilityZone: Swift.Equatable {
        /// The name of the Availability Zone for a subnet in the subnet group.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension SecurityHubClientTypes.AwsRdsEventSubscriptionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case custSubscriptionId = "CustSubscriptionId"
        case customerAwsId = "CustomerAwsId"
        case enabled = "Enabled"
        case eventCategoriesList = "EventCategoriesList"
        case eventSubscriptionArn = "EventSubscriptionArn"
        case snsTopicArn = "SnsTopicArn"
        case sourceIdsList = "SourceIdsList"
        case sourceType = "SourceType"
        case status = "Status"
        case subscriptionCreationTime = "SubscriptionCreationTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let custSubscriptionId = self.custSubscriptionId {
            try encodeContainer.encode(custSubscriptionId, forKey: .custSubscriptionId)
        }
        if let customerAwsId = self.customerAwsId {
            try encodeContainer.encode(customerAwsId, forKey: .customerAwsId)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventCategoriesList = eventCategoriesList {
            var eventCategoriesListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventCategoriesList)
            for nonemptystring0 in eventCategoriesList {
                try eventCategoriesListContainer.encode(nonemptystring0)
            }
        }
        if let eventSubscriptionArn = self.eventSubscriptionArn {
            try encodeContainer.encode(eventSubscriptionArn, forKey: .eventSubscriptionArn)
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let sourceIdsList = sourceIdsList {
            var sourceIdsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIdsList)
            for nonemptystring0 in sourceIdsList {
                try sourceIdsListContainer.encode(nonemptystring0)
            }
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subscriptionCreationTime = self.subscriptionCreationTime {
            try encodeContainer.encode(subscriptionCreationTime, forKey: .subscriptionCreationTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let custSubscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .custSubscriptionId)
        custSubscriptionId = custSubscriptionIdDecoded
        let customerAwsIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAwsId)
        customerAwsId = customerAwsIdDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let eventCategoriesListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventCategoriesList)
        var eventCategoriesListDecoded0:[Swift.String]? = nil
        if let eventCategoriesListContainer = eventCategoriesListContainer {
            eventCategoriesListDecoded0 = [Swift.String]()
            for string0 in eventCategoriesListContainer {
                if let string0 = string0 {
                    eventCategoriesListDecoded0?.append(string0)
                }
            }
        }
        eventCategoriesList = eventCategoriesListDecoded0
        let eventSubscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventSubscriptionArn)
        eventSubscriptionArn = eventSubscriptionArnDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let sourceIdsListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceIdsList)
        var sourceIdsListDecoded0:[Swift.String]? = nil
        if let sourceIdsListContainer = sourceIdsListContainer {
            sourceIdsListDecoded0 = [Swift.String]()
            for string0 in sourceIdsListContainer {
                if let string0 = string0 {
                    sourceIdsListDecoded0?.append(string0)
                }
            }
        }
        sourceIdsList = sourceIdsListDecoded0
        let sourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let subscriptionCreationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionCreationTime)
        subscriptionCreationTime = subscriptionCreationTimeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an Amazon RDS event notification subscription. The subscription allows Amazon RDS to post events to an SNS topic.
    public struct AwsRdsEventSubscriptionDetails: Swift.Equatable {
        /// The identifier of the account that is associated with the event notification subscription.
        public var custSubscriptionId: Swift.String?
        /// The identifier of the event notification subscription.
        public var customerAwsId: Swift.String?
        /// Whether the event notification subscription is enabled.
        public var enabled: Swift.Bool
        /// The list of event categories for the event notification subscription.
        public var eventCategoriesList: [Swift.String]?
        /// The ARN of the event notification subscription.
        public var eventSubscriptionArn: Swift.String?
        /// The ARN of the SNS topic to post the event notifications to.
        public var snsTopicArn: Swift.String?
        /// A list of source identifiers for the event notification subscription.
        public var sourceIdsList: [Swift.String]?
        /// The source type for the event notification subscription.
        public var sourceType: Swift.String?
        /// The status of the event notification subscription. Valid values: creating | modifying | deleting | active | no-permission | topic-not-exist
        public var status: Swift.String?
        /// The datetime when the event notification subscription was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var subscriptionCreationTime: Swift.String?

        public init (
            custSubscriptionId: Swift.String? = nil,
            customerAwsId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            eventCategoriesList: [Swift.String]? = nil,
            eventSubscriptionArn: Swift.String? = nil,
            snsTopicArn: Swift.String? = nil,
            sourceIdsList: [Swift.String]? = nil,
            sourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            subscriptionCreationTime: Swift.String? = nil
        )
        {
            self.custSubscriptionId = custSubscriptionId
            self.customerAwsId = customerAwsId
            self.enabled = enabled
            self.eventCategoriesList = eventCategoriesList
            self.eventSubscriptionArn = eventSubscriptionArn
            self.snsTopicArn = snsTopicArn
            self.sourceIdsList = sourceIdsList
            self.sourceType = sourceType
            self.status = status
            self.subscriptionCreationTime = subscriptionCreationTime
        }
    }

}

extension SecurityHubClientTypes.AwsRdsPendingCloudWatchLogsExports: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logTypesToDisable = "LogTypesToDisable"
        case logTypesToEnable = "LogTypesToEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logTypesToDisable = logTypesToDisable {
            var logTypesToDisableContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logTypesToDisable)
            for nonemptystring0 in logTypesToDisable {
                try logTypesToDisableContainer.encode(nonemptystring0)
            }
        }
        if let logTypesToEnable = logTypesToEnable {
            var logTypesToEnableContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logTypesToEnable)
            for nonemptystring0 in logTypesToEnable {
                try logTypesToEnableContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTypesToEnableContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logTypesToEnable)
        var logTypesToEnableDecoded0:[Swift.String]? = nil
        if let logTypesToEnableContainer = logTypesToEnableContainer {
            logTypesToEnableDecoded0 = [Swift.String]()
            for string0 in logTypesToEnableContainer {
                if let string0 = string0 {
                    logTypesToEnableDecoded0?.append(string0)
                }
            }
        }
        logTypesToEnable = logTypesToEnableDecoded0
        let logTypesToDisableContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logTypesToDisable)
        var logTypesToDisableDecoded0:[Swift.String]? = nil
        if let logTypesToDisableContainer = logTypesToDisableContainer {
            logTypesToDisableDecoded0 = [Swift.String]()
            for string0 in logTypesToDisableContainer {
                if let string0 = string0 {
                    logTypesToDisableDecoded0?.append(string0)
                }
            }
        }
        logTypesToDisable = logTypesToDisableDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Identifies the log types to enable and disable.
    public struct AwsRdsPendingCloudWatchLogsExports: Swift.Equatable {
        /// A list of log types that are being disabled.
        public var logTypesToDisable: [Swift.String]?
        /// A list of log types that are being enabled.
        public var logTypesToEnable: [Swift.String]?

        public init (
            logTypesToDisable: [Swift.String]? = nil,
            logTypesToEnable: [Swift.String]? = nil
        )
        {
            self.logTypesToDisable = logTypesToDisable
            self.logTypesToEnable = logTypesToEnable
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterNode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeRole = "NodeRole"
        case privateIpAddress = "PrivateIpAddress"
        case publicIpAddress = "PublicIpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeRole = self.nodeRole {
            try encodeContainer.encode(nodeRole, forKey: .nodeRole)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let publicIpAddress = self.publicIpAddress {
            try encodeContainer.encode(publicIpAddress, forKey: .publicIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeRole)
        nodeRole = nodeRoleDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let publicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIpAddress)
        publicIpAddress = publicIpAddressDecoded
    }
}

extension SecurityHubClientTypes {
    /// A node in an Amazon Redshift cluster.
    public struct AwsRedshiftClusterClusterNode: Swift.Equatable {
        /// The role of the node. A node might be a leader node or a compute node.
        public var nodeRole: Swift.String?
        /// The private IP address of the node.
        public var privateIpAddress: Swift.String?
        /// The public IP address of the node.
        public var publicIpAddress: Swift.String?

        public init (
            nodeRole: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIpAddress: Swift.String? = nil
        )
        {
            self.nodeRole = nodeRole
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterParameterStatusList = "ClusterParameterStatusList"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterParameterStatusList = clusterParameterStatusList {
            var clusterParameterStatusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterParameterStatusList)
            for awsredshiftclusterclusterparameterstatus0 in clusterParameterStatusList {
                try clusterParameterStatusListContainer.encode(awsredshiftclusterclusterparameterstatus0)
            }
        }
        if let parameterApplyStatus = self.parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
        if let parameterGroupName = self.parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterParameterStatusListContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus?].self, forKey: .clusterParameterStatusList)
        var clusterParameterStatusListDecoded0:[SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus]? = nil
        if let clusterParameterStatusListContainer = clusterParameterStatusListContainer {
            clusterParameterStatusListDecoded0 = [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus]()
            for structure0 in clusterParameterStatusListContainer {
                if let structure0 = structure0 {
                    clusterParameterStatusListDecoded0?.append(structure0)
                }
            }
        }
        clusterParameterStatusList = clusterParameterStatusListDecoded0
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// A cluster parameter group that is associated with an Amazon Redshift cluster.
    public struct AwsRedshiftClusterClusterParameterGroup: Swift.Equatable {
        /// The list of parameter statuses.
        public var clusterParameterStatusList: [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus]?
        /// The status of updates to the parameters.
        public var parameterApplyStatus: Swift.String?
        /// The name of the parameter group.
        public var parameterGroupName: Swift.String?

        public init (
            clusterParameterStatusList: [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus]? = nil,
            parameterApplyStatus: Swift.String? = nil,
            parameterGroupName: Swift.String? = nil
        )
        {
            self.clusterParameterStatusList = clusterParameterStatusList
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterGroupName = parameterGroupName
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterParameterStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterApplyErrorDescription = "ParameterApplyErrorDescription"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterName = "ParameterName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterApplyErrorDescription = self.parameterApplyErrorDescription {
            try encodeContainer.encode(parameterApplyErrorDescription, forKey: .parameterApplyErrorDescription)
        }
        if let parameterApplyStatus = self.parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let parameterApplyErrorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterApplyErrorDescription)
        parameterApplyErrorDescription = parameterApplyErrorDescriptionDecoded
    }
}

extension SecurityHubClientTypes {
    /// The status of a parameter in a cluster parameter group for an Amazon Redshift cluster.
    public struct AwsRedshiftClusterClusterParameterStatus: Swift.Equatable {
        /// The error that prevented the parameter from being applied to the database.
        public var parameterApplyErrorDescription: Swift.String?
        /// The status of the parameter. Indicates whether the parameter is in sync with the database, waiting for a cluster reboot, or encountered an error when it was applied. Valid values: in-sync | pending-reboot | applying | invalid-parameter | apply-deferred | apply-error | unknown-error
        public var parameterApplyStatus: Swift.String?
        /// The name of the parameter.
        public var parameterName: Swift.String?

        public init (
            parameterApplyErrorDescription: Swift.String? = nil,
            parameterApplyStatus: Swift.String? = nil,
            parameterName: Swift.String? = nil
        )
        {
            self.parameterApplyErrorDescription = parameterApplyErrorDescription
            self.parameterApplyStatus = parameterApplyStatus
            self.parameterName = parameterName
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterSecurityGroupName = "ClusterSecurityGroupName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterSecurityGroupName = self.clusterSecurityGroupName {
            try encodeContainer.encode(clusterSecurityGroupName, forKey: .clusterSecurityGroupName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterSecurityGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterSecurityGroupName)
        clusterSecurityGroupName = clusterSecurityGroupNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// A security group that is associated with the cluster.
    public struct AwsRedshiftClusterClusterSecurityGroup: Swift.Equatable {
        /// The name of the cluster security group.
        public var clusterSecurityGroupName: Swift.String?
        /// The status of the cluster security group.
        public var status: Swift.String?

        public init (
            clusterSecurityGroupName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.clusterSecurityGroupName = clusterSecurityGroupName
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationRegion = "DestinationRegion"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case retentionPeriod = "RetentionPeriod"
        case snapshotCopyGrantName = "SnapshotCopyGrantName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if manualSnapshotRetentionPeriod != 0 {
            try encodeContainer.encode(manualSnapshotRetentionPeriod, forKey: .manualSnapshotRetentionPeriod)
        }
        if retentionPeriod != 0 {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let snapshotCopyGrantName = self.snapshotCopyGrantName {
            try encodeContainer.encode(snapshotCopyGrantName, forKey: .snapshotCopyGrantName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualSnapshotRetentionPeriod) ?? 0
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionPeriod) ?? 0
        retentionPeriod = retentionPeriodDecoded
        let snapshotCopyGrantNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCopyGrantName)
        snapshotCopyGrantName = snapshotCopyGrantNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a cross-Region snapshot copy.
    public struct AwsRedshiftClusterClusterSnapshotCopyStatus: Swift.Equatable {
        /// The destination Region that snapshots are automatically copied to when cross-Region snapshot copy is enabled.
        public var destinationRegion: Swift.String?
        /// The number of days that manual snapshots are retained in the destination region after they are copied from a source region. If the value is -1, then the manual snapshot is retained indefinitely. Valid values: Either -1 or an integer between 1 and 3,653
        public var manualSnapshotRetentionPeriod: Swift.Int
        /// The number of days to retain automated snapshots in the destination Region after they are copied from a source Region.
        public var retentionPeriod: Swift.Int
        /// The name of the snapshot copy grant.
        public var snapshotCopyGrantName: Swift.String?

        public init (
            destinationRegion: Swift.String? = nil,
            manualSnapshotRetentionPeriod: Swift.Int = 0,
            retentionPeriod: Swift.Int = 0,
            snapshotCopyGrantName: Swift.String? = nil
        )
        {
            self.destinationRegion = destinationRegion
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.retentionPeriod = retentionPeriod
            self.snapshotCopyGrantName = snapshotCopyGrantName
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deferMaintenanceEndTime = "DeferMaintenanceEndTime"
        case deferMaintenanceIdentifier = "DeferMaintenanceIdentifier"
        case deferMaintenanceStartTime = "DeferMaintenanceStartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deferMaintenanceEndTime = self.deferMaintenanceEndTime {
            try encodeContainer.encode(deferMaintenanceEndTime, forKey: .deferMaintenanceEndTime)
        }
        if let deferMaintenanceIdentifier = self.deferMaintenanceIdentifier {
            try encodeContainer.encode(deferMaintenanceIdentifier, forKey: .deferMaintenanceIdentifier)
        }
        if let deferMaintenanceStartTime = self.deferMaintenanceStartTime {
            try encodeContainer.encode(deferMaintenanceStartTime, forKey: .deferMaintenanceStartTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deferMaintenanceEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deferMaintenanceEndTime)
        deferMaintenanceEndTime = deferMaintenanceEndTimeDecoded
        let deferMaintenanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deferMaintenanceIdentifier)
        deferMaintenanceIdentifier = deferMaintenanceIdentifierDecoded
        let deferMaintenanceStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deferMaintenanceStartTime)
        deferMaintenanceStartTime = deferMaintenanceStartTimeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A time windows during which maintenance was deferred for an Amazon Redshift cluster.
    public struct AwsRedshiftClusterDeferredMaintenanceWindow: Swift.Equatable {
        /// The end of the time window for which maintenance was deferred. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var deferMaintenanceEndTime: Swift.String?
        /// The identifier of the maintenance window.
        public var deferMaintenanceIdentifier: Swift.String?
        /// The start of the time window for which maintenance was deferred. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var deferMaintenanceStartTime: Swift.String?

        public init (
            deferMaintenanceEndTime: Swift.String? = nil,
            deferMaintenanceIdentifier: Swift.String? = nil,
            deferMaintenanceStartTime: Swift.String? = nil
        )
        {
            self.deferMaintenanceEndTime = deferMaintenanceEndTime
            self.deferMaintenanceIdentifier = deferMaintenanceIdentifier
            self.deferMaintenanceStartTime = deferMaintenanceStartTime
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowVersionUpgrade = "AllowVersionUpgrade"
        case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
        case availabilityZone = "AvailabilityZone"
        case clusterAvailabilityStatus = "ClusterAvailabilityStatus"
        case clusterCreateTime = "ClusterCreateTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterNodes = "ClusterNodes"
        case clusterParameterGroups = "ClusterParameterGroups"
        case clusterPublicKey = "ClusterPublicKey"
        case clusterRevisionNumber = "ClusterRevisionNumber"
        case clusterSecurityGroups = "ClusterSecurityGroups"
        case clusterSnapshotCopyStatus = "ClusterSnapshotCopyStatus"
        case clusterStatus = "ClusterStatus"
        case clusterSubnetGroupName = "ClusterSubnetGroupName"
        case clusterVersion = "ClusterVersion"
        case dbName = "DBName"
        case deferredMaintenanceWindows = "DeferredMaintenanceWindows"
        case elasticIpStatus = "ElasticIpStatus"
        case elasticResizeNumberOfNodeOptions = "ElasticResizeNumberOfNodeOptions"
        case encrypted = "Encrypted"
        case endpoint = "Endpoint"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case expectedNextSnapshotScheduleTime = "ExpectedNextSnapshotScheduleTime"
        case expectedNextSnapshotScheduleTimeStatus = "ExpectedNextSnapshotScheduleTimeStatus"
        case hsmStatus = "HsmStatus"
        case iamRoles = "IamRoles"
        case kmsKeyId = "KmsKeyId"
        case loggingStatus = "LoggingStatus"
        case maintenanceTrackName = "MaintenanceTrackName"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case masterUsername = "MasterUsername"
        case nextMaintenanceWindowStartTime = "NextMaintenanceWindowStartTime"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case pendingActions = "PendingActions"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case resizeInfo = "ResizeInfo"
        case restoreStatus = "RestoreStatus"
        case snapshotScheduleIdentifier = "SnapshotScheduleIdentifier"
        case snapshotScheduleState = "SnapshotScheduleState"
        case vpcId = "VpcId"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowVersionUpgrade != false {
            try encodeContainer.encode(allowVersionUpgrade, forKey: .allowVersionUpgrade)
        }
        if automatedSnapshotRetentionPeriod != 0 {
            try encodeContainer.encode(automatedSnapshotRetentionPeriod, forKey: .automatedSnapshotRetentionPeriod)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let clusterAvailabilityStatus = self.clusterAvailabilityStatus {
            try encodeContainer.encode(clusterAvailabilityStatus, forKey: .clusterAvailabilityStatus)
        }
        if let clusterCreateTime = self.clusterCreateTime {
            try encodeContainer.encode(clusterCreateTime, forKey: .clusterCreateTime)
        }
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let clusterNodes = clusterNodes {
            var clusterNodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterNodes)
            for awsredshiftclusterclusternode0 in clusterNodes {
                try clusterNodesContainer.encode(awsredshiftclusterclusternode0)
            }
        }
        if let clusterParameterGroups = clusterParameterGroups {
            var clusterParameterGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterParameterGroups)
            for awsredshiftclusterclusterparametergroup0 in clusterParameterGroups {
                try clusterParameterGroupsContainer.encode(awsredshiftclusterclusterparametergroup0)
            }
        }
        if let clusterPublicKey = self.clusterPublicKey {
            try encodeContainer.encode(clusterPublicKey, forKey: .clusterPublicKey)
        }
        if let clusterRevisionNumber = self.clusterRevisionNumber {
            try encodeContainer.encode(clusterRevisionNumber, forKey: .clusterRevisionNumber)
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterSecurityGroups)
            for awsredshiftclusterclustersecuritygroup0 in clusterSecurityGroups {
                try clusterSecurityGroupsContainer.encode(awsredshiftclusterclustersecuritygroup0)
            }
        }
        if let clusterSnapshotCopyStatus = self.clusterSnapshotCopyStatus {
            try encodeContainer.encode(clusterSnapshotCopyStatus, forKey: .clusterSnapshotCopyStatus)
        }
        if let clusterStatus = self.clusterStatus {
            try encodeContainer.encode(clusterStatus, forKey: .clusterStatus)
        }
        if let clusterSubnetGroupName = self.clusterSubnetGroupName {
            try encodeContainer.encode(clusterSubnetGroupName, forKey: .clusterSubnetGroupName)
        }
        if let clusterVersion = self.clusterVersion {
            try encodeContainer.encode(clusterVersion, forKey: .clusterVersion)
        }
        if let dbName = self.dbName {
            try encodeContainer.encode(dbName, forKey: .dbName)
        }
        if let deferredMaintenanceWindows = deferredMaintenanceWindows {
            var deferredMaintenanceWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deferredMaintenanceWindows)
            for awsredshiftclusterdeferredmaintenancewindow0 in deferredMaintenanceWindows {
                try deferredMaintenanceWindowsContainer.encode(awsredshiftclusterdeferredmaintenancewindow0)
            }
        }
        if let elasticIpStatus = self.elasticIpStatus {
            try encodeContainer.encode(elasticIpStatus, forKey: .elasticIpStatus)
        }
        if let elasticResizeNumberOfNodeOptions = self.elasticResizeNumberOfNodeOptions {
            try encodeContainer.encode(elasticResizeNumberOfNodeOptions, forKey: .elasticResizeNumberOfNodeOptions)
        }
        if encrypted != false {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if enhancedVpcRouting != false {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let expectedNextSnapshotScheduleTime = self.expectedNextSnapshotScheduleTime {
            try encodeContainer.encode(expectedNextSnapshotScheduleTime, forKey: .expectedNextSnapshotScheduleTime)
        }
        if let expectedNextSnapshotScheduleTimeStatus = self.expectedNextSnapshotScheduleTimeStatus {
            try encodeContainer.encode(expectedNextSnapshotScheduleTimeStatus, forKey: .expectedNextSnapshotScheduleTimeStatus)
        }
        if let hsmStatus = self.hsmStatus {
            try encodeContainer.encode(hsmStatus, forKey: .hsmStatus)
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iamRoles)
            for awsredshiftclusteriamrole0 in iamRoles {
                try iamRolesContainer.encode(awsredshiftclusteriamrole0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let loggingStatus = self.loggingStatus {
            try encodeContainer.encode(loggingStatus, forKey: .loggingStatus)
        }
        if let maintenanceTrackName = self.maintenanceTrackName {
            try encodeContainer.encode(maintenanceTrackName, forKey: .maintenanceTrackName)
        }
        if manualSnapshotRetentionPeriod != 0 {
            try encodeContainer.encode(manualSnapshotRetentionPeriod, forKey: .manualSnapshotRetentionPeriod)
        }
        if let masterUsername = self.masterUsername {
            try encodeContainer.encode(masterUsername, forKey: .masterUsername)
        }
        if let nextMaintenanceWindowStartTime = self.nextMaintenanceWindowStartTime {
            try encodeContainer.encode(nextMaintenanceWindowStartTime, forKey: .nextMaintenanceWindowStartTime)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if numberOfNodes != 0 {
            try encodeContainer.encode(numberOfNodes, forKey: .numberOfNodes)
        }
        if let pendingActions = pendingActions {
            var pendingActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pendingActions)
            for nonemptystring0 in pendingActions {
                try pendingActionsContainer.encode(nonemptystring0)
            }
        }
        if let pendingModifiedValues = self.pendingModifiedValues {
            try encodeContainer.encode(pendingModifiedValues, forKey: .pendingModifiedValues)
        }
        if let preferredMaintenanceWindow = self.preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let resizeInfo = self.resizeInfo {
            try encodeContainer.encode(resizeInfo, forKey: .resizeInfo)
        }
        if let restoreStatus = self.restoreStatus {
            try encodeContainer.encode(restoreStatus, forKey: .restoreStatus)
        }
        if let snapshotScheduleIdentifier = self.snapshotScheduleIdentifier {
            try encodeContainer.encode(snapshotScheduleIdentifier, forKey: .snapshotScheduleIdentifier)
        }
        if let snapshotScheduleState = self.snapshotScheduleState {
            try encodeContainer.encode(snapshotScheduleState, forKey: .snapshotScheduleState)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcSecurityGroups)
            for awsredshiftclustervpcsecuritygroup0 in vpcSecurityGroups {
                try vpcSecurityGroupsContainer.encode(awsredshiftclustervpcsecuritygroup0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowVersionUpgrade) ?? false
        allowVersionUpgrade = allowVersionUpgradeDecoded
        let automatedSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automatedSnapshotRetentionPeriod) ?? 0
        automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriodDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let clusterAvailabilityStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterAvailabilityStatus)
        clusterAvailabilityStatus = clusterAvailabilityStatusDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        clusterCreateTime = clusterCreateTimeDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let clusterNodesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRedshiftClusterClusterNode?].self, forKey: .clusterNodes)
        var clusterNodesDecoded0:[SecurityHubClientTypes.AwsRedshiftClusterClusterNode]? = nil
        if let clusterNodesContainer = clusterNodesContainer {
            clusterNodesDecoded0 = [SecurityHubClientTypes.AwsRedshiftClusterClusterNode]()
            for structure0 in clusterNodesContainer {
                if let structure0 = structure0 {
                    clusterNodesDecoded0?.append(structure0)
                }
            }
        }
        clusterNodes = clusterNodesDecoded0
        let clusterParameterGroupsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup?].self, forKey: .clusterParameterGroups)
        var clusterParameterGroupsDecoded0:[SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup]? = nil
        if let clusterParameterGroupsContainer = clusterParameterGroupsContainer {
            clusterParameterGroupsDecoded0 = [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup]()
            for structure0 in clusterParameterGroupsContainer {
                if let structure0 = structure0 {
                    clusterParameterGroupsDecoded0?.append(structure0)
                }
            }
        }
        clusterParameterGroups = clusterParameterGroupsDecoded0
        let clusterPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterPublicKey)
        clusterPublicKey = clusterPublicKeyDecoded
        let clusterRevisionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterRevisionNumber)
        clusterRevisionNumber = clusterRevisionNumberDecoded
        let clusterSecurityGroupsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup?].self, forKey: .clusterSecurityGroups)
        var clusterSecurityGroupsDecoded0:[SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup]? = nil
        if let clusterSecurityGroupsContainer = clusterSecurityGroupsContainer {
            clusterSecurityGroupsDecoded0 = [SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup]()
            for structure0 in clusterSecurityGroupsContainer {
                if let structure0 = structure0 {
                    clusterSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        clusterSecurityGroups = clusterSecurityGroupsDecoded0
        let clusterSnapshotCopyStatusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus.self, forKey: .clusterSnapshotCopyStatus)
        clusterSnapshotCopyStatus = clusterSnapshotCopyStatusDecoded
        let clusterStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let clusterSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterSubnetGroupName)
        clusterSubnetGroupName = clusterSubnetGroupNameDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let dbNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbName)
        dbName = dbNameDecoded
        let deferredMaintenanceWindowsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow?].self, forKey: .deferredMaintenanceWindows)
        var deferredMaintenanceWindowsDecoded0:[SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow]? = nil
        if let deferredMaintenanceWindowsContainer = deferredMaintenanceWindowsContainer {
            deferredMaintenanceWindowsDecoded0 = [SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow]()
            for structure0 in deferredMaintenanceWindowsContainer {
                if let structure0 = structure0 {
                    deferredMaintenanceWindowsDecoded0?.append(structure0)
                }
            }
        }
        deferredMaintenanceWindows = deferredMaintenanceWindowsDecoded0
        let elasticIpStatusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus.self, forKey: .elasticIpStatus)
        elasticIpStatus = elasticIpStatusDecoded
        let elasticResizeNumberOfNodeOptionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticResizeNumberOfNodeOptions)
        elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptionsDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted) ?? false
        encrypted = encryptedDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRedshiftClusterEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedVpcRouting) ?? false
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let expectedNextSnapshotScheduleTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedNextSnapshotScheduleTime)
        expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTimeDecoded
        let expectedNextSnapshotScheduleTimeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedNextSnapshotScheduleTimeStatus)
        expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatusDecoded
        let hsmStatusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRedshiftClusterHsmStatus.self, forKey: .hsmStatus)
        hsmStatus = hsmStatusDecoded
        let iamRolesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRedshiftClusterIamRole?].self, forKey: .iamRoles)
        var iamRolesDecoded0:[SecurityHubClientTypes.AwsRedshiftClusterIamRole]? = nil
        if let iamRolesContainer = iamRolesContainer {
            iamRolesDecoded0 = [SecurityHubClientTypes.AwsRedshiftClusterIamRole]()
            for structure0 in iamRolesContainer {
                if let structure0 = structure0 {
                    iamRolesDecoded0?.append(structure0)
                }
            }
        }
        iamRoles = iamRolesDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualSnapshotRetentionPeriod) ?? 0
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let nextMaintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMaintenanceWindowStartTime)
        nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTimeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNodes) ?? 0
        numberOfNodes = numberOfNodesDecoded
        let pendingActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pendingActions)
        var pendingActionsDecoded0:[Swift.String]? = nil
        if let pendingActionsContainer = pendingActionsContainer {
            pendingActionsDecoded0 = [Swift.String]()
            for string0 in pendingActionsContainer {
                if let string0 = string0 {
                    pendingActionsDecoded0?.append(string0)
                }
            }
        }
        pendingActions = pendingActionsDecoded0
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible) ?? false
        publiclyAccessible = publiclyAccessibleDecoded
        let resizeInfoDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRedshiftClusterResizeInfo.self, forKey: .resizeInfo)
        resizeInfo = resizeInfoDecoded
        let restoreStatusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus.self, forKey: .restoreStatus)
        restoreStatus = restoreStatusDecoded
        let snapshotScheduleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotScheduleIdentifier)
        snapshotScheduleIdentifier = snapshotScheduleIdentifierDecoded
        let snapshotScheduleStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotScheduleState)
        snapshotScheduleState = snapshotScheduleStateDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let vpcSecurityGroupsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup?].self, forKey: .vpcSecurityGroups)
        var vpcSecurityGroupsDecoded0:[SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup]? = nil
        if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
            vpcSecurityGroupsDecoded0 = [SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup]()
            for structure0 in vpcSecurityGroupsContainer {
                if let structure0 = structure0 {
                    vpcSecurityGroupsDecoded0?.append(structure0)
                }
            }
        }
        vpcSecurityGroups = vpcSecurityGroupsDecoded0
        let loggingStatusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus.self, forKey: .loggingStatus)
        loggingStatus = loggingStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an Amazon Redshift cluster.
    public struct AwsRedshiftClusterDetails: Swift.Equatable {
        /// Indicates whether major version upgrades are applied automatically to the cluster during the maintenance window.
        public var allowVersionUpgrade: Swift.Bool
        /// The number of days that automatic cluster snapshots are retained.
        public var automatedSnapshotRetentionPeriod: Swift.Int
        /// The name of the Availability Zone in which the cluster is located.
        public var availabilityZone: Swift.String?
        /// The availability status of the cluster for queries. Possible values are the following:
        ///
        /// * Available - The cluster is available for queries.
        ///
        /// * Unavailable - The cluster is not available for queries.
        ///
        /// * Maintenance - The cluster is intermittently available for queries due to maintenance activities.
        ///
        /// * Modifying -The cluster is intermittently available for queries due to changes that modify the cluster.
        ///
        /// * Failed - The cluster failed and is not available for queries.
        public var clusterAvailabilityStatus: Swift.String?
        /// Indicates when the cluster was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var clusterCreateTime: Swift.String?
        /// The unique identifier of the cluster.
        public var clusterIdentifier: Swift.String?
        /// The nodes in the cluster.
        public var clusterNodes: [SecurityHubClientTypes.AwsRedshiftClusterClusterNode]?
        /// The list of cluster parameter groups that are associated with this cluster.
        public var clusterParameterGroups: [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup]?
        /// The public key for the cluster.
        public var clusterPublicKey: Swift.String?
        /// The specific revision number of the database in the cluster.
        public var clusterRevisionNumber: Swift.String?
        /// A list of cluster security groups that are associated with the cluster.
        public var clusterSecurityGroups: [SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup]?
        /// Information about the destination Region and retention period for the cross-Region snapshot copy.
        public var clusterSnapshotCopyStatus: SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus?
        /// The current status of the cluster. Valid values: available | available, prep-for-resize | available, resize-cleanup | cancelling-resize | creating | deleting | final-snapshot | hardware-failure | incompatible-hsm | incompatible-network | incompatible-parameters | incompatible-restore | modifying | paused | rebooting | renaming | resizing | rotating-keys | storage-full | updating-hsm
        public var clusterStatus: Swift.String?
        /// The name of the subnet group that is associated with the cluster. This parameter is valid only when the cluster is in a VPC.
        public var clusterSubnetGroupName: Swift.String?
        /// The version ID of the Amazon Redshift engine that runs on the cluster.
        public var clusterVersion: Swift.String?
        /// The name of the initial database that was created when the cluster was created. The same name is returned for the life of the cluster. If an initial database is not specified, a database named devdev is created by default.
        public var dbName: Swift.String?
        /// List of time windows during which maintenance was deferred.
        public var deferredMaintenanceWindows: [SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow]?
        /// Information about the status of the Elastic IP (EIP) address.
        public var elasticIpStatus: SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus?
        /// The number of nodes that you can use the elastic resize method to resize the cluster to.
        public var elasticResizeNumberOfNodeOptions: Swift.String?
        /// Indicates whether the data in the cluster is encrypted at rest.
        public var encrypted: Swift.Bool
        /// The connection endpoint.
        public var endpoint: SecurityHubClientTypes.AwsRedshiftClusterEndpoint?
        /// Indicates whether to create the cluster with enhanced VPC routing enabled.
        public var enhancedVpcRouting: Swift.Bool
        /// Indicates when the next snapshot is expected to be taken. The cluster must have a valid snapshot schedule and have backups enabled. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var expectedNextSnapshotScheduleTime: Swift.String?
        /// The status of the next expected snapshot. Valid values: OnTrack | Pending
        public var expectedNextSnapshotScheduleTimeStatus: Swift.String?
        /// Information about whether the Amazon Redshift cluster finished applying any changes to hardware security module (HSM) settings that were specified in a modify cluster command.
        public var hsmStatus: SecurityHubClientTypes.AwsRedshiftClusterHsmStatus?
        /// A list of IAM roles that the cluster can use to access other Amazon Web Services services.
        public var iamRoles: [SecurityHubClientTypes.AwsRedshiftClusterIamRole]?
        /// The identifier of the KMS encryption key that is used to encrypt data in the cluster.
        public var kmsKeyId: Swift.String?
        /// Information about the logging status of the cluster.
        public var loggingStatus: SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus?
        /// The name of the maintenance track for the cluster.
        public var maintenanceTrackName: Swift.String?
        /// The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots. Valid values: Either -1 or an integer between 1 and 3,653
        public var manualSnapshotRetentionPeriod: Swift.Int
        /// The master user name for the cluster. This name is used to connect to the database that is specified in as the value of DBName.
        public var masterUsername: Swift.String?
        /// Indicates the start of the next maintenance window. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var nextMaintenanceWindowStartTime: Swift.String?
        /// The node type for the nodes in the cluster.
        public var nodeType: Swift.String?
        /// The number of compute nodes in the cluster.
        public var numberOfNodes: Swift.Int
        /// A list of cluster operations that are waiting to start.
        public var pendingActions: [Swift.String]?
        /// A list of changes to the cluster that are currently pending.
        public var pendingModifiedValues: SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues?
        /// The weekly time range, in Universal Coordinated Time (UTC), during which system maintenance can occur. Format:  :HH:MM-:HH:MM For the day values, use mon | tue | wed | thu | fri | sat | sun For example, sun:09:32-sun:10:02
        public var preferredMaintenanceWindow: Swift.String?
        /// Whether the cluster can be accessed from a public network.
        public var publiclyAccessible: Swift.Bool
        /// Information about the resize operation for the cluster.
        public var resizeInfo: SecurityHubClientTypes.AwsRedshiftClusterResizeInfo?
        /// Information about the status of a cluster restore action. Only applies to a cluster that was created by restoring a snapshot.
        public var restoreStatus: SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus?
        /// A unique identifier for the cluster snapshot schedule.
        public var snapshotScheduleIdentifier: Swift.String?
        /// The current state of the cluster snapshot schedule. Valid values: MODIFYING | ACTIVE | FAILED
        public var snapshotScheduleState: Swift.String?
        /// The identifier of the VPC that the cluster is in, if the cluster is in a VPC.
        public var vpcId: Swift.String?
        /// The list of VPC security groups that the cluster belongs to, if the cluster is in a VPC.
        public var vpcSecurityGroups: [SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup]?

        public init (
            allowVersionUpgrade: Swift.Bool = false,
            automatedSnapshotRetentionPeriod: Swift.Int = 0,
            availabilityZone: Swift.String? = nil,
            clusterAvailabilityStatus: Swift.String? = nil,
            clusterCreateTime: Swift.String? = nil,
            clusterIdentifier: Swift.String? = nil,
            clusterNodes: [SecurityHubClientTypes.AwsRedshiftClusterClusterNode]? = nil,
            clusterParameterGroups: [SecurityHubClientTypes.AwsRedshiftClusterClusterParameterGroup]? = nil,
            clusterPublicKey: Swift.String? = nil,
            clusterRevisionNumber: Swift.String? = nil,
            clusterSecurityGroups: [SecurityHubClientTypes.AwsRedshiftClusterClusterSecurityGroup]? = nil,
            clusterSnapshotCopyStatus: SecurityHubClientTypes.AwsRedshiftClusterClusterSnapshotCopyStatus? = nil,
            clusterStatus: Swift.String? = nil,
            clusterSubnetGroupName: Swift.String? = nil,
            clusterVersion: Swift.String? = nil,
            dbName: Swift.String? = nil,
            deferredMaintenanceWindows: [SecurityHubClientTypes.AwsRedshiftClusterDeferredMaintenanceWindow]? = nil,
            elasticIpStatus: SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus? = nil,
            elasticResizeNumberOfNodeOptions: Swift.String? = nil,
            encrypted: Swift.Bool = false,
            endpoint: SecurityHubClientTypes.AwsRedshiftClusterEndpoint? = nil,
            enhancedVpcRouting: Swift.Bool = false,
            expectedNextSnapshotScheduleTime: Swift.String? = nil,
            expectedNextSnapshotScheduleTimeStatus: Swift.String? = nil,
            hsmStatus: SecurityHubClientTypes.AwsRedshiftClusterHsmStatus? = nil,
            iamRoles: [SecurityHubClientTypes.AwsRedshiftClusterIamRole]? = nil,
            kmsKeyId: Swift.String? = nil,
            loggingStatus: SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus? = nil,
            maintenanceTrackName: Swift.String? = nil,
            manualSnapshotRetentionPeriod: Swift.Int = 0,
            masterUsername: Swift.String? = nil,
            nextMaintenanceWindowStartTime: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numberOfNodes: Swift.Int = 0,
            pendingActions: [Swift.String]? = nil,
            pendingModifiedValues: SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            publiclyAccessible: Swift.Bool = false,
            resizeInfo: SecurityHubClientTypes.AwsRedshiftClusterResizeInfo? = nil,
            restoreStatus: SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus? = nil,
            snapshotScheduleIdentifier: Swift.String? = nil,
            snapshotScheduleState: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            vpcSecurityGroups: [SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup]? = nil
        )
        {
            self.allowVersionUpgrade = allowVersionUpgrade
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.availabilityZone = availabilityZone
            self.clusterAvailabilityStatus = clusterAvailabilityStatus
            self.clusterCreateTime = clusterCreateTime
            self.clusterIdentifier = clusterIdentifier
            self.clusterNodes = clusterNodes
            self.clusterParameterGroups = clusterParameterGroups
            self.clusterPublicKey = clusterPublicKey
            self.clusterRevisionNumber = clusterRevisionNumber
            self.clusterSecurityGroups = clusterSecurityGroups
            self.clusterSnapshotCopyStatus = clusterSnapshotCopyStatus
            self.clusterStatus = clusterStatus
            self.clusterSubnetGroupName = clusterSubnetGroupName
            self.clusterVersion = clusterVersion
            self.dbName = dbName
            self.deferredMaintenanceWindows = deferredMaintenanceWindows
            self.elasticIpStatus = elasticIpStatus
            self.elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions
            self.encrypted = encrypted
            self.endpoint = endpoint
            self.enhancedVpcRouting = enhancedVpcRouting
            self.expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime
            self.expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus
            self.hsmStatus = hsmStatus
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.loggingStatus = loggingStatus
            self.maintenanceTrackName = maintenanceTrackName
            self.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod
            self.masterUsername = masterUsername
            self.nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.pendingActions = pendingActions
            self.pendingModifiedValues = pendingModifiedValues
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.publiclyAccessible = publiclyAccessible
            self.resizeInfo = resizeInfo
            self.restoreStatus = restoreStatus
            self.snapshotScheduleIdentifier = snapshotScheduleIdentifier
            self.snapshotScheduleState = snapshotScheduleState
            self.vpcId = vpcId
            self.vpcSecurityGroups = vpcSecurityGroups
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterElasticIpStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elasticIp = "ElasticIp"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let elasticIp = self.elasticIp {
            try encodeContainer.encode(elasticIp, forKey: .elasticIp)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elasticIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticIp)
        elasticIp = elasticIpDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// The status of the elastic IP (EIP) address for an Amazon Redshift cluster.
    public struct AwsRedshiftClusterElasticIpStatus: Swift.Equatable {
        /// The elastic IP address for the cluster.
        public var elasticIp: Swift.String?
        /// The status of the elastic IP address.
        public var status: Swift.String?

        public init (
            elasticIp: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.elasticIp = elasticIp
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case port = "Port"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
    }
}

extension SecurityHubClientTypes {
    /// The connection endpoint for an Amazon Redshift cluster.
    public struct AwsRedshiftClusterEndpoint: Swift.Equatable {
        /// The DNS address of the cluster.
        public var address: Swift.String?
        /// The port that the database engine listens on.
        public var port: Swift.Int

        public init (
            address: Swift.String? = nil,
            port: Swift.Int = 0
        )
        {
            self.address = address
            self.port = port
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterHsmStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hsmClientCertificateIdentifier = "HsmClientCertificateIdentifier"
        case hsmConfigurationIdentifier = "HsmConfigurationIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hsmClientCertificateIdentifier = self.hsmClientCertificateIdentifier {
            try encodeContainer.encode(hsmClientCertificateIdentifier, forKey: .hsmClientCertificateIdentifier)
        }
        if let hsmConfigurationIdentifier = self.hsmConfigurationIdentifier {
            try encodeContainer.encode(hsmConfigurationIdentifier, forKey: .hsmConfigurationIdentifier)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hsmClientCertificateIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmClientCertificateIdentifier)
        hsmClientCertificateIdentifier = hsmClientCertificateIdentifierDecoded
        let hsmConfigurationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hsmConfigurationIdentifier)
        hsmConfigurationIdentifier = hsmConfigurationIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about whether an Amazon Redshift cluster finished applying any hardware changes to security module (HSM) settings that were specified in a modify cluster command.
    public struct AwsRedshiftClusterHsmStatus: Swift.Equatable {
        /// The name of the HSM client certificate that the Amazon Redshift cluster uses to retrieve the data encryption keys that are stored in an HSM.
        public var hsmClientCertificateIdentifier: Swift.String?
        /// The name of the HSM configuration that contains the information that the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
        public var hsmConfigurationIdentifier: Swift.String?
        /// Indicates whether the Amazon Redshift cluster has finished applying any HSM settings changes specified in a modify cluster command. Type: String Valid values: active | applying
        public var status: Swift.String?

        public init (
            hsmClientCertificateIdentifier: Swift.String? = nil,
            hsmConfigurationIdentifier: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier
            self.hsmConfigurationIdentifier = hsmConfigurationIdentifier
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterIamRole: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyStatus = "ApplyStatus"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyStatus = self.applyStatus {
            try encodeContainer.encode(applyStatus, forKey: .applyStatus)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applyStatus)
        applyStatus = applyStatusDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// An IAM role that the cluster can use to access other Amazon Web Services services.
    public struct AwsRedshiftClusterIamRole: Swift.Equatable {
        /// The status of the IAM role's association with the cluster. Valid values: in-sync | adding | removing
        public var applyStatus: Swift.String?
        /// The ARN of the IAM role.
        public var iamRoleArn: Swift.String?

        public init (
            applyStatus: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.applyStatus = applyStatus
            self.iamRoleArn = iamRoleArn
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterLoggingStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case lastFailureMessage = "LastFailureMessage"
        case lastFailureTime = "LastFailureTime"
        case lastSuccessfulDeliveryTime = "LastSuccessfulDeliveryTime"
        case loggingEnabled = "LoggingEnabled"
        case s3KeyPrefix = "S3KeyPrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let lastFailureMessage = self.lastFailureMessage {
            try encodeContainer.encode(lastFailureMessage, forKey: .lastFailureMessage)
        }
        if let lastFailureTime = self.lastFailureTime {
            try encodeContainer.encode(lastFailureTime, forKey: .lastFailureTime)
        }
        if let lastSuccessfulDeliveryTime = self.lastSuccessfulDeliveryTime {
            try encodeContainer.encode(lastSuccessfulDeliveryTime, forKey: .lastSuccessfulDeliveryTime)
        }
        if loggingEnabled != false {
            try encodeContainer.encode(loggingEnabled, forKey: .loggingEnabled)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let lastFailureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureMessage)
        lastFailureMessage = lastFailureMessageDecoded
        let lastFailureTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastFailureTime)
        lastFailureTime = lastFailureTimeDecoded
        let lastSuccessfulDeliveryTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulDeliveryTime)
        lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTimeDecoded
        let loggingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .loggingEnabled) ?? false
        loggingEnabled = loggingEnabledDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the logging status of the cluster.
    public struct AwsRedshiftClusterLoggingStatus: Swift.Equatable {
        /// The name of the S3 bucket where the log files are stored.
        public var bucketName: Swift.String?
        /// The message indicating that the logs failed to be delivered.
        public var lastFailureMessage: Swift.String?
        /// The last time when logs failed to be delivered. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastFailureTime: Swift.String?
        /// The last time that logs were delivered successfully. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastSuccessfulDeliveryTime: Swift.String?
        /// Indicates whether logging is enabled.
        public var loggingEnabled: Swift.Bool
        /// Provides the prefix applied to the log file names.
        public var s3KeyPrefix: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            lastFailureMessage: Swift.String? = nil,
            lastFailureTime: Swift.String? = nil,
            lastSuccessfulDeliveryTime: Swift.String? = nil,
            loggingEnabled: Swift.Bool = false,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.lastFailureMessage = lastFailureMessage
            self.lastFailureTime = lastFailureTime
            self.lastSuccessfulDeliveryTime = lastSuccessfulDeliveryTime
            self.loggingEnabled = loggingEnabled
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterPendingModifiedValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterType = "ClusterType"
        case clusterVersion = "ClusterVersion"
        case encryptionType = "EncryptionType"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case maintenanceTrackName = "MaintenanceTrackName"
        case masterUserPassword = "MasterUserPassword"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case publiclyAccessible = "PubliclyAccessible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automatedSnapshotRetentionPeriod != 0 {
            try encodeContainer.encode(automatedSnapshotRetentionPeriod, forKey: .automatedSnapshotRetentionPeriod)
        }
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let clusterType = self.clusterType {
            try encodeContainer.encode(clusterType, forKey: .clusterType)
        }
        if let clusterVersion = self.clusterVersion {
            try encodeContainer.encode(clusterVersion, forKey: .clusterVersion)
        }
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType, forKey: .encryptionType)
        }
        if enhancedVpcRouting != false {
            try encodeContainer.encode(enhancedVpcRouting, forKey: .enhancedVpcRouting)
        }
        if let maintenanceTrackName = self.maintenanceTrackName {
            try encodeContainer.encode(maintenanceTrackName, forKey: .maintenanceTrackName)
        }
        if let masterUserPassword = self.masterUserPassword {
            try encodeContainer.encode(masterUserPassword, forKey: .masterUserPassword)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if numberOfNodes != 0 {
            try encodeContainer.encode(numberOfNodes, forKey: .numberOfNodes)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automatedSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automatedSnapshotRetentionPeriod) ?? 0
        automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriodDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let clusterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterType)
        clusterType = clusterTypeDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedVpcRouting) ?? false
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNodes) ?? 0
        numberOfNodes = numberOfNodesDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible) ?? false
        publiclyAccessible = publiclyAccessibleDecoded
    }
}

extension SecurityHubClientTypes {
    /// Changes to the Amazon Redshift cluster that are currently pending.
    public struct AwsRedshiftClusterPendingModifiedValues: Swift.Equatable {
        /// The pending or in-progress change to the automated snapshot retention period.
        public var automatedSnapshotRetentionPeriod: Swift.Int
        /// The pending or in-progress change to the identifier for the cluster.
        public var clusterIdentifier: Swift.String?
        /// The pending or in-progress change to the cluster type.
        public var clusterType: Swift.String?
        /// The pending or in-progress change to the service version.
        public var clusterVersion: Swift.String?
        /// The encryption type for a cluster.
        public var encryptionType: Swift.String?
        /// Indicates whether to create the cluster with enhanced VPC routing enabled.
        public var enhancedVpcRouting: Swift.Bool
        /// The name of the maintenance track that the cluster changes to during the next maintenance window.
        public var maintenanceTrackName: Swift.String?
        /// The pending or in-progress change to the master user password for the cluster.
        public var masterUserPassword: Swift.String?
        /// The pending or in-progress change to the cluster's node type.
        public var nodeType: Swift.String?
        /// The pending or in-progress change to the number of nodes in the cluster.
        public var numberOfNodes: Swift.Int
        /// The pending or in-progress change to whether the cluster can be connected to from the public network.
        public var publiclyAccessible: Swift.Bool

        public init (
            automatedSnapshotRetentionPeriod: Swift.Int = 0,
            clusterIdentifier: Swift.String? = nil,
            clusterType: Swift.String? = nil,
            clusterVersion: Swift.String? = nil,
            encryptionType: Swift.String? = nil,
            enhancedVpcRouting: Swift.Bool = false,
            maintenanceTrackName: Swift.String? = nil,
            masterUserPassword: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            numberOfNodes: Swift.Int = 0,
            publiclyAccessible: Swift.Bool = false
        )
        {
            self.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod
            self.clusterIdentifier = clusterIdentifier
            self.clusterType = clusterType
            self.clusterVersion = clusterVersion
            self.encryptionType = encryptionType
            self.enhancedVpcRouting = enhancedVpcRouting
            self.maintenanceTrackName = maintenanceTrackName
            self.masterUserPassword = masterUserPassword
            self.nodeType = nodeType
            self.numberOfNodes = numberOfNodes
            self.publiclyAccessible = publiclyAccessible
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterResizeInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCancelResize = "AllowCancelResize"
        case resizeType = "ResizeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowCancelResize != false {
            try encodeContainer.encode(allowCancelResize, forKey: .allowCancelResize)
        }
        if let resizeType = self.resizeType {
            try encodeContainer.encode(resizeType, forKey: .resizeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowCancelResizeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCancelResize) ?? false
        allowCancelResize = allowCancelResizeDecoded
        let resizeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the resize operation for the cluster.
    public struct AwsRedshiftClusterResizeInfo: Swift.Equatable {
        /// Indicates whether the resize operation can be canceled.
        public var allowCancelResize: Swift.Bool
        /// The type of resize operation. Valid values: ClassicResize
        public var resizeType: Swift.String?

        public init (
            allowCancelResize: Swift.Bool = false,
            resizeType: Swift.String? = nil
        )
        {
            self.allowCancelResize = allowCancelResize
            self.resizeType = resizeType
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterRestoreStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentRestoreRateInMegaBytesPerSecond = "CurrentRestoreRateInMegaBytesPerSecond"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case snapshotSizeInMegaBytes = "SnapshotSizeInMegaBytes"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentRestoreRateInMegaBytesPerSecond != 0.0 {
            try encodeContainer.encode(currentRestoreRateInMegaBytesPerSecond, forKey: .currentRestoreRateInMegaBytesPerSecond)
        }
        if elapsedTimeInSeconds != 0 {
            try encodeContainer.encode(elapsedTimeInSeconds, forKey: .elapsedTimeInSeconds)
        }
        if estimatedTimeToCompletionInSeconds != 0 {
            try encodeContainer.encode(estimatedTimeToCompletionInSeconds, forKey: .estimatedTimeToCompletionInSeconds)
        }
        if progressInMegaBytes != 0 {
            try encodeContainer.encode(progressInMegaBytes, forKey: .progressInMegaBytes)
        }
        if snapshotSizeInMegaBytes != 0 {
            try encodeContainer.encode(snapshotSizeInMegaBytes, forKey: .snapshotSizeInMegaBytes)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentRestoreRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .currentRestoreRateInMegaBytesPerSecond) ?? 0.0
        currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecondDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeInSeconds) ?? 0
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeToCompletionInSeconds) ?? 0
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressInMegaBytes) ?? 0
        progressInMegaBytes = progressInMegaBytesDecoded
        let snapshotSizeInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotSizeInMegaBytes) ?? 0
        snapshotSizeInMegaBytes = snapshotSizeInMegaBytesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the status of a cluster restore action. It only applies if the cluster was created by restoring a snapshot.
    public struct AwsRedshiftClusterRestoreStatus: Swift.Equatable {
        /// The number of megabytes per second being transferred from the backup storage. Returns the average rate for a completed backup. This field is only updated when you restore to DC2 and DS2 node types.
        public var currentRestoreRateInMegaBytesPerSecond: Swift.Double
        /// The amount of time an in-progress restore has been running, or the amount of time it took a completed restore to finish. This field is only updated when you restore to DC2 and DS2 node types.
        public var elapsedTimeInSeconds: Swift.Int
        /// The estimate of the time remaining before the restore is complete. Returns 0 for a completed restore. This field is only updated when you restore to DC2 and DS2 node types.
        public var estimatedTimeToCompletionInSeconds: Swift.Int
        /// The number of megabytes that were transferred from snapshot storage. This field is only updated when you restore to DC2 and DS2 node types.
        public var progressInMegaBytes: Swift.Int
        /// The size of the set of snapshot data that was used to restore the cluster. This field is only updated when you restore to DC2 and DS2 node types.
        public var snapshotSizeInMegaBytes: Swift.Int
        /// The status of the restore action. Valid values: starting | restoring | completed | failed
        public var status: Swift.String?

        public init (
            currentRestoreRateInMegaBytesPerSecond: Swift.Double = 0.0,
            elapsedTimeInSeconds: Swift.Int = 0,
            estimatedTimeToCompletionInSeconds: Swift.Int = 0,
            progressInMegaBytes: Swift.Int = 0,
            snapshotSizeInMegaBytes: Swift.Int = 0,
            status: Swift.String? = nil
        )
        {
            self.currentRestoreRateInMegaBytesPerSecond = currentRestoreRateInMegaBytesPerSecond
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSeconds
            self.progressInMegaBytes = progressInMegaBytes
            self.snapshotSizeInMegaBytes = snapshotSizeInMegaBytes
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsRedshiftClusterVpcSecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case vpcSecurityGroupId = "VpcSecurityGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let vpcSecurityGroupId = self.vpcSecurityGroupId {
            try encodeContainer.encode(vpcSecurityGroupId, forKey: .vpcSecurityGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let vpcSecurityGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcSecurityGroupId)
        vpcSecurityGroupId = vpcSecurityGroupIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// A VPC security group that the cluster belongs to, if the cluster is in a VPC.
    public struct AwsRedshiftClusterVpcSecurityGroup: Swift.Equatable {
        /// The status of the VPC security group.
        public var status: Swift.String?
        /// The identifier of the VPC security group.
        public var vpcSecurityGroupId: Swift.String?

        public init (
            status: Swift.String? = nil,
            vpcSecurityGroupId: Swift.String? = nil
        )
        {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }
    }

}

extension SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAcls = "BlockPublicAcls"
        case blockPublicPolicy = "BlockPublicPolicy"
        case ignorePublicAcls = "IgnorePublicAcls"
        case restrictPublicBuckets = "RestrictPublicBuckets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicAcls != false {
            try encodeContainer.encode(blockPublicAcls, forKey: .blockPublicAcls)
        }
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if ignorePublicAcls != false {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if restrictPublicBuckets != false {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicAcls) ?? false
        blockPublicAcls = blockPublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicPolicy) ?? false
        blockPublicPolicy = blockPublicPolicyDecoded
        let ignorePublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignorePublicAcls) ?? false
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restrictPublicBuckets) ?? false
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension SecurityHubClientTypes {
    /// provides information about the Amazon S3 Public Access Block configuration for accounts.
    public struct AwsS3AccountPublicAccessBlockDetails: Swift.Equatable {
        /// Indicates whether to reject calls to update an S3 bucket if the calls include a public access control list (ACL).
        public var blockPublicAcls: Swift.Bool
        /// Indicates whether to reject calls to update the access policy for an S3 bucket or access point if the policy allows public access.
        public var blockPublicPolicy: Swift.Bool
        /// Indicates whether Amazon S3 ignores public ACLs that are associated with an S3 bucket.
        public var ignorePublicAcls: Swift.Bool
        /// Indicates whether to restrict access to an access point or S3 bucket that has a public policy to only Amazon Web Services service principals and authorized users within the S3 bucket owner's account.
        public var restrictPublicBuckets: Swift.Bool

        public init (
            blockPublicAcls: Swift.Bool = false,
            blockPublicPolicy: Swift.Bool = false,
            ignorePublicAcls: Swift.Bool = false,
            restrictPublicBuckets: Swift.Bool = false
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for awss3bucketbucketlifecycleconfigurationrulesdetails0 in rules {
                try rulesContainer.encode(awss3bucketbucketlifecycleconfigurationrulesdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails?].self, forKey: .rules)
        var rulesDecoded0:[SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// The lifecycle configuration for the objects in the S3 bucket.
    public struct AwsS3BucketBucketLifecycleConfigurationDetails: Swift.Equatable {
        /// The lifecycle rules.
        public var rules: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails]?

        public init (
            rules: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case daysAfterInitiation = "DaysAfterInitiation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if daysAfterInitiation != 0 {
            try encodeContainer.encode(daysAfterInitiation, forKey: .daysAfterInitiation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysAfterInitiationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .daysAfterInitiation) ?? 0
        daysAfterInitiation = daysAfterInitiationDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about what Amazon S3 does when a multipart upload is incomplete.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails: Swift.Equatable {
        /// The number of days after which Amazon S3 cancels an incomplete multipart upload.
        public var daysAfterInitiation: Swift.Int

        public init (
            daysAfterInitiation: Swift.Int = 0
        )
        {
            self.daysAfterInitiation = daysAfterInitiation
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortIncompleteMultipartUpload = "AbortIncompleteMultipartUpload"
        case expirationDate = "ExpirationDate"
        case expirationInDays = "ExpirationInDays"
        case expiredObjectDeleteMarker = "ExpiredObjectDeleteMarker"
        case filter = "Filter"
        case id = "ID"
        case noncurrentVersionExpirationInDays = "NoncurrentVersionExpirationInDays"
        case noncurrentVersionTransitions = "NoncurrentVersionTransitions"
        case `prefix` = "Prefix"
        case status = "Status"
        case transitions = "Transitions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortIncompleteMultipartUpload = self.abortIncompleteMultipartUpload {
            try encodeContainer.encode(abortIncompleteMultipartUpload, forKey: .abortIncompleteMultipartUpload)
        }
        if let expirationDate = self.expirationDate {
            try encodeContainer.encode(expirationDate, forKey: .expirationDate)
        }
        if expirationInDays != 0 {
            try encodeContainer.encode(expirationInDays, forKey: .expirationInDays)
        }
        if expiredObjectDeleteMarker != false {
            try encodeContainer.encode(expiredObjectDeleteMarker, forKey: .expiredObjectDeleteMarker)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if noncurrentVersionExpirationInDays != 0 {
            try encodeContainer.encode(noncurrentVersionExpirationInDays, forKey: .noncurrentVersionExpirationInDays)
        }
        if let noncurrentVersionTransitions = noncurrentVersionTransitions {
            var noncurrentVersionTransitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .noncurrentVersionTransitions)
            for awss3bucketbucketlifecycleconfigurationrulesnoncurrentversiontransitionsdetails0 in noncurrentVersionTransitions {
                try noncurrentVersionTransitionsContainer.encode(awss3bucketbucketlifecycleconfigurationrulesnoncurrentversiontransitionsdetails0)
            }
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let transitions = transitions {
            var transitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .transitions)
            for awss3bucketbucketlifecycleconfigurationrulestransitionsdetails0 in transitions {
                try transitionsContainer.encode(awss3bucketbucketlifecycleconfigurationrulestransitionsdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let abortIncompleteMultipartUploadDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails.self, forKey: .abortIncompleteMultipartUpload)
        abortIncompleteMultipartUpload = abortIncompleteMultipartUploadDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let expirationInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationInDays) ?? 0
        expirationInDays = expirationInDaysDecoded
        let expiredObjectDeleteMarkerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .expiredObjectDeleteMarker) ?? false
        expiredObjectDeleteMarker = expiredObjectDeleteMarkerDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails.self, forKey: .filter)
        filter = filterDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let noncurrentVersionExpirationInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .noncurrentVersionExpirationInDays) ?? 0
        noncurrentVersionExpirationInDays = noncurrentVersionExpirationInDaysDecoded
        let noncurrentVersionTransitionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails?].self, forKey: .noncurrentVersionTransitions)
        var noncurrentVersionTransitionsDecoded0:[SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]? = nil
        if let noncurrentVersionTransitionsContainer = noncurrentVersionTransitionsContainer {
            noncurrentVersionTransitionsDecoded0 = [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]()
            for structure0 in noncurrentVersionTransitionsContainer {
                if let structure0 = structure0 {
                    noncurrentVersionTransitionsDecoded0?.append(structure0)
                }
            }
        }
        noncurrentVersionTransitions = noncurrentVersionTransitionsDecoded0
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let transitionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails?].self, forKey: .transitions)
        var transitionsDecoded0:[SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]? = nil
        if let transitionsContainer = transitionsContainer {
            transitionsDecoded0 = [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]()
            for structure0 in transitionsContainer {
                if let structure0 = structure0 {
                    transitionsDecoded0?.append(structure0)
                }
            }
        }
        transitions = transitionsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Configuration for a lifecycle rule.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesDetails: Swift.Equatable {
        /// How Amazon S3 responds when a multipart upload is incomplete. Specifically, provides a number of days before Amazon S3 cancels the entire upload.
        public var abortIncompleteMultipartUpload: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails?
        /// The date when objects are moved or deleted. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var expirationDate: Swift.String?
        /// The length in days of the lifetime for objects that are subject to the rule.
        public var expirationInDays: Swift.Int
        /// Whether Amazon S3 removes a delete marker that has no noncurrent versions. If set to true, the delete marker is expired. If set to false, the policy takes no action. If you provide ExpiredObjectDeleteMarker, you cannot provide ExpirationInDays or ExpirationDate.
        public var expiredObjectDeleteMarker: Swift.Bool
        /// Identifies the objects that a rule applies to.
        public var filter: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails?
        /// The unique identifier of the rule.
        public var id: Swift.String?
        /// The number of days that an object is noncurrent before Amazon S3 can perform the associated action.
        public var noncurrentVersionExpirationInDays: Swift.Int
        /// Transition rules that describe when noncurrent objects transition to a specified storage class.
        public var noncurrentVersionTransitions: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]?
        /// A prefix that identifies one or more objects that the rule applies to.
        public var `prefix`: Swift.String?
        /// The current status of the rule. Indicates whether the rule is currently being applied.
        public var status: Swift.String?
        /// Transition rules that indicate when objects transition to a specified storage class.
        public var transitions: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]?

        public init (
            abortIncompleteMultipartUpload: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails? = nil,
            expirationDate: Swift.String? = nil,
            expirationInDays: Swift.Int = 0,
            expiredObjectDeleteMarker: Swift.Bool = false,
            filter: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails? = nil,
            id: Swift.String? = nil,
            noncurrentVersionExpirationInDays: Swift.Int = 0,
            noncurrentVersionTransitions: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails]? = nil,
            `prefix`: Swift.String? = nil,
            status: Swift.String? = nil,
            transitions: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails]? = nil
        )
        {
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.expirationDate = expirationDate
            self.expirationInDays = expirationInDays
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
            self.filter = filter
            self.id = id
            self.noncurrentVersionExpirationInDays = noncurrentVersionExpirationInDays
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
            self.`prefix` = `prefix`
            self.status = status
            self.transitions = transitions
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case predicate = "Predicate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predicate = self.predicate {
            try encodeContainer.encode(predicate, forKey: .predicate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predicateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails.self, forKey: .predicate)
        predicate = predicateDecoded
    }
}

extension SecurityHubClientTypes {
    /// Identifies the objects that a rule applies to.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails: Swift.Equatable {
        /// The configuration for the filter.
        public var predicate: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails?

        public init (
            predicate: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails? = nil
        )
        {
            self.predicate = predicate
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operands = "Operands"
        case `prefix` = "Prefix"
        case tag = "Tag"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operands = operands {
            var operandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operands)
            for awss3bucketbucketlifecycleconfigurationrulesfilterpredicateoperandsdetails0 in operands {
                try operandsContainer.encode(awss3bucketbucketlifecycleconfigurationrulesfilterpredicateoperandsdetails0)
            }
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let tag = self.tag {
            try encodeContainer.encode(tag, forKey: .tag)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operandsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails?].self, forKey: .operands)
        var operandsDecoded0:[SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]? = nil
        if let operandsContainer = operandsContainer {
            operandsDecoded0 = [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]()
            for structure0 in operandsContainer {
                if let structure0 = structure0 {
                    operandsDecoded0?.append(structure0)
                }
            }
        }
        operands = operandsDecoded0
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let tagDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails.self, forKey: .tag)
        tag = tagDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// The configuration for the filter.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails: Swift.Equatable {
        /// The values to use for the filter.
        public var operands: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]?
        /// A prefix filter.
        public var `prefix`: Swift.String?
        /// A tag filter.
        public var tag: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails?
        /// Whether to use AND or OR to join the operands. Valid values are LifecycleAndOperator or LifecycleOrOperator.
        public var type: Swift.String?

        public init (
            operands: [SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails]? = nil,
            `prefix`: Swift.String? = nil,
            tag: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails? = nil,
            type: Swift.String? = nil
        )
        {
            self.operands = operands
            self.`prefix` = `prefix`
            self.tag = tag
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `prefix` = "Prefix"
        case tag = "Tag"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let tag = self.tag {
            try encodeContainer.encode(tag, forKey: .tag)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let tagDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails.self, forKey: .tag)
        tag = tagDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A value to use for the filter.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails: Swift.Equatable {
        /// Prefix text for matching objects.
        public var `prefix`: Swift.String?
        /// A tag that is assigned to matching objects.
        public var tag: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails?
        /// The type of filter value. Valid values are LifecyclePrefixPredicate or LifecycleTagPredicate.
        public var type: Swift.String?

        public init (
            `prefix`: Swift.String? = nil,
            tag: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails? = nil,
            type: Swift.String? = nil
        )
        {
            self.`prefix` = `prefix`
            self.tag = tag
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A tag that is assigned to matching objects.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails: Swift.Equatable {
        /// The tag key.
        public var key: Swift.String?
        /// The tag value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A tag filter.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails: Swift.Equatable {
        /// The tag key.
        public var key: Swift.String?
        /// The tag value
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case days = "Days"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if days != 0 {
            try encodeContainer.encode(days, forKey: .days)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass, forKey: .storageClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let daysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .days) ?? 0
        days = daysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension SecurityHubClientTypes {
    /// A transition rule that describes when noncurrent objects transition to a specified storage class.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails: Swift.Equatable {
        /// The number of days that an object is noncurrent before Amazon S3 can perform the associated action.
        public var days: Swift.Int
        /// The class of storage to change the object to after the object is noncurrent for the specified number of days.
        public var storageClass: Swift.String?

        public init (
            days: Swift.Int = 0,
            storageClass: Swift.String? = nil
        )
        {
            self.days = days
            self.storageClass = storageClass
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case date = "Date"
        case days = "Days"
        case storageClass = "StorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = self.date {
            try encodeContainer.encode(date, forKey: .date)
        }
        if days != 0 {
            try encodeContainer.encode(days, forKey: .days)
        }
        if let storageClass = self.storageClass {
            try encodeContainer.encode(storageClass, forKey: .storageClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .date)
        date = dateDecoded
        let daysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .days) ?? 0
        days = daysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageClass)
        storageClass = storageClassDecoded
    }
}

extension SecurityHubClientTypes {
    /// A rule for when objects transition to specific storage classes.
    public struct AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails: Swift.Equatable {
        /// A date on which to transition objects to the specified storage class. If you provide Date, you cannot provide Days. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var date: Swift.String?
        /// The number of days after which to transition the object to the specified storage class. If you provide Days, you cannot provide Date.
        public var days: Swift.Int
        /// The storage class to transition the object to. Valid values are as follows:
        ///
        /// * DEEP_ARCHIVE
        ///
        /// * GLACIER
        ///
        /// * INTELLIGENT_TIERING
        ///
        /// * ONEZONE_IA
        ///
        /// * STANDARD_IA
        public var storageClass: Swift.String?

        public init (
            date: Swift.String? = nil,
            days: Swift.Int = 0,
            storageClass: Swift.String? = nil
        )
        {
            self.date = date
            self.days = days
            self.storageClass = storageClass
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isMfaDeleteEnabled = "IsMfaDeleteEnabled"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isMfaDeleteEnabled != false {
            try encodeContainer.encode(isMfaDeleteEnabled, forKey: .isMfaDeleteEnabled)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isMfaDeleteEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMfaDeleteEnabled) ?? false
        isMfaDeleteEnabled = isMfaDeleteEnabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Describes the versioning state of an S3 bucket.
    public struct AwsS3BucketBucketVersioningConfiguration: Swift.Equatable {
        /// Specifies whether MFA delete is currently enabled in the S3 bucket versioning configuration. If the S3 bucket was never configured with MFA delete, then this attribute is not included.
        public var isMfaDeleteEnabled: Swift.Bool
        /// The versioning status of the S3 bucket. Valid values are Enabled or Suspended.
        public var status: Swift.String?

        public init (
            isMfaDeleteEnabled: Swift.Bool = false,
            status: Swift.String? = nil
        )
        {
            self.isMfaDeleteEnabled = isMfaDeleteEnabled
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "AccessControlList"
        case bucketLifecycleConfiguration = "BucketLifecycleConfiguration"
        case bucketLoggingConfiguration = "BucketLoggingConfiguration"
        case bucketNotificationConfiguration = "BucketNotificationConfiguration"
        case bucketVersioningConfiguration = "BucketVersioningConfiguration"
        case bucketWebsiteConfiguration = "BucketWebsiteConfiguration"
        case createdAt = "CreatedAt"
        case ownerAccountId = "OwnerAccountId"
        case ownerId = "OwnerId"
        case ownerName = "OwnerName"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = self.accessControlList {
            try encodeContainer.encode(accessControlList, forKey: .accessControlList)
        }
        if let bucketLifecycleConfiguration = self.bucketLifecycleConfiguration {
            try encodeContainer.encode(bucketLifecycleConfiguration, forKey: .bucketLifecycleConfiguration)
        }
        if let bucketLoggingConfiguration = self.bucketLoggingConfiguration {
            try encodeContainer.encode(bucketLoggingConfiguration, forKey: .bucketLoggingConfiguration)
        }
        if let bucketNotificationConfiguration = self.bucketNotificationConfiguration {
            try encodeContainer.encode(bucketNotificationConfiguration, forKey: .bucketNotificationConfiguration)
        }
        if let bucketVersioningConfiguration = self.bucketVersioningConfiguration {
            try encodeContainer.encode(bucketVersioningConfiguration, forKey: .bucketVersioningConfiguration)
        }
        if let bucketWebsiteConfiguration = self.bucketWebsiteConfiguration {
            try encodeContainer.encode(bucketWebsiteConfiguration, forKey: .bucketWebsiteConfiguration)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let ownerName = self.ownerName {
            try encodeContainer.encode(ownerName, forKey: .ownerName)
        }
        if let publicAccessBlockConfiguration = self.publicAccessBlockConfiguration {
            try encodeContainer.encode(publicAccessBlockConfiguration, forKey: .publicAccessBlockConfiguration)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let ownerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerName)
        ownerName = ownerNameDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let bucketLifecycleConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails.self, forKey: .bucketLifecycleConfiguration)
        bucketLifecycleConfiguration = bucketLifecycleConfigurationDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let accessControlListDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let bucketLoggingConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketLoggingConfiguration.self, forKey: .bucketLoggingConfiguration)
        bucketLoggingConfiguration = bucketLoggingConfigurationDecoded
        let bucketWebsiteConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration.self, forKey: .bucketWebsiteConfiguration)
        bucketWebsiteConfiguration = bucketWebsiteConfigurationDecoded
        let bucketNotificationConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketNotificationConfiguration.self, forKey: .bucketNotificationConfiguration)
        bucketNotificationConfiguration = bucketNotificationConfigurationDecoded
        let bucketVersioningConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration.self, forKey: .bucketVersioningConfiguration)
        bucketVersioningConfiguration = bucketVersioningConfigurationDecoded
    }
}

extension SecurityHubClientTypes {
    /// The details of an Amazon S3 bucket.
    public struct AwsS3BucketDetails: Swift.Equatable {
        /// The access control list for the S3 bucket.
        public var accessControlList: Swift.String?
        /// The lifecycle configuration for objects in the S3 bucket.
        public var bucketLifecycleConfiguration: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails?
        /// The logging configuration for the S3 bucket.
        public var bucketLoggingConfiguration: SecurityHubClientTypes.AwsS3BucketLoggingConfiguration?
        /// The notification configuration for the S3 bucket.
        public var bucketNotificationConfiguration: SecurityHubClientTypes.AwsS3BucketNotificationConfiguration?
        /// The versioning state of an S3 bucket.
        public var bucketVersioningConfiguration: SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration?
        /// The website configuration parameters for the S3 bucket.
        public var bucketWebsiteConfiguration: SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration?
        /// Indicates when the S3 bucket was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var createdAt: Swift.String?
        /// The Amazon Web Services account identifier of the account that owns the S3 bucket.
        public var ownerAccountId: Swift.String?
        /// The canonical user ID of the owner of the S3 bucket.
        public var ownerId: Swift.String?
        /// The display name of the owner of the S3 bucket.
        public var ownerName: Swift.String?
        /// Provides information about the Amazon S3 Public Access Block configuration for the S3 bucket.
        public var publicAccessBlockConfiguration: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails?
        /// The encryption rules that are applied to the S3 bucket.
        public var serverSideEncryptionConfiguration: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration?

        public init (
            accessControlList: Swift.String? = nil,
            bucketLifecycleConfiguration: SecurityHubClientTypes.AwsS3BucketBucketLifecycleConfigurationDetails? = nil,
            bucketLoggingConfiguration: SecurityHubClientTypes.AwsS3BucketLoggingConfiguration? = nil,
            bucketNotificationConfiguration: SecurityHubClientTypes.AwsS3BucketNotificationConfiguration? = nil,
            bucketVersioningConfiguration: SecurityHubClientTypes.AwsS3BucketBucketVersioningConfiguration? = nil,
            bucketWebsiteConfiguration: SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration? = nil,
            createdAt: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            ownerName: Swift.String? = nil,
            publicAccessBlockConfiguration: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails? = nil,
            serverSideEncryptionConfiguration: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration? = nil
        )
        {
            self.accessControlList = accessControlList
            self.bucketLifecycleConfiguration = bucketLifecycleConfiguration
            self.bucketLoggingConfiguration = bucketLoggingConfiguration
            self.bucketNotificationConfiguration = bucketNotificationConfiguration
            self.bucketVersioningConfiguration = bucketVersioningConfiguration
            self.bucketWebsiteConfiguration = bucketWebsiteConfiguration
            self.createdAt = createdAt
            self.ownerAccountId = ownerAccountId
            self.ownerId = ownerId
            self.ownerName = ownerName
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketLoggingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationBucketName = "DestinationBucketName"
        case logFilePrefix = "LogFilePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationBucketName = self.destinationBucketName {
            try encodeContainer.encode(destinationBucketName, forKey: .destinationBucketName)
        }
        if let logFilePrefix = self.logFilePrefix {
            try encodeContainer.encode(logFilePrefix, forKey: .logFilePrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationBucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationBucketName)
        destinationBucketName = destinationBucketNameDecoded
        let logFilePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logFilePrefix)
        logFilePrefix = logFilePrefixDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about logging for the S3 bucket
    public struct AwsS3BucketLoggingConfiguration: Swift.Equatable {
        /// The name of the S3 bucket where log files for the S3 bucket are stored.
        public var destinationBucketName: Swift.String?
        /// The prefix added to log files for the S3 bucket.
        public var logFilePrefix: Swift.String?

        public init (
            destinationBucketName: Swift.String? = nil,
            logFilePrefix: Swift.String? = nil
        )
        {
            self.destinationBucketName = destinationBucketName
            self.logFilePrefix = logFilePrefix
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurations = "Configurations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurations)
            for awss3bucketnotificationconfigurationdetail0 in configurations {
                try configurationsContainer.encode(awss3bucketnotificationconfigurationdetail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail?].self, forKey: .configurations)
        var configurationsDecoded0:[SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// The notification configuration for the S3 bucket.
    public struct AwsS3BucketNotificationConfiguration: Swift.Equatable {
        /// Configurations for S3 bucket notifications.
        public var configurations: [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail]?

        public init (
            configurations: [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail]? = nil
        )
        {
            self.configurations = configurations
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfigurationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case events = "Events"
        case filter = "Filter"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for nonemptystring0 in events {
                try eventsContainer.encode(nonemptystring0)
            }
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .events)
        var eventsDecoded0:[Swift.String]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Swift.String]()
            for string0 in eventsContainer {
                if let string0 = string0 {
                    eventsDecoded0?.append(string0)
                }
            }
        }
        events = eventsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter.self, forKey: .filter)
        filter = filterDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details for an S3 bucket notification configuration.
    public struct AwsS3BucketNotificationConfigurationDetail: Swift.Equatable {
        /// The ARN of the Lambda function, Amazon SQS queue, or Amazon SNS topic that generates the notification.
        public var destination: Swift.String?
        /// The list of events that trigger a notification.
        public var events: [Swift.String]?
        /// The filters that determine which S3 buckets generate notifications.
        public var filter: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter?
        /// Indicates the type of notification. Notifications can be generated using Lambda functions, Amazon SQS queues, or Amazon SNS topics, with corresponding valid values as follows:
        ///
        /// * LambdaConfiguration
        ///
        /// * QueueConfiguration
        ///
        /// * TopicConfiguration
        public var type: Swift.String?

        public init (
            destination: Swift.String? = nil,
            events: [Swift.String]? = nil,
            filter: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter? = nil,
            type: Swift.String? = nil
        )
        {
            self.destination = destination
            self.events = events
            self.filter = filter
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfigurationFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3KeyFilter = "S3KeyFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3KeyFilter = self.s3KeyFilter {
            try encodeContainer.encode(s3KeyFilter, forKey: .s3KeyFilter)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3KeyFilterDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter.self, forKey: .s3KeyFilter)
        s3KeyFilter = s3KeyFilterDecoded
    }
}

extension SecurityHubClientTypes {
    /// Filtering information for the notifications. The filtering is based on Amazon S3 key names.
    public struct AwsS3BucketNotificationConfigurationFilter: Swift.Equatable {
        /// Details for an Amazon S3 filter.
        public var s3KeyFilter: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter?

        public init (
            s3KeyFilter: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter? = nil
        )
        {
            self.s3KeyFilter = s3KeyFilter
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterRules = "FilterRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterRules = filterRules {
            var filterRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterRules)
            for awss3bucketnotificationconfigurations3keyfilterrule0 in filterRules {
                try filterRulesContainer.encode(awss3bucketnotificationconfigurations3keyfilterrule0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterRulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule?].self, forKey: .filterRules)
        var filterRulesDecoded0:[SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule]? = nil
        if let filterRulesContainer = filterRulesContainer {
            filterRulesDecoded0 = [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule]()
            for structure0 in filterRulesContainer {
                if let structure0 = structure0 {
                    filterRulesDecoded0?.append(structure0)
                }
            }
        }
        filterRules = filterRulesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Details for an Amazon S3 filter.
    public struct AwsS3BucketNotificationConfigurationS3KeyFilter: Swift.Equatable {
        /// The filter rules for the filter.
        public var filterRules: [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule]?

        public init (
            filterRules: [SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule]? = nil
        )
        {
            self.filterRules = filterRules
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRuleName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details for a filter rule.
    public struct AwsS3BucketNotificationConfigurationS3KeyFilterRule: Swift.Equatable {
        /// Indicates whether the filter is based on the prefix or suffix of the Amazon S3 key.
        public var name: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRuleName?
        /// The filter value.
        public var value: Swift.String?

        public init (
            name: SecurityHubClientTypes.AwsS3BucketNotificationConfigurationS3KeyFilterRuleName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    public enum AwsS3BucketNotificationConfigurationS3KeyFilterRuleName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `prefix`
        case suffix
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsS3BucketNotificationConfigurationS3KeyFilterRuleName] {
            return [
                .prefix,
                .suffix,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .prefix: return "Prefix"
            case .suffix: return "Suffix"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsS3BucketNotificationConfigurationS3KeyFilterRuleName(rawValue: rawValue) ?? AwsS3BucketNotificationConfigurationS3KeyFilterRuleName.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsMasterKeyID = "KMSMasterKeyID"
        case sseAlgorithm = "SSEAlgorithm"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsMasterKeyID = self.kmsMasterKeyID {
            try encodeContainer.encode(kmsMasterKeyID, forKey: .kmsMasterKeyID)
        }
        if let sseAlgorithm = self.sseAlgorithm {
            try encodeContainer.encode(sseAlgorithm, forKey: .sseAlgorithm)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sseAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sseAlgorithm)
        sseAlgorithm = sseAlgorithmDecoded
        let kmsMasterKeyIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyID)
        kmsMasterKeyID = kmsMasterKeyIDDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies the default server-side encryption to apply to new objects in the bucket.
    public struct AwsS3BucketServerSideEncryptionByDefault: Swift.Equatable {
        /// KMS key ID to use for the default encryption.
        public var kmsMasterKeyID: Swift.String?
        /// Server-side encryption algorithm to use for the default encryption. Valid values are aws: kms or AES256.
        public var sseAlgorithm: Swift.String?

        public init (
            kmsMasterKeyID: Swift.String? = nil,
            sseAlgorithm: Swift.String? = nil
        )
        {
            self.kmsMasterKeyID = kmsMasterKeyID
            self.sseAlgorithm = sseAlgorithm
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for awss3bucketserversideencryptionrule0 in rules {
                try rulesContainer.encode(awss3bucketserversideencryptionrule0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule?].self, forKey: .rules)
        var rulesDecoded0:[SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// The encryption configuration for the S3 bucket.
    public struct AwsS3BucketServerSideEncryptionConfiguration: Swift.Equatable {
        /// The encryption rules that are applied to the S3 bucket.
        public var rules: [SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule]?

        public init (
            rules: [SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketServerSideEncryptionRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyServerSideEncryptionByDefault = "ApplyServerSideEncryptionByDefault"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyServerSideEncryptionByDefault = self.applyServerSideEncryptionByDefault {
            try encodeContainer.encode(applyServerSideEncryptionByDefault, forKey: .applyServerSideEncryptionByDefault)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applyServerSideEncryptionByDefaultDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault.self, forKey: .applyServerSideEncryptionByDefault)
        applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefaultDecoded
    }
}

extension SecurityHubClientTypes {
    /// An encryption rule to apply to the S3 bucket.
    public struct AwsS3BucketServerSideEncryptionRule: Swift.Equatable {
        /// Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT object request doesn't specify any server-side encryption, this default encryption is applied.
        public var applyServerSideEncryptionByDefault: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault?

        public init (
            applyServerSideEncryptionByDefault: SecurityHubClientTypes.AwsS3BucketServerSideEncryptionByDefault? = nil
        )
        {
            self.applyServerSideEncryptionByDefault = applyServerSideEncryptionByDefault
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDocument = "ErrorDocument"
        case indexDocumentSuffix = "IndexDocumentSuffix"
        case redirectAllRequestsTo = "RedirectAllRequestsTo"
        case routingRules = "RoutingRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorDocument = self.errorDocument {
            try encodeContainer.encode(errorDocument, forKey: .errorDocument)
        }
        if let indexDocumentSuffix = self.indexDocumentSuffix {
            try encodeContainer.encode(indexDocumentSuffix, forKey: .indexDocumentSuffix)
        }
        if let redirectAllRequestsTo = self.redirectAllRequestsTo {
            try encodeContainer.encode(redirectAllRequestsTo, forKey: .redirectAllRequestsTo)
        }
        if let routingRules = routingRules {
            var routingRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingRules)
            for awss3bucketwebsiteconfigurationroutingrule0 in routingRules {
                try routingRulesContainer.encode(awss3bucketwebsiteconfigurationroutingrule0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorDocument)
        errorDocument = errorDocumentDecoded
        let indexDocumentSuffixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .indexDocumentSuffix)
        indexDocumentSuffix = indexDocumentSuffixDecoded
        let redirectAllRequestsToDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo.self, forKey: .redirectAllRequestsTo)
        redirectAllRequestsTo = redirectAllRequestsToDecoded
        let routingRulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule?].self, forKey: .routingRules)
        var routingRulesDecoded0:[SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule]? = nil
        if let routingRulesContainer = routingRulesContainer {
            routingRulesDecoded0 = [SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule]()
            for structure0 in routingRulesContainer {
                if let structure0 = structure0 {
                    routingRulesDecoded0?.append(structure0)
                }
            }
        }
        routingRules = routingRulesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Website parameters for the S3 bucket.
    public struct AwsS3BucketWebsiteConfiguration: Swift.Equatable {
        /// The name of the error document for the website.
        public var errorDocument: Swift.String?
        /// The name of the index document for the website.
        public var indexDocumentSuffix: Swift.String?
        /// The redirect behavior for requests to the website.
        public var redirectAllRequestsTo: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo?
        /// The rules for applying redirects for requests to the website.
        public var routingRules: [SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule]?

        public init (
            errorDocument: Swift.String? = nil,
            indexDocumentSuffix: Swift.String? = nil,
            redirectAllRequestsTo: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo? = nil,
            routingRules: [SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule]? = nil
        )
        {
            self.errorDocument = errorDocument
            self.indexDocumentSuffix = indexDocumentSuffix
            self.redirectAllRequestsTo = redirectAllRequestsTo
            self.routingRules = routingRules
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRedirectTo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension SecurityHubClientTypes {
    /// The redirect behavior for requests to the website.
    public struct AwsS3BucketWebsiteConfigurationRedirectTo: Swift.Equatable {
        /// The name of the host to redirect requests to.
        public var hostname: Swift.String?
        /// The protocol to use when redirecting requests. By default, this field uses the same protocol as the original request. Valid values are http or https.
        public var `protocol`: Swift.String?

        public init (
            hostname: Swift.String? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.`protocol` = `protocol`
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition = "Condition"
        case redirect = "Redirect"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let redirect = self.redirect {
            try encodeContainer.encode(redirect, forKey: .redirect)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition.self, forKey: .condition)
        condition = conditionDecoded
        let redirectDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect.self, forKey: .redirect)
        redirect = redirectDecoded
    }
}

extension SecurityHubClientTypes {
    /// A rule for redirecting requests to the website.
    public struct AwsS3BucketWebsiteConfigurationRoutingRule: Swift.Equatable {
        /// Provides the condition that must be met in order to apply the routing rule.
        public var condition: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition?
        /// Provides the rules to redirect the request if the condition in Condition is met.
        public var redirect: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect?

        public init (
            condition: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition? = nil,
            redirect: SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect? = nil
        )
        {
            self.condition = condition
            self.redirect = redirect
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpErrorCodeReturnedEquals = "HttpErrorCodeReturnedEquals"
        case keyPrefixEquals = "KeyPrefixEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpErrorCodeReturnedEquals = self.httpErrorCodeReturnedEquals {
            try encodeContainer.encode(httpErrorCodeReturnedEquals, forKey: .httpErrorCodeReturnedEquals)
        }
        if let keyPrefixEquals = self.keyPrefixEquals {
            try encodeContainer.encode(keyPrefixEquals, forKey: .keyPrefixEquals)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpErrorCodeReturnedEqualsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpErrorCodeReturnedEquals)
        httpErrorCodeReturnedEquals = httpErrorCodeReturnedEqualsDecoded
        let keyPrefixEqualsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefixEquals)
        keyPrefixEquals = keyPrefixEqualsDecoded
    }
}

extension SecurityHubClientTypes {
    /// The condition that must be met in order to apply the routing rule.
    public struct AwsS3BucketWebsiteConfigurationRoutingRuleCondition: Swift.Equatable {
        /// Indicates to redirect the request if the HTTP error code matches this value.
        public var httpErrorCodeReturnedEquals: Swift.String?
        /// Indicates to redirect the request if the key prefix matches this value.
        public var keyPrefixEquals: Swift.String?

        public init (
            httpErrorCodeReturnedEquals: Swift.String? = nil,
            keyPrefixEquals: Swift.String? = nil
        )
        {
            self.httpErrorCodeReturnedEquals = httpErrorCodeReturnedEquals
            self.keyPrefixEquals = keyPrefixEquals
        }
    }

}

extension SecurityHubClientTypes.AwsS3BucketWebsiteConfigurationRoutingRuleRedirect: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostname = "Hostname"
        case httpRedirectCode = "HttpRedirectCode"
        case `protocol` = "Protocol"
        case replaceKeyPrefixWith = "ReplaceKeyPrefixWith"
        case replaceKeyWith = "ReplaceKeyWith"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let httpRedirectCode = self.httpRedirectCode {
            try encodeContainer.encode(httpRedirectCode, forKey: .httpRedirectCode)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let replaceKeyPrefixWith = self.replaceKeyPrefixWith {
            try encodeContainer.encode(replaceKeyPrefixWith, forKey: .replaceKeyPrefixWith)
        }
        if let replaceKeyWith = self.replaceKeyWith {
            try encodeContainer.encode(replaceKeyWith, forKey: .replaceKeyWith)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let httpRedirectCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpRedirectCode)
        httpRedirectCode = httpRedirectCodeDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let replaceKeyPrefixWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceKeyPrefixWith)
        replaceKeyPrefixWith = replaceKeyPrefixWithDecoded
        let replaceKeyWithDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replaceKeyWith)
        replaceKeyWith = replaceKeyWithDecoded
    }
}

extension SecurityHubClientTypes {
    /// The rules to redirect the request if the condition in Condition is met.
    public struct AwsS3BucketWebsiteConfigurationRoutingRuleRedirect: Swift.Equatable {
        /// The host name to use in the redirect request.
        public var hostname: Swift.String?
        /// The HTTP redirect code to use in the response.
        public var httpRedirectCode: Swift.String?
        /// The protocol to use to redirect the request. By default, uses the protocol from the original request.
        public var `protocol`: Swift.String?
        /// The object key prefix to use in the redirect request. Cannot be provided if ReplaceKeyWith is present.
        public var replaceKeyPrefixWith: Swift.String?
        /// The specific object key to use in the redirect request. Cannot be provided if ReplaceKeyPrefixWith is present.
        public var replaceKeyWith: Swift.String?

        public init (
            hostname: Swift.String? = nil,
            httpRedirectCode: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            replaceKeyPrefixWith: Swift.String? = nil,
            replaceKeyWith: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.httpRedirectCode = httpRedirectCode
            self.`protocol` = `protocol`
            self.replaceKeyPrefixWith = replaceKeyPrefixWith
            self.replaceKeyWith = replaceKeyWith
        }
    }

}

extension SecurityHubClientTypes.AwsS3ObjectDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType = "ContentType"
        case eTag = "ETag"
        case lastModified = "LastModified"
        case ssekmsKeyId = "SSEKMSKeyId"
        case serverSideEncryption = "ServerSideEncryption"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let eTag = self.eTag {
            try encodeContainer.encode(eTag, forKey: .eTag)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let ssekmsKeyId = self.ssekmsKeyId {
            try encodeContainer.encode(ssekmsKeyId, forKey: .ssekmsKeyId)
        }
        if let serverSideEncryption = self.serverSideEncryption {
            try encodeContainer.encode(serverSideEncryption, forKey: .serverSideEncryption)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let eTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eTag)
        eTag = eTagDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let serverSideEncryptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverSideEncryption)
        serverSideEncryption = serverSideEncryptionDecoded
        let ssekmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssekmsKeyId)
        ssekmsKeyId = ssekmsKeyIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an Amazon S3 object.
    public struct AwsS3ObjectDetails: Swift.Equatable {
        /// A standard MIME type describing the format of the object data.
        public var contentType: Swift.String?
        /// The opaque identifier assigned by a web server to a specific version of a resource found at a URL.
        public var eTag: Swift.String?
        /// Indicates when the object was last modified. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastModified: Swift.String?
        /// If the object is stored using server-side encryption, the value of the server-side encryption algorithm used when storing this object in Amazon S3.
        public var serverSideEncryption: Swift.String?
        /// The identifier of the KMS symmetric customer managed key that was used for the object.
        public var ssekmsKeyId: Swift.String?
        /// The version of the object.
        public var versionId: Swift.String?

        public init (
            contentType: Swift.String? = nil,
            eTag: Swift.String? = nil,
            lastModified: Swift.String? = nil,
            serverSideEncryption: Swift.String? = nil,
            ssekmsKeyId: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.eTag = eTag
            self.lastModified = lastModified
            self.serverSideEncryption = serverSideEncryption
            self.ssekmsKeyId = ssekmsKeyId
            self.versionId = versionId
        }
    }

}

extension SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorTypes = "AcceleratorTypes"
        case additionalCodeRepositories = "AdditionalCodeRepositories"
        case defaultCodeRepository = "DefaultCodeRepository"
        case directInternetAccess = "DirectInternetAccess"
        case failureReason = "FailureReason"
        case instanceMetadataServiceConfiguration = "InstanceMetadataServiceConfiguration"
        case instanceType = "InstanceType"
        case kmsKeyId = "KmsKeyId"
        case networkInterfaceId = "NetworkInterfaceId"
        case notebookInstanceArn = "NotebookInstanceArn"
        case notebookInstanceLifecycleConfigName = "NotebookInstanceLifecycleConfigName"
        case notebookInstanceName = "NotebookInstanceName"
        case notebookInstanceStatus = "NotebookInstanceStatus"
        case platformIdentifier = "PlatformIdentifier"
        case roleArn = "RoleArn"
        case rootAccess = "RootAccess"
        case securityGroups = "SecurityGroups"
        case subnetId = "SubnetId"
        case url = "Url"
        case volumeSizeInGB = "VolumeSizeInGB"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceleratorTypes = acceleratorTypes {
            var acceleratorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceleratorTypes)
            for nonemptystring0 in acceleratorTypes {
                try acceleratorTypesContainer.encode(nonemptystring0)
            }
        }
        if let additionalCodeRepositories = additionalCodeRepositories {
            var additionalCodeRepositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalCodeRepositories)
            for nonemptystring0 in additionalCodeRepositories {
                try additionalCodeRepositoriesContainer.encode(nonemptystring0)
            }
        }
        if let defaultCodeRepository = self.defaultCodeRepository {
            try encodeContainer.encode(defaultCodeRepository, forKey: .defaultCodeRepository)
        }
        if let directInternetAccess = self.directInternetAccess {
            try encodeContainer.encode(directInternetAccess, forKey: .directInternetAccess)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let instanceMetadataServiceConfiguration = self.instanceMetadataServiceConfiguration {
            try encodeContainer.encode(instanceMetadataServiceConfiguration, forKey: .instanceMetadataServiceConfiguration)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let notebookInstanceArn = self.notebookInstanceArn {
            try encodeContainer.encode(notebookInstanceArn, forKey: .notebookInstanceArn)
        }
        if let notebookInstanceLifecycleConfigName = self.notebookInstanceLifecycleConfigName {
            try encodeContainer.encode(notebookInstanceLifecycleConfigName, forKey: .notebookInstanceLifecycleConfigName)
        }
        if let notebookInstanceName = self.notebookInstanceName {
            try encodeContainer.encode(notebookInstanceName, forKey: .notebookInstanceName)
        }
        if let notebookInstanceStatus = self.notebookInstanceStatus {
            try encodeContainer.encode(notebookInstanceStatus, forKey: .notebookInstanceStatus)
        }
        if let platformIdentifier = self.platformIdentifier {
            try encodeContainer.encode(platformIdentifier, forKey: .platformIdentifier)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let rootAccess = self.rootAccess {
            try encodeContainer.encode(rootAccess, forKey: .rootAccess)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for nonemptystring0 in securityGroups {
                try securityGroupsContainer.encode(nonemptystring0)
            }
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if volumeSizeInGB != 0 {
            try encodeContainer.encode(volumeSizeInGB, forKey: .volumeSizeInGB)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceleratorTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .acceleratorTypes)
        var acceleratorTypesDecoded0:[Swift.String]? = nil
        if let acceleratorTypesContainer = acceleratorTypesContainer {
            acceleratorTypesDecoded0 = [Swift.String]()
            for string0 in acceleratorTypesContainer {
                if let string0 = string0 {
                    acceleratorTypesDecoded0?.append(string0)
                }
            }
        }
        acceleratorTypes = acceleratorTypesDecoded0
        let additionalCodeRepositoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalCodeRepositories)
        var additionalCodeRepositoriesDecoded0:[Swift.String]? = nil
        if let additionalCodeRepositoriesContainer = additionalCodeRepositoriesContainer {
            additionalCodeRepositoriesDecoded0 = [Swift.String]()
            for string0 in additionalCodeRepositoriesContainer {
                if let string0 = string0 {
                    additionalCodeRepositoriesDecoded0?.append(string0)
                }
            }
        }
        additionalCodeRepositories = additionalCodeRepositoriesDecoded0
        let defaultCodeRepositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultCodeRepository)
        defaultCodeRepository = defaultCodeRepositoryDecoded
        let directInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directInternetAccess)
        directInternetAccess = directInternetAccessDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let instanceMetadataServiceConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails.self, forKey: .instanceMetadataServiceConfiguration)
        instanceMetadataServiceConfiguration = instanceMetadataServiceConfigurationDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let notebookInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookInstanceArn)
        notebookInstanceArn = notebookInstanceArnDecoded
        let notebookInstanceLifecycleConfigNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookInstanceLifecycleConfigName)
        notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigNameDecoded
        let notebookInstanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookInstanceName)
        notebookInstanceName = notebookInstanceNameDecoded
        let notebookInstanceStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notebookInstanceStatus)
        notebookInstanceStatus = notebookInstanceStatusDecoded
        let platformIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformIdentifier)
        platformIdentifier = platformIdentifierDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let rootAccessDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootAccess)
        rootAccess = rootAccessDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let volumeSizeInGBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInGB) ?? 0
        volumeSizeInGB = volumeSizeInGBDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about an Amazon SageMaker notebook instance.
    public struct AwsSageMakerNotebookInstanceDetails: Swift.Equatable {
        /// A list of Amazon Elastic Inference instance types to associate with the notebook instance. Currently, only one instance type can be associated with a notebook instance.
        public var acceleratorTypes: [Swift.String]?
        /// An array of up to three Git repositories associated with the notebook instance. These can be either the names of Git repositories stored as resources in your account, or the URL of Git repositories in [AWS CodeCommit](https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html) or in any other Git repository. These repositories are cloned at the same level as the default repository of your notebook instance. For more information, see [Associating Git repositories with SageMaker notebook instances](https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html) in the Amazon SageMaker Developer Guide.
        public var additionalCodeRepositories: [Swift.String]?
        /// The Git repository associated with the notebook instance as its default code repository. This can be either the name of a Git repository stored as a resource in your account, or the URL of a Git repository in [AWS CodeCommit](https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html) or in any other Git repository. When you open a notebook instance, it opens in the directory that contains this repository. For more information, see [Associating Git repositories with SageMaker notebook instances](https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html) in the Amazon SageMaker Developer Guide.
        public var defaultCodeRepository: Swift.String?
        /// Sets whether SageMaker provides internet access to the notebook instance. If you set this to Disabled, this notebook instance is able to access resources only in your VPC, and is not be able to connect to SageMaker training and endpoint services unless you configure a Network Address Translation (NAT) Gateway in your VPC.
        public var directInternetAccess: Swift.String?
        /// If status of the instance is Failed, the reason it failed.
        public var failureReason: Swift.String?
        /// Information on the IMDS configuration of the notebook instance.
        public var instanceMetadataServiceConfiguration: SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails?
        /// The type of machine learning (ML) compute instance to launch for the notebook instance.
        public var instanceType: Swift.String?
        /// The Amazon Resource Name (ARN) of an Key Management Service (KMS) key that SageMaker uses to encrypt data on the storage volume attached to your notebook instance. The KMS key you provide must be enabled. For information, see [Enabling and disabling keys](https://docs.aws.amazon.com/kms/latest/developerguide/enabling-keys.html) in the Key Management Service Developer Guide.
        public var kmsKeyId: Swift.String?
        /// The network interface ID that SageMaker created when the instance was created.
        public var networkInterfaceId: Swift.String?
        /// The Amazon Resource Name (ARN) of the notebook instance.
        public var notebookInstanceArn: Swift.String?
        /// The name of a notebook instance lifecycle configuration.
        public var notebookInstanceLifecycleConfigName: Swift.String?
        /// The name of the new notebook instance.
        public var notebookInstanceName: Swift.String?
        /// The status of the notebook instance.
        public var notebookInstanceStatus: Swift.String?
        /// The platform identifier of the notebook instance runtime environment.
        public var platformIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role associated with the instance.
        public var roleArn: Swift.String?
        /// Whether root access is enabled or disabled for users of the notebook instance.
        public var rootAccess: Swift.String?
        /// The VPC security group IDs.
        public var securityGroups: [Swift.String]?
        /// The ID of the VPC subnet to which you have a connectivity from your ML compute instance.
        public var subnetId: Swift.String?
        /// The URL that you use to connect to the Jupyter notebook that is running in your notebook instance.
        public var url: Swift.String?
        /// The size, in GB, of the ML storage volume to attach to the notebook instance.
        public var volumeSizeInGB: Swift.Int

        public init (
            acceleratorTypes: [Swift.String]? = nil,
            additionalCodeRepositories: [Swift.String]? = nil,
            defaultCodeRepository: Swift.String? = nil,
            directInternetAccess: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            instanceMetadataServiceConfiguration: SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails? = nil,
            instanceType: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            notebookInstanceArn: Swift.String? = nil,
            notebookInstanceLifecycleConfigName: Swift.String? = nil,
            notebookInstanceName: Swift.String? = nil,
            notebookInstanceStatus: Swift.String? = nil,
            platformIdentifier: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            rootAccess: Swift.String? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetId: Swift.String? = nil,
            url: Swift.String? = nil,
            volumeSizeInGB: Swift.Int = 0
        )
        {
            self.acceleratorTypes = acceleratorTypes
            self.additionalCodeRepositories = additionalCodeRepositories
            self.defaultCodeRepository = defaultCodeRepository
            self.directInternetAccess = directInternetAccess
            self.failureReason = failureReason
            self.instanceMetadataServiceConfiguration = instanceMetadataServiceConfiguration
            self.instanceType = instanceType
            self.kmsKeyId = kmsKeyId
            self.networkInterfaceId = networkInterfaceId
            self.notebookInstanceArn = notebookInstanceArn
            self.notebookInstanceLifecycleConfigName = notebookInstanceLifecycleConfigName
            self.notebookInstanceName = notebookInstanceName
            self.notebookInstanceStatus = notebookInstanceStatus
            self.platformIdentifier = platformIdentifier
            self.roleArn = roleArn
            self.rootAccess = rootAccess
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.url = url
            self.volumeSizeInGB = volumeSizeInGB
        }
    }

}

extension SecurityHubClientTypes.AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case minimumInstanceMetadataServiceVersion = "MinimumInstanceMetadataServiceVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let minimumInstanceMetadataServiceVersion = self.minimumInstanceMetadataServiceVersion {
            try encodeContainer.encode(minimumInstanceMetadataServiceVersion, forKey: .minimumInstanceMetadataServiceVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumInstanceMetadataServiceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumInstanceMetadataServiceVersion)
        minimumInstanceMetadataServiceVersion = minimumInstanceMetadataServiceVersionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information on the instance metadata service (IMDS) configuration of the notebook instance.
    public struct AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails: Swift.Equatable {
        /// Indicates the minimum IMDS version that the notebook instance supports.
        public var minimumInstanceMetadataServiceVersion: Swift.String?

        public init (
            minimumInstanceMetadataServiceVersion: Swift.String? = nil
        )
        {
            self.minimumInstanceMetadataServiceVersion = minimumInstanceMetadataServiceVersion
        }
    }

}

extension SecurityHubClientTypes.AwsSecretsManagerSecretDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleted = "Deleted"
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case rotationEnabled = "RotationEnabled"
        case rotationLambdaArn = "RotationLambdaArn"
        case rotationOccurredWithinFrequency = "RotationOccurredWithinFrequency"
        case rotationRules = "RotationRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleted != false {
            try encodeContainer.encode(deleted, forKey: .deleted)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if rotationEnabled != false {
            try encodeContainer.encode(rotationEnabled, forKey: .rotationEnabled)
        }
        if let rotationLambdaArn = self.rotationLambdaArn {
            try encodeContainer.encode(rotationLambdaArn, forKey: .rotationLambdaArn)
        }
        if rotationOccurredWithinFrequency != false {
            try encodeContainer.encode(rotationOccurredWithinFrequency, forKey: .rotationOccurredWithinFrequency)
        }
        if let rotationRules = self.rotationRules {
            try encodeContainer.encode(rotationRules, forKey: .rotationRules)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationRulesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules.self, forKey: .rotationRules)
        rotationRules = rotationRulesDecoded
        let rotationOccurredWithinFrequencyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rotationOccurredWithinFrequency) ?? false
        rotationOccurredWithinFrequency = rotationOccurredWithinFrequencyDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let rotationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rotationEnabled) ?? false
        rotationEnabled = rotationEnabledDecoded
        let rotationLambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationLambdaArn)
        rotationLambdaArn = rotationLambdaArnDecoded
        let deletedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleted) ?? false
        deleted = deletedDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an Secrets Manager secret.
    public struct AwsSecretsManagerSecretDetails: Swift.Equatable {
        /// Whether the secret is deleted.
        public var deleted: Swift.Bool
        /// The user-provided description of the secret.
        public var description: Swift.String?
        /// The ARN, Key ID, or alias of the KMS key used to encrypt the SecretString or SecretBinary values for versions of this secret.
        public var kmsKeyId: Swift.String?
        /// The name of the secret.
        public var name: Swift.String?
        /// Whether rotation is enabled.
        public var rotationEnabled: Swift.Bool
        /// The ARN of the Lambda function that rotates the secret.
        public var rotationLambdaArn: Swift.String?
        /// Whether the rotation occurred within the specified rotation frequency.
        public var rotationOccurredWithinFrequency: Swift.Bool
        /// Defines the rotation schedule for the secret.
        public var rotationRules: SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules?

        public init (
            deleted: Swift.Bool = false,
            description: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            rotationEnabled: Swift.Bool = false,
            rotationLambdaArn: Swift.String? = nil,
            rotationOccurredWithinFrequency: Swift.Bool = false,
            rotationRules: SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules? = nil
        )
        {
            self.deleted = deleted
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.rotationEnabled = rotationEnabled
            self.rotationLambdaArn = rotationLambdaArn
            self.rotationOccurredWithinFrequency = rotationOccurredWithinFrequency
            self.rotationRules = rotationRules
        }
    }

}

extension SecurityHubClientTypes.AwsSecretsManagerSecretRotationRules: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticallyAfterDays = "AutomaticallyAfterDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if automaticallyAfterDays != 0 {
            try encodeContainer.encode(automaticallyAfterDays, forKey: .automaticallyAfterDays)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let automaticallyAfterDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automaticallyAfterDays) ?? 0
        automaticallyAfterDays = automaticallyAfterDaysDecoded
    }
}

extension SecurityHubClientTypes {
    /// Defines the rotation schedule for the secret.
    public struct AwsSecretsManagerSecretRotationRules: Swift.Equatable {
        /// The number of days after the previous rotation to rotate the secret.
        public var automaticallyAfterDays: Swift.Int

        public init (
            automaticallyAfterDays: Swift.Int = 0
        )
        {
            self.automaticallyAfterDays = automaticallyAfterDays
        }
    }

}

extension SecurityHubClientTypes.AwsSecurityFinding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case awsAccountId = "AwsAccountId"
        case companyName = "CompanyName"
        case compliance = "Compliance"
        case confidence = "Confidence"
        case createdAt = "CreatedAt"
        case criticality = "Criticality"
        case description = "Description"
        case findingProviderFields = "FindingProviderFields"
        case firstObservedAt = "FirstObservedAt"
        case generatorId = "GeneratorId"
        case id = "Id"
        case lastObservedAt = "LastObservedAt"
        case malware = "Malware"
        case network = "Network"
        case networkPath = "NetworkPath"
        case note = "Note"
        case patchSummary = "PatchSummary"
        case process = "Process"
        case productArn = "ProductArn"
        case productFields = "ProductFields"
        case productName = "ProductName"
        case recordState = "RecordState"
        case region = "Region"
        case relatedFindings = "RelatedFindings"
        case remediation = "Remediation"
        case resources = "Resources"
        case sample = "Sample"
        case schemaVersion = "SchemaVersion"
        case severity = "Severity"
        case sourceUrl = "SourceUrl"
        case threatIntelIndicators = "ThreatIntelIndicators"
        case threats = "Threats"
        case title = "Title"
        case types = "Types"
        case updatedAt = "UpdatedAt"
        case userDefinedFields = "UserDefinedFields"
        case verificationState = "VerificationState"
        case vulnerabilities = "Vulnerabilities"
        case workflow = "Workflow"
        case workflowState = "WorkflowState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let companyName = self.companyName {
            try encodeContainer.encode(companyName, forKey: .companyName)
        }
        if let compliance = self.compliance {
            try encodeContainer.encode(compliance, forKey: .compliance)
        }
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if criticality != 0 {
            try encodeContainer.encode(criticality, forKey: .criticality)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingProviderFields = self.findingProviderFields {
            try encodeContainer.encode(findingProviderFields, forKey: .findingProviderFields)
        }
        if let firstObservedAt = self.firstObservedAt {
            try encodeContainer.encode(firstObservedAt, forKey: .firstObservedAt)
        }
        if let generatorId = self.generatorId {
            try encodeContainer.encode(generatorId, forKey: .generatorId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastObservedAt = self.lastObservedAt {
            try encodeContainer.encode(lastObservedAt, forKey: .lastObservedAt)
        }
        if let malware = malware {
            var malwareContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malware)
            for malware0 in malware {
                try malwareContainer.encode(malware0)
            }
        }
        if let network = self.network {
            try encodeContainer.encode(network, forKey: .network)
        }
        if let networkPath = networkPath {
            var networkPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkPath)
            for networkpathcomponent0 in networkPath {
                try networkPathContainer.encode(networkpathcomponent0)
            }
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let patchSummary = self.patchSummary {
            try encodeContainer.encode(patchSummary, forKey: .patchSummary)
        }
        if let process = self.process {
            try encodeContainer.encode(process, forKey: .process)
        }
        if let productArn = self.productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
        if let productFields = productFields {
            var productFieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .productFields)
            for (dictKey0, fieldMap0) in productFields {
                try productFieldsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let recordState = self.recordState {
            try encodeContainer.encode(recordState.rawValue, forKey: .recordState)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let relatedFindings = relatedFindings {
            var relatedFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindings)
            for relatedfinding0 in relatedFindings {
                try relatedFindingsContainer.encode(relatedfinding0)
            }
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if sample != false {
            try encodeContainer.encode(sample, forKey: .sample)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let sourceUrl = self.sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let threatIntelIndicators = threatIntelIndicators {
            var threatIntelIndicatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicators)
            for threatintelindicator0 in threatIntelIndicators {
                try threatIntelIndicatorsContainer.encode(threatintelindicator0)
            }
        }
        if let threats = threats {
            var threatsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threats)
            for threat0 in threats {
                try threatsContainer.encode(threat0)
            }
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for nonemptystring0 in types {
                try typesContainer.encode(nonemptystring0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
        if let userDefinedFields = userDefinedFields {
            var userDefinedFieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .userDefinedFields)
            for (dictKey0, fieldMap0) in userDefinedFields {
                try userDefinedFieldsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let verificationState = self.verificationState {
            try encodeContainer.encode(verificationState.rawValue, forKey: .verificationState)
        }
        if let vulnerabilities = vulnerabilities {
            var vulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerabilities)
            for vulnerability0 in vulnerabilities {
                try vulnerabilitiesContainer.encode(vulnerability0)
            }
        }
        if let workflow = self.workflow {
            try encodeContainer.encode(workflow, forKey: .workflow)
        }
        if let workflowState = self.workflowState {
            try encodeContainer.encode(workflowState.rawValue, forKey: .workflowState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let productArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productArn)
        productArn = productArnDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let companyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyName)
        companyName = companyNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let generatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatorId)
        generatorId = generatorIdDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let typesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .types)
        var typesDecoded0:[Swift.String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [Swift.String]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
        let firstObservedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstObservedAt)
        firstObservedAt = firstObservedAtDecoded
        let lastObservedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastObservedAt)
        lastObservedAt = lastObservedAtDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let severityDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .confidence) ?? 0
        confidence = confidenceDecoded
        let criticalityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .criticality) ?? 0
        criticality = criticalityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Remediation.self, forKey: .remediation)
        remediation = remediationDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let productFieldsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .productFields)
        var productFieldsDecoded0: [Swift.String:Swift.String]? = nil
        if let productFieldsContainer = productFieldsContainer {
            productFieldsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in productFieldsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    productFieldsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        productFields = productFieldsDecoded0
        let userDefinedFieldsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .userDefinedFields)
        var userDefinedFieldsDecoded0: [Swift.String:Swift.String]? = nil
        if let userDefinedFieldsContainer = userDefinedFieldsContainer {
            userDefinedFieldsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in userDefinedFieldsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    userDefinedFieldsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        userDefinedFields = userDefinedFieldsDecoded0
        let malwareContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Malware?].self, forKey: .malware)
        var malwareDecoded0:[SecurityHubClientTypes.Malware]? = nil
        if let malwareContainer = malwareContainer {
            malwareDecoded0 = [SecurityHubClientTypes.Malware]()
            for structure0 in malwareContainer {
                if let structure0 = structure0 {
                    malwareDecoded0?.append(structure0)
                }
            }
        }
        malware = malwareDecoded0
        let networkDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Network.self, forKey: .network)
        network = networkDecoded
        let networkPathContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NetworkPathComponent?].self, forKey: .networkPath)
        var networkPathDecoded0:[SecurityHubClientTypes.NetworkPathComponent]? = nil
        if let networkPathContainer = networkPathContainer {
            networkPathDecoded0 = [SecurityHubClientTypes.NetworkPathComponent]()
            for structure0 in networkPathContainer {
                if let structure0 = structure0 {
                    networkPathDecoded0?.append(structure0)
                }
            }
        }
        networkPath = networkPathDecoded0
        let processDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ProcessDetails.self, forKey: .process)
        process = processDecoded
        let threatsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Threat?].self, forKey: .threats)
        var threatsDecoded0:[SecurityHubClientTypes.Threat]? = nil
        if let threatsContainer = threatsContainer {
            threatsDecoded0 = [SecurityHubClientTypes.Threat]()
            for structure0 in threatsContainer {
                if let structure0 = structure0 {
                    threatsDecoded0?.append(structure0)
                }
            }
        }
        threats = threatsDecoded0
        let threatIntelIndicatorsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.ThreatIntelIndicator?].self, forKey: .threatIntelIndicators)
        var threatIntelIndicatorsDecoded0:[SecurityHubClientTypes.ThreatIntelIndicator]? = nil
        if let threatIntelIndicatorsContainer = threatIntelIndicatorsContainer {
            threatIntelIndicatorsDecoded0 = [SecurityHubClientTypes.ThreatIntelIndicator]()
            for structure0 in threatIntelIndicatorsContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorsDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicators = threatIntelIndicatorsDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[SecurityHubClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [SecurityHubClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let complianceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Compliance.self, forKey: .compliance)
        compliance = complianceDecoded
        let verificationStateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.VerificationState.self, forKey: .verificationState)
        verificationState = verificationStateDecoded
        let workflowStateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.WorkflowState.self, forKey: .workflowState)
        workflowState = workflowStateDecoded
        let workflowDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Workflow.self, forKey: .workflow)
        workflow = workflowDecoded
        let recordStateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RecordState.self, forKey: .recordState)
        recordState = recordStateDecoded
        let relatedFindingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RelatedFinding?].self, forKey: .relatedFindings)
        var relatedFindingsDecoded0:[SecurityHubClientTypes.RelatedFinding]? = nil
        if let relatedFindingsContainer = relatedFindingsContainer {
            relatedFindingsDecoded0 = [SecurityHubClientTypes.RelatedFinding]()
            for structure0 in relatedFindingsContainer {
                if let structure0 = structure0 {
                    relatedFindingsDecoded0?.append(structure0)
                }
            }
        }
        relatedFindings = relatedFindingsDecoded0
        let noteDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Note.self, forKey: .note)
        note = noteDecoded
        let vulnerabilitiesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Vulnerability?].self, forKey: .vulnerabilities)
        var vulnerabilitiesDecoded0:[SecurityHubClientTypes.Vulnerability]? = nil
        if let vulnerabilitiesContainer = vulnerabilitiesContainer {
            vulnerabilitiesDecoded0 = [SecurityHubClientTypes.Vulnerability]()
            for structure0 in vulnerabilitiesContainer {
                if let structure0 = structure0 {
                    vulnerabilitiesDecoded0?.append(structure0)
                }
            }
        }
        vulnerabilities = vulnerabilitiesDecoded0
        let patchSummaryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.PatchSummary.self, forKey: .patchSummary)
        patchSummary = patchSummaryDecoded
        let actionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let findingProviderFieldsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.FindingProviderFields.self, forKey: .findingProviderFields)
        findingProviderFields = findingProviderFieldsDecoded
        let sampleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sample) ?? false
        sample = sampleDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides a consistent format for Security Hub findings. AwsSecurityFinding format allows you to share findings between Amazon Web Services security services and third-party solutions. A finding is a potential security issue generated either by Amazon Web Services services or by the integrated third-party solutions and standards checks.
    public struct AwsSecurityFinding: Swift.Equatable {
        /// Provides details about an action that affects or that was taken on a resource.
        public var action: SecurityHubClientTypes.Action?
        /// The Amazon Web Services account ID that a finding is generated in.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The name of the company for the product that generated the finding. Security Hub populates this attribute automatically for each finding. You cannot update this attribute with BatchImportFindings or BatchUpdateFindings. The exception to this is a custom integration. When you use the Security Hub console or API to filter findings by company name, you use this attribute.
        public var companyName: Swift.String?
        /// This data type is exclusive to findings that are generated as the result of a check run against a specific rule in a supported security standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.
        public var compliance: SecurityHubClientTypes.Compliance?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public var confidence: Swift.Int
        /// Indicates when the security-findings provider created the potential security issue that a finding captured. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        /// This member is required.
        public var createdAt: Swift.String?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public var criticality: Swift.Int
        /// A finding's description. In this release, Description is a required property.
        /// This member is required.
        public var description: Swift.String?
        /// In a BatchImportFindings request, finding providers use FindingProviderFields to provide and update their own values for confidence, criticality, related findings, severity, and types.
        public var findingProviderFields: SecurityHubClientTypes.FindingProviderFields?
        /// Indicates when the security-findings provider first observed the potential security issue that a finding captured. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var firstObservedAt: Swift.String?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.
        /// This member is required.
        public var generatorId: Swift.String?
        /// The security findings provider-specific identifier for a finding.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates when the security-findings provider most recently observed the potential security issue that a finding captured. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastObservedAt: Swift.String?
        /// A list of malware related to a finding.
        public var malware: [SecurityHubClientTypes.Malware]?
        /// The details of network-related information about a finding.
        public var network: SecurityHubClientTypes.Network?
        /// Provides information about a network path that is relevant to a finding. Each entry under NetworkPath represents a component of that path.
        public var networkPath: [SecurityHubClientTypes.NetworkPathComponent]?
        /// A user-defined note added to a finding.
        public var note: SecurityHubClientTypes.Note?
        /// Provides an overview of the patch compliance status for an instance against a selected compliance standard.
        public var patchSummary: SecurityHubClientTypes.PatchSummary?
        /// The details of process-related information about a finding.
        public var process: SecurityHubClientTypes.ProcessDetails?
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.
        /// This member is required.
        public var productArn: Swift.String?
        /// A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. Can contain up to 50 key-value pairs. For each key-value pair, the key can contain up to 128 characters, and the value can contain up to 2048 characters.
        public var productFields: [Swift.String:Swift.String]?
        /// The name of the product that generated the finding. Security Hub populates this attribute automatically for each finding. You cannot update this attribute with BatchImportFindings or BatchUpdateFindings. The exception to this is a custom integration. When you use the Security Hub console or API to filter findings by product name, you use this attribute.
        public var productName: Swift.String?
        /// The record state of a finding.
        public var recordState: SecurityHubClientTypes.RecordState?
        /// The Region from which the finding was generated. Security Hub populates this attribute automatically for each finding. You cannot update it using BatchImportFindings or BatchUpdateFindings.
        public var region: Swift.String?
        /// A list of related findings.
        public var relatedFindings: [SecurityHubClientTypes.RelatedFinding]?
        /// A data type that describes the remediation options for a finding.
        public var remediation: SecurityHubClientTypes.Remediation?
        /// A set of resource data types that describe the resources that the finding refers to.
        /// This member is required.
        public var resources: [SecurityHubClientTypes.Resource]?
        /// Indicates whether the finding is a sample finding.
        public var sample: Swift.Bool
        /// The schema version that a finding is formatted for.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// A finding's severity.
        public var severity: SecurityHubClientTypes.Severity?
        /// A URL that links to a page about the current finding in the security-findings provider's solution.
        public var sourceUrl: Swift.String?
        /// Threat intelligence details related to a finding.
        public var threatIntelIndicators: [SecurityHubClientTypes.ThreatIntelIndicator]?
        /// Details about the threat detected in a security finding and the file paths that were affected by the threat.
        public var threats: [SecurityHubClientTypes.Threat]?
        /// A finding's title. In this release, Title is a required property.
        /// This member is required.
        public var title: Swift.String?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public var types: [Swift.String]?
        /// Indicates when the security-findings provider last updated the finding record. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        /// This member is required.
        public var updatedAt: Swift.String?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
        public var userDefinedFields: [Swift.String:Swift.String]?
        /// Indicates the veracity of a finding.
        public var verificationState: SecurityHubClientTypes.VerificationState?
        /// Provides a list of vulnerabilities associated with the findings.
        public var vulnerabilities: [SecurityHubClientTypes.Vulnerability]?
        /// Provides information about the status of the investigation into a finding.
        public var workflow: SecurityHubClientTypes.Workflow?
        /// The workflow state of a finding.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use SeverityLabel or FindingProviderFieldsSeverityLabel.")
        public var workflowState: SecurityHubClientTypes.WorkflowState?

        public init (
            action: SecurityHubClientTypes.Action? = nil,
            awsAccountId: Swift.String? = nil,
            companyName: Swift.String? = nil,
            compliance: SecurityHubClientTypes.Compliance? = nil,
            confidence: Swift.Int = 0,
            createdAt: Swift.String? = nil,
            criticality: Swift.Int = 0,
            description: Swift.String? = nil,
            findingProviderFields: SecurityHubClientTypes.FindingProviderFields? = nil,
            firstObservedAt: Swift.String? = nil,
            generatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            lastObservedAt: Swift.String? = nil,
            malware: [SecurityHubClientTypes.Malware]? = nil,
            network: SecurityHubClientTypes.Network? = nil,
            networkPath: [SecurityHubClientTypes.NetworkPathComponent]? = nil,
            note: SecurityHubClientTypes.Note? = nil,
            patchSummary: SecurityHubClientTypes.PatchSummary? = nil,
            process: SecurityHubClientTypes.ProcessDetails? = nil,
            productArn: Swift.String? = nil,
            productFields: [Swift.String:Swift.String]? = nil,
            productName: Swift.String? = nil,
            recordState: SecurityHubClientTypes.RecordState? = nil,
            region: Swift.String? = nil,
            relatedFindings: [SecurityHubClientTypes.RelatedFinding]? = nil,
            remediation: SecurityHubClientTypes.Remediation? = nil,
            resources: [SecurityHubClientTypes.Resource]? = nil,
            sample: Swift.Bool = false,
            schemaVersion: Swift.String? = nil,
            severity: SecurityHubClientTypes.Severity? = nil,
            sourceUrl: Swift.String? = nil,
            threatIntelIndicators: [SecurityHubClientTypes.ThreatIntelIndicator]? = nil,
            threats: [SecurityHubClientTypes.Threat]? = nil,
            title: Swift.String? = nil,
            types: [Swift.String]? = nil,
            updatedAt: Swift.String? = nil,
            userDefinedFields: [Swift.String:Swift.String]? = nil,
            verificationState: SecurityHubClientTypes.VerificationState? = nil,
            vulnerabilities: [SecurityHubClientTypes.Vulnerability]? = nil,
            workflow: SecurityHubClientTypes.Workflow? = nil,
            workflowState: SecurityHubClientTypes.WorkflowState? = nil
        )
        {
            self.action = action
            self.awsAccountId = awsAccountId
            self.companyName = companyName
            self.compliance = compliance
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.findingProviderFields = findingProviderFields
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.lastObservedAt = lastObservedAt
            self.malware = malware
            self.network = network
            self.networkPath = networkPath
            self.note = note
            self.patchSummary = patchSummary
            self.process = process
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recordState = recordState
            self.region = region
            self.relatedFindings = relatedFindings
            self.remediation = remediation
            self.resources = resources
            self.sample = sample
            self.schemaVersion = schemaVersion
            self.severity = severity
            self.sourceUrl = sourceUrl
            self.threatIntelIndicators = threatIntelIndicators
            self.threats = threats
            self.title = title
            self.types = types
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.vulnerabilities = vulnerabilities
            self.workflow = workflow
            self.workflowState = workflowState
        }
    }

}

extension SecurityHubClientTypes.AwsSecurityFindingFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AwsAccountId"
        case companyName = "CompanyName"
        case complianceStatus = "ComplianceStatus"
        case confidence = "Confidence"
        case createdAt = "CreatedAt"
        case criticality = "Criticality"
        case description = "Description"
        case findingProviderFieldsConfidence = "FindingProviderFieldsConfidence"
        case findingProviderFieldsCriticality = "FindingProviderFieldsCriticality"
        case findingProviderFieldsRelatedFindingsId = "FindingProviderFieldsRelatedFindingsId"
        case findingProviderFieldsRelatedFindingsProductArn = "FindingProviderFieldsRelatedFindingsProductArn"
        case findingProviderFieldsSeverityLabel = "FindingProviderFieldsSeverityLabel"
        case findingProviderFieldsSeverityOriginal = "FindingProviderFieldsSeverityOriginal"
        case findingProviderFieldsTypes = "FindingProviderFieldsTypes"
        case firstObservedAt = "FirstObservedAt"
        case generatorId = "GeneratorId"
        case id = "Id"
        case keyword = "Keyword"
        case lastObservedAt = "LastObservedAt"
        case malwareName = "MalwareName"
        case malwarePath = "MalwarePath"
        case malwareState = "MalwareState"
        case malwareType = "MalwareType"
        case networkDestinationDomain = "NetworkDestinationDomain"
        case networkDestinationIpV4 = "NetworkDestinationIpV4"
        case networkDestinationIpV6 = "NetworkDestinationIpV6"
        case networkDestinationPort = "NetworkDestinationPort"
        case networkDirection = "NetworkDirection"
        case networkProtocol = "NetworkProtocol"
        case networkSourceDomain = "NetworkSourceDomain"
        case networkSourceIpV4 = "NetworkSourceIpV4"
        case networkSourceIpV6 = "NetworkSourceIpV6"
        case networkSourceMac = "NetworkSourceMac"
        case networkSourcePort = "NetworkSourcePort"
        case noteText = "NoteText"
        case noteUpdatedAt = "NoteUpdatedAt"
        case noteUpdatedBy = "NoteUpdatedBy"
        case processLaunchedAt = "ProcessLaunchedAt"
        case processName = "ProcessName"
        case processParentPid = "ProcessParentPid"
        case processPath = "ProcessPath"
        case processPid = "ProcessPid"
        case processTerminatedAt = "ProcessTerminatedAt"
        case productArn = "ProductArn"
        case productFields = "ProductFields"
        case productName = "ProductName"
        case recommendationText = "RecommendationText"
        case recordState = "RecordState"
        case region = "Region"
        case relatedFindingsId = "RelatedFindingsId"
        case relatedFindingsProductArn = "RelatedFindingsProductArn"
        case resourceAwsEc2InstanceIamInstanceProfileArn = "ResourceAwsEc2InstanceIamInstanceProfileArn"
        case resourceAwsEc2InstanceImageId = "ResourceAwsEc2InstanceImageId"
        case resourceAwsEc2InstanceIpV4Addresses = "ResourceAwsEc2InstanceIpV4Addresses"
        case resourceAwsEc2InstanceIpV6Addresses = "ResourceAwsEc2InstanceIpV6Addresses"
        case resourceAwsEc2InstanceKeyName = "ResourceAwsEc2InstanceKeyName"
        case resourceAwsEc2InstanceLaunchedAt = "ResourceAwsEc2InstanceLaunchedAt"
        case resourceAwsEc2InstanceSubnetId = "ResourceAwsEc2InstanceSubnetId"
        case resourceAwsEc2InstanceType = "ResourceAwsEc2InstanceType"
        case resourceAwsEc2InstanceVpcId = "ResourceAwsEc2InstanceVpcId"
        case resourceAwsIamAccessKeyCreatedAt = "ResourceAwsIamAccessKeyCreatedAt"
        case resourceAwsIamAccessKeyPrincipalName = "ResourceAwsIamAccessKeyPrincipalName"
        case resourceAwsIamAccessKeyStatus = "ResourceAwsIamAccessKeyStatus"
        case resourceAwsIamAccessKeyUserName = "ResourceAwsIamAccessKeyUserName"
        case resourceAwsIamUserUserName = "ResourceAwsIamUserUserName"
        case resourceAwsS3BucketOwnerId = "ResourceAwsS3BucketOwnerId"
        case resourceAwsS3BucketOwnerName = "ResourceAwsS3BucketOwnerName"
        case resourceContainerImageId = "ResourceContainerImageId"
        case resourceContainerImageName = "ResourceContainerImageName"
        case resourceContainerLaunchedAt = "ResourceContainerLaunchedAt"
        case resourceContainerName = "ResourceContainerName"
        case resourceDetailsOther = "ResourceDetailsOther"
        case resourceId = "ResourceId"
        case resourcePartition = "ResourcePartition"
        case resourceRegion = "ResourceRegion"
        case resourceTags = "ResourceTags"
        case resourceType = "ResourceType"
        case sample = "Sample"
        case severityLabel = "SeverityLabel"
        case severityNormalized = "SeverityNormalized"
        case severityProduct = "SeverityProduct"
        case sourceUrl = "SourceUrl"
        case threatIntelIndicatorCategory = "ThreatIntelIndicatorCategory"
        case threatIntelIndicatorLastObservedAt = "ThreatIntelIndicatorLastObservedAt"
        case threatIntelIndicatorSource = "ThreatIntelIndicatorSource"
        case threatIntelIndicatorSourceUrl = "ThreatIntelIndicatorSourceUrl"
        case threatIntelIndicatorType = "ThreatIntelIndicatorType"
        case threatIntelIndicatorValue = "ThreatIntelIndicatorValue"
        case title = "Title"
        case type = "Type"
        case updatedAt = "UpdatedAt"
        case userDefinedFields = "UserDefinedFields"
        case verificationState = "VerificationState"
        case workflowState = "WorkflowState"
        case workflowStatus = "WorkflowStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = awsAccountId {
            var awsAccountIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountId)
            for stringfilter0 in awsAccountId {
                try awsAccountIdContainer.encode(stringfilter0)
            }
        }
        if let companyName = companyName {
            var companyNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .companyName)
            for stringfilter0 in companyName {
                try companyNameContainer.encode(stringfilter0)
            }
        }
        if let complianceStatus = complianceStatus {
            var complianceStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .complianceStatus)
            for stringfilter0 in complianceStatus {
                try complianceStatusContainer.encode(stringfilter0)
            }
        }
        if let confidence = confidence {
            var confidenceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .confidence)
            for numberfilter0 in confidence {
                try confidenceContainer.encode(numberfilter0)
            }
        }
        if let createdAt = createdAt {
            var createdAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createdAt)
            for datefilter0 in createdAt {
                try createdAtContainer.encode(datefilter0)
            }
        }
        if let criticality = criticality {
            var criticalityContainer = encodeContainer.nestedUnkeyedContainer(forKey: .criticality)
            for numberfilter0 in criticality {
                try criticalityContainer.encode(numberfilter0)
            }
        }
        if let description = description {
            var descriptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .description)
            for stringfilter0 in description {
                try descriptionContainer.encode(stringfilter0)
            }
        }
        if let findingProviderFieldsConfidence = findingProviderFieldsConfidence {
            var findingProviderFieldsConfidenceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsConfidence)
            for numberfilter0 in findingProviderFieldsConfidence {
                try findingProviderFieldsConfidenceContainer.encode(numberfilter0)
            }
        }
        if let findingProviderFieldsCriticality = findingProviderFieldsCriticality {
            var findingProviderFieldsCriticalityContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsCriticality)
            for numberfilter0 in findingProviderFieldsCriticality {
                try findingProviderFieldsCriticalityContainer.encode(numberfilter0)
            }
        }
        if let findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsId {
            var findingProviderFieldsRelatedFindingsIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsRelatedFindingsId)
            for stringfilter0 in findingProviderFieldsRelatedFindingsId {
                try findingProviderFieldsRelatedFindingsIdContainer.encode(stringfilter0)
            }
        }
        if let findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArn {
            var findingProviderFieldsRelatedFindingsProductArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsRelatedFindingsProductArn)
            for stringfilter0 in findingProviderFieldsRelatedFindingsProductArn {
                try findingProviderFieldsRelatedFindingsProductArnContainer.encode(stringfilter0)
            }
        }
        if let findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabel {
            var findingProviderFieldsSeverityLabelContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsSeverityLabel)
            for stringfilter0 in findingProviderFieldsSeverityLabel {
                try findingProviderFieldsSeverityLabelContainer.encode(stringfilter0)
            }
        }
        if let findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginal {
            var findingProviderFieldsSeverityOriginalContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsSeverityOriginal)
            for stringfilter0 in findingProviderFieldsSeverityOriginal {
                try findingProviderFieldsSeverityOriginalContainer.encode(stringfilter0)
            }
        }
        if let findingProviderFieldsTypes = findingProviderFieldsTypes {
            var findingProviderFieldsTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingProviderFieldsTypes)
            for stringfilter0 in findingProviderFieldsTypes {
                try findingProviderFieldsTypesContainer.encode(stringfilter0)
            }
        }
        if let firstObservedAt = firstObservedAt {
            var firstObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .firstObservedAt)
            for datefilter0 in firstObservedAt {
                try firstObservedAtContainer.encode(datefilter0)
            }
        }
        if let generatorId = generatorId {
            var generatorIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .generatorId)
            for stringfilter0 in generatorId {
                try generatorIdContainer.encode(stringfilter0)
            }
        }
        if let id = id {
            var idContainer = encodeContainer.nestedUnkeyedContainer(forKey: .id)
            for stringfilter0 in id {
                try idContainer.encode(stringfilter0)
            }
        }
        if let keyword = keyword {
            var keywordContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyword)
            for keywordfilter0 in keyword {
                try keywordContainer.encode(keywordfilter0)
            }
        }
        if let lastObservedAt = lastObservedAt {
            var lastObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastObservedAt)
            for datefilter0 in lastObservedAt {
                try lastObservedAtContainer.encode(datefilter0)
            }
        }
        if let malwareName = malwareName {
            var malwareNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malwareName)
            for stringfilter0 in malwareName {
                try malwareNameContainer.encode(stringfilter0)
            }
        }
        if let malwarePath = malwarePath {
            var malwarePathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malwarePath)
            for stringfilter0 in malwarePath {
                try malwarePathContainer.encode(stringfilter0)
            }
        }
        if let malwareState = malwareState {
            var malwareStateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malwareState)
            for stringfilter0 in malwareState {
                try malwareStateContainer.encode(stringfilter0)
            }
        }
        if let malwareType = malwareType {
            var malwareTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .malwareType)
            for stringfilter0 in malwareType {
                try malwareTypeContainer.encode(stringfilter0)
            }
        }
        if let networkDestinationDomain = networkDestinationDomain {
            var networkDestinationDomainContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkDestinationDomain)
            for stringfilter0 in networkDestinationDomain {
                try networkDestinationDomainContainer.encode(stringfilter0)
            }
        }
        if let networkDestinationIpV4 = networkDestinationIpV4 {
            var networkDestinationIpV4Container = encodeContainer.nestedUnkeyedContainer(forKey: .networkDestinationIpV4)
            for ipfilter0 in networkDestinationIpV4 {
                try networkDestinationIpV4Container.encode(ipfilter0)
            }
        }
        if let networkDestinationIpV6 = networkDestinationIpV6 {
            var networkDestinationIpV6Container = encodeContainer.nestedUnkeyedContainer(forKey: .networkDestinationIpV6)
            for ipfilter0 in networkDestinationIpV6 {
                try networkDestinationIpV6Container.encode(ipfilter0)
            }
        }
        if let networkDestinationPort = networkDestinationPort {
            var networkDestinationPortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkDestinationPort)
            for numberfilter0 in networkDestinationPort {
                try networkDestinationPortContainer.encode(numberfilter0)
            }
        }
        if let networkDirection = networkDirection {
            var networkDirectionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkDirection)
            for stringfilter0 in networkDirection {
                try networkDirectionContainer.encode(stringfilter0)
            }
        }
        if let networkProtocol = networkProtocol {
            var networkProtocolContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkProtocol)
            for stringfilter0 in networkProtocol {
                try networkProtocolContainer.encode(stringfilter0)
            }
        }
        if let networkSourceDomain = networkSourceDomain {
            var networkSourceDomainContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourceDomain)
            for stringfilter0 in networkSourceDomain {
                try networkSourceDomainContainer.encode(stringfilter0)
            }
        }
        if let networkSourceIpV4 = networkSourceIpV4 {
            var networkSourceIpV4Container = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourceIpV4)
            for ipfilter0 in networkSourceIpV4 {
                try networkSourceIpV4Container.encode(ipfilter0)
            }
        }
        if let networkSourceIpV6 = networkSourceIpV6 {
            var networkSourceIpV6Container = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourceIpV6)
            for ipfilter0 in networkSourceIpV6 {
                try networkSourceIpV6Container.encode(ipfilter0)
            }
        }
        if let networkSourceMac = networkSourceMac {
            var networkSourceMacContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourceMac)
            for stringfilter0 in networkSourceMac {
                try networkSourceMacContainer.encode(stringfilter0)
            }
        }
        if let networkSourcePort = networkSourcePort {
            var networkSourcePortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkSourcePort)
            for numberfilter0 in networkSourcePort {
                try networkSourcePortContainer.encode(numberfilter0)
            }
        }
        if let noteText = noteText {
            var noteTextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .noteText)
            for stringfilter0 in noteText {
                try noteTextContainer.encode(stringfilter0)
            }
        }
        if let noteUpdatedAt = noteUpdatedAt {
            var noteUpdatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .noteUpdatedAt)
            for datefilter0 in noteUpdatedAt {
                try noteUpdatedAtContainer.encode(datefilter0)
            }
        }
        if let noteUpdatedBy = noteUpdatedBy {
            var noteUpdatedByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .noteUpdatedBy)
            for stringfilter0 in noteUpdatedBy {
                try noteUpdatedByContainer.encode(stringfilter0)
            }
        }
        if let processLaunchedAt = processLaunchedAt {
            var processLaunchedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processLaunchedAt)
            for datefilter0 in processLaunchedAt {
                try processLaunchedAtContainer.encode(datefilter0)
            }
        }
        if let processName = processName {
            var processNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processName)
            for stringfilter0 in processName {
                try processNameContainer.encode(stringfilter0)
            }
        }
        if let processParentPid = processParentPid {
            var processParentPidContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processParentPid)
            for numberfilter0 in processParentPid {
                try processParentPidContainer.encode(numberfilter0)
            }
        }
        if let processPath = processPath {
            var processPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processPath)
            for stringfilter0 in processPath {
                try processPathContainer.encode(stringfilter0)
            }
        }
        if let processPid = processPid {
            var processPidContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processPid)
            for numberfilter0 in processPid {
                try processPidContainer.encode(numberfilter0)
            }
        }
        if let processTerminatedAt = processTerminatedAt {
            var processTerminatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processTerminatedAt)
            for datefilter0 in processTerminatedAt {
                try processTerminatedAtContainer.encode(datefilter0)
            }
        }
        if let productArn = productArn {
            var productArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productArn)
            for stringfilter0 in productArn {
                try productArnContainer.encode(stringfilter0)
            }
        }
        if let productFields = productFields {
            var productFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productFields)
            for mapfilter0 in productFields {
                try productFieldsContainer.encode(mapfilter0)
            }
        }
        if let productName = productName {
            var productNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productName)
            for stringfilter0 in productName {
                try productNameContainer.encode(stringfilter0)
            }
        }
        if let recommendationText = recommendationText {
            var recommendationTextContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationText)
            for stringfilter0 in recommendationText {
                try recommendationTextContainer.encode(stringfilter0)
            }
        }
        if let recordState = recordState {
            var recordStateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordState)
            for stringfilter0 in recordState {
                try recordStateContainer.encode(stringfilter0)
            }
        }
        if let region = region {
            var regionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .region)
            for stringfilter0 in region {
                try regionContainer.encode(stringfilter0)
            }
        }
        if let relatedFindingsId = relatedFindingsId {
            var relatedFindingsIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindingsId)
            for stringfilter0 in relatedFindingsId {
                try relatedFindingsIdContainer.encode(stringfilter0)
            }
        }
        if let relatedFindingsProductArn = relatedFindingsProductArn {
            var relatedFindingsProductArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindingsProductArn)
            for stringfilter0 in relatedFindingsProductArn {
                try relatedFindingsProductArnContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn {
            var resourceAwsEc2InstanceIamInstanceProfileArnContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceIamInstanceProfileArn)
            for stringfilter0 in resourceAwsEc2InstanceIamInstanceProfileArn {
                try resourceAwsEc2InstanceIamInstanceProfileArnContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId {
            var resourceAwsEc2InstanceImageIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceImageId)
            for stringfilter0 in resourceAwsEc2InstanceImageId {
                try resourceAwsEc2InstanceImageIdContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses {
            var resourceAwsEc2InstanceIpV4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceIpV4Addresses)
            for ipfilter0 in resourceAwsEc2InstanceIpV4Addresses {
                try resourceAwsEc2InstanceIpV4AddressesContainer.encode(ipfilter0)
            }
        }
        if let resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses {
            var resourceAwsEc2InstanceIpV6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceIpV6Addresses)
            for ipfilter0 in resourceAwsEc2InstanceIpV6Addresses {
                try resourceAwsEc2InstanceIpV6AddressesContainer.encode(ipfilter0)
            }
        }
        if let resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName {
            var resourceAwsEc2InstanceKeyNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceKeyName)
            for stringfilter0 in resourceAwsEc2InstanceKeyName {
                try resourceAwsEc2InstanceKeyNameContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt {
            var resourceAwsEc2InstanceLaunchedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceLaunchedAt)
            for datefilter0 in resourceAwsEc2InstanceLaunchedAt {
                try resourceAwsEc2InstanceLaunchedAtContainer.encode(datefilter0)
            }
        }
        if let resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId {
            var resourceAwsEc2InstanceSubnetIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceSubnetId)
            for stringfilter0 in resourceAwsEc2InstanceSubnetId {
                try resourceAwsEc2InstanceSubnetIdContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsEc2InstanceType = resourceAwsEc2InstanceType {
            var resourceAwsEc2InstanceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceType)
            for stringfilter0 in resourceAwsEc2InstanceType {
                try resourceAwsEc2InstanceTypeContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId {
            var resourceAwsEc2InstanceVpcIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsEc2InstanceVpcId)
            for stringfilter0 in resourceAwsEc2InstanceVpcId {
                try resourceAwsEc2InstanceVpcIdContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt {
            var resourceAwsIamAccessKeyCreatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsIamAccessKeyCreatedAt)
            for datefilter0 in resourceAwsIamAccessKeyCreatedAt {
                try resourceAwsIamAccessKeyCreatedAtContainer.encode(datefilter0)
            }
        }
        if let resourceAwsIamAccessKeyPrincipalName = resourceAwsIamAccessKeyPrincipalName {
            var resourceAwsIamAccessKeyPrincipalNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsIamAccessKeyPrincipalName)
            for stringfilter0 in resourceAwsIamAccessKeyPrincipalName {
                try resourceAwsIamAccessKeyPrincipalNameContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus {
            var resourceAwsIamAccessKeyStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsIamAccessKeyStatus)
            for stringfilter0 in resourceAwsIamAccessKeyStatus {
                try resourceAwsIamAccessKeyStatusContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserName {
            var resourceAwsIamAccessKeyUserNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsIamAccessKeyUserName)
            for stringfilter0 in resourceAwsIamAccessKeyUserName {
                try resourceAwsIamAccessKeyUserNameContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsIamUserUserName = resourceAwsIamUserUserName {
            var resourceAwsIamUserUserNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsIamUserUserName)
            for stringfilter0 in resourceAwsIamUserUserName {
                try resourceAwsIamUserUserNameContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId {
            var resourceAwsS3BucketOwnerIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsS3BucketOwnerId)
            for stringfilter0 in resourceAwsS3BucketOwnerId {
                try resourceAwsS3BucketOwnerIdContainer.encode(stringfilter0)
            }
        }
        if let resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName {
            var resourceAwsS3BucketOwnerNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAwsS3BucketOwnerName)
            for stringfilter0 in resourceAwsS3BucketOwnerName {
                try resourceAwsS3BucketOwnerNameContainer.encode(stringfilter0)
            }
        }
        if let resourceContainerImageId = resourceContainerImageId {
            var resourceContainerImageIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceContainerImageId)
            for stringfilter0 in resourceContainerImageId {
                try resourceContainerImageIdContainer.encode(stringfilter0)
            }
        }
        if let resourceContainerImageName = resourceContainerImageName {
            var resourceContainerImageNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceContainerImageName)
            for stringfilter0 in resourceContainerImageName {
                try resourceContainerImageNameContainer.encode(stringfilter0)
            }
        }
        if let resourceContainerLaunchedAt = resourceContainerLaunchedAt {
            var resourceContainerLaunchedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceContainerLaunchedAt)
            for datefilter0 in resourceContainerLaunchedAt {
                try resourceContainerLaunchedAtContainer.encode(datefilter0)
            }
        }
        if let resourceContainerName = resourceContainerName {
            var resourceContainerNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceContainerName)
            for stringfilter0 in resourceContainerName {
                try resourceContainerNameContainer.encode(stringfilter0)
            }
        }
        if let resourceDetailsOther = resourceDetailsOther {
            var resourceDetailsOtherContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceDetailsOther)
            for mapfilter0 in resourceDetailsOther {
                try resourceDetailsOtherContainer.encode(mapfilter0)
            }
        }
        if let resourceId = resourceId {
            var resourceIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceId)
            for stringfilter0 in resourceId {
                try resourceIdContainer.encode(stringfilter0)
            }
        }
        if let resourcePartition = resourcePartition {
            var resourcePartitionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourcePartition)
            for stringfilter0 in resourcePartition {
                try resourcePartitionContainer.encode(stringfilter0)
            }
        }
        if let resourceRegion = resourceRegion {
            var resourceRegionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceRegion)
            for stringfilter0 in resourceRegion {
                try resourceRegionContainer.encode(stringfilter0)
            }
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for mapfilter0 in resourceTags {
                try resourceTagsContainer.encode(mapfilter0)
            }
        }
        if let resourceType = resourceType {
            var resourceTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceType)
            for stringfilter0 in resourceType {
                try resourceTypeContainer.encode(stringfilter0)
            }
        }
        if let sample = sample {
            var sampleContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sample)
            for booleanfilter0 in sample {
                try sampleContainer.encode(booleanfilter0)
            }
        }
        if let severityLabel = severityLabel {
            var severityLabelContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severityLabel)
            for stringfilter0 in severityLabel {
                try severityLabelContainer.encode(stringfilter0)
            }
        }
        if let severityNormalized = severityNormalized {
            var severityNormalizedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severityNormalized)
            for numberfilter0 in severityNormalized {
                try severityNormalizedContainer.encode(numberfilter0)
            }
        }
        if let severityProduct = severityProduct {
            var severityProductContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severityProduct)
            for numberfilter0 in severityProduct {
                try severityProductContainer.encode(numberfilter0)
            }
        }
        if let sourceUrl = sourceUrl {
            var sourceUrlContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceUrl)
            for stringfilter0 in sourceUrl {
                try sourceUrlContainer.encode(stringfilter0)
            }
        }
        if let threatIntelIndicatorCategory = threatIntelIndicatorCategory {
            var threatIntelIndicatorCategoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorCategory)
            for stringfilter0 in threatIntelIndicatorCategory {
                try threatIntelIndicatorCategoryContainer.encode(stringfilter0)
            }
        }
        if let threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt {
            var threatIntelIndicatorLastObservedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorLastObservedAt)
            for datefilter0 in threatIntelIndicatorLastObservedAt {
                try threatIntelIndicatorLastObservedAtContainer.encode(datefilter0)
            }
        }
        if let threatIntelIndicatorSource = threatIntelIndicatorSource {
            var threatIntelIndicatorSourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorSource)
            for stringfilter0 in threatIntelIndicatorSource {
                try threatIntelIndicatorSourceContainer.encode(stringfilter0)
            }
        }
        if let threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl {
            var threatIntelIndicatorSourceUrlContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorSourceUrl)
            for stringfilter0 in threatIntelIndicatorSourceUrl {
                try threatIntelIndicatorSourceUrlContainer.encode(stringfilter0)
            }
        }
        if let threatIntelIndicatorType = threatIntelIndicatorType {
            var threatIntelIndicatorTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorType)
            for stringfilter0 in threatIntelIndicatorType {
                try threatIntelIndicatorTypeContainer.encode(stringfilter0)
            }
        }
        if let threatIntelIndicatorValue = threatIntelIndicatorValue {
            var threatIntelIndicatorValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelIndicatorValue)
            for stringfilter0 in threatIntelIndicatorValue {
                try threatIntelIndicatorValueContainer.encode(stringfilter0)
            }
        }
        if let title = title {
            var titleContainer = encodeContainer.nestedUnkeyedContainer(forKey: .title)
            for stringfilter0 in title {
                try titleContainer.encode(stringfilter0)
            }
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for stringfilter0 in type {
                try typeContainer.encode(stringfilter0)
            }
        }
        if let updatedAt = updatedAt {
            var updatedAtContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updatedAt)
            for datefilter0 in updatedAt {
                try updatedAtContainer.encode(datefilter0)
            }
        }
        if let userDefinedFields = userDefinedFields {
            var userDefinedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userDefinedFields)
            for mapfilter0 in userDefinedFields {
                try userDefinedFieldsContainer.encode(mapfilter0)
            }
        }
        if let verificationState = verificationState {
            var verificationStateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .verificationState)
            for stringfilter0 in verificationState {
                try verificationStateContainer.encode(stringfilter0)
            }
        }
        if let workflowState = workflowState {
            var workflowStateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workflowState)
            for stringfilter0 in workflowState {
                try workflowStateContainer.encode(stringfilter0)
            }
        }
        if let workflowStatus = workflowStatus {
            var workflowStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workflowStatus)
            for stringfilter0 in workflowStatus {
                try workflowStatusContainer.encode(stringfilter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productArnContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .productArn)
        var productArnDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let productArnContainer = productArnContainer {
            productArnDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in productArnContainer {
                if let structure0 = structure0 {
                    productArnDecoded0?.append(structure0)
                }
            }
        }
        productArn = productArnDecoded0
        let awsAccountIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .awsAccountId)
        var awsAccountIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let awsAccountIdContainer = awsAccountIdContainer {
            awsAccountIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in awsAccountIdContainer {
                if let structure0 = structure0 {
                    awsAccountIdDecoded0?.append(structure0)
                }
            }
        }
        awsAccountId = awsAccountIdDecoded0
        let idContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .id)
        var idDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let idContainer = idContainer {
            idDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in idContainer {
                if let structure0 = structure0 {
                    idDecoded0?.append(structure0)
                }
            }
        }
        id = idDecoded0
        let generatorIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .generatorId)
        var generatorIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let generatorIdContainer = generatorIdContainer {
            generatorIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in generatorIdContainer {
                if let structure0 = structure0 {
                    generatorIdDecoded0?.append(structure0)
                }
            }
        }
        generatorId = generatorIdDecoded0
        let regionContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .region)
        var regionDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let regionContainer = regionContainer {
            regionDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in regionContainer {
                if let structure0 = structure0 {
                    regionDecoded0?.append(structure0)
                }
            }
        }
        region = regionDecoded0
        let typeContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .type)
        var typeDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in typeContainer {
                if let structure0 = structure0 {
                    typeDecoded0?.append(structure0)
                }
            }
        }
        type = typeDecoded0
        let firstObservedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .firstObservedAt)
        var firstObservedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let firstObservedAtContainer = firstObservedAtContainer {
            firstObservedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in firstObservedAtContainer {
                if let structure0 = structure0 {
                    firstObservedAtDecoded0?.append(structure0)
                }
            }
        }
        firstObservedAt = firstObservedAtDecoded0
        let lastObservedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .lastObservedAt)
        var lastObservedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let lastObservedAtContainer = lastObservedAtContainer {
            lastObservedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in lastObservedAtContainer {
                if let structure0 = structure0 {
                    lastObservedAtDecoded0?.append(structure0)
                }
            }
        }
        lastObservedAt = lastObservedAtDecoded0
        let createdAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .createdAt)
        var createdAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let createdAtContainer = createdAtContainer {
            createdAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in createdAtContainer {
                if let structure0 = structure0 {
                    createdAtDecoded0?.append(structure0)
                }
            }
        }
        createdAt = createdAtDecoded0
        let updatedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .updatedAt)
        var updatedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let updatedAtContainer = updatedAtContainer {
            updatedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in updatedAtContainer {
                if let structure0 = structure0 {
                    updatedAtDecoded0?.append(structure0)
                }
            }
        }
        updatedAt = updatedAtDecoded0
        let severityProductContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .severityProduct)
        var severityProductDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let severityProductContainer = severityProductContainer {
            severityProductDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in severityProductContainer {
                if let structure0 = structure0 {
                    severityProductDecoded0?.append(structure0)
                }
            }
        }
        severityProduct = severityProductDecoded0
        let severityNormalizedContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .severityNormalized)
        var severityNormalizedDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let severityNormalizedContainer = severityNormalizedContainer {
            severityNormalizedDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in severityNormalizedContainer {
                if let structure0 = structure0 {
                    severityNormalizedDecoded0?.append(structure0)
                }
            }
        }
        severityNormalized = severityNormalizedDecoded0
        let severityLabelContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .severityLabel)
        var severityLabelDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let severityLabelContainer = severityLabelContainer {
            severityLabelDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in severityLabelContainer {
                if let structure0 = structure0 {
                    severityLabelDecoded0?.append(structure0)
                }
            }
        }
        severityLabel = severityLabelDecoded0
        let confidenceContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .confidence)
        var confidenceDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let confidenceContainer = confidenceContainer {
            confidenceDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in confidenceContainer {
                if let structure0 = structure0 {
                    confidenceDecoded0?.append(structure0)
                }
            }
        }
        confidence = confidenceDecoded0
        let criticalityContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .criticality)
        var criticalityDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let criticalityContainer = criticalityContainer {
            criticalityDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in criticalityContainer {
                if let structure0 = structure0 {
                    criticalityDecoded0?.append(structure0)
                }
            }
        }
        criticality = criticalityDecoded0
        let titleContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .title)
        var titleDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let titleContainer = titleContainer {
            titleDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in titleContainer {
                if let structure0 = structure0 {
                    titleDecoded0?.append(structure0)
                }
            }
        }
        title = titleDecoded0
        let descriptionContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .description)
        var descriptionDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let descriptionContainer = descriptionContainer {
            descriptionDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in descriptionContainer {
                if let structure0 = structure0 {
                    descriptionDecoded0?.append(structure0)
                }
            }
        }
        description = descriptionDecoded0
        let recommendationTextContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .recommendationText)
        var recommendationTextDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let recommendationTextContainer = recommendationTextContainer {
            recommendationTextDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in recommendationTextContainer {
                if let structure0 = structure0 {
                    recommendationTextDecoded0?.append(structure0)
                }
            }
        }
        recommendationText = recommendationTextDecoded0
        let sourceUrlContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .sourceUrl)
        var sourceUrlDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let sourceUrlContainer = sourceUrlContainer {
            sourceUrlDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in sourceUrlContainer {
                if let structure0 = structure0 {
                    sourceUrlDecoded0?.append(structure0)
                }
            }
        }
        sourceUrl = sourceUrlDecoded0
        let productFieldsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.MapFilter?].self, forKey: .productFields)
        var productFieldsDecoded0:[SecurityHubClientTypes.MapFilter]? = nil
        if let productFieldsContainer = productFieldsContainer {
            productFieldsDecoded0 = [SecurityHubClientTypes.MapFilter]()
            for structure0 in productFieldsContainer {
                if let structure0 = structure0 {
                    productFieldsDecoded0?.append(structure0)
                }
            }
        }
        productFields = productFieldsDecoded0
        let productNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .productName)
        var productNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let productNameContainer = productNameContainer {
            productNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in productNameContainer {
                if let structure0 = structure0 {
                    productNameDecoded0?.append(structure0)
                }
            }
        }
        productName = productNameDecoded0
        let companyNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .companyName)
        var companyNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let companyNameContainer = companyNameContainer {
            companyNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in companyNameContainer {
                if let structure0 = structure0 {
                    companyNameDecoded0?.append(structure0)
                }
            }
        }
        companyName = companyNameDecoded0
        let userDefinedFieldsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.MapFilter?].self, forKey: .userDefinedFields)
        var userDefinedFieldsDecoded0:[SecurityHubClientTypes.MapFilter]? = nil
        if let userDefinedFieldsContainer = userDefinedFieldsContainer {
            userDefinedFieldsDecoded0 = [SecurityHubClientTypes.MapFilter]()
            for structure0 in userDefinedFieldsContainer {
                if let structure0 = structure0 {
                    userDefinedFieldsDecoded0?.append(structure0)
                }
            }
        }
        userDefinedFields = userDefinedFieldsDecoded0
        let malwareNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .malwareName)
        var malwareNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let malwareNameContainer = malwareNameContainer {
            malwareNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in malwareNameContainer {
                if let structure0 = structure0 {
                    malwareNameDecoded0?.append(structure0)
                }
            }
        }
        malwareName = malwareNameDecoded0
        let malwareTypeContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .malwareType)
        var malwareTypeDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let malwareTypeContainer = malwareTypeContainer {
            malwareTypeDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in malwareTypeContainer {
                if let structure0 = structure0 {
                    malwareTypeDecoded0?.append(structure0)
                }
            }
        }
        malwareType = malwareTypeDecoded0
        let malwarePathContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .malwarePath)
        var malwarePathDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let malwarePathContainer = malwarePathContainer {
            malwarePathDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in malwarePathContainer {
                if let structure0 = structure0 {
                    malwarePathDecoded0?.append(structure0)
                }
            }
        }
        malwarePath = malwarePathDecoded0
        let malwareStateContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .malwareState)
        var malwareStateDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let malwareStateContainer = malwareStateContainer {
            malwareStateDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in malwareStateContainer {
                if let structure0 = structure0 {
                    malwareStateDecoded0?.append(structure0)
                }
            }
        }
        malwareState = malwareStateDecoded0
        let networkDirectionContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .networkDirection)
        var networkDirectionDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let networkDirectionContainer = networkDirectionContainer {
            networkDirectionDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in networkDirectionContainer {
                if let structure0 = structure0 {
                    networkDirectionDecoded0?.append(structure0)
                }
            }
        }
        networkDirection = networkDirectionDecoded0
        let networkProtocolContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .networkProtocol)
        var networkProtocolDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let networkProtocolContainer = networkProtocolContainer {
            networkProtocolDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in networkProtocolContainer {
                if let structure0 = structure0 {
                    networkProtocolDecoded0?.append(structure0)
                }
            }
        }
        networkProtocol = networkProtocolDecoded0
        let networkSourceIpV4Container = try containerValues.decodeIfPresent([SecurityHubClientTypes.IpFilter?].self, forKey: .networkSourceIpV4)
        var networkSourceIpV4Decoded0:[SecurityHubClientTypes.IpFilter]? = nil
        if let networkSourceIpV4Container = networkSourceIpV4Container {
            networkSourceIpV4Decoded0 = [SecurityHubClientTypes.IpFilter]()
            for structure0 in networkSourceIpV4Container {
                if let structure0 = structure0 {
                    networkSourceIpV4Decoded0?.append(structure0)
                }
            }
        }
        networkSourceIpV4 = networkSourceIpV4Decoded0
        let networkSourceIpV6Container = try containerValues.decodeIfPresent([SecurityHubClientTypes.IpFilter?].self, forKey: .networkSourceIpV6)
        var networkSourceIpV6Decoded0:[SecurityHubClientTypes.IpFilter]? = nil
        if let networkSourceIpV6Container = networkSourceIpV6Container {
            networkSourceIpV6Decoded0 = [SecurityHubClientTypes.IpFilter]()
            for structure0 in networkSourceIpV6Container {
                if let structure0 = structure0 {
                    networkSourceIpV6Decoded0?.append(structure0)
                }
            }
        }
        networkSourceIpV6 = networkSourceIpV6Decoded0
        let networkSourcePortContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .networkSourcePort)
        var networkSourcePortDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let networkSourcePortContainer = networkSourcePortContainer {
            networkSourcePortDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in networkSourcePortContainer {
                if let structure0 = structure0 {
                    networkSourcePortDecoded0?.append(structure0)
                }
            }
        }
        networkSourcePort = networkSourcePortDecoded0
        let networkSourceDomainContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .networkSourceDomain)
        var networkSourceDomainDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let networkSourceDomainContainer = networkSourceDomainContainer {
            networkSourceDomainDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in networkSourceDomainContainer {
                if let structure0 = structure0 {
                    networkSourceDomainDecoded0?.append(structure0)
                }
            }
        }
        networkSourceDomain = networkSourceDomainDecoded0
        let networkSourceMacContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .networkSourceMac)
        var networkSourceMacDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let networkSourceMacContainer = networkSourceMacContainer {
            networkSourceMacDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in networkSourceMacContainer {
                if let structure0 = structure0 {
                    networkSourceMacDecoded0?.append(structure0)
                }
            }
        }
        networkSourceMac = networkSourceMacDecoded0
        let networkDestinationIpV4Container = try containerValues.decodeIfPresent([SecurityHubClientTypes.IpFilter?].self, forKey: .networkDestinationIpV4)
        var networkDestinationIpV4Decoded0:[SecurityHubClientTypes.IpFilter]? = nil
        if let networkDestinationIpV4Container = networkDestinationIpV4Container {
            networkDestinationIpV4Decoded0 = [SecurityHubClientTypes.IpFilter]()
            for structure0 in networkDestinationIpV4Container {
                if let structure0 = structure0 {
                    networkDestinationIpV4Decoded0?.append(structure0)
                }
            }
        }
        networkDestinationIpV4 = networkDestinationIpV4Decoded0
        let networkDestinationIpV6Container = try containerValues.decodeIfPresent([SecurityHubClientTypes.IpFilter?].self, forKey: .networkDestinationIpV6)
        var networkDestinationIpV6Decoded0:[SecurityHubClientTypes.IpFilter]? = nil
        if let networkDestinationIpV6Container = networkDestinationIpV6Container {
            networkDestinationIpV6Decoded0 = [SecurityHubClientTypes.IpFilter]()
            for structure0 in networkDestinationIpV6Container {
                if let structure0 = structure0 {
                    networkDestinationIpV6Decoded0?.append(structure0)
                }
            }
        }
        networkDestinationIpV6 = networkDestinationIpV6Decoded0
        let networkDestinationPortContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .networkDestinationPort)
        var networkDestinationPortDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let networkDestinationPortContainer = networkDestinationPortContainer {
            networkDestinationPortDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in networkDestinationPortContainer {
                if let structure0 = structure0 {
                    networkDestinationPortDecoded0?.append(structure0)
                }
            }
        }
        networkDestinationPort = networkDestinationPortDecoded0
        let networkDestinationDomainContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .networkDestinationDomain)
        var networkDestinationDomainDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let networkDestinationDomainContainer = networkDestinationDomainContainer {
            networkDestinationDomainDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in networkDestinationDomainContainer {
                if let structure0 = structure0 {
                    networkDestinationDomainDecoded0?.append(structure0)
                }
            }
        }
        networkDestinationDomain = networkDestinationDomainDecoded0
        let processNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .processName)
        var processNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let processNameContainer = processNameContainer {
            processNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in processNameContainer {
                if let structure0 = structure0 {
                    processNameDecoded0?.append(structure0)
                }
            }
        }
        processName = processNameDecoded0
        let processPathContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .processPath)
        var processPathDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let processPathContainer = processPathContainer {
            processPathDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in processPathContainer {
                if let structure0 = structure0 {
                    processPathDecoded0?.append(structure0)
                }
            }
        }
        processPath = processPathDecoded0
        let processPidContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .processPid)
        var processPidDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let processPidContainer = processPidContainer {
            processPidDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in processPidContainer {
                if let structure0 = structure0 {
                    processPidDecoded0?.append(structure0)
                }
            }
        }
        processPid = processPidDecoded0
        let processParentPidContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .processParentPid)
        var processParentPidDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let processParentPidContainer = processParentPidContainer {
            processParentPidDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in processParentPidContainer {
                if let structure0 = structure0 {
                    processParentPidDecoded0?.append(structure0)
                }
            }
        }
        processParentPid = processParentPidDecoded0
        let processLaunchedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .processLaunchedAt)
        var processLaunchedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let processLaunchedAtContainer = processLaunchedAtContainer {
            processLaunchedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in processLaunchedAtContainer {
                if let structure0 = structure0 {
                    processLaunchedAtDecoded0?.append(structure0)
                }
            }
        }
        processLaunchedAt = processLaunchedAtDecoded0
        let processTerminatedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .processTerminatedAt)
        var processTerminatedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let processTerminatedAtContainer = processTerminatedAtContainer {
            processTerminatedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in processTerminatedAtContainer {
                if let structure0 = structure0 {
                    processTerminatedAtDecoded0?.append(structure0)
                }
            }
        }
        processTerminatedAt = processTerminatedAtDecoded0
        let threatIntelIndicatorTypeContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .threatIntelIndicatorType)
        var threatIntelIndicatorTypeDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let threatIntelIndicatorTypeContainer = threatIntelIndicatorTypeContainer {
            threatIntelIndicatorTypeDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in threatIntelIndicatorTypeContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorTypeDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorType = threatIntelIndicatorTypeDecoded0
        let threatIntelIndicatorValueContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .threatIntelIndicatorValue)
        var threatIntelIndicatorValueDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let threatIntelIndicatorValueContainer = threatIntelIndicatorValueContainer {
            threatIntelIndicatorValueDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in threatIntelIndicatorValueContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorValueDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorValue = threatIntelIndicatorValueDecoded0
        let threatIntelIndicatorCategoryContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .threatIntelIndicatorCategory)
        var threatIntelIndicatorCategoryDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let threatIntelIndicatorCategoryContainer = threatIntelIndicatorCategoryContainer {
            threatIntelIndicatorCategoryDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in threatIntelIndicatorCategoryContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorCategoryDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorCategory = threatIntelIndicatorCategoryDecoded0
        let threatIntelIndicatorLastObservedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .threatIntelIndicatorLastObservedAt)
        var threatIntelIndicatorLastObservedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let threatIntelIndicatorLastObservedAtContainer = threatIntelIndicatorLastObservedAtContainer {
            threatIntelIndicatorLastObservedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in threatIntelIndicatorLastObservedAtContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorLastObservedAtDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAtDecoded0
        let threatIntelIndicatorSourceContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .threatIntelIndicatorSource)
        var threatIntelIndicatorSourceDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let threatIntelIndicatorSourceContainer = threatIntelIndicatorSourceContainer {
            threatIntelIndicatorSourceDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in threatIntelIndicatorSourceContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorSourceDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorSource = threatIntelIndicatorSourceDecoded0
        let threatIntelIndicatorSourceUrlContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .threatIntelIndicatorSourceUrl)
        var threatIntelIndicatorSourceUrlDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let threatIntelIndicatorSourceUrlContainer = threatIntelIndicatorSourceUrlContainer {
            threatIntelIndicatorSourceUrlDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in threatIntelIndicatorSourceUrlContainer {
                if let structure0 = structure0 {
                    threatIntelIndicatorSourceUrlDecoded0?.append(structure0)
                }
            }
        }
        threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrlDecoded0
        let resourceTypeContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceType)
        var resourceTypeDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceTypeContainer = resourceTypeContainer {
            resourceTypeDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceTypeContainer {
                if let structure0 = structure0 {
                    resourceTypeDecoded0?.append(structure0)
                }
            }
        }
        resourceType = resourceTypeDecoded0
        let resourceIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceId)
        var resourceIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceIdContainer = resourceIdContainer {
            resourceIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceIdContainer {
                if let structure0 = structure0 {
                    resourceIdDecoded0?.append(structure0)
                }
            }
        }
        resourceId = resourceIdDecoded0
        let resourcePartitionContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourcePartition)
        var resourcePartitionDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourcePartitionContainer = resourcePartitionContainer {
            resourcePartitionDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourcePartitionContainer {
                if let structure0 = structure0 {
                    resourcePartitionDecoded0?.append(structure0)
                }
            }
        }
        resourcePartition = resourcePartitionDecoded0
        let resourceRegionContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceRegion)
        var resourceRegionDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceRegionContainer = resourceRegionContainer {
            resourceRegionDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceRegionContainer {
                if let structure0 = structure0 {
                    resourceRegionDecoded0?.append(structure0)
                }
            }
        }
        resourceRegion = resourceRegionDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.MapFilter?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[SecurityHubClientTypes.MapFilter]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [SecurityHubClientTypes.MapFilter]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let resourceAwsEc2InstanceTypeContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsEc2InstanceType)
        var resourceAwsEc2InstanceTypeDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsEc2InstanceTypeContainer = resourceAwsEc2InstanceTypeContainer {
            resourceAwsEc2InstanceTypeDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsEc2InstanceTypeContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceTypeDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceType = resourceAwsEc2InstanceTypeDecoded0
        let resourceAwsEc2InstanceImageIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsEc2InstanceImageId)
        var resourceAwsEc2InstanceImageIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsEc2InstanceImageIdContainer = resourceAwsEc2InstanceImageIdContainer {
            resourceAwsEc2InstanceImageIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsEc2InstanceImageIdContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceImageIdDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageIdDecoded0
        let resourceAwsEc2InstanceIpV4AddressesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.IpFilter?].self, forKey: .resourceAwsEc2InstanceIpV4Addresses)
        var resourceAwsEc2InstanceIpV4AddressesDecoded0:[SecurityHubClientTypes.IpFilter]? = nil
        if let resourceAwsEc2InstanceIpV4AddressesContainer = resourceAwsEc2InstanceIpV4AddressesContainer {
            resourceAwsEc2InstanceIpV4AddressesDecoded0 = [SecurityHubClientTypes.IpFilter]()
            for structure0 in resourceAwsEc2InstanceIpV4AddressesContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceIpV4AddressesDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4AddressesDecoded0
        let resourceAwsEc2InstanceIpV6AddressesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.IpFilter?].self, forKey: .resourceAwsEc2InstanceIpV6Addresses)
        var resourceAwsEc2InstanceIpV6AddressesDecoded0:[SecurityHubClientTypes.IpFilter]? = nil
        if let resourceAwsEc2InstanceIpV6AddressesContainer = resourceAwsEc2InstanceIpV6AddressesContainer {
            resourceAwsEc2InstanceIpV6AddressesDecoded0 = [SecurityHubClientTypes.IpFilter]()
            for structure0 in resourceAwsEc2InstanceIpV6AddressesContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceIpV6AddressesDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6AddressesDecoded0
        let resourceAwsEc2InstanceKeyNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsEc2InstanceKeyName)
        var resourceAwsEc2InstanceKeyNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsEc2InstanceKeyNameContainer = resourceAwsEc2InstanceKeyNameContainer {
            resourceAwsEc2InstanceKeyNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsEc2InstanceKeyNameContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceKeyNameDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyNameDecoded0
        let resourceAwsEc2InstanceIamInstanceProfileArnContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsEc2InstanceIamInstanceProfileArn)
        var resourceAwsEc2InstanceIamInstanceProfileArnDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsEc2InstanceIamInstanceProfileArnContainer = resourceAwsEc2InstanceIamInstanceProfileArnContainer {
            resourceAwsEc2InstanceIamInstanceProfileArnDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsEc2InstanceIamInstanceProfileArnContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceIamInstanceProfileArnDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArnDecoded0
        let resourceAwsEc2InstanceVpcIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsEc2InstanceVpcId)
        var resourceAwsEc2InstanceVpcIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsEc2InstanceVpcIdContainer = resourceAwsEc2InstanceVpcIdContainer {
            resourceAwsEc2InstanceVpcIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsEc2InstanceVpcIdContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceVpcIdDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcIdDecoded0
        let resourceAwsEc2InstanceSubnetIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsEc2InstanceSubnetId)
        var resourceAwsEc2InstanceSubnetIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsEc2InstanceSubnetIdContainer = resourceAwsEc2InstanceSubnetIdContainer {
            resourceAwsEc2InstanceSubnetIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsEc2InstanceSubnetIdContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceSubnetIdDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetIdDecoded0
        let resourceAwsEc2InstanceLaunchedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .resourceAwsEc2InstanceLaunchedAt)
        var resourceAwsEc2InstanceLaunchedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let resourceAwsEc2InstanceLaunchedAtContainer = resourceAwsEc2InstanceLaunchedAtContainer {
            resourceAwsEc2InstanceLaunchedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in resourceAwsEc2InstanceLaunchedAtContainer {
                if let structure0 = structure0 {
                    resourceAwsEc2InstanceLaunchedAtDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAtDecoded0
        let resourceAwsS3BucketOwnerIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsS3BucketOwnerId)
        var resourceAwsS3BucketOwnerIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsS3BucketOwnerIdContainer = resourceAwsS3BucketOwnerIdContainer {
            resourceAwsS3BucketOwnerIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsS3BucketOwnerIdContainer {
                if let structure0 = structure0 {
                    resourceAwsS3BucketOwnerIdDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerIdDecoded0
        let resourceAwsS3BucketOwnerNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsS3BucketOwnerName)
        var resourceAwsS3BucketOwnerNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsS3BucketOwnerNameContainer = resourceAwsS3BucketOwnerNameContainer {
            resourceAwsS3BucketOwnerNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsS3BucketOwnerNameContainer {
                if let structure0 = structure0 {
                    resourceAwsS3BucketOwnerNameDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerNameDecoded0
        let resourceAwsIamAccessKeyUserNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsIamAccessKeyUserName)
        var resourceAwsIamAccessKeyUserNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsIamAccessKeyUserNameContainer = resourceAwsIamAccessKeyUserNameContainer {
            resourceAwsIamAccessKeyUserNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsIamAccessKeyUserNameContainer {
                if let structure0 = structure0 {
                    resourceAwsIamAccessKeyUserNameDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserNameDecoded0
        let resourceAwsIamAccessKeyPrincipalNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsIamAccessKeyPrincipalName)
        var resourceAwsIamAccessKeyPrincipalNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsIamAccessKeyPrincipalNameContainer = resourceAwsIamAccessKeyPrincipalNameContainer {
            resourceAwsIamAccessKeyPrincipalNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsIamAccessKeyPrincipalNameContainer {
                if let structure0 = structure0 {
                    resourceAwsIamAccessKeyPrincipalNameDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsIamAccessKeyPrincipalName = resourceAwsIamAccessKeyPrincipalNameDecoded0
        let resourceAwsIamAccessKeyStatusContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsIamAccessKeyStatus)
        var resourceAwsIamAccessKeyStatusDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsIamAccessKeyStatusContainer = resourceAwsIamAccessKeyStatusContainer {
            resourceAwsIamAccessKeyStatusDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsIamAccessKeyStatusContainer {
                if let structure0 = structure0 {
                    resourceAwsIamAccessKeyStatusDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatusDecoded0
        let resourceAwsIamAccessKeyCreatedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .resourceAwsIamAccessKeyCreatedAt)
        var resourceAwsIamAccessKeyCreatedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let resourceAwsIamAccessKeyCreatedAtContainer = resourceAwsIamAccessKeyCreatedAtContainer {
            resourceAwsIamAccessKeyCreatedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in resourceAwsIamAccessKeyCreatedAtContainer {
                if let structure0 = structure0 {
                    resourceAwsIamAccessKeyCreatedAtDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAtDecoded0
        let resourceAwsIamUserUserNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceAwsIamUserUserName)
        var resourceAwsIamUserUserNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceAwsIamUserUserNameContainer = resourceAwsIamUserUserNameContainer {
            resourceAwsIamUserUserNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceAwsIamUserUserNameContainer {
                if let structure0 = structure0 {
                    resourceAwsIamUserUserNameDecoded0?.append(structure0)
                }
            }
        }
        resourceAwsIamUserUserName = resourceAwsIamUserUserNameDecoded0
        let resourceContainerNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceContainerName)
        var resourceContainerNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceContainerNameContainer = resourceContainerNameContainer {
            resourceContainerNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceContainerNameContainer {
                if let structure0 = structure0 {
                    resourceContainerNameDecoded0?.append(structure0)
                }
            }
        }
        resourceContainerName = resourceContainerNameDecoded0
        let resourceContainerImageIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceContainerImageId)
        var resourceContainerImageIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceContainerImageIdContainer = resourceContainerImageIdContainer {
            resourceContainerImageIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceContainerImageIdContainer {
                if let structure0 = structure0 {
                    resourceContainerImageIdDecoded0?.append(structure0)
                }
            }
        }
        resourceContainerImageId = resourceContainerImageIdDecoded0
        let resourceContainerImageNameContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .resourceContainerImageName)
        var resourceContainerImageNameDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let resourceContainerImageNameContainer = resourceContainerImageNameContainer {
            resourceContainerImageNameDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in resourceContainerImageNameContainer {
                if let structure0 = structure0 {
                    resourceContainerImageNameDecoded0?.append(structure0)
                }
            }
        }
        resourceContainerImageName = resourceContainerImageNameDecoded0
        let resourceContainerLaunchedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .resourceContainerLaunchedAt)
        var resourceContainerLaunchedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let resourceContainerLaunchedAtContainer = resourceContainerLaunchedAtContainer {
            resourceContainerLaunchedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in resourceContainerLaunchedAtContainer {
                if let structure0 = structure0 {
                    resourceContainerLaunchedAtDecoded0?.append(structure0)
                }
            }
        }
        resourceContainerLaunchedAt = resourceContainerLaunchedAtDecoded0
        let resourceDetailsOtherContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.MapFilter?].self, forKey: .resourceDetailsOther)
        var resourceDetailsOtherDecoded0:[SecurityHubClientTypes.MapFilter]? = nil
        if let resourceDetailsOtherContainer = resourceDetailsOtherContainer {
            resourceDetailsOtherDecoded0 = [SecurityHubClientTypes.MapFilter]()
            for structure0 in resourceDetailsOtherContainer {
                if let structure0 = structure0 {
                    resourceDetailsOtherDecoded0?.append(structure0)
                }
            }
        }
        resourceDetailsOther = resourceDetailsOtherDecoded0
        let complianceStatusContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .complianceStatus)
        var complianceStatusDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let complianceStatusContainer = complianceStatusContainer {
            complianceStatusDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in complianceStatusContainer {
                if let structure0 = structure0 {
                    complianceStatusDecoded0?.append(structure0)
                }
            }
        }
        complianceStatus = complianceStatusDecoded0
        let verificationStateContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .verificationState)
        var verificationStateDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let verificationStateContainer = verificationStateContainer {
            verificationStateDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in verificationStateContainer {
                if let structure0 = structure0 {
                    verificationStateDecoded0?.append(structure0)
                }
            }
        }
        verificationState = verificationStateDecoded0
        let workflowStateContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .workflowState)
        var workflowStateDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let workflowStateContainer = workflowStateContainer {
            workflowStateDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in workflowStateContainer {
                if let structure0 = structure0 {
                    workflowStateDecoded0?.append(structure0)
                }
            }
        }
        workflowState = workflowStateDecoded0
        let workflowStatusContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .workflowStatus)
        var workflowStatusDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let workflowStatusContainer = workflowStatusContainer {
            workflowStatusDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in workflowStatusContainer {
                if let structure0 = structure0 {
                    workflowStatusDecoded0?.append(structure0)
                }
            }
        }
        workflowStatus = workflowStatusDecoded0
        let recordStateContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .recordState)
        var recordStateDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let recordStateContainer = recordStateContainer {
            recordStateDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in recordStateContainer {
                if let structure0 = structure0 {
                    recordStateDecoded0?.append(structure0)
                }
            }
        }
        recordState = recordStateDecoded0
        let relatedFindingsProductArnContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .relatedFindingsProductArn)
        var relatedFindingsProductArnDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let relatedFindingsProductArnContainer = relatedFindingsProductArnContainer {
            relatedFindingsProductArnDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in relatedFindingsProductArnContainer {
                if let structure0 = structure0 {
                    relatedFindingsProductArnDecoded0?.append(structure0)
                }
            }
        }
        relatedFindingsProductArn = relatedFindingsProductArnDecoded0
        let relatedFindingsIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .relatedFindingsId)
        var relatedFindingsIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let relatedFindingsIdContainer = relatedFindingsIdContainer {
            relatedFindingsIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in relatedFindingsIdContainer {
                if let structure0 = structure0 {
                    relatedFindingsIdDecoded0?.append(structure0)
                }
            }
        }
        relatedFindingsId = relatedFindingsIdDecoded0
        let noteTextContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .noteText)
        var noteTextDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let noteTextContainer = noteTextContainer {
            noteTextDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in noteTextContainer {
                if let structure0 = structure0 {
                    noteTextDecoded0?.append(structure0)
                }
            }
        }
        noteText = noteTextDecoded0
        let noteUpdatedAtContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.DateFilter?].self, forKey: .noteUpdatedAt)
        var noteUpdatedAtDecoded0:[SecurityHubClientTypes.DateFilter]? = nil
        if let noteUpdatedAtContainer = noteUpdatedAtContainer {
            noteUpdatedAtDecoded0 = [SecurityHubClientTypes.DateFilter]()
            for structure0 in noteUpdatedAtContainer {
                if let structure0 = structure0 {
                    noteUpdatedAtDecoded0?.append(structure0)
                }
            }
        }
        noteUpdatedAt = noteUpdatedAtDecoded0
        let noteUpdatedByContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .noteUpdatedBy)
        var noteUpdatedByDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let noteUpdatedByContainer = noteUpdatedByContainer {
            noteUpdatedByDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in noteUpdatedByContainer {
                if let structure0 = structure0 {
                    noteUpdatedByDecoded0?.append(structure0)
                }
            }
        }
        noteUpdatedBy = noteUpdatedByDecoded0
        let keywordContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.KeywordFilter?].self, forKey: .keyword)
        var keywordDecoded0:[SecurityHubClientTypes.KeywordFilter]? = nil
        if let keywordContainer = keywordContainer {
            keywordDecoded0 = [SecurityHubClientTypes.KeywordFilter]()
            for structure0 in keywordContainer {
                if let structure0 = structure0 {
                    keywordDecoded0?.append(structure0)
                }
            }
        }
        keyword = keywordDecoded0
        let findingProviderFieldsConfidenceContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .findingProviderFieldsConfidence)
        var findingProviderFieldsConfidenceDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let findingProviderFieldsConfidenceContainer = findingProviderFieldsConfidenceContainer {
            findingProviderFieldsConfidenceDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in findingProviderFieldsConfidenceContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsConfidenceDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsConfidence = findingProviderFieldsConfidenceDecoded0
        let findingProviderFieldsCriticalityContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.NumberFilter?].self, forKey: .findingProviderFieldsCriticality)
        var findingProviderFieldsCriticalityDecoded0:[SecurityHubClientTypes.NumberFilter]? = nil
        if let findingProviderFieldsCriticalityContainer = findingProviderFieldsCriticalityContainer {
            findingProviderFieldsCriticalityDecoded0 = [SecurityHubClientTypes.NumberFilter]()
            for structure0 in findingProviderFieldsCriticalityContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsCriticalityDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsCriticality = findingProviderFieldsCriticalityDecoded0
        let findingProviderFieldsRelatedFindingsIdContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .findingProviderFieldsRelatedFindingsId)
        var findingProviderFieldsRelatedFindingsIdDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let findingProviderFieldsRelatedFindingsIdContainer = findingProviderFieldsRelatedFindingsIdContainer {
            findingProviderFieldsRelatedFindingsIdDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in findingProviderFieldsRelatedFindingsIdContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsRelatedFindingsIdDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsIdDecoded0
        let findingProviderFieldsRelatedFindingsProductArnContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .findingProviderFieldsRelatedFindingsProductArn)
        var findingProviderFieldsRelatedFindingsProductArnDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let findingProviderFieldsRelatedFindingsProductArnContainer = findingProviderFieldsRelatedFindingsProductArnContainer {
            findingProviderFieldsRelatedFindingsProductArnDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in findingProviderFieldsRelatedFindingsProductArnContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsRelatedFindingsProductArnDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArnDecoded0
        let findingProviderFieldsSeverityLabelContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .findingProviderFieldsSeverityLabel)
        var findingProviderFieldsSeverityLabelDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let findingProviderFieldsSeverityLabelContainer = findingProviderFieldsSeverityLabelContainer {
            findingProviderFieldsSeverityLabelDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in findingProviderFieldsSeverityLabelContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsSeverityLabelDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabelDecoded0
        let findingProviderFieldsSeverityOriginalContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .findingProviderFieldsSeverityOriginal)
        var findingProviderFieldsSeverityOriginalDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let findingProviderFieldsSeverityOriginalContainer = findingProviderFieldsSeverityOriginalContainer {
            findingProviderFieldsSeverityOriginalDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in findingProviderFieldsSeverityOriginalContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsSeverityOriginalDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginalDecoded0
        let findingProviderFieldsTypesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StringFilter?].self, forKey: .findingProviderFieldsTypes)
        var findingProviderFieldsTypesDecoded0:[SecurityHubClientTypes.StringFilter]? = nil
        if let findingProviderFieldsTypesContainer = findingProviderFieldsTypesContainer {
            findingProviderFieldsTypesDecoded0 = [SecurityHubClientTypes.StringFilter]()
            for structure0 in findingProviderFieldsTypesContainer {
                if let structure0 = structure0 {
                    findingProviderFieldsTypesDecoded0?.append(structure0)
                }
            }
        }
        findingProviderFieldsTypes = findingProviderFieldsTypesDecoded0
        let sampleContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.BooleanFilter?].self, forKey: .sample)
        var sampleDecoded0:[SecurityHubClientTypes.BooleanFilter]? = nil
        if let sampleContainer = sampleContainer {
            sampleDecoded0 = [SecurityHubClientTypes.BooleanFilter]()
            for structure0 in sampleContainer {
                if let structure0 = structure0 {
                    sampleDecoded0?.append(structure0)
                }
            }
        }
        sample = sampleDecoded0
    }
}

extension SecurityHubClientTypes {
    /// A collection of attributes that are applied to all active Security Hub-aggregated findings and that result in a subset of findings that are included in this insight. You can filter by up to 10 finding attributes. For each attribute, you can provide up to 20 filter values.
    public struct AwsSecurityFindingFilters: Swift.Equatable {
        /// The Amazon Web Services account ID that a finding is generated in.
        public var awsAccountId: [SecurityHubClientTypes.StringFilter]?
        /// The name of the findings provider (company) that owns the solution (product) that generates findings.
        public var companyName: [SecurityHubClientTypes.StringFilter]?
        /// Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS Amazon Web Services Foundations. Contains security standard-related finding details.
        public var complianceStatus: [SecurityHubClientTypes.StringFilter]?
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public var confidence: [SecurityHubClientTypes.NumberFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured.
        public var createdAt: [SecurityHubClientTypes.DateFilter]?
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public var criticality: [SecurityHubClientTypes.NumberFilter]?
        /// A finding's description.
        public var description: [SecurityHubClientTypes.StringFilter]?
        /// The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public var findingProviderFieldsConfidence: [SecurityHubClientTypes.NumberFilter]?
        /// The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public var findingProviderFieldsCriticality: [SecurityHubClientTypes.NumberFilter]?
        /// The finding identifier of a related finding that is identified by the finding provider.
        public var findingProviderFieldsRelatedFindingsId: [SecurityHubClientTypes.StringFilter]?
        /// The ARN of the solution that generated a related finding that is identified by the finding provider.
        public var findingProviderFieldsRelatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]?
        /// The finding provider value for the severity label.
        public var findingProviderFieldsSeverityLabel: [SecurityHubClientTypes.StringFilter]?
        /// The finding provider's original value for the severity.
        public var findingProviderFieldsSeverityOriginal: [SecurityHubClientTypes.StringFilter]?
        /// One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public var findingProviderFieldsTypes: [SecurityHubClientTypes.StringFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured.
        public var firstObservedAt: [SecurityHubClientTypes.DateFilter]?
        /// The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. In various security-findings providers' solutions, this generator can be called a rule, a check, a detector, a plugin, etc.
        public var generatorId: [SecurityHubClientTypes.StringFilter]?
        /// The security findings provider-specific identifier for a finding.
        public var id: [SecurityHubClientTypes.StringFilter]?
        /// A keyword for a finding.
        @available(*, deprecated, message: "The Keyword property is deprecated.")
        public var keyword: [SecurityHubClientTypes.KeywordFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured.
        public var lastObservedAt: [SecurityHubClientTypes.DateFilter]?
        /// The name of the malware that was observed.
        public var malwareName: [SecurityHubClientTypes.StringFilter]?
        /// The filesystem path of the malware that was observed.
        public var malwarePath: [SecurityHubClientTypes.StringFilter]?
        /// The state of the malware that was observed.
        public var malwareState: [SecurityHubClientTypes.StringFilter]?
        /// The type of the malware that was observed.
        public var malwareType: [SecurityHubClientTypes.StringFilter]?
        /// The destination domain of network-related information about a finding.
        public var networkDestinationDomain: [SecurityHubClientTypes.StringFilter]?
        /// The destination IPv4 address of network-related information about a finding.
        public var networkDestinationIpV4: [SecurityHubClientTypes.IpFilter]?
        /// The destination IPv6 address of network-related information about a finding.
        public var networkDestinationIpV6: [SecurityHubClientTypes.IpFilter]?
        /// The destination port of network-related information about a finding.
        public var networkDestinationPort: [SecurityHubClientTypes.NumberFilter]?
        /// Indicates the direction of network traffic associated with a finding.
        public var networkDirection: [SecurityHubClientTypes.StringFilter]?
        /// The protocol of network-related information about a finding.
        public var networkProtocol: [SecurityHubClientTypes.StringFilter]?
        /// The source domain of network-related information about a finding.
        public var networkSourceDomain: [SecurityHubClientTypes.StringFilter]?
        /// The source IPv4 address of network-related information about a finding.
        public var networkSourceIpV4: [SecurityHubClientTypes.IpFilter]?
        /// The source IPv6 address of network-related information about a finding.
        public var networkSourceIpV6: [SecurityHubClientTypes.IpFilter]?
        /// The source media access control (MAC) address of network-related information about a finding.
        public var networkSourceMac: [SecurityHubClientTypes.StringFilter]?
        /// The source port of network-related information about a finding.
        public var networkSourcePort: [SecurityHubClientTypes.NumberFilter]?
        /// The text of a note.
        public var noteText: [SecurityHubClientTypes.StringFilter]?
        /// The timestamp of when the note was updated.
        public var noteUpdatedAt: [SecurityHubClientTypes.DateFilter]?
        /// The principal that created a note.
        public var noteUpdatedBy: [SecurityHubClientTypes.StringFilter]?
        /// The date/time that the process was launched.
        public var processLaunchedAt: [SecurityHubClientTypes.DateFilter]?
        /// The name of the process.
        public var processName: [SecurityHubClientTypes.StringFilter]?
        /// The parent process ID.
        public var processParentPid: [SecurityHubClientTypes.NumberFilter]?
        /// The path to the process executable.
        public var processPath: [SecurityHubClientTypes.StringFilter]?
        /// The process ID.
        public var processPid: [SecurityHubClientTypes.NumberFilter]?
        /// The date/time that the process was terminated.
        public var processTerminatedAt: [SecurityHubClientTypes.DateFilter]?
        /// The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub.
        public var productArn: [SecurityHubClientTypes.StringFilter]?
        /// A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format.
        public var productFields: [SecurityHubClientTypes.MapFilter]?
        /// The name of the solution (product) that generates findings.
        public var productName: [SecurityHubClientTypes.StringFilter]?
        /// The recommendation of what to do about the issue described in a finding.
        public var recommendationText: [SecurityHubClientTypes.StringFilter]?
        /// The updated record state for the finding.
        public var recordState: [SecurityHubClientTypes.StringFilter]?
        /// The Region from which the finding was generated.
        public var region: [SecurityHubClientTypes.StringFilter]?
        /// The solution-generated identifier for a related finding.
        public var relatedFindingsId: [SecurityHubClientTypes.StringFilter]?
        /// The ARN of the solution that generated a related finding.
        public var relatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]?
        /// The IAM profile ARN of the instance.
        public var resourceAwsEc2InstanceIamInstanceProfileArn: [SecurityHubClientTypes.StringFilter]?
        /// The Amazon Machine Image (AMI) ID of the instance.
        public var resourceAwsEc2InstanceImageId: [SecurityHubClientTypes.StringFilter]?
        /// The IPv4 addresses associated with the instance.
        public var resourceAwsEc2InstanceIpV4Addresses: [SecurityHubClientTypes.IpFilter]?
        /// The IPv6 addresses associated with the instance.
        public var resourceAwsEc2InstanceIpV6Addresses: [SecurityHubClientTypes.IpFilter]?
        /// The key name associated with the instance.
        public var resourceAwsEc2InstanceKeyName: [SecurityHubClientTypes.StringFilter]?
        /// The date and time the instance was launched.
        public var resourceAwsEc2InstanceLaunchedAt: [SecurityHubClientTypes.DateFilter]?
        /// The identifier of the subnet that the instance was launched in.
        public var resourceAwsEc2InstanceSubnetId: [SecurityHubClientTypes.StringFilter]?
        /// The instance type of the instance.
        public var resourceAwsEc2InstanceType: [SecurityHubClientTypes.StringFilter]?
        /// The identifier of the VPC that the instance was launched in.
        public var resourceAwsEc2InstanceVpcId: [SecurityHubClientTypes.StringFilter]?
        /// The creation date/time of the IAM access key related to a finding.
        public var resourceAwsIamAccessKeyCreatedAt: [SecurityHubClientTypes.DateFilter]?
        /// The name of the principal that is associated with an IAM access key.
        public var resourceAwsIamAccessKeyPrincipalName: [SecurityHubClientTypes.StringFilter]?
        /// The status of the IAM access key related to a finding.
        public var resourceAwsIamAccessKeyStatus: [SecurityHubClientTypes.StringFilter]?
        /// The user associated with the IAM access key related to a finding.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use ResourceAwsIamAccessKeyPrincipalName.")
        public var resourceAwsIamAccessKeyUserName: [SecurityHubClientTypes.StringFilter]?
        /// The name of an IAM user.
        public var resourceAwsIamUserUserName: [SecurityHubClientTypes.StringFilter]?
        /// The canonical user ID of the owner of the S3 bucket.
        public var resourceAwsS3BucketOwnerId: [SecurityHubClientTypes.StringFilter]?
        /// The display name of the owner of the S3 bucket.
        public var resourceAwsS3BucketOwnerName: [SecurityHubClientTypes.StringFilter]?
        /// The identifier of the image related to a finding.
        public var resourceContainerImageId: [SecurityHubClientTypes.StringFilter]?
        /// The name of the image related to a finding.
        public var resourceContainerImageName: [SecurityHubClientTypes.StringFilter]?
        /// The date/time that the container was started.
        public var resourceContainerLaunchedAt: [SecurityHubClientTypes.DateFilter]?
        /// The name of the container related to a finding.
        public var resourceContainerName: [SecurityHubClientTypes.StringFilter]?
        /// The details of a resource that doesn't have a specific subfield for the resource type defined.
        public var resourceDetailsOther: [SecurityHubClientTypes.MapFilter]?
        /// The canonical identifier for the given resource type.
        public var resourceId: [SecurityHubClientTypes.StringFilter]?
        /// The canonical Amazon Web Services partition name that the Region is assigned to.
        public var resourcePartition: [SecurityHubClientTypes.StringFilter]?
        /// The canonical Amazon Web Services external Region name where this resource is located.
        public var resourceRegion: [SecurityHubClientTypes.StringFilter]?
        /// A list of Amazon Web Services tags associated with a resource at the time the finding was processed.
        public var resourceTags: [SecurityHubClientTypes.MapFilter]?
        /// Specifies the type of the resource that details are provided for.
        public var resourceType: [SecurityHubClientTypes.StringFilter]?
        /// Indicates whether or not sample findings are included in the filter results.
        public var sample: [SecurityHubClientTypes.BooleanFilter]?
        /// The label of a finding's severity.
        public var severityLabel: [SecurityHubClientTypes.StringFilter]?
        /// The normalized severity of a finding.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use SeverityLabel or FindingProviderFieldsSeverityLabel.")
        public var severityNormalized: [SecurityHubClientTypes.NumberFilter]?
        /// The native severity as defined by the security-findings provider's solution that generated the finding.
        @available(*, deprecated, message: "This filter is deprecated. Instead, use FindingProviderSeverityOriginal.")
        public var severityProduct: [SecurityHubClientTypes.NumberFilter]?
        /// A URL that links to a page about the current finding in the security-findings provider's solution.
        public var sourceUrl: [SecurityHubClientTypes.StringFilter]?
        /// The category of a threat intelligence indicator.
        public var threatIntelIndicatorCategory: [SecurityHubClientTypes.StringFilter]?
        /// The date/time of the last observation of a threat intelligence indicator.
        public var threatIntelIndicatorLastObservedAt: [SecurityHubClientTypes.DateFilter]?
        /// The source of the threat intelligence.
        public var threatIntelIndicatorSource: [SecurityHubClientTypes.StringFilter]?
        /// The URL for more details from the source of the threat intelligence.
        public var threatIntelIndicatorSourceUrl: [SecurityHubClientTypes.StringFilter]?
        /// The type of a threat intelligence indicator.
        public var threatIntelIndicatorType: [SecurityHubClientTypes.StringFilter]?
        /// The value of a threat intelligence indicator.
        public var threatIntelIndicatorValue: [SecurityHubClientTypes.StringFilter]?
        /// A finding's title.
        public var title: [SecurityHubClientTypes.StringFilter]?
        /// A finding type in the format of namespace/category/classifier that classifies a finding.
        public var type: [SecurityHubClientTypes.StringFilter]?
        /// An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record.
        public var updatedAt: [SecurityHubClientTypes.DateFilter]?
        /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
        public var userDefinedFields: [SecurityHubClientTypes.MapFilter]?
        /// The veracity of a finding.
        public var verificationState: [SecurityHubClientTypes.StringFilter]?
        /// The workflow state of a finding. Note that this field is deprecated. To search for a finding based on its workflow status, use WorkflowStatus.
        public var workflowState: [SecurityHubClientTypes.StringFilter]?
        /// The status of the investigation into a finding. Allowed values are the following.
        ///
        /// * NEW - The initial state of a finding, before it is reviewed. Security Hub also resets the workflow status from NOTIFIED or RESOLVED to NEW in the following cases:
        ///
        /// * RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * Compliance.Status changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.
        ///
        ///
        ///
        ///
        /// * NOTIFIED - Indicates that the resource owner has been notified about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner. If one of the following occurs, the workflow status is changed automatically from NOTIFIED to NEW:
        ///
        /// * RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * Compliance.Status changes from PASSED to FAILED, WARNING, or NOT_AVAILABLE.
        ///
        ///
        ///
        ///
        /// * SUPPRESSED - Indicates that you reviewed the finding and do not believe that any action is needed. The workflow status of a SUPPRESSED finding does not change if RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * RESOLVED - The finding was reviewed and remediated and is now considered resolved. The finding remains RESOLVED unless one of the following occurs:
        ///
        /// * RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * Compliance.Status changes from PASSED to FAILED, WARNING, or NOT_AVAILABLE.
        ///
        ///
        /// In those cases, the workflow status is automatically reset to NEW. For findings from controls, if Compliance.Status is PASSED, then Security Hub automatically sets the workflow status to RESOLVED.
        public var workflowStatus: [SecurityHubClientTypes.StringFilter]?

        public init (
            awsAccountId: [SecurityHubClientTypes.StringFilter]? = nil,
            companyName: [SecurityHubClientTypes.StringFilter]? = nil,
            complianceStatus: [SecurityHubClientTypes.StringFilter]? = nil,
            confidence: [SecurityHubClientTypes.NumberFilter]? = nil,
            createdAt: [SecurityHubClientTypes.DateFilter]? = nil,
            criticality: [SecurityHubClientTypes.NumberFilter]? = nil,
            description: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsConfidence: [SecurityHubClientTypes.NumberFilter]? = nil,
            findingProviderFieldsCriticality: [SecurityHubClientTypes.NumberFilter]? = nil,
            findingProviderFieldsRelatedFindingsId: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsRelatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsSeverityLabel: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsSeverityOriginal: [SecurityHubClientTypes.StringFilter]? = nil,
            findingProviderFieldsTypes: [SecurityHubClientTypes.StringFilter]? = nil,
            firstObservedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            generatorId: [SecurityHubClientTypes.StringFilter]? = nil,
            id: [SecurityHubClientTypes.StringFilter]? = nil,
            keyword: [SecurityHubClientTypes.KeywordFilter]? = nil,
            lastObservedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            malwareName: [SecurityHubClientTypes.StringFilter]? = nil,
            malwarePath: [SecurityHubClientTypes.StringFilter]? = nil,
            malwareState: [SecurityHubClientTypes.StringFilter]? = nil,
            malwareType: [SecurityHubClientTypes.StringFilter]? = nil,
            networkDestinationDomain: [SecurityHubClientTypes.StringFilter]? = nil,
            networkDestinationIpV4: [SecurityHubClientTypes.IpFilter]? = nil,
            networkDestinationIpV6: [SecurityHubClientTypes.IpFilter]? = nil,
            networkDestinationPort: [SecurityHubClientTypes.NumberFilter]? = nil,
            networkDirection: [SecurityHubClientTypes.StringFilter]? = nil,
            networkProtocol: [SecurityHubClientTypes.StringFilter]? = nil,
            networkSourceDomain: [SecurityHubClientTypes.StringFilter]? = nil,
            networkSourceIpV4: [SecurityHubClientTypes.IpFilter]? = nil,
            networkSourceIpV6: [SecurityHubClientTypes.IpFilter]? = nil,
            networkSourceMac: [SecurityHubClientTypes.StringFilter]? = nil,
            networkSourcePort: [SecurityHubClientTypes.NumberFilter]? = nil,
            noteText: [SecurityHubClientTypes.StringFilter]? = nil,
            noteUpdatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            noteUpdatedBy: [SecurityHubClientTypes.StringFilter]? = nil,
            processLaunchedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            processName: [SecurityHubClientTypes.StringFilter]? = nil,
            processParentPid: [SecurityHubClientTypes.NumberFilter]? = nil,
            processPath: [SecurityHubClientTypes.StringFilter]? = nil,
            processPid: [SecurityHubClientTypes.NumberFilter]? = nil,
            processTerminatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            productArn: [SecurityHubClientTypes.StringFilter]? = nil,
            productFields: [SecurityHubClientTypes.MapFilter]? = nil,
            productName: [SecurityHubClientTypes.StringFilter]? = nil,
            recommendationText: [SecurityHubClientTypes.StringFilter]? = nil,
            recordState: [SecurityHubClientTypes.StringFilter]? = nil,
            region: [SecurityHubClientTypes.StringFilter]? = nil,
            relatedFindingsId: [SecurityHubClientTypes.StringFilter]? = nil,
            relatedFindingsProductArn: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceIamInstanceProfileArn: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceImageId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceIpV4Addresses: [SecurityHubClientTypes.IpFilter]? = nil,
            resourceAwsEc2InstanceIpV6Addresses: [SecurityHubClientTypes.IpFilter]? = nil,
            resourceAwsEc2InstanceKeyName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceLaunchedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            resourceAwsEc2InstanceSubnetId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceType: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsEc2InstanceVpcId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsIamAccessKeyCreatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            resourceAwsIamAccessKeyPrincipalName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsIamAccessKeyStatus: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsIamAccessKeyUserName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsIamUserUserName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsS3BucketOwnerId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceAwsS3BucketOwnerName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceContainerImageId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceContainerImageName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceContainerLaunchedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            resourceContainerName: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceDetailsOther: [SecurityHubClientTypes.MapFilter]? = nil,
            resourceId: [SecurityHubClientTypes.StringFilter]? = nil,
            resourcePartition: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceRegion: [SecurityHubClientTypes.StringFilter]? = nil,
            resourceTags: [SecurityHubClientTypes.MapFilter]? = nil,
            resourceType: [SecurityHubClientTypes.StringFilter]? = nil,
            sample: [SecurityHubClientTypes.BooleanFilter]? = nil,
            severityLabel: [SecurityHubClientTypes.StringFilter]? = nil,
            severityNormalized: [SecurityHubClientTypes.NumberFilter]? = nil,
            severityProduct: [SecurityHubClientTypes.NumberFilter]? = nil,
            sourceUrl: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorCategory: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorLastObservedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            threatIntelIndicatorSource: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorSourceUrl: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorType: [SecurityHubClientTypes.StringFilter]? = nil,
            threatIntelIndicatorValue: [SecurityHubClientTypes.StringFilter]? = nil,
            title: [SecurityHubClientTypes.StringFilter]? = nil,
            type: [SecurityHubClientTypes.StringFilter]? = nil,
            updatedAt: [SecurityHubClientTypes.DateFilter]? = nil,
            userDefinedFields: [SecurityHubClientTypes.MapFilter]? = nil,
            verificationState: [SecurityHubClientTypes.StringFilter]? = nil,
            workflowState: [SecurityHubClientTypes.StringFilter]? = nil,
            workflowStatus: [SecurityHubClientTypes.StringFilter]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.companyName = companyName
            self.complianceStatus = complianceStatus
            self.confidence = confidence
            self.createdAt = createdAt
            self.criticality = criticality
            self.description = description
            self.findingProviderFieldsConfidence = findingProviderFieldsConfidence
            self.findingProviderFieldsCriticality = findingProviderFieldsCriticality
            self.findingProviderFieldsRelatedFindingsId = findingProviderFieldsRelatedFindingsId
            self.findingProviderFieldsRelatedFindingsProductArn = findingProviderFieldsRelatedFindingsProductArn
            self.findingProviderFieldsSeverityLabel = findingProviderFieldsSeverityLabel
            self.findingProviderFieldsSeverityOriginal = findingProviderFieldsSeverityOriginal
            self.findingProviderFieldsTypes = findingProviderFieldsTypes
            self.firstObservedAt = firstObservedAt
            self.generatorId = generatorId
            self.id = id
            self.keyword = keyword
            self.lastObservedAt = lastObservedAt
            self.malwareName = malwareName
            self.malwarePath = malwarePath
            self.malwareState = malwareState
            self.malwareType = malwareType
            self.networkDestinationDomain = networkDestinationDomain
            self.networkDestinationIpV4 = networkDestinationIpV4
            self.networkDestinationIpV6 = networkDestinationIpV6
            self.networkDestinationPort = networkDestinationPort
            self.networkDirection = networkDirection
            self.networkProtocol = networkProtocol
            self.networkSourceDomain = networkSourceDomain
            self.networkSourceIpV4 = networkSourceIpV4
            self.networkSourceIpV6 = networkSourceIpV6
            self.networkSourceMac = networkSourceMac
            self.networkSourcePort = networkSourcePort
            self.noteText = noteText
            self.noteUpdatedAt = noteUpdatedAt
            self.noteUpdatedBy = noteUpdatedBy
            self.processLaunchedAt = processLaunchedAt
            self.processName = processName
            self.processParentPid = processParentPid
            self.processPath = processPath
            self.processPid = processPid
            self.processTerminatedAt = processTerminatedAt
            self.productArn = productArn
            self.productFields = productFields
            self.productName = productName
            self.recommendationText = recommendationText
            self.recordState = recordState
            self.region = region
            self.relatedFindingsId = relatedFindingsId
            self.relatedFindingsProductArn = relatedFindingsProductArn
            self.resourceAwsEc2InstanceIamInstanceProfileArn = resourceAwsEc2InstanceIamInstanceProfileArn
            self.resourceAwsEc2InstanceImageId = resourceAwsEc2InstanceImageId
            self.resourceAwsEc2InstanceIpV4Addresses = resourceAwsEc2InstanceIpV4Addresses
            self.resourceAwsEc2InstanceIpV6Addresses = resourceAwsEc2InstanceIpV6Addresses
            self.resourceAwsEc2InstanceKeyName = resourceAwsEc2InstanceKeyName
            self.resourceAwsEc2InstanceLaunchedAt = resourceAwsEc2InstanceLaunchedAt
            self.resourceAwsEc2InstanceSubnetId = resourceAwsEc2InstanceSubnetId
            self.resourceAwsEc2InstanceType = resourceAwsEc2InstanceType
            self.resourceAwsEc2InstanceVpcId = resourceAwsEc2InstanceVpcId
            self.resourceAwsIamAccessKeyCreatedAt = resourceAwsIamAccessKeyCreatedAt
            self.resourceAwsIamAccessKeyPrincipalName = resourceAwsIamAccessKeyPrincipalName
            self.resourceAwsIamAccessKeyStatus = resourceAwsIamAccessKeyStatus
            self.resourceAwsIamAccessKeyUserName = resourceAwsIamAccessKeyUserName
            self.resourceAwsIamUserUserName = resourceAwsIamUserUserName
            self.resourceAwsS3BucketOwnerId = resourceAwsS3BucketOwnerId
            self.resourceAwsS3BucketOwnerName = resourceAwsS3BucketOwnerName
            self.resourceContainerImageId = resourceContainerImageId
            self.resourceContainerImageName = resourceContainerImageName
            self.resourceContainerLaunchedAt = resourceContainerLaunchedAt
            self.resourceContainerName = resourceContainerName
            self.resourceDetailsOther = resourceDetailsOther
            self.resourceId = resourceId
            self.resourcePartition = resourcePartition
            self.resourceRegion = resourceRegion
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.sample = sample
            self.severityLabel = severityLabel
            self.severityNormalized = severityNormalized
            self.severityProduct = severityProduct
            self.sourceUrl = sourceUrl
            self.threatIntelIndicatorCategory = threatIntelIndicatorCategory
            self.threatIntelIndicatorLastObservedAt = threatIntelIndicatorLastObservedAt
            self.threatIntelIndicatorSource = threatIntelIndicatorSource
            self.threatIntelIndicatorSourceUrl = threatIntelIndicatorSourceUrl
            self.threatIntelIndicatorType = threatIntelIndicatorType
            self.threatIntelIndicatorValue = threatIntelIndicatorValue
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.userDefinedFields = userDefinedFields
            self.verificationState = verificationState
            self.workflowState = workflowState
            self.workflowStatus = workflowStatus
        }
    }

}

extension SecurityHubClientTypes.AwsSecurityFindingIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case productArn = "ProductArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let productArn = self.productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let productArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productArn)
        productArn = productArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Identifies a finding to update using BatchUpdateFindings.
    public struct AwsSecurityFindingIdentifier: Swift.Equatable {
        /// The identifier of the finding that was specified by the finding provider.
        /// This member is required.
        public var id: Swift.String?
        /// The ARN generated by Security Hub that uniquely identifies a product that generates findings. This can be the ARN for a third-party product that is integrated with Security Hub, or the ARN for a custom integration.
        /// This member is required.
        public var productArn: Swift.String?

        public init (
            id: Swift.String? = nil,
            productArn: Swift.String? = nil
        )
        {
            self.id = id
            self.productArn = productArn
        }
    }

}

extension SecurityHubClientTypes.AwsSnsTopicDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationSuccessFeedbackRoleArn = "ApplicationSuccessFeedbackRoleArn"
        case firehoseFailureFeedbackRoleArn = "FirehoseFailureFeedbackRoleArn"
        case firehoseSuccessFeedbackRoleArn = "FirehoseSuccessFeedbackRoleArn"
        case httpFailureFeedbackRoleArn = "HttpFailureFeedbackRoleArn"
        case httpSuccessFeedbackRoleArn = "HttpSuccessFeedbackRoleArn"
        case kmsMasterKeyId = "KmsMasterKeyId"
        case owner = "Owner"
        case sqsFailureFeedbackRoleArn = "SqsFailureFeedbackRoleArn"
        case sqsSuccessFeedbackRoleArn = "SqsSuccessFeedbackRoleArn"
        case subscription = "Subscription"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationSuccessFeedbackRoleArn = self.applicationSuccessFeedbackRoleArn {
            try encodeContainer.encode(applicationSuccessFeedbackRoleArn, forKey: .applicationSuccessFeedbackRoleArn)
        }
        if let firehoseFailureFeedbackRoleArn = self.firehoseFailureFeedbackRoleArn {
            try encodeContainer.encode(firehoseFailureFeedbackRoleArn, forKey: .firehoseFailureFeedbackRoleArn)
        }
        if let firehoseSuccessFeedbackRoleArn = self.firehoseSuccessFeedbackRoleArn {
            try encodeContainer.encode(firehoseSuccessFeedbackRoleArn, forKey: .firehoseSuccessFeedbackRoleArn)
        }
        if let httpFailureFeedbackRoleArn = self.httpFailureFeedbackRoleArn {
            try encodeContainer.encode(httpFailureFeedbackRoleArn, forKey: .httpFailureFeedbackRoleArn)
        }
        if let httpSuccessFeedbackRoleArn = self.httpSuccessFeedbackRoleArn {
            try encodeContainer.encode(httpSuccessFeedbackRoleArn, forKey: .httpSuccessFeedbackRoleArn)
        }
        if let kmsMasterKeyId = self.kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let sqsFailureFeedbackRoleArn = self.sqsFailureFeedbackRoleArn {
            try encodeContainer.encode(sqsFailureFeedbackRoleArn, forKey: .sqsFailureFeedbackRoleArn)
        }
        if let sqsSuccessFeedbackRoleArn = self.sqsSuccessFeedbackRoleArn {
            try encodeContainer.encode(sqsSuccessFeedbackRoleArn, forKey: .sqsSuccessFeedbackRoleArn)
        }
        if let subscription = subscription {
            var subscriptionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscription)
            for awssnstopicsubscription0 in subscription {
                try subscriptionContainer.encode(awssnstopicsubscription0)
            }
        }
        if let topicName = self.topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
        let subscriptionContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsSnsTopicSubscription?].self, forKey: .subscription)
        var subscriptionDecoded0:[SecurityHubClientTypes.AwsSnsTopicSubscription]? = nil
        if let subscriptionContainer = subscriptionContainer {
            subscriptionDecoded0 = [SecurityHubClientTypes.AwsSnsTopicSubscription]()
            for structure0 in subscriptionContainer {
                if let structure0 = structure0 {
                    subscriptionDecoded0?.append(structure0)
                }
            }
        }
        subscription = subscriptionDecoded0
        let topicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicName)
        topicName = topicNameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let sqsSuccessFeedbackRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqsSuccessFeedbackRoleArn)
        sqsSuccessFeedbackRoleArn = sqsSuccessFeedbackRoleArnDecoded
        let sqsFailureFeedbackRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqsFailureFeedbackRoleArn)
        sqsFailureFeedbackRoleArn = sqsFailureFeedbackRoleArnDecoded
        let applicationSuccessFeedbackRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationSuccessFeedbackRoleArn)
        applicationSuccessFeedbackRoleArn = applicationSuccessFeedbackRoleArnDecoded
        let firehoseSuccessFeedbackRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firehoseSuccessFeedbackRoleArn)
        firehoseSuccessFeedbackRoleArn = firehoseSuccessFeedbackRoleArnDecoded
        let firehoseFailureFeedbackRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firehoseFailureFeedbackRoleArn)
        firehoseFailureFeedbackRoleArn = firehoseFailureFeedbackRoleArnDecoded
        let httpSuccessFeedbackRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpSuccessFeedbackRoleArn)
        httpSuccessFeedbackRoleArn = httpSuccessFeedbackRoleArnDecoded
        let httpFailureFeedbackRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpFailureFeedbackRoleArn)
        httpFailureFeedbackRoleArn = httpFailureFeedbackRoleArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an Amazon SNS topic to which notifications can be published.
    public struct AwsSnsTopicDetails: Swift.Equatable {
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint.
        public var applicationSuccessFeedbackRoleArn: Swift.String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
        public var firehoseFailureFeedbackRoleArn: Swift.String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
        public var firehoseSuccessFeedbackRoleArn: Swift.String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
        public var httpFailureFeedbackRoleArn: Swift.String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
        public var httpSuccessFeedbackRoleArn: Swift.String?
        /// The ID of an Amazon Web Services managed key for Amazon SNS or a customer managed key.
        public var kmsMasterKeyId: Swift.String?
        /// The subscription's owner.
        public var owner: Swift.String?
        /// Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
        public var sqsFailureFeedbackRoleArn: Swift.String?
        /// Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
        public var sqsSuccessFeedbackRoleArn: Swift.String?
        /// Subscription is an embedded property that describes the subscription endpoints of an Amazon SNS topic.
        public var subscription: [SecurityHubClientTypes.AwsSnsTopicSubscription]?
        /// The name of the Amazon SNS topic.
        public var topicName: Swift.String?

        public init (
            applicationSuccessFeedbackRoleArn: Swift.String? = nil,
            firehoseFailureFeedbackRoleArn: Swift.String? = nil,
            firehoseSuccessFeedbackRoleArn: Swift.String? = nil,
            httpFailureFeedbackRoleArn: Swift.String? = nil,
            httpSuccessFeedbackRoleArn: Swift.String? = nil,
            kmsMasterKeyId: Swift.String? = nil,
            owner: Swift.String? = nil,
            sqsFailureFeedbackRoleArn: Swift.String? = nil,
            sqsSuccessFeedbackRoleArn: Swift.String? = nil,
            subscription: [SecurityHubClientTypes.AwsSnsTopicSubscription]? = nil,
            topicName: Swift.String? = nil
        )
        {
            self.applicationSuccessFeedbackRoleArn = applicationSuccessFeedbackRoleArn
            self.firehoseFailureFeedbackRoleArn = firehoseFailureFeedbackRoleArn
            self.firehoseSuccessFeedbackRoleArn = firehoseSuccessFeedbackRoleArn
            self.httpFailureFeedbackRoleArn = httpFailureFeedbackRoleArn
            self.httpSuccessFeedbackRoleArn = httpSuccessFeedbackRoleArn
            self.kmsMasterKeyId = kmsMasterKeyId
            self.owner = owner
            self.sqsFailureFeedbackRoleArn = sqsFailureFeedbackRoleArn
            self.sqsSuccessFeedbackRoleArn = sqsSuccessFeedbackRoleArn
            self.subscription = subscription
            self.topicName = topicName
        }
    }

}

extension SecurityHubClientTypes.AwsSnsTopicSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension SecurityHubClientTypes {
    /// A wrapper type for the attributes of an Amazon SNS subscription.
    public struct AwsSnsTopicSubscription: Swift.Equatable {
        /// The subscription's endpoint (format depends on the protocol).
        public var endpoint: Swift.String?
        /// The subscription's protocol.
        public var `protocol`: Swift.String?

        public init (
            endpoint: Swift.String? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.`protocol` = `protocol`
        }
    }

}

extension SecurityHubClientTypes.AwsSqsQueueDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deadLetterTargetArn = "DeadLetterTargetArn"
        case kmsDataKeyReusePeriodSeconds = "KmsDataKeyReusePeriodSeconds"
        case kmsMasterKeyId = "KmsMasterKeyId"
        case queueName = "QueueName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterTargetArn = self.deadLetterTargetArn {
            try encodeContainer.encode(deadLetterTargetArn, forKey: .deadLetterTargetArn)
        }
        if kmsDataKeyReusePeriodSeconds != 0 {
            try encodeContainer.encode(kmsDataKeyReusePeriodSeconds, forKey: .kmsDataKeyReusePeriodSeconds)
        }
        if let kmsMasterKeyId = self.kmsMasterKeyId {
            try encodeContainer.encode(kmsMasterKeyId, forKey: .kmsMasterKeyId)
        }
        if let queueName = self.queueName {
            try encodeContainer.encode(queueName, forKey: .queueName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsDataKeyReusePeriodSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .kmsDataKeyReusePeriodSeconds) ?? 0
        kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSecondsDecoded
        let kmsMasterKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyId)
        kmsMasterKeyId = kmsMasterKeyIdDecoded
        let queueNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queueName)
        queueName = queueNameDecoded
        let deadLetterTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deadLetterTargetArn)
        deadLetterTargetArn = deadLetterTargetArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Data about a queue.
    public struct AwsSqsQueueDetails: Swift.Equatable {
        /// The ARN of the dead-letter queue to which Amazon SQS moves messages after the value of maxReceiveCount is exceeded.
        public var deadLetterTargetArn: Swift.String?
        /// The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling KMS again.
        public var kmsDataKeyReusePeriodSeconds: Swift.Int
        /// The ID of an Amazon Web Services managed key for Amazon SQS or a custom KMS key.
        public var kmsMasterKeyId: Swift.String?
        /// The name of the new queue.
        public var queueName: Swift.String?

        public init (
            deadLetterTargetArn: Swift.String? = nil,
            kmsDataKeyReusePeriodSeconds: Swift.Int = 0,
            kmsMasterKeyId: Swift.String? = nil,
            queueName: Swift.String? = nil
        )
        {
            self.deadLetterTargetArn = deadLetterTargetArn
            self.kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSeconds
            self.kmsMasterKeyId = kmsMasterKeyId
            self.queueName = queueName
        }
    }

}

extension SecurityHubClientTypes.AwsSsmComplianceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceType = "ComplianceType"
        case compliantCriticalCount = "CompliantCriticalCount"
        case compliantHighCount = "CompliantHighCount"
        case compliantInformationalCount = "CompliantInformationalCount"
        case compliantLowCount = "CompliantLowCount"
        case compliantMediumCount = "CompliantMediumCount"
        case compliantUnspecifiedCount = "CompliantUnspecifiedCount"
        case executionType = "ExecutionType"
        case nonCompliantCriticalCount = "NonCompliantCriticalCount"
        case nonCompliantHighCount = "NonCompliantHighCount"
        case nonCompliantInformationalCount = "NonCompliantInformationalCount"
        case nonCompliantLowCount = "NonCompliantLowCount"
        case nonCompliantMediumCount = "NonCompliantMediumCount"
        case nonCompliantUnspecifiedCount = "NonCompliantUnspecifiedCount"
        case overallSeverity = "OverallSeverity"
        case patchBaselineId = "PatchBaselineId"
        case patchGroup = "PatchGroup"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = self.complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if compliantCriticalCount != 0 {
            try encodeContainer.encode(compliantCriticalCount, forKey: .compliantCriticalCount)
        }
        if compliantHighCount != 0 {
            try encodeContainer.encode(compliantHighCount, forKey: .compliantHighCount)
        }
        if compliantInformationalCount != 0 {
            try encodeContainer.encode(compliantInformationalCount, forKey: .compliantInformationalCount)
        }
        if compliantLowCount != 0 {
            try encodeContainer.encode(compliantLowCount, forKey: .compliantLowCount)
        }
        if compliantMediumCount != 0 {
            try encodeContainer.encode(compliantMediumCount, forKey: .compliantMediumCount)
        }
        if compliantUnspecifiedCount != 0 {
            try encodeContainer.encode(compliantUnspecifiedCount, forKey: .compliantUnspecifiedCount)
        }
        if let executionType = self.executionType {
            try encodeContainer.encode(executionType, forKey: .executionType)
        }
        if nonCompliantCriticalCount != 0 {
            try encodeContainer.encode(nonCompliantCriticalCount, forKey: .nonCompliantCriticalCount)
        }
        if nonCompliantHighCount != 0 {
            try encodeContainer.encode(nonCompliantHighCount, forKey: .nonCompliantHighCount)
        }
        if nonCompliantInformationalCount != 0 {
            try encodeContainer.encode(nonCompliantInformationalCount, forKey: .nonCompliantInformationalCount)
        }
        if nonCompliantLowCount != 0 {
            try encodeContainer.encode(nonCompliantLowCount, forKey: .nonCompliantLowCount)
        }
        if nonCompliantMediumCount != 0 {
            try encodeContainer.encode(nonCompliantMediumCount, forKey: .nonCompliantMediumCount)
        }
        if nonCompliantUnspecifiedCount != 0 {
            try encodeContainer.encode(nonCompliantUnspecifiedCount, forKey: .nonCompliantUnspecifiedCount)
        }
        if let overallSeverity = self.overallSeverity {
            try encodeContainer.encode(overallSeverity, forKey: .overallSeverity)
        }
        if let patchBaselineId = self.patchBaselineId {
            try encodeContainer.encode(patchBaselineId, forKey: .patchBaselineId)
        }
        if let patchGroup = self.patchGroup {
            try encodeContainer.encode(patchGroup, forKey: .patchGroup)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let compliantCriticalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantCriticalCount) ?? 0
        compliantCriticalCount = compliantCriticalCountDecoded
        let compliantHighCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantHighCount) ?? 0
        compliantHighCount = compliantHighCountDecoded
        let compliantMediumCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantMediumCount) ?? 0
        compliantMediumCount = compliantMediumCountDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionType)
        executionType = executionTypeDecoded
        let nonCompliantCriticalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantCriticalCount) ?? 0
        nonCompliantCriticalCount = nonCompliantCriticalCountDecoded
        let compliantInformationalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantInformationalCount) ?? 0
        compliantInformationalCount = compliantInformationalCountDecoded
        let nonCompliantInformationalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantInformationalCount) ?? 0
        nonCompliantInformationalCount = nonCompliantInformationalCountDecoded
        let compliantUnspecifiedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantUnspecifiedCount) ?? 0
        compliantUnspecifiedCount = compliantUnspecifiedCountDecoded
        let nonCompliantLowCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantLowCount) ?? 0
        nonCompliantLowCount = nonCompliantLowCountDecoded
        let nonCompliantHighCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantHighCount) ?? 0
        nonCompliantHighCount = nonCompliantHighCountDecoded
        let compliantLowCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compliantLowCount) ?? 0
        compliantLowCount = compliantLowCountDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let patchBaselineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchBaselineId)
        patchBaselineId = patchBaselineIdDecoded
        let overallSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overallSeverity)
        overallSeverity = overallSeverityDecoded
        let nonCompliantMediumCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantMediumCount) ?? 0
        nonCompliantMediumCount = nonCompliantMediumCountDecoded
        let nonCompliantUnspecifiedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nonCompliantUnspecifiedCount) ?? 0
        nonCompliantUnspecifiedCount = nonCompliantUnspecifiedCountDecoded
        let patchGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchGroup)
        patchGroup = patchGroupDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides the details about the compliance status for a patch.
    public struct AwsSsmComplianceSummary: Swift.Equatable {
        /// The type of resource for which the compliance was determined. For AwsSsmPatchCompliance, ComplianceType is Patch.
        public var complianceType: Swift.String?
        /// For the patches that are compliant, the number that have a severity of CRITICAL.
        public var compliantCriticalCount: Swift.Int
        /// For the patches that are compliant, the number that have a severity of HIGH.
        public var compliantHighCount: Swift.Int
        /// For the patches that are compliant, the number that have a severity of INFORMATIONAL.
        public var compliantInformationalCount: Swift.Int
        /// For the patches that are compliant, the number that have a severity of LOW.
        public var compliantLowCount: Swift.Int
        /// For the patches that are compliant, the number that have a severity of MEDIUM.
        public var compliantMediumCount: Swift.Int
        /// For the patches that are compliant, the number that have a severity of UNSPECIFIED.
        public var compliantUnspecifiedCount: Swift.Int
        /// The type of execution that was used determine compliance.
        public var executionType: Swift.String?
        /// For the patch items that are noncompliant, the number of items that have a severity of CRITICAL.
        public var nonCompliantCriticalCount: Swift.Int
        /// For the patches that are noncompliant, the number that have a severity of HIGH.
        public var nonCompliantHighCount: Swift.Int
        /// For the patches that are noncompliant, the number that have a severity of INFORMATIONAL.
        public var nonCompliantInformationalCount: Swift.Int
        /// For the patches that are noncompliant, the number that have a severity of LOW.
        public var nonCompliantLowCount: Swift.Int
        /// For the patches that are noncompliant, the number that have a severity of MEDIUM.
        public var nonCompliantMediumCount: Swift.Int
        /// For the patches that are noncompliant, the number that have a severity of UNSPECIFIED.
        public var nonCompliantUnspecifiedCount: Swift.Int
        /// The highest severity for the patches. Valid values are as follows:
        ///
        /// * CRITICAL
        ///
        /// * HIGH
        ///
        /// * MEDIUM
        ///
        /// * LOW
        ///
        /// * INFORMATIONAL
        ///
        /// * UNSPECIFIED
        public var overallSeverity: Swift.String?
        /// The identifier of the patch baseline. The patch baseline lists the patches that are approved for installation.
        public var patchBaselineId: Swift.String?
        /// The identifier of the patch group for which compliance was determined. A patch group uses tags to group EC2 instances that should have the same patch compliance.
        public var patchGroup: Swift.String?
        /// The current patch compliance status. Valid values are as follows:
        ///
        /// * COMPLIANT
        ///
        /// * NON_COMPLIANT
        ///
        /// * UNSPECIFIED_DATA
        public var status: Swift.String?

        public init (
            complianceType: Swift.String? = nil,
            compliantCriticalCount: Swift.Int = 0,
            compliantHighCount: Swift.Int = 0,
            compliantInformationalCount: Swift.Int = 0,
            compliantLowCount: Swift.Int = 0,
            compliantMediumCount: Swift.Int = 0,
            compliantUnspecifiedCount: Swift.Int = 0,
            executionType: Swift.String? = nil,
            nonCompliantCriticalCount: Swift.Int = 0,
            nonCompliantHighCount: Swift.Int = 0,
            nonCompliantInformationalCount: Swift.Int = 0,
            nonCompliantLowCount: Swift.Int = 0,
            nonCompliantMediumCount: Swift.Int = 0,
            nonCompliantUnspecifiedCount: Swift.Int = 0,
            overallSeverity: Swift.String? = nil,
            patchBaselineId: Swift.String? = nil,
            patchGroup: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.complianceType = complianceType
            self.compliantCriticalCount = compliantCriticalCount
            self.compliantHighCount = compliantHighCount
            self.compliantInformationalCount = compliantInformationalCount
            self.compliantLowCount = compliantLowCount
            self.compliantMediumCount = compliantMediumCount
            self.compliantUnspecifiedCount = compliantUnspecifiedCount
            self.executionType = executionType
            self.nonCompliantCriticalCount = nonCompliantCriticalCount
            self.nonCompliantHighCount = nonCompliantHighCount
            self.nonCompliantInformationalCount = nonCompliantInformationalCount
            self.nonCompliantLowCount = nonCompliantLowCount
            self.nonCompliantMediumCount = nonCompliantMediumCount
            self.nonCompliantUnspecifiedCount = nonCompliantUnspecifiedCount
            self.overallSeverity = overallSeverity
            self.patchBaselineId = patchBaselineId
            self.patchGroup = patchGroup
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.AwsSsmPatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case complianceSummary = "ComplianceSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceSummary = self.complianceSummary {
            try encodeContainer.encode(complianceSummary, forKey: .complianceSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let complianceSummaryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSsmComplianceSummary.self, forKey: .complianceSummary)
        complianceSummary = complianceSummaryDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the compliance for a patch.
    public struct AwsSsmPatch: Swift.Equatable {
        /// The compliance status details for the patch.
        public var complianceSummary: SecurityHubClientTypes.AwsSsmComplianceSummary?

        public init (
            complianceSummary: SecurityHubClientTypes.AwsSsmComplianceSummary? = nil
        )
        {
            self.complianceSummary = complianceSummary
        }
    }

}

extension SecurityHubClientTypes.AwsSsmPatchComplianceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patch = "Patch"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patch = self.patch {
            try encodeContainer.encode(patch, forKey: .patch)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSsmPatch.self, forKey: .patch)
        patch = patchDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.
    public struct AwsSsmPatchComplianceDetails: Swift.Equatable {
        /// Information about the status of a patch.
        public var patch: SecurityHubClientTypes.AwsSsmPatch?

        public init (
            patch: SecurityHubClientTypes.AwsSsmPatch? = nil
        )
        {
            self.patch = patch
        }
    }

}

extension SecurityHubClientTypes.AwsWafRateBasedRuleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchPredicates = "MatchPredicates"
        case metricName = "MetricName"
        case name = "Name"
        case rateKey = "RateKey"
        case rateLimit = "RateLimit"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchPredicates = matchPredicates {
            var matchPredicatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchPredicates)
            for awswafratebasedrulematchpredicate0 in matchPredicates {
                try matchPredicatesContainer.encode(awswafratebasedrulematchpredicate0)
            }
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rateKey = self.rateKey {
            try encodeContainer.encode(rateKey, forKey: .rateKey)
        }
        if rateLimit != 0 {
            try encodeContainer.encode(rateLimit, forKey: .rateLimit)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let rateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rateKey)
        rateKey = rateKeyDecoded
        let rateLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rateLimit) ?? 0
        rateLimit = rateLimitDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let matchPredicatesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate?].self, forKey: .matchPredicates)
        var matchPredicatesDecoded0:[SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate]? = nil
        if let matchPredicatesContainer = matchPredicatesContainer {
            matchPredicatesDecoded0 = [SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate]()
            for structure0 in matchPredicatesContainer {
                if let structure0 = structure0 {
                    matchPredicatesDecoded0?.append(structure0)
                }
            }
        }
        matchPredicates = matchPredicatesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Details about a rate-based rule for global resources. A rate-based rule provides settings to indicate when to allow, block, or count a request. Rate-based rules include the number of requests that arrive over a specified period of time.
    public struct AwsWafRateBasedRuleDetails: Swift.Equatable {
        /// The predicates to include in the rate-based rule.
        public var matchPredicates: [SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate]?
        /// The name of the metrics for the rate-based rule.
        public var metricName: Swift.String?
        /// The name of the rate-based rule.
        public var name: Swift.String?
        /// The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.
        public var rateKey: Swift.String?
        /// The maximum number of requests that have an identical value for the field specified in RateKey that are allowed within a five-minute period. If the number of requests exceeds RateLimit and the other predicates specified in the rule are met, WAF triggers the action for the rule.
        public var rateLimit: Swift.Int
        /// The unique identifier for the rate-based rule.
        public var ruleId: Swift.String?

        public init (
            matchPredicates: [SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate]? = nil,
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            rateKey: Swift.String? = nil,
            rateLimit: Swift.Int = 0,
            ruleId: Swift.String? = nil
        )
        {
            self.matchPredicates = matchPredicates
            self.metricName = metricName
            self.name = name
            self.rateKey = rateKey
            self.rateLimit = rateLimit
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes.AwsWafRateBasedRuleMatchPredicate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataId = "DataId"
        case negated = "Negated"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataId = self.dataId {
            try encodeContainer.encode(dataId, forKey: .dataId)
        }
        if negated != false {
            try encodeContainer.encode(negated, forKey: .negated)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataId)
        dataId = dataIdDecoded
        let negatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negated) ?? false
        negated = negatedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A match predicate. A predicate might look for characteristics such as specific IP addresses, geographic locations, or sizes.
    public struct AwsWafRateBasedRuleMatchPredicate: Swift.Equatable {
        /// The unique identifier for the predicate.
        public var dataId: Swift.String?
        /// If set to true, then the rule actions are performed on requests that match the predicate settings. If set to false, then the rule actions are performed on all requests except those that match the predicate settings.
        public var negated: Swift.Bool
        /// The type of predicate. Valid values are as follows:
        ///
        /// * ByteMatch
        ///
        /// * GeoMatch
        ///
        /// * IPMatch
        ///
        /// * RegexMatch
        ///
        /// * SizeConstraint
        ///
        /// * SqlInjectionMatch
        ///
        /// * XssMatch
        public var type: Swift.String?

        public init (
            dataId: Swift.String? = nil,
            negated: Swift.Bool = false,
            type: Swift.String? = nil
        )
        {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case matchPredicates = "MatchPredicates"
        case metricName = "MetricName"
        case name = "Name"
        case rateKey = "RateKey"
        case rateLimit = "RateLimit"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchPredicates = matchPredicates {
            var matchPredicatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchPredicates)
            for awswafregionalratebasedrulematchpredicate0 in matchPredicates {
                try matchPredicatesContainer.encode(awswafregionalratebasedrulematchpredicate0)
            }
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rateKey = self.rateKey {
            try encodeContainer.encode(rateKey, forKey: .rateKey)
        }
        if rateLimit != 0 {
            try encodeContainer.encode(rateLimit, forKey: .rateLimit)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let rateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rateKey)
        rateKey = rateKeyDecoded
        let rateLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rateLimit) ?? 0
        rateLimit = rateLimitDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let matchPredicatesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate?].self, forKey: .matchPredicates)
        var matchPredicatesDecoded0:[SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate]? = nil
        if let matchPredicatesContainer = matchPredicatesContainer {
            matchPredicatesDecoded0 = [SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate]()
            for structure0 in matchPredicatesContainer {
                if let structure0 = structure0 {
                    matchPredicatesDecoded0?.append(structure0)
                }
            }
        }
        matchPredicates = matchPredicatesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// contains details about a rate-based rule for Regional resources. A rate-based rule provides settings to indicate when to allow, block, or count a request. Rate-based rules include the number of requests that arrive over a specified period of time.
    public struct AwsWafRegionalRateBasedRuleDetails: Swift.Equatable {
        /// The predicates to include in the rate-based rule.
        public var matchPredicates: [SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate]?
        /// The name of the metrics for the rate-based rule.
        public var metricName: Swift.String?
        /// The name of the rate-based rule.
        public var name: Swift.String?
        /// The field that WAF uses to determine whether requests are likely arriving from single source and are subject to rate monitoring.
        public var rateKey: Swift.String?
        /// The maximum number of requests that have an identical value for the field specified in RateKey that are allowed within a five-minute period. If the number of requests exceeds RateLimit and the other predicates specified in the rule are met, WAF triggers the action for the rule.
        public var rateLimit: Swift.Int
        /// The unique identifier for the rate-based rule.
        public var ruleId: Swift.String?

        public init (
            matchPredicates: [SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate]? = nil,
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            rateKey: Swift.String? = nil,
            rateLimit: Swift.Int = 0,
            ruleId: Swift.String? = nil
        )
        {
            self.matchPredicates = matchPredicates
            self.metricName = metricName
            self.name = name
            self.rateKey = rateKey
            self.rateLimit = rateLimit
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalRateBasedRuleMatchPredicate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataId = "DataId"
        case negated = "Negated"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataId = self.dataId {
            try encodeContainer.encode(dataId, forKey: .dataId)
        }
        if negated != false {
            try encodeContainer.encode(negated, forKey: .negated)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataId)
        dataId = dataIdDecoded
        let negatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negated) ?? false
        negated = negatedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details for a match predicate. A predicate might look for characteristics such as specific IP addresses, geographic locations, or sizes.
    public struct AwsWafRegionalRateBasedRuleMatchPredicate: Swift.Equatable {
        /// The unique identifier for the predicate.
        public var dataId: Swift.String?
        /// If set to true, then the rule actions are performed on requests that match the predicate settings. If set to false, then the rule actions are performed on all requests except those that match the predicate settings.
        public var negated: Swift.Bool
        /// The type of predicate. Valid values are as follows:
        ///
        /// * ByteMatch
        ///
        /// * GeoMatch
        ///
        /// * IPMatch
        ///
        /// * RegexMatch
        ///
        /// * SizeConstraint
        ///
        /// * SqlInjectionMatch
        ///
        /// * XssMatch
        public var type: Swift.String?

        public init (
            dataId: Swift.String? = nil,
            negated: Swift.Bool = false,
            type: Swift.String? = nil
        )
        {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalRuleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case name = "Name"
        case predicateList = "PredicateList"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predicateList = predicateList {
            var predicateListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predicateList)
            for awswafregionalrulepredicatelistdetails0 in predicateList {
                try predicateListContainer.encode(awswafregionalrulepredicatelistdetails0)
            }
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let predicateListContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails?].self, forKey: .predicateList)
        var predicateListDecoded0:[SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails]? = nil
        if let predicateListContainer = predicateListContainer {
            predicateListDecoded0 = [SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails]()
            for structure0 in predicateListContainer {
                if let structure0 = structure0 {
                    predicateListDecoded0?.append(structure0)
                }
            }
        }
        predicateList = predicateListDecoded0
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an WAF Regional rule. This rule identifies the web requests that you want to allow, block, or count.
    public struct AwsWafRegionalRuleDetails: Swift.Equatable {
        /// A name for the metrics for the rule.
        public var metricName: Swift.String?
        /// A descriptive name for the rule.
        public var name: Swift.String?
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public var predicateList: [SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails]?
        /// The ID of the rule.
        public var ruleId: Swift.String?

        public init (
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            predicateList: [SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails]? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.name = name
            self.predicateList = predicateList
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case name = "Name"
        case ruleGroupId = "RuleGroupId"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ruleGroupId = self.ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for awswafregionalrulegrouprulesdetails0 in rules {
                try rulesContainer.encode(awswafregionalrulegrouprulesdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let rulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails?].self, forKey: .rules)
        var rulesDecoded0:[SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an WAF Regional rule group. The rule group is a collection of rules for inspecting and controlling web requests.
    public struct AwsWafRegionalRuleGroupDetails: Swift.Equatable {
        /// A name for the metrics for this rule group.
        public var metricName: Swift.String?
        /// The descriptive name of the rule group.
        public var name: Swift.String?
        /// The ID of the rule group.
        public var ruleGroupId: Swift.String?
        /// Provides information about the rule statements used to identify the web requests that you want to allow, block, or count.
        public var rules: [SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails]?

        public init (
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            ruleGroupId: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails]? = nil
        )
        {
            self.metricName = metricName
            self.name = name
            self.ruleGroupId = ruleGroupId
            self.rules = rules
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Describes the action that WAF should take on a web request when it matches the criteria defined in the rule.
    public struct AwsWafRegionalRuleGroupRulesActionDetails: Swift.Equatable {
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case priority = "Priority"
        case ruleId = "RuleId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails.self, forKey: .action)
        action = actionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the rules attached to a rule group
    public struct AwsWafRegionalRuleGroupRulesDetails: Swift.Equatable {
        /// The action that WAF should take on a web request when it matches the criteria defined in the rule.
        public var action: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails?
        /// If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of Priority.
        public var priority: Swift.Int
        /// The ID for a rule.
        public var ruleId: Swift.String?
        /// The type of rule in the rule group.
        public var type: Swift.String?

        public init (
            action: SecurityHubClientTypes.AwsWafRegionalRuleGroupRulesActionDetails? = nil,
            priority: Swift.Int = 0,
            ruleId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.action = action
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalRulePredicateListDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataId = "DataId"
        case negated = "Negated"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataId = self.dataId {
            try encodeContainer.encode(dataId, forKey: .dataId)
        }
        if negated != false {
            try encodeContainer.encode(negated, forKey: .negated)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataId)
        dataId = dataIdDecoded
        let negatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negated) ?? false
        negated = negatedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
    public struct AwsWafRegionalRulePredicateListDetails: Swift.Equatable {
        /// A unique identifier for a predicate in a rule, such as ByteMatchSetId or IPSetId.
        public var dataId: Swift.String?
        /// Specifies if you want WAF to allow, block, or count requests based on the settings in the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, or SizeConstraintSet.
        public var negated: Swift.Bool
        /// The type of predicate in a rule, such as ByteMatch or IPSet.
        public var type: Swift.String?

        public init (
            dataId: Swift.String? = nil,
            negated: Swift.Bool = false,
            type: Swift.String? = nil
        )
        {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalWebAclDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAction = "DefaultAction"
        case metricName = "MetricName"
        case name = "Name"
        case rulesList = "RulesList"
        case webAclId = "WebAclId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAction = self.defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rulesList = rulesList {
            var rulesListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesList)
            for awswafregionalwebaclruleslistdetails0 in rulesList {
                try rulesListContainer.encode(awswafregionalwebaclruleslistdetails0)
            }
        }
        if let webAclId = self.webAclId {
            try encodeContainer.encode(webAclId, forKey: .webAclId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let rulesListContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails?].self, forKey: .rulesList)
        var rulesListDecoded0:[SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails]? = nil
        if let rulesListContainer = rulesListContainer {
            rulesListDecoded0 = [SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails]()
            for structure0 in rulesListContainer {
                if let structure0 = structure0 {
                    rulesListDecoded0?.append(structure0)
                }
            }
        }
        rulesList = rulesListDecoded0
        let webAclIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclId)
        webAclId = webAclIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the web access control list (web ACL). The web ACL contains the rules that identify the requests that you want to allow, block, or count.
    public struct AwsWafRegionalWebAclDetails: Swift.Equatable {
        /// The action to perform if none of the rules contained in the web ACL match.
        public var defaultAction: Swift.String?
        /// A name for the metrics for this web ACL.
        public var metricName: Swift.String?
        /// A descriptive name for the web ACL.
        public var name: Swift.String?
        /// An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.
        public var rulesList: [SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails]?
        /// The ID of the web ACL.
        public var webAclId: Swift.String?

        public init (
            defaultAction: Swift.String? = nil,
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            rulesList: [SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails]? = nil,
            webAclId: Swift.String? = nil
        )
        {
            self.defaultAction = defaultAction
            self.metricName = metricName
            self.name = name
            self.rulesList = rulesList
            self.webAclId = webAclId
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// The action that WAF takes when a web request matches all conditions in the rule, such as allow, block, or count the request.
    public struct AwsWafRegionalWebAclRulesListActionDetails: Swift.Equatable {
        /// For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule.
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalWebAclRulesListDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case overrideAction = "OverrideAction"
        case priority = "Priority"
        case ruleId = "RuleId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let overrideAction = self.overrideAction {
            try encodeContainer.encode(overrideAction, forKey: .overrideAction)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails.self, forKey: .action)
        action = actionDecoded
        let overrideActionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails.self, forKey: .overrideAction)
        overrideAction = overrideActionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A combination of ByteMatchSet, IPSet, and/or SqlInjectionMatchSet objects that identify the web requests that you want to allow, block, or count.
    public struct AwsWafRegionalWebAclRulesListDetails: Swift.Equatable {
        /// The action that WAF takes when a web request matches all conditions in the rule, such as allow, block, or count the request.
        public var action: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails?
        /// Overrides the rule evaluation result in the rule group.
        public var overrideAction: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails?
        /// The order in which WAF evaluates the rules in a web ACL.
        public var priority: Swift.Int
        /// The ID of an WAF Regional rule to associate with a web ACL.
        public var ruleId: Swift.String?
        /// For actions that are associated with a rule, the action that WAF takes when a web request matches all conditions in a rule.
        public var type: Swift.String?

        public init (
            action: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListActionDetails? = nil,
            overrideAction: SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails? = nil,
            priority: Swift.Int = 0,
            ruleId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.action = action
            self.overrideAction = overrideAction
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRegionalWebAclRulesListOverrideActionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the action to use in the place of the action that results from the rule group evaluation.
    public struct AwsWafRegionalWebAclRulesListOverrideActionDetails: Swift.Equatable {
        /// Overrides the rule evaluation result in the rule group.
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRuleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case name = "Name"
        case predicateList = "PredicateList"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predicateList = predicateList {
            var predicateListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predicateList)
            for awswafrulepredicatelistdetails0 in predicateList {
                try predicateListContainer.encode(awswafrulepredicatelistdetails0)
            }
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let predicateListContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafRulePredicateListDetails?].self, forKey: .predicateList)
        var predicateListDecoded0:[SecurityHubClientTypes.AwsWafRulePredicateListDetails]? = nil
        if let predicateListContainer = predicateListContainer {
            predicateListDecoded0 = [SecurityHubClientTypes.AwsWafRulePredicateListDetails]()
            for structure0 in predicateListContainer {
                if let structure0 = structure0 {
                    predicateListDecoded0?.append(structure0)
                }
            }
        }
        predicateList = predicateListDecoded0
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about a WAF rule. This rule specifies the web requests that you want to allow, block, or count.
    public struct AwsWafRuleDetails: Swift.Equatable {
        /// The name of the metrics for this rule.
        public var metricName: Swift.String?
        /// A descriptive name for the rule.
        public var name: Swift.String?
        /// Specifies the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
        public var predicateList: [SecurityHubClientTypes.AwsWafRulePredicateListDetails]?
        /// The ID of the WAF rule.
        public var ruleId: Swift.String?

        public init (
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            predicateList: [SecurityHubClientTypes.AwsWafRulePredicateListDetails]? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.metricName = metricName
            self.name = name
            self.predicateList = predicateList
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes.AwsWafRuleGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricName = "MetricName"
        case name = "Name"
        case ruleGroupId = "RuleGroupId"
        case rules = "Rules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ruleGroupId = self.ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for awswafrulegrouprulesdetails0 in rules {
                try rulesContainer.encode(awswafrulegrouprulesdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let rulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafRuleGroupRulesDetails?].self, forKey: .rules)
        var rulesDecoded0:[SecurityHubClientTypes.AwsWafRuleGroupRulesDetails]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [SecurityHubClientTypes.AwsWafRuleGroupRulesDetails]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an WAF rule group. A rule group is a collection of rules for inspecting and controlling web requests.
    public struct AwsWafRuleGroupDetails: Swift.Equatable {
        /// The name of the metrics for this rule group.
        public var metricName: Swift.String?
        /// The name of the rule group.
        public var name: Swift.String?
        /// The ID of the rule group.
        public var ruleGroupId: Swift.String?
        /// Provides information about the rules attached to the rule group. These rules identify the web requests that you want to allow, block, or count.
        public var rules: [SecurityHubClientTypes.AwsWafRuleGroupRulesDetails]?

        public init (
            metricName: Swift.String? = nil,
            name: Swift.String? = nil,
            ruleGroupId: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafRuleGroupRulesDetails]? = nil
        )
        {
            self.metricName = metricName
            self.name = name
            self.ruleGroupId = ruleGroupId
            self.rules = rules
        }
    }

}

extension SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule.
    public struct AwsWafRuleGroupRulesActionDetails: Swift.Equatable {
        /// The action that WAF should take on a web request when it matches the rule's statement.
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRuleGroupRulesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case priority = "Priority"
        case ruleId = "RuleId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails.self, forKey: .action)
        action = actionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the rules attached to the rule group. These rules identify the web requests that you want to allow, block, or count.
    public struct AwsWafRuleGroupRulesDetails: Swift.Equatable {
        /// Provides information about what action WAF should take on a web request when it matches the criteria defined in the rule.
        public var action: SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails?
        /// If you define more than one rule in a web ACL, WAF evaluates each request against the rules in order based on the value of Priority.
        public var priority: Swift.Int
        /// The rule ID for a rule.
        public var ruleId: Swift.String?
        /// The type of rule.
        public var type: Swift.String?

        public init (
            action: SecurityHubClientTypes.AwsWafRuleGroupRulesActionDetails? = nil,
            priority: Swift.Int = 0,
            ruleId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.action = action
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafRulePredicateListDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataId = "DataId"
        case negated = "Negated"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataId = self.dataId {
            try encodeContainer.encode(dataId, forKey: .dataId)
        }
        if negated != false {
            try encodeContainer.encode(negated, forKey: .negated)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataId)
        dataId = dataIdDecoded
        let negatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .negated) ?? false
        negated = negatedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, and SizeConstraintSet objects that you want to add to a rule and, for each object, indicates whether you want to negate the settings.
    public struct AwsWafRulePredicateListDetails: Swift.Equatable {
        /// A unique identifier for a predicate in a rule, such as ByteMatchSetId or IPSetId.
        public var dataId: Swift.String?
        /// Specifies if you want WAF to allow, block, or count requests based on the settings in the ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, RegexMatchSet, GeoMatchSet, or SizeConstraintSet.
        public var negated: Swift.Bool
        /// The type of predicate in a rule, such as ByteMatch or IPSet.
        public var type: Swift.String?

        public init (
            dataId: Swift.String? = nil,
            negated: Swift.Bool = false,
            type: Swift.String? = nil
        )
        {
            self.dataId = dataId
            self.negated = negated
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafWebAclDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAction = "DefaultAction"
        case name = "Name"
        case rules = "Rules"
        case webAclId = "WebAclId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAction = self.defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for awswafwebaclrule0 in rules {
                try rulesContainer.encode(awswafwebaclrule0)
            }
        }
        if let webAclId = self.webAclId {
            try encodeContainer.encode(webAclId, forKey: .webAclId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafWebAclRule?].self, forKey: .rules)
        var rulesDecoded0:[SecurityHubClientTypes.AwsWafWebAclRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [SecurityHubClientTypes.AwsWafWebAclRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let webAclIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclId)
        webAclId = webAclIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an WAF web access control list (web ACL).
    public struct AwsWafWebAclDetails: Swift.Equatable {
        /// The action to perform if none of the rules contained in the web ACL match.
        public var defaultAction: Swift.String?
        /// A friendly name or description of the web ACL. You can't change the name of a web ACL after you create it.
        public var name: Swift.String?
        /// An array that contains the action for each rule in a web ACL, the priority of the rule, and the ID of the rule.
        public var rules: [SecurityHubClientTypes.AwsWafWebAclRule]?
        /// A unique identifier for a web ACL.
        public var webAclId: Swift.String?

        public init (
            defaultAction: Swift.String? = nil,
            name: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafWebAclRule]? = nil,
            webAclId: Swift.String? = nil
        )
        {
            self.defaultAction = defaultAction
            self.name = name
            self.rules = rules
            self.webAclId = webAclId
        }
    }

}

extension SecurityHubClientTypes.AwsWafWebAclRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case excludedRules = "ExcludedRules"
        case overrideAction = "OverrideAction"
        case priority = "Priority"
        case ruleId = "RuleId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let excludedRules = excludedRules {
            var excludedRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedRules)
            for wafexcludedrule0 in excludedRules {
                try excludedRulesContainer.encode(wafexcludedrule0)
            }
        }
        if let overrideAction = self.overrideAction {
            try encodeContainer.encode(overrideAction, forKey: .overrideAction)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.WafAction.self, forKey: .action)
        action = actionDecoded
        let excludedRulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.WafExcludedRule?].self, forKey: .excludedRules)
        var excludedRulesDecoded0:[SecurityHubClientTypes.WafExcludedRule]? = nil
        if let excludedRulesContainer = excludedRulesContainer {
            excludedRulesDecoded0 = [SecurityHubClientTypes.WafExcludedRule]()
            for structure0 in excludedRulesContainer {
                if let structure0 = structure0 {
                    excludedRulesDecoded0?.append(structure0)
                }
            }
        }
        excludedRules = excludedRulesDecoded0
        let overrideActionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.WafOverrideAction.self, forKey: .overrideAction)
        overrideAction = overrideActionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details for a rule in an WAF web ACL.
    public struct AwsWafWebAclRule: Swift.Equatable {
        /// Specifies the action that CloudFront or WAF takes when a web request matches the conditions in the rule.
        public var action: SecurityHubClientTypes.WafAction?
        /// Rules to exclude from a rule group.
        public var excludedRules: [SecurityHubClientTypes.WafExcludedRule]?
        /// Use the OverrideAction to test your RuleGroup. Any rule in a RuleGroup can potentially block a request. If you set the OverrideAction to None, the RuleGroup blocks a request if any individual rule in the RuleGroup matches the request and is configured to block that request. However, if you first want to test the RuleGroup, set the OverrideAction to Count. The RuleGroup then overrides any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests are counted. ActivatedRule|OverrideAction applies only when updating or adding a RuleGroup to a web ACL. In this case you do not use ActivatedRuleAction. For all other update requests, ActivatedRuleAction is used instead of ActivatedRuleOverrideAction.
        public var overrideAction: SecurityHubClientTypes.WafOverrideAction?
        /// Specifies the order in which the rules in a web ACL are evaluated. Rules with a lower value for Priority are evaluated before rules with a higher value. The value must be a unique integer. If you add multiple rules to a web ACL, the values do not need to be consecutive.
        public var priority: Swift.Int
        /// The identifier for a rule.
        public var ruleId: Swift.String?
        /// The rule type. Valid values: REGULAR | RATE_BASED | GROUP The default is REGULAR.
        public var type: Swift.String?

        public init (
            action: SecurityHubClientTypes.WafAction? = nil,
            excludedRules: [SecurityHubClientTypes.WafExcludedRule]? = nil,
            overrideAction: SecurityHubClientTypes.WafOverrideAction? = nil,
            priority: Swift.Int = 0,
            ruleId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.action = action
            self.excludedRules = excludedRules
            self.overrideAction = overrideAction
            self.priority = priority
            self.ruleId = ruleId
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2ActionAllowDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRequestHandling = "CustomRequestHandling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRequestHandling = self.customRequestHandling {
            try encodeContainer.encode(customRequestHandling, forKey: .customRequestHandling)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRequestHandlingDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails.self, forKey: .customRequestHandling)
        customRequestHandling = customRequestHandlingDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies that WAF should allow the request and optionally defines additional custom handling for the request.
    public struct AwsWafv2ActionAllowDetails: Swift.Equatable {
        /// Defines custom handling for the web request. For information about customizing web requests and responses, see [Customizing web requests and responses in WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the WAF Developer Guide..
        public var customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails?

        public init (
            customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails? = nil
        )
        {
            self.customRequestHandling = customRequestHandling
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2ActionBlockDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customResponse = "CustomResponse"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customResponse = self.customResponse {
            try encodeContainer.encode(customResponse, forKey: .customResponse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customResponseDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2CustomResponseDetails.self, forKey: .customResponse)
        customResponse = customResponseDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies that WAF should block the request and optionally defines additional custom handling for the response to the web request.
    public struct AwsWafv2ActionBlockDetails: Swift.Equatable {
        /// Defines a custom response for the web request. For information, see [Customizing web requests and responses in WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the WAF Developer Guide..
        public var customResponse: SecurityHubClientTypes.AwsWafv2CustomResponseDetails?

        public init (
            customResponse: SecurityHubClientTypes.AwsWafv2CustomResponseDetails? = nil
        )
        {
            self.customResponse = customResponse
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2CustomHttpHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A custom header for custom request and response handling.
    public struct AwsWafv2CustomHttpHeader: Swift.Equatable {
        /// The name of the custom header.
        public var name: Swift.String?
        /// The value of the custom header.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insertHeaders = "InsertHeaders"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insertHeaders = insertHeaders {
            var insertHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insertHeaders)
            for awswafv2customhttpheader0 in insertHeaders {
                try insertHeadersContainer.encode(awswafv2customhttpheader0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insertHeadersContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafv2CustomHttpHeader?].self, forKey: .insertHeaders)
        var insertHeadersDecoded0:[SecurityHubClientTypes.AwsWafv2CustomHttpHeader]? = nil
        if let insertHeadersContainer = insertHeadersContainer {
            insertHeadersDecoded0 = [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]()
            for structure0 in insertHeadersContainer {
                if let structure0 = structure0 {
                    insertHeadersDecoded0?.append(structure0)
                }
            }
        }
        insertHeaders = insertHeadersDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Custom request handling behavior that inserts custom headers into a web request. WAF uses custom request handling when the rule action doesn't block the request.
    public struct AwsWafv2CustomRequestHandlingDetails: Swift.Equatable {
        /// The HTTP headers to insert into the request.
        public var insertHeaders: [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]?

        public init (
            insertHeaders: [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]? = nil
        )
        {
            self.insertHeaders = insertHeaders
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2CustomResponseDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customResponseBodyKey = "CustomResponseBodyKey"
        case responseCode = "ResponseCode"
        case responseHeaders = "ResponseHeaders"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customResponseBodyKey = self.customResponseBodyKey {
            try encodeContainer.encode(customResponseBodyKey, forKey: .customResponseBodyKey)
        }
        if responseCode != 0 {
            try encodeContainer.encode(responseCode, forKey: .responseCode)
        }
        if let responseHeaders = responseHeaders {
            var responseHeadersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseHeaders)
            for awswafv2customhttpheader0 in responseHeaders {
                try responseHeadersContainer.encode(awswafv2customhttpheader0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customResponseBodyKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customResponseBodyKey)
        customResponseBodyKey = customResponseBodyKeyDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .responseCode) ?? 0
        responseCode = responseCodeDecoded
        let responseHeadersContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafv2CustomHttpHeader?].self, forKey: .responseHeaders)
        var responseHeadersDecoded0:[SecurityHubClientTypes.AwsWafv2CustomHttpHeader]? = nil
        if let responseHeadersContainer = responseHeadersContainer {
            responseHeadersDecoded0 = [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]()
            for structure0 in responseHeadersContainer {
                if let structure0 = structure0 {
                    responseHeadersDecoded0?.append(structure0)
                }
            }
        }
        responseHeaders = responseHeadersDecoded0
    }
}

extension SecurityHubClientTypes {
    /// A custom response to send to the client. You can define a custom response for rule actions and default web ACL actions that are set to block.
    public struct AwsWafv2CustomResponseDetails: Swift.Equatable {
        /// References the response body that you want WAF to return to the web request client. You can define a custom response for a rule action or a default web ACL action that is set to block.
        public var customResponseBodyKey: Swift.String?
        /// The HTTP status code to return to the client. For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the WAF Developer Guide.
        public var responseCode: Swift.Int
        /// The HTTP headers to use in the response.
        public var responseHeaders: [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]?

        public init (
            customResponseBodyKey: Swift.String? = nil,
            responseCode: Swift.Int = 0,
            responseHeaders: [SecurityHubClientTypes.AwsWafv2CustomHttpHeader]? = nil
        )
        {
            self.customResponseBodyKey = customResponseBodyKey
            self.responseCode = responseCode
            self.responseHeaders = responseHeaders
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2RuleGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case capacity = "Capacity"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case rules = "Rules"
        case scope = "Scope"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if capacity != 0 {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for awswafv2rulesdetails0 in rules {
                try rulesContainer.encode(awswafv2rulesdetails0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let visibilityConfig = self.visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .capacity) ?? 0
        capacity = capacityDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let rulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafv2RulesDetails?].self, forKey: .rules)
        var rulesDecoded0:[SecurityHubClientTypes.AwsWafv2RulesDetails]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [SecurityHubClientTypes.AwsWafv2RulesDetails]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an WAFv2 rule group.
    public struct AwsWafv2RuleGroupDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the entity.
        public var arn: Swift.String?
        /// The web ACL capacity units (WCUs) required for this rule group.
        public var capacity: Swift.Int
        /// A description of the rule group that helps with identification.
        public var description: Swift.String?
        /// A unique identifier for the rule group.
        public var id: Swift.String?
        /// The name of the rule group. You cannot change the name of a rule group after you create it.
        public var name: Swift.String?
        /// The Rule statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them.
        public var rules: [SecurityHubClientTypes.AwsWafv2RulesDetails]?
        /// Specifies whether the rule group is for an Amazon CloudFront distribution or for a regional application. A regional application can be an Application Load Balancer (ALB), an Amazon API Gateway REST API, an AppSync GraphQL API, or an Amazon Cognito user pool.
        public var scope: Swift.String?
        /// Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public var visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails?

        public init (
            arn: Swift.String? = nil,
            capacity: Swift.Int = 0,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafv2RulesDetails]? = nil,
            scope: Swift.String? = nil,
            visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails? = nil
        )
        {
            self.arn = arn
            self.capacity = capacity
            self.description = description
            self.id = id
            self.name = name
            self.rules = rules
            self.scope = scope
            self.visibilityConfig = visibilityConfig
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRequestHandling = "CustomRequestHandling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRequestHandling = self.customRequestHandling {
            try encodeContainer.encode(customRequestHandling, forKey: .customRequestHandling)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRequestHandlingDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails.self, forKey: .customRequestHandling)
        customRequestHandling = customRequestHandlingDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies that WAF should run a CAPTCHA check against the request.
    public struct AwsWafv2RulesActionCaptchaDetails: Swift.Equatable {
        /// Defines custom handling for the web request, used when the CAPTCHA inspection determines that the request's token is valid and unexpired. For more information, see [Customizing web requests and responses in WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the WAF Developer Guide..
        public var customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails?

        public init (
            customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails? = nil
        )
        {
            self.customRequestHandling = customRequestHandling
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2RulesActionCountDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customRequestHandling = "CustomRequestHandling"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRequestHandling = self.customRequestHandling {
            try encodeContainer.encode(customRequestHandling, forKey: .customRequestHandling)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customRequestHandlingDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails.self, forKey: .customRequestHandling)
        customRequestHandling = customRequestHandlingDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies that WAF should count the request.
    public struct AwsWafv2RulesActionCountDetails: Swift.Equatable {
        /// Defines custom handling for the web request. For more information, see [Customizing web requests and responses in WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the WAF Developer Guide..
        public var customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails?

        public init (
            customRequestHandling: SecurityHubClientTypes.AwsWafv2CustomRequestHandlingDetails? = nil
        )
        {
            self.customRequestHandling = customRequestHandling
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2RulesActionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allow = "Allow"
        case block = "Block"
        case captcha = "Captcha"
        case count = "Count"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allow = self.allow {
            try encodeContainer.encode(allow, forKey: .allow)
        }
        if let block = self.block {
            try encodeContainer.encode(block, forKey: .block)
        }
        if let captcha = self.captcha {
            try encodeContainer.encode(captcha, forKey: .captcha)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2ActionAllowDetails.self, forKey: .allow)
        allow = allowDecoded
        let blockDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2ActionBlockDetails.self, forKey: .block)
        block = blockDecoded
        let captchaDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails.self, forKey: .captcha)
        captcha = captchaDecoded
        let countDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2RulesActionCountDetails.self, forKey: .count)
        count = countDecoded
    }
}

extension SecurityHubClientTypes {
    /// The action that WAF should take on a web request when it matches a rule's statement. Settings at the web ACL level can override the rule action setting.
    public struct AwsWafv2RulesActionDetails: Swift.Equatable {
        /// Instructs WAF to allow the web request.
        public var allow: SecurityHubClientTypes.AwsWafv2ActionAllowDetails?
        /// Instructs WAF to block the web request.
        public var block: SecurityHubClientTypes.AwsWafv2ActionBlockDetails?
        /// Instructs WAF to run a CAPTCHA check against the web request.
        public var captcha: SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails?
        /// Instructs WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
        public var count: SecurityHubClientTypes.AwsWafv2RulesActionCountDetails?

        public init (
            allow: SecurityHubClientTypes.AwsWafv2ActionAllowDetails? = nil,
            block: SecurityHubClientTypes.AwsWafv2ActionBlockDetails? = nil,
            captcha: SecurityHubClientTypes.AwsWafv2RulesActionCaptchaDetails? = nil,
            count: SecurityHubClientTypes.AwsWafv2RulesActionCountDetails? = nil
        )
        {
            self.allow = allow
            self.block = block
            self.captcha = captcha
            self.count = count
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2RulesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case name = "Name"
        case overrideAction = "OverrideAction"
        case priority = "Priority"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrideAction = self.overrideAction {
            try encodeContainer.encode(overrideAction, forKey: .overrideAction)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let visibilityConfig = self.visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2RulesActionDetails.self, forKey: .action)
        action = actionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let overrideActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideAction)
        overrideAction = overrideActionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about rules in a rule group. A rule identifies web requests that you want to allow, block, or count. Each rule includes one top-level Statement that AWS WAF uses to identify matching web requests, and parameters that govern how AWS WAF handles them.
    public struct AwsWafv2RulesDetails: Swift.Equatable {
        /// The action that WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting.
        public var action: SecurityHubClientTypes.AwsWafv2RulesActionDetails?
        /// The name of the rule.
        public var name: Swift.String?
        /// The action to use in the place of the action that results from the rule group evaluation.
        public var overrideAction: Swift.String?
        /// If you define more than one Rule in a WebACL, WAF evaluates each request against the Rules in order based on the value of Priority. WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
        public var priority: Swift.Int
        /// Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public var visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails?

        public init (
            action: SecurityHubClientTypes.AwsWafv2RulesActionDetails? = nil,
            name: Swift.String? = nil,
            overrideAction: Swift.String? = nil,
            priority: Swift.Int = 0,
            visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails? = nil
        )
        {
            self.action = action
            self.name = name
            self.overrideAction = overrideAction
            self.priority = priority
            self.visibilityConfig = visibilityConfig
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
        case metricName = "MetricName"
        case sampledRequestsEnabled = "SampledRequestsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cloudWatchMetricsEnabled != false {
            try encodeContainer.encode(cloudWatchMetricsEnabled, forKey: .cloudWatchMetricsEnabled)
        }
        if let metricName = self.metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if sampledRequestsEnabled != false {
            try encodeContainer.encode(sampledRequestsEnabled, forKey: .sampledRequestsEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cloudWatchMetricsEnabled) ?? false
        cloudWatchMetricsEnabled = cloudWatchMetricsEnabledDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let sampledRequestsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sampledRequestsEnabled) ?? false
        sampledRequestsEnabled = sampledRequestsEnabledDecoded
    }
}

extension SecurityHubClientTypes {
    /// Defines and enables Amazon CloudWatch metrics and web request sample collection.
    public struct AwsWafv2VisibilityConfigDetails: Swift.Equatable {
        /// A boolean indicating whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [WAF metrics and dimensions](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the WAF Developer Guide.
        public var cloudWatchMetricsEnabled: Swift.Bool
        /// A name of the Amazon CloudWatch metric.
        public var metricName: Swift.String?
        /// A boolean indicating whether WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the WAF console.
        public var sampledRequestsEnabled: Swift.Bool

        public init (
            cloudWatchMetricsEnabled: Swift.Bool = false,
            metricName: Swift.String? = nil,
            sampledRequestsEnabled: Swift.Bool = false
        )
        {
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.metricName = metricName
            self.sampledRequestsEnabled = sampledRequestsEnabled
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2WebAclActionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allow = "Allow"
        case block = "Block"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allow = self.allow {
            try encodeContainer.encode(allow, forKey: .allow)
        }
        if let block = self.block {
            try encodeContainer.encode(block, forKey: .block)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2ActionAllowDetails.self, forKey: .allow)
        allow = allowDecoded
        let blockDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2ActionBlockDetails.self, forKey: .block)
        block = blockDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies the action that Amazon CloudFront or WAF takes when a web request matches the conditions in the rule.
    public struct AwsWafv2WebAclActionDetails: Swift.Equatable {
        /// Specifies that WAF should allow requests by default.
        public var allow: SecurityHubClientTypes.AwsWafv2ActionAllowDetails?
        /// Specifies that WAF should block requests by default.
        public var block: SecurityHubClientTypes.AwsWafv2ActionBlockDetails?

        public init (
            allow: SecurityHubClientTypes.AwsWafv2ActionAllowDetails? = nil,
            block: SecurityHubClientTypes.AwsWafv2ActionBlockDetails? = nil
        )
        {
            self.allow = allow
            self.block = block
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case immunityTimeProperty = "ImmunityTimeProperty"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let immunityTimeProperty = self.immunityTimeProperty {
            try encodeContainer.encode(immunityTimeProperty, forKey: .immunityTimeProperty)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let immunityTimePropertyDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails.self, forKey: .immunityTimeProperty)
        immunityTimeProperty = immunityTimePropertyDecoded
    }
}

extension SecurityHubClientTypes {
    /// Specifies how WAF should handle CAPTCHA evaluations for rules that don't have their own CaptchaConfig settings.
    public struct AwsWafv2WebAclCaptchaConfigDetails: Swift.Equatable {
        /// Determines how long a CAPTCHA timestamp in the token remains valid after the client successfully solves a CAPTCHA puzzle.
        public var immunityTimeProperty: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails?

        public init (
            immunityTimeProperty: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails? = nil
        )
        {
            self.immunityTimeProperty = immunityTimeProperty
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case immunityTime = "ImmunityTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if immunityTime != 0 {
            try encodeContainer.encode(immunityTime, forKey: .immunityTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let immunityTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .immunityTime) ?? 0
        immunityTime = immunityTimeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Used for CAPTCHA and challenge token settings. Determines how long a CAPTCHA or challenge timestamp remains valid after WAF updates it for a successful CAPTCHA or challenge response.
    public struct AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails: Swift.Equatable {
        /// The amount of time, in seconds, that a CAPTCHA or challenge timestamp is considered valid by WAF.
        public var immunityTime: Swift.Int

        public init (
            immunityTime: Swift.Int = 0
        )
        {
            self.immunityTime = immunityTime
        }
    }

}

extension SecurityHubClientTypes.AwsWafv2WebAclDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case capacity = "Capacity"
        case captchaConfig = "CaptchaConfig"
        case defaultAction = "DefaultAction"
        case description = "Description"
        case id = "Id"
        case managedbyFirewallManager = "ManagedbyFirewallManager"
        case name = "Name"
        case rules = "Rules"
        case visibilityConfig = "VisibilityConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if capacity != 0 {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let captchaConfig = self.captchaConfig {
            try encodeContainer.encode(captchaConfig, forKey: .captchaConfig)
        }
        if let defaultAction = self.defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if managedbyFirewallManager != false {
            try encodeContainer.encode(managedbyFirewallManager, forKey: .managedbyFirewallManager)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for awswafv2rulesdetails0 in rules {
                try rulesContainer.encode(awswafv2rulesdetails0)
            }
        }
        if let visibilityConfig = self.visibilityConfig {
            try encodeContainer.encode(visibilityConfig, forKey: .visibilityConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let managedbyFirewallManagerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .managedbyFirewallManager) ?? false
        managedbyFirewallManager = managedbyFirewallManagerDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .capacity) ?? 0
        capacity = capacityDecoded
        let captchaConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails.self, forKey: .captchaConfig)
        captchaConfig = captchaConfigDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2WebAclActionDetails.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsWafv2RulesDetails?].self, forKey: .rules)
        var rulesDecoded0:[SecurityHubClientTypes.AwsWafv2RulesDetails]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [SecurityHubClientTypes.AwsWafv2RulesDetails]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let visibilityConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails.self, forKey: .visibilityConfig)
        visibilityConfig = visibilityConfigDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an WAFv2 web Access Control List (ACL).
    public struct AwsWafv2WebAclDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the web ACL that you want to associate with the resource.
        public var arn: Swift.String?
        /// The web ACL capacity units (WCUs) currently being used by this web ACL.
        public var capacity: Swift.Int
        /// Specifies how WAF should handle CAPTCHA evaluations for rules that don't have their own CaptchaConfig settings.
        public var captchaConfig: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails?
        /// The action to perform if none of the Rules contained in the web ACL match.
        public var defaultAction: SecurityHubClientTypes.AwsWafv2WebAclActionDetails?
        /// A description of the web ACL that helps with identification.
        public var description: Swift.String?
        /// A unique identifier for the web ACL.
        public var id: Swift.String?
        /// Indicates whether this web ACL is managed by Firewall Manager.
        public var managedbyFirewallManager: Swift.Bool
        /// The name of the web ACL.
        public var name: Swift.String?
        /// The Rule statements used to identify the web requests that you want to allow, block, or count. Each rule includes one top-level statement that WAF uses to identify matching web requests, and parameters that govern how WAF handles them.
        public var rules: [SecurityHubClientTypes.AwsWafv2RulesDetails]?
        /// Defines and enables Amazon CloudWatch metrics and web request sample collection.
        public var visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails?

        public init (
            arn: Swift.String? = nil,
            capacity: Swift.Int = 0,
            captchaConfig: SecurityHubClientTypes.AwsWafv2WebAclCaptchaConfigDetails? = nil,
            defaultAction: SecurityHubClientTypes.AwsWafv2WebAclActionDetails? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            managedbyFirewallManager: Swift.Bool = false,
            name: Swift.String? = nil,
            rules: [SecurityHubClientTypes.AwsWafv2RulesDetails]? = nil,
            visibilityConfig: SecurityHubClientTypes.AwsWafv2VisibilityConfigDetails? = nil
        )
        {
            self.arn = arn
            self.capacity = capacity
            self.captchaConfig = captchaConfig
            self.defaultAction = defaultAction
            self.description = description
            self.id = id
            self.managedbyFirewallManager = managedbyFirewallManager
            self.name = name
            self.rules = rules
            self.visibilityConfig = visibilityConfig
        }
    }

}

extension SecurityHubClientTypes.AwsXrayEncryptionConfigDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId = "KeyId"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = self.keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the encryption configuration for X-Ray.
    public struct AwsXrayEncryptionConfigDetails: Swift.Equatable {
        /// The identifier of the KMS key that is used for encryption. Provided if Type is KMS.
        public var keyId: Swift.String?
        /// The current status of the encryption configuration. Valid values are ACTIVE or UPDATING. When Status is equal to UPDATING, X-Ray might use both the old and new encryption.
        public var status: Swift.String?
        /// The type of encryption. KMS indicates that the encryption uses KMS keys. NONE indicates the default encryption.
        public var type: Swift.String?

        public init (
            keyId: Swift.String? = nil,
            status: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.keyId = keyId
            self.status = status
            self.type = type
        }
    }

}

extension BatchDisableStandardsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case standardsSubscriptionArns = "StandardsSubscriptionArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let standardsSubscriptionArns = standardsSubscriptionArns {
            var standardsSubscriptionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardsSubscriptionArns)
            for nonemptystring0 in standardsSubscriptionArns {
                try standardsSubscriptionArnsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension BatchDisableStandardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/standards/deregister"
    }
}

public struct BatchDisableStandardsInput: Swift.Equatable {
    /// The ARNs of the standards subscriptions to disable.
    /// This member is required.
    public var standardsSubscriptionArns: [Swift.String]?

    public init (
        standardsSubscriptionArns: [Swift.String]? = nil
    )
    {
        self.standardsSubscriptionArns = standardsSubscriptionArns
    }
}

struct BatchDisableStandardsInputBody: Swift.Equatable {
    let standardsSubscriptionArns: [Swift.String]?
}

extension BatchDisableStandardsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case standardsSubscriptionArns = "StandardsSubscriptionArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .standardsSubscriptionArns)
        var standardsSubscriptionArnsDecoded0:[Swift.String]? = nil
        if let standardsSubscriptionArnsContainer = standardsSubscriptionArnsContainer {
            standardsSubscriptionArnsDecoded0 = [Swift.String]()
            for string0 in standardsSubscriptionArnsContainer {
                if let string0 = string0 {
                    standardsSubscriptionArnsDecoded0?.append(string0)
                }
            }
        }
        standardsSubscriptionArns = standardsSubscriptionArnsDecoded0
    }
}

extension BatchDisableStandardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisableStandardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDisableStandardsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisableStandardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDisableStandardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.standardsSubscriptions = output.standardsSubscriptions
        } else {
            self.standardsSubscriptions = nil
        }
    }
}

public struct BatchDisableStandardsOutputResponse: Swift.Equatable {
    /// The details of the standards subscriptions that were disabled.
    public var standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]?

    public init (
        standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]? = nil
    )
    {
        self.standardsSubscriptions = standardsSubscriptions
    }
}

struct BatchDisableStandardsOutputResponseBody: Swift.Equatable {
    let standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]?
}

extension BatchDisableStandardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case standardsSubscriptions = "StandardsSubscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StandardsSubscription?].self, forKey: .standardsSubscriptions)
        var standardsSubscriptionsDecoded0:[SecurityHubClientTypes.StandardsSubscription]? = nil
        if let standardsSubscriptionsContainer = standardsSubscriptionsContainer {
            standardsSubscriptionsDecoded0 = [SecurityHubClientTypes.StandardsSubscription]()
            for structure0 in standardsSubscriptionsContainer {
                if let structure0 = structure0 {
                    standardsSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        standardsSubscriptions = standardsSubscriptionsDecoded0
    }
}

extension BatchEnableStandardsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case standardsSubscriptionRequests = "StandardsSubscriptionRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let standardsSubscriptionRequests = standardsSubscriptionRequests {
            var standardsSubscriptionRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardsSubscriptionRequests)
            for standardssubscriptionrequest0 in standardsSubscriptionRequests {
                try standardsSubscriptionRequestsContainer.encode(standardssubscriptionrequest0)
            }
        }
    }
}

extension BatchEnableStandardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/standards/register"
    }
}

public struct BatchEnableStandardsInput: Swift.Equatable {
    /// The list of standards checks to enable.
    /// This member is required.
    public var standardsSubscriptionRequests: [SecurityHubClientTypes.StandardsSubscriptionRequest]?

    public init (
        standardsSubscriptionRequests: [SecurityHubClientTypes.StandardsSubscriptionRequest]? = nil
    )
    {
        self.standardsSubscriptionRequests = standardsSubscriptionRequests
    }
}

struct BatchEnableStandardsInputBody: Swift.Equatable {
    let standardsSubscriptionRequests: [SecurityHubClientTypes.StandardsSubscriptionRequest]?
}

extension BatchEnableStandardsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case standardsSubscriptionRequests = "StandardsSubscriptionRequests"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionRequestsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StandardsSubscriptionRequest?].self, forKey: .standardsSubscriptionRequests)
        var standardsSubscriptionRequestsDecoded0:[SecurityHubClientTypes.StandardsSubscriptionRequest]? = nil
        if let standardsSubscriptionRequestsContainer = standardsSubscriptionRequestsContainer {
            standardsSubscriptionRequestsDecoded0 = [SecurityHubClientTypes.StandardsSubscriptionRequest]()
            for structure0 in standardsSubscriptionRequestsContainer {
                if let structure0 = structure0 {
                    standardsSubscriptionRequestsDecoded0?.append(structure0)
                }
            }
        }
        standardsSubscriptionRequests = standardsSubscriptionRequestsDecoded0
    }
}

extension BatchEnableStandardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchEnableStandardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchEnableStandardsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchEnableStandardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchEnableStandardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.standardsSubscriptions = output.standardsSubscriptions
        } else {
            self.standardsSubscriptions = nil
        }
    }
}

public struct BatchEnableStandardsOutputResponse: Swift.Equatable {
    /// The details of the standards subscriptions that were enabled.
    public var standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]?

    public init (
        standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]? = nil
    )
    {
        self.standardsSubscriptions = standardsSubscriptions
    }
}

struct BatchEnableStandardsOutputResponseBody: Swift.Equatable {
    let standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]?
}

extension BatchEnableStandardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case standardsSubscriptions = "StandardsSubscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StandardsSubscription?].self, forKey: .standardsSubscriptions)
        var standardsSubscriptionsDecoded0:[SecurityHubClientTypes.StandardsSubscription]? = nil
        if let standardsSubscriptionsContainer = standardsSubscriptionsContainer {
            standardsSubscriptionsDecoded0 = [SecurityHubClientTypes.StandardsSubscription]()
            for structure0 in standardsSubscriptionsContainer {
                if let structure0 = structure0 {
                    standardsSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        standardsSubscriptions = standardsSubscriptionsDecoded0
    }
}

extension BatchImportFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings = "Findings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findings = findings {
            var findingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findings)
            for awssecurityfinding0 in findings {
                try findingsContainer.encode(awssecurityfinding0)
            }
        }
    }
}

extension BatchImportFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/import"
    }
}

public struct BatchImportFindingsInput: Swift.Equatable {
    /// A list of findings to import. To successfully import a finding, it must follow the [Amazon Web Services Security Finding Format](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format.html). Maximum of 100 findings per request.
    /// This member is required.
    public var findings: [SecurityHubClientTypes.AwsSecurityFinding]?

    public init (
        findings: [SecurityHubClientTypes.AwsSecurityFinding]? = nil
    )
    {
        self.findings = findings
    }
}

struct BatchImportFindingsInputBody: Swift.Equatable {
    let findings: [SecurityHubClientTypes.AwsSecurityFinding]?
}

extension BatchImportFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings = "Findings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsSecurityFinding?].self, forKey: .findings)
        var findingsDecoded0:[SecurityHubClientTypes.AwsSecurityFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [SecurityHubClientTypes.AwsSecurityFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

extension BatchImportFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchImportFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchImportFindingsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchImportFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchImportFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedCount = output.failedCount
            self.failedFindings = output.failedFindings
            self.successCount = output.successCount
        } else {
            self.failedCount = 0
            self.failedFindings = nil
            self.successCount = 0
        }
    }
}

public struct BatchImportFindingsOutputResponse: Swift.Equatable {
    /// The number of findings that failed to import.
    /// This member is required.
    public var failedCount: Swift.Int
    /// The list of findings that failed to import.
    public var failedFindings: [SecurityHubClientTypes.ImportFindingsError]?
    /// The number of findings that were successfully imported.
    /// This member is required.
    public var successCount: Swift.Int

    public init (
        failedCount: Swift.Int = 0,
        failedFindings: [SecurityHubClientTypes.ImportFindingsError]? = nil,
        successCount: Swift.Int = 0
    )
    {
        self.failedCount = failedCount
        self.failedFindings = failedFindings
        self.successCount = successCount
    }
}

struct BatchImportFindingsOutputResponseBody: Swift.Equatable {
    let failedCount: Swift.Int
    let successCount: Swift.Int
    let failedFindings: [SecurityHubClientTypes.ImportFindingsError]?
}

extension BatchImportFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedCount = "FailedCount"
        case failedFindings = "FailedFindings"
        case successCount = "SuccessCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedCount) ?? 0
        failedCount = failedCountDecoded
        let successCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .successCount) ?? 0
        successCount = successCountDecoded
        let failedFindingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.ImportFindingsError?].self, forKey: .failedFindings)
        var failedFindingsDecoded0:[SecurityHubClientTypes.ImportFindingsError]? = nil
        if let failedFindingsContainer = failedFindingsContainer {
            failedFindingsDecoded0 = [SecurityHubClientTypes.ImportFindingsError]()
            for structure0 in failedFindingsContainer {
                if let structure0 = structure0 {
                    failedFindingsDecoded0?.append(structure0)
                }
            }
        }
        failedFindings = failedFindingsDecoded0
    }
}

extension BatchUpdateFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidence = "Confidence"
        case criticality = "Criticality"
        case findingIdentifiers = "FindingIdentifiers"
        case note = "Note"
        case relatedFindings = "RelatedFindings"
        case severity = "Severity"
        case types = "Types"
        case userDefinedFields = "UserDefinedFields"
        case verificationState = "VerificationState"
        case workflow = "Workflow"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if criticality != 0 {
            try encodeContainer.encode(criticality, forKey: .criticality)
        }
        if let findingIdentifiers = findingIdentifiers {
            var findingIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIdentifiers)
            for awssecurityfindingidentifier0 in findingIdentifiers {
                try findingIdentifiersContainer.encode(awssecurityfindingidentifier0)
            }
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let relatedFindings = relatedFindings {
            var relatedFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindings)
            for relatedfinding0 in relatedFindings {
                try relatedFindingsContainer.encode(relatedfinding0)
            }
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for nonemptystring0 in types {
                try typesContainer.encode(nonemptystring0)
            }
        }
        if let userDefinedFields = userDefinedFields {
            var userDefinedFieldsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .userDefinedFields)
            for (dictKey0, fieldMap0) in userDefinedFields {
                try userDefinedFieldsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let verificationState = self.verificationState {
            try encodeContainer.encode(verificationState.rawValue, forKey: .verificationState)
        }
        if let workflow = self.workflow {
            try encodeContainer.encode(workflow, forKey: .workflow)
        }
    }
}

extension BatchUpdateFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings/batchupdate"
    }
}

public struct BatchUpdateFindingsInput: Swift.Equatable {
    /// The updated value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
    public var confidence: Swift.Int
    /// The updated value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
    public var criticality: Swift.Int
    /// The list of findings to update. BatchUpdateFindings can be used to update up to 100 findings at a time. For each finding, the list provides the finding identifier and the ARN of the finding provider.
    /// This member is required.
    public var findingIdentifiers: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]?
    /// The updated note.
    public var note: SecurityHubClientTypes.NoteUpdate?
    /// A list of findings that are related to the updated findings.
    public var relatedFindings: [SecurityHubClientTypes.RelatedFinding]?
    /// Used to update the finding severity.
    public var severity: SecurityHubClientTypes.SeverityUpdate?
    /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are as follows.
    ///
    /// * Software and Configuration Checks
    ///
    /// * TTPs
    ///
    /// * Effects
    ///
    /// * Unusual Behaviors
    ///
    /// * Sensitive Data Identifications
    public var types: [Swift.String]?
    /// A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding.
    public var userDefinedFields: [Swift.String:Swift.String]?
    /// Indicates the veracity of a finding. The available values for VerificationState are as follows.
    ///
    /// * UNKNOWN  The default disposition of a security finding
    ///
    /// * TRUE_POSITIVE  The security finding is confirmed
    ///
    /// * FALSE_POSITIVE  The security finding was determined to be a false alarm
    ///
    /// * BENIGN_POSITIVE  A special case of TRUE_POSITIVE where the finding doesn't pose any threat, is expected, or both
    public var verificationState: SecurityHubClientTypes.VerificationState?
    /// Used to update the workflow status of a finding. The workflow status indicates the progress of the investigation into the finding.
    public var workflow: SecurityHubClientTypes.WorkflowUpdate?

    public init (
        confidence: Swift.Int = 0,
        criticality: Swift.Int = 0,
        findingIdentifiers: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]? = nil,
        note: SecurityHubClientTypes.NoteUpdate? = nil,
        relatedFindings: [SecurityHubClientTypes.RelatedFinding]? = nil,
        severity: SecurityHubClientTypes.SeverityUpdate? = nil,
        types: [Swift.String]? = nil,
        userDefinedFields: [Swift.String:Swift.String]? = nil,
        verificationState: SecurityHubClientTypes.VerificationState? = nil,
        workflow: SecurityHubClientTypes.WorkflowUpdate? = nil
    )
    {
        self.confidence = confidence
        self.criticality = criticality
        self.findingIdentifiers = findingIdentifiers
        self.note = note
        self.relatedFindings = relatedFindings
        self.severity = severity
        self.types = types
        self.userDefinedFields = userDefinedFields
        self.verificationState = verificationState
        self.workflow = workflow
    }
}

struct BatchUpdateFindingsInputBody: Swift.Equatable {
    let findingIdentifiers: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]?
    let note: SecurityHubClientTypes.NoteUpdate?
    let severity: SecurityHubClientTypes.SeverityUpdate?
    let verificationState: SecurityHubClientTypes.VerificationState?
    let confidence: Swift.Int
    let criticality: Swift.Int
    let types: [Swift.String]?
    let userDefinedFields: [Swift.String:Swift.String]?
    let workflow: SecurityHubClientTypes.WorkflowUpdate?
    let relatedFindings: [SecurityHubClientTypes.RelatedFinding]?
}

extension BatchUpdateFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidence = "Confidence"
        case criticality = "Criticality"
        case findingIdentifiers = "FindingIdentifiers"
        case note = "Note"
        case relatedFindings = "RelatedFindings"
        case severity = "Severity"
        case types = "Types"
        case userDefinedFields = "UserDefinedFields"
        case verificationState = "VerificationState"
        case workflow = "Workflow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdentifiersContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsSecurityFindingIdentifier?].self, forKey: .findingIdentifiers)
        var findingIdentifiersDecoded0:[SecurityHubClientTypes.AwsSecurityFindingIdentifier]? = nil
        if let findingIdentifiersContainer = findingIdentifiersContainer {
            findingIdentifiersDecoded0 = [SecurityHubClientTypes.AwsSecurityFindingIdentifier]()
            for structure0 in findingIdentifiersContainer {
                if let structure0 = structure0 {
                    findingIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        findingIdentifiers = findingIdentifiersDecoded0
        let noteDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.NoteUpdate.self, forKey: .note)
        note = noteDecoded
        let severityDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.SeverityUpdate.self, forKey: .severity)
        severity = severityDecoded
        let verificationStateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.VerificationState.self, forKey: .verificationState)
        verificationState = verificationStateDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .confidence) ?? 0
        confidence = confidenceDecoded
        let criticalityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .criticality) ?? 0
        criticality = criticalityDecoded
        let typesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .types)
        var typesDecoded0:[Swift.String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [Swift.String]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
        let userDefinedFieldsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .userDefinedFields)
        var userDefinedFieldsDecoded0: [Swift.String:Swift.String]? = nil
        if let userDefinedFieldsContainer = userDefinedFieldsContainer {
            userDefinedFieldsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in userDefinedFieldsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    userDefinedFieldsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        userDefinedFields = userDefinedFieldsDecoded0
        let workflowDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.WorkflowUpdate.self, forKey: .workflow)
        workflow = workflowDecoded
        let relatedFindingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RelatedFinding?].self, forKey: .relatedFindings)
        var relatedFindingsDecoded0:[SecurityHubClientTypes.RelatedFinding]? = nil
        if let relatedFindingsContainer = relatedFindingsContainer {
            relatedFindingsDecoded0 = [SecurityHubClientTypes.RelatedFinding]()
            for structure0 in relatedFindingsContainer {
                if let structure0 = structure0 {
                    relatedFindingsDecoded0?.append(structure0)
                }
            }
        }
        relatedFindings = relatedFindingsDecoded0
    }
}

extension BatchUpdateFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchUpdateFindingsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchUpdateFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.processedFindings = output.processedFindings
            self.unprocessedFindings = output.unprocessedFindings
        } else {
            self.processedFindings = nil
            self.unprocessedFindings = nil
        }
    }
}

public struct BatchUpdateFindingsOutputResponse: Swift.Equatable {
    /// The list of findings that were updated successfully.
    /// This member is required.
    public var processedFindings: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]?
    /// The list of findings that were not updated.
    /// This member is required.
    public var unprocessedFindings: [SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding]?

    public init (
        processedFindings: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]? = nil,
        unprocessedFindings: [SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding]? = nil
    )
    {
        self.processedFindings = processedFindings
        self.unprocessedFindings = unprocessedFindings
    }
}

struct BatchUpdateFindingsOutputResponseBody: Swift.Equatable {
    let processedFindings: [SecurityHubClientTypes.AwsSecurityFindingIdentifier]?
    let unprocessedFindings: [SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding]?
}

extension BatchUpdateFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case processedFindings = "ProcessedFindings"
        case unprocessedFindings = "UnprocessedFindings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processedFindingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsSecurityFindingIdentifier?].self, forKey: .processedFindings)
        var processedFindingsDecoded0:[SecurityHubClientTypes.AwsSecurityFindingIdentifier]? = nil
        if let processedFindingsContainer = processedFindingsContainer {
            processedFindingsDecoded0 = [SecurityHubClientTypes.AwsSecurityFindingIdentifier]()
            for structure0 in processedFindingsContainer {
                if let structure0 = structure0 {
                    processedFindingsDecoded0?.append(structure0)
                }
            }
        }
        processedFindings = processedFindingsDecoded0
        let unprocessedFindingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding?].self, forKey: .unprocessedFindings)
        var unprocessedFindingsDecoded0:[SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding]? = nil
        if let unprocessedFindingsContainer = unprocessedFindingsContainer {
            unprocessedFindingsDecoded0 = [SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding]()
            for structure0 in unprocessedFindingsContainer {
                if let structure0 = structure0 {
                    unprocessedFindingsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedFindings = unprocessedFindingsDecoded0
    }
}

extension SecurityHubClientTypes.BatchUpdateFindingsUnprocessedFinding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case findingIdentifier = "FindingIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let findingIdentifier = self.findingIdentifier {
            try encodeContainer.encode(findingIdentifier, forKey: .findingIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdentifierDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSecurityFindingIdentifier.self, forKey: .findingIdentifier)
        findingIdentifier = findingIdentifierDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension SecurityHubClientTypes {
    /// A finding from a BatchUpdateFindings request that Security Hub was unable to update.
    public struct BatchUpdateFindingsUnprocessedFinding: Swift.Equatable {
        /// The code associated with the error. Possible values are:
        ///
        /// * ConcurrentUpdateError - Another request attempted to update the finding while this request was being processed. This error may also occur if you call [BatchUpdateFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateFindings.html) and [BatchImportFindings](https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchImportFindings.html) at the same time.
        ///
        /// * DuplicatedFindingIdentifier - The request included two or more findings with the same FindingIdentifier.
        ///
        /// * FindingNotFound - The FindingIdentifier included in the request did not match an existing finding.
        ///
        /// * FindingSizeExceeded - The finding size was greater than the permissible value of 240 KB.
        ///
        /// * InternalFailure - An internal service failure occurred when updating the finding.
        ///
        /// * InvalidInput - The finding update contained an invalid value that did not satisfy the [Amazon Web Services Security Finding Format](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format.html) syntax.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message associated with the error. Possible values are:
        ///
        /// * Concurrent finding updates detected
        ///
        /// * Finding Identifier is duplicated
        ///
        /// * Finding Not Found
        ///
        /// * Finding size exceeded 240 KB
        ///
        /// * Internal service failure
        ///
        /// * Invalid Input
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The identifier of the finding that was not updated.
        /// This member is required.
        public var findingIdentifier: SecurityHubClientTypes.AwsSecurityFindingIdentifier?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            findingIdentifier: SecurityHubClientTypes.AwsSecurityFindingIdentifier? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.findingIdentifier = findingIdentifier
        }
    }

}

extension SecurityHubClientTypes.BooleanFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if value != false {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .value) ?? false
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// Boolean filter for querying findings.
    public struct BooleanFilter: Swift.Equatable {
        /// The value of the boolean.
        public var value: Swift.Bool

        public init (
            value: Swift.Bool = false
        )
        {
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.Cell: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellReference = "CellReference"
        case column = "Column"
        case columnName = "ColumnName"
        case row = "Row"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellReference = self.cellReference {
            try encodeContainer.encode(cellReference, forKey: .cellReference)
        }
        if column != 0 {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if row != 0 {
            try encodeContainer.encode(row, forKey: .row)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .column) ?? 0
        column = columnDecoded
        let rowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .row) ?? 0
        row = rowDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let cellReferenceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cellReference)
        cellReference = cellReferenceDecoded
    }
}

extension SecurityHubClientTypes {
    /// An occurrence of sensitive data detected in a Microsoft Excel workbook, comma-separated value (CSV) file, or tab-separated value (TSV) file.
    public struct Cell: Swift.Equatable {
        /// For a Microsoft Excel workbook, provides the location of the cell, as an absolute cell reference, that contains the data. For example, Sheet2!C5 for cell C5 on Sheet2.
        public var cellReference: Swift.String?
        /// The column number of the column that contains the data. For a Microsoft Excel workbook, the column number corresponds to the alphabetical column identifiers. For example, a value of 1 for Column corresponds to the A column in the workbook.
        public var column: Swift.Int
        /// The name of the column that contains the data.
        public var columnName: Swift.String?
        /// The row number of the row that contains the data.
        public var row: Swift.Int

        public init (
            cellReference: Swift.String? = nil,
            column: Swift.Int = 0,
            columnName: Swift.String? = nil,
            row: Swift.Int = 0
        )
        {
            self.cellReference = cellReference
            self.column = column
            self.columnName = columnName
            self.row = row
        }
    }

}

extension SecurityHubClientTypes.CidrBlockAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case cidrBlock = "CidrBlock"
        case cidrBlockState = "CidrBlockState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let cidrBlock = self.cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
        if let cidrBlockState = self.cidrBlockState {
            try encodeContainer.encode(cidrBlockState, forKey: .cidrBlockState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let cidrBlockStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlockState)
        cidrBlockState = cidrBlockStateDecoded
    }
}

extension SecurityHubClientTypes {
    /// An IPv4 CIDR block association.
    public struct CidrBlockAssociation: Swift.Equatable {
        /// The association ID for the IPv4 CIDR block.
        public var associationId: Swift.String?
        /// The IPv4 CIDR block.
        public var cidrBlock: Swift.String?
        /// Information about the state of the IPv4 CIDR block.
        public var cidrBlockState: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            cidrBlock: Swift.String? = nil,
            cidrBlockState: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.cidrBlock = cidrBlock
            self.cidrBlockState = cidrBlockState
        }
    }

}

extension SecurityHubClientTypes.City: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cityName = "CityName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cityName = self.cityName {
            try encodeContainer.encode(cityName, forKey: .cityName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cityName)
        cityName = cityNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a city.
    public struct City: Swift.Equatable {
        /// The name of the city.
        public var cityName: Swift.String?

        public init (
            cityName: Swift.String? = nil
        )
        {
            self.cityName = cityName
        }
    }

}

extension SecurityHubClientTypes.ClassificationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalOccurrences = "AdditionalOccurrences"
        case customDataIdentifiers = "CustomDataIdentifiers"
        case mimeType = "MimeType"
        case sensitiveData = "SensitiveData"
        case sizeClassified = "SizeClassified"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if additionalOccurrences != false {
            try encodeContainer.encode(additionalOccurrences, forKey: .additionalOccurrences)
        }
        if let customDataIdentifiers = self.customDataIdentifiers {
            try encodeContainer.encode(customDataIdentifiers, forKey: .customDataIdentifiers)
        }
        if let mimeType = self.mimeType {
            try encodeContainer.encode(mimeType, forKey: .mimeType)
        }
        if let sensitiveData = sensitiveData {
            var sensitiveDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sensitiveData)
            for sensitivedataresult0 in sensitiveData {
                try sensitiveDataContainer.encode(sensitivedataresult0)
            }
        }
        if sizeClassified != 0 {
            try encodeContainer.encode(sizeClassified, forKey: .sizeClassified)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mimeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mimeType)
        mimeType = mimeTypeDecoded
        let sizeClassifiedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sizeClassified) ?? 0
        sizeClassified = sizeClassifiedDecoded
        let additionalOccurrencesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .additionalOccurrences) ?? false
        additionalOccurrences = additionalOccurrencesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ClassificationStatus.self, forKey: .status)
        status = statusDecoded
        let sensitiveDataContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.SensitiveDataResult?].self, forKey: .sensitiveData)
        var sensitiveDataDecoded0:[SecurityHubClientTypes.SensitiveDataResult]? = nil
        if let sensitiveDataContainer = sensitiveDataContainer {
            sensitiveDataDecoded0 = [SecurityHubClientTypes.SensitiveDataResult]()
            for structure0 in sensitiveDataContainer {
                if let structure0 = structure0 {
                    sensitiveDataDecoded0?.append(structure0)
                }
            }
        }
        sensitiveData = sensitiveDataDecoded0
        let customDataIdentifiersDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.CustomDataIdentifiersResult.self, forKey: .customDataIdentifiers)
        customDataIdentifiers = customDataIdentifiersDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the sensitive data that was detected on the resource.
    public struct ClassificationResult: Swift.Equatable {
        /// Indicates whether there are additional occurrences of sensitive data that are not included in the finding. This occurs when the number of occurrences exceeds the maximum that can be included.
        public var additionalOccurrences: Swift.Bool
        /// Provides details about sensitive data that was identified based on customer-defined configuration.
        public var customDataIdentifiers: SecurityHubClientTypes.CustomDataIdentifiersResult?
        /// The type of content that the finding applies to.
        public var mimeType: Swift.String?
        /// Provides details about sensitive data that was identified based on built-in configuration.
        public var sensitiveData: [SecurityHubClientTypes.SensitiveDataResult]?
        /// The total size in bytes of the affected data.
        public var sizeClassified: Swift.Int
        /// The current status of the sensitive data detection.
        public var status: SecurityHubClientTypes.ClassificationStatus?

        public init (
            additionalOccurrences: Swift.Bool = false,
            customDataIdentifiers: SecurityHubClientTypes.CustomDataIdentifiersResult? = nil,
            mimeType: Swift.String? = nil,
            sensitiveData: [SecurityHubClientTypes.SensitiveDataResult]? = nil,
            sizeClassified: Swift.Int = 0,
            status: SecurityHubClientTypes.ClassificationStatus? = nil
        )
        {
            self.additionalOccurrences = additionalOccurrences
            self.customDataIdentifiers = customDataIdentifiers
            self.mimeType = mimeType
            self.sensitiveData = sensitiveData
            self.sizeClassified = sizeClassified
            self.status = status
        }
    }

}

extension SecurityHubClientTypes.ClassificationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the current status of the sensitive data detection.
    public struct ClassificationStatus: Swift.Equatable {
        /// The code that represents the status of the sensitive data detection.
        public var code: Swift.String?
        /// A longer description of the current status of the sensitive data detection.
        public var reason: Swift.String?

        public init (
            code: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.code = code
            self.reason = reason
        }
    }

}

extension SecurityHubClientTypes.Compliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case relatedRequirements = "RelatedRequirements"
        case status = "Status"
        case statusReasons = "StatusReasons"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let relatedRequirements = relatedRequirements {
            var relatedRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedRequirements)
            for nonemptystring0 in relatedRequirements {
                try relatedRequirementsContainer.encode(nonemptystring0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReasons = statusReasons {
            var statusReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusReasons)
            for statusreason0 in statusReasons {
                try statusReasonsContainer.encode(statusreason0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ComplianceStatus.self, forKey: .status)
        status = statusDecoded
        let relatedRequirementsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedRequirements)
        var relatedRequirementsDecoded0:[Swift.String]? = nil
        if let relatedRequirementsContainer = relatedRequirementsContainer {
            relatedRequirementsDecoded0 = [Swift.String]()
            for string0 in relatedRequirementsContainer {
                if let string0 = string0 {
                    relatedRequirementsDecoded0?.append(string0)
                }
            }
        }
        relatedRequirements = relatedRequirementsDecoded0
        let statusReasonsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StatusReason?].self, forKey: .statusReasons)
        var statusReasonsDecoded0:[SecurityHubClientTypes.StatusReason]? = nil
        if let statusReasonsContainer = statusReasonsContainer {
            statusReasonsDecoded0 = [SecurityHubClientTypes.StatusReason]()
            for structure0 in statusReasonsContainer {
                if let structure0 = structure0 {
                    statusReasonsDecoded0?.append(structure0)
                }
            }
        }
        statusReasons = statusReasonsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Contains finding details that are specific to control-based findings. Only returned for findings generated from controls.
    public struct Compliance: Swift.Equatable {
        /// For a control, the industry or regulatory framework requirements that are related to the control. The check for that control is aligned with these requirements.
        public var relatedRequirements: [Swift.String]?
        /// The result of a standards check. The valid values for Status are as follows.
        ///
        ///
        /// * PASSED - Standards check passed for all evaluated resources.
        ///
        /// * WARNING - Some information is missing or this check is not supported for your configuration.
        ///
        /// * FAILED - Standards check failed for at least one evaluated resource.
        ///
        /// * NOT_AVAILABLE - Check could not be performed due to a service outage, API error, or because the result of the Config evaluation was NOT_APPLICABLE. If the Config evaluation result was NOT_APPLICABLE, then after 3 days, Security Hub automatically archives the finding.
        public var status: SecurityHubClientTypes.ComplianceStatus?
        /// For findings generated from controls, a list of reasons behind the value of Status. For the list of status reason codes and their meanings, see [Standards-related information in the ASFF](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff) in the Security Hub User Guide.
        public var statusReasons: [SecurityHubClientTypes.StatusReason]?

        public init (
            relatedRequirements: [Swift.String]? = nil,
            status: SecurityHubClientTypes.ComplianceStatus? = nil,
            statusReasons: [SecurityHubClientTypes.StatusReason]? = nil
        )
        {
            self.relatedRequirements = relatedRequirements
            self.status = status
            self.statusReasons = statusReasons
        }
    }

}

extension SecurityHubClientTypes {
    public enum ComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case notAvailable
        case passed
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [ComplianceStatus] {
            return [
                .failed,
                .notAvailable,
                .passed,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .notAvailable: return "NOT_AVAILABLE"
            case .passed: return "PASSED"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComplianceStatus(rawValue: rawValue) ?? ComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.ContainerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRuntime = "ContainerRuntime"
        case imageId = "ImageId"
        case imageName = "ImageName"
        case launchedAt = "LaunchedAt"
        case name = "Name"
        case privileged = "Privileged"
        case volumeMounts = "VolumeMounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerRuntime = self.containerRuntime {
            try encodeContainer.encode(containerRuntime, forKey: .containerRuntime)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let imageName = self.imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let launchedAt = self.launchedAt {
            try encodeContainer.encode(launchedAt, forKey: .launchedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if privileged != false {
            try encodeContainer.encode(privileged, forKey: .privileged)
        }
        if let volumeMounts = volumeMounts {
            var volumeMountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeMounts)
            for volumemount0 in volumeMounts {
                try volumeMountsContainer.encode(volumemount0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerRuntimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRuntime)
        containerRuntime = containerRuntimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let launchedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchedAt)
        launchedAt = launchedAtDecoded
        let volumeMountsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.VolumeMount?].self, forKey: .volumeMounts)
        var volumeMountsDecoded0:[SecurityHubClientTypes.VolumeMount]? = nil
        if let volumeMountsContainer = volumeMountsContainer {
            volumeMountsDecoded0 = [SecurityHubClientTypes.VolumeMount]()
            for structure0 in volumeMountsContainer {
                if let structure0 = structure0 {
                    volumeMountsDecoded0?.append(structure0)
                }
            }
        }
        volumeMounts = volumeMountsDecoded0
        let privilegedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privileged) ?? false
        privileged = privilegedDecoded
    }
}

extension SecurityHubClientTypes {
    /// Container details related to a finding.
    public struct ContainerDetails: Swift.Equatable {
        /// The runtime of the container.
        public var containerRuntime: Swift.String?
        /// The identifier of the container image related to a finding.
        public var imageId: Swift.String?
        /// The name of the container image related to a finding.
        public var imageName: Swift.String?
        /// Indicates when the container started. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var launchedAt: Swift.String?
        /// The name of the container related to a finding.
        public var name: Swift.String?
        /// When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user).
        public var privileged: Swift.Bool
        /// Provides information about the mounting of a volume in a container.
        public var volumeMounts: [SecurityHubClientTypes.VolumeMount]?

        public init (
            containerRuntime: Swift.String? = nil,
            imageId: Swift.String? = nil,
            imageName: Swift.String? = nil,
            launchedAt: Swift.String? = nil,
            name: Swift.String? = nil,
            privileged: Swift.Bool = false,
            volumeMounts: [SecurityHubClientTypes.VolumeMount]? = nil
        )
        {
            self.containerRuntime = containerRuntime
            self.imageId = imageId
            self.imageName = imageName
            self.launchedAt = launchedAt
            self.name = name
            self.privileged = privileged
            self.volumeMounts = volumeMounts
        }
    }

}

extension SecurityHubClientTypes {
    public enum ControlStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ControlStatus(rawValue: rawValue) ?? ControlStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.Country: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "CountryCode"
        case countryName = "CountryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let countryName = self.countryName {
            try encodeContainer.encode(countryName, forKey: .countryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let countryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryName)
        countryName = countryNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a country.
    public struct Country: Swift.Equatable {
        /// The 2-letter ISO 3166 country code for the country.
        public var countryCode: Swift.String?
        /// The name of the country.
        public var countryName: Swift.String?

        public init (
            countryCode: Swift.String? = nil,
            countryName: Swift.String? = nil
        )
        {
            self.countryCode = countryCode
            self.countryName = countryName
        }
    }

}

extension CreateActionTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateActionTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/actionTargets"
    }
}

public struct CreateActionTargetInput: Swift.Equatable {
    /// The description for the custom action target.
    /// This member is required.
    public var description: Swift.String?
    /// The ID for the custom action target. Can contain up to 20 alphanumeric characters.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the custom action target. Can contain up to 20 characters.
    /// This member is required.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct CreateActionTargetInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let id: Swift.String?
}

extension CreateActionTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateActionTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateActionTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateActionTargetOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateActionTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateActionTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionTargetArn = output.actionTargetArn
        } else {
            self.actionTargetArn = nil
        }
    }
}

public struct CreateActionTargetOutputResponse: Swift.Equatable {
    /// The ARN for the custom action target.
    /// This member is required.
    public var actionTargetArn: Swift.String?

    public init (
        actionTargetArn: Swift.String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
    }
}

struct CreateActionTargetOutputResponseBody: Swift.Equatable {
    let actionTargetArn: Swift.String?
}

extension CreateActionTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTargetArn = "ActionTargetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionTargetArn)
        actionTargetArn = actionTargetArnDecoded
    }
}

extension CreateFindingAggregatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regionLinkingMode = "RegionLinkingMode"
        case regions = "Regions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regionLinkingMode = self.regionLinkingMode {
            try encodeContainer.encode(regionLinkingMode, forKey: .regionLinkingMode)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for nonemptystring0 in regions {
                try regionsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension CreateFindingAggregatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findingAggregator/create"
    }
}

public struct CreateFindingAggregatorInput: Swift.Equatable {
    /// Indicates whether to aggregate findings from all of the available Regions in the current partition. Also determines whether to automatically aggregate findings from new Regions as Security Hub supports them and you opt into them. The selected option also determines how to use the Regions provided in the Regions list. The options are as follows:
    ///
    /// * ALL_REGIONS - Indicates to aggregate findings from all of the Regions where Security Hub is enabled. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.
    ///
    /// * ALL_REGIONS_EXCEPT_SPECIFIED - Indicates to aggregate findings from all of the Regions where Security Hub is enabled, except for the Regions listed in the Regions parameter. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.
    ///
    /// * SPECIFIED_REGIONS - Indicates to aggregate findings only from the Regions listed in the Regions parameter. Security Hub does not automatically aggregate findings from new Regions.
    /// This member is required.
    public var regionLinkingMode: Swift.String?
    /// If RegionLinkingMode is ALL_REGIONS_EXCEPT_SPECIFIED, then this is a space-separated list of Regions that do not aggregate findings to the aggregation Region. If RegionLinkingMode is SPECIFIED_REGIONS, then this is a space-separated list of Regions that do aggregate findings to the aggregation Region.
    public var regions: [Swift.String]?

    public init (
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

struct CreateFindingAggregatorInputBody: Swift.Equatable {
    let regionLinkingMode: Swift.String?
    let regions: [Swift.String]?
}

extension CreateFindingAggregatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regionLinkingMode = "RegionLinkingMode"
        case regions = "Regions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionLinkingModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionLinkingMode)
        regionLinkingMode = regionLinkingModeDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension CreateFindingAggregatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFindingAggregatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFindingAggregatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFindingAggregatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFindingAggregatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingAggregationRegion = output.findingAggregationRegion
            self.findingAggregatorArn = output.findingAggregatorArn
            self.regionLinkingMode = output.regionLinkingMode
            self.regions = output.regions
        } else {
            self.findingAggregationRegion = nil
            self.findingAggregatorArn = nil
            self.regionLinkingMode = nil
            self.regions = nil
        }
    }
}

public struct CreateFindingAggregatorOutputResponse: Swift.Equatable {
    /// The aggregation Region.
    public var findingAggregationRegion: Swift.String?
    /// The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and stop finding aggregation.
    public var findingAggregatorArn: Swift.String?
    /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
    public var regionLinkingMode: Swift.String?
    /// The list of excluded Regions or included Regions.
    public var regions: [Swift.String]?

    public init (
        findingAggregationRegion: Swift.String? = nil,
        findingAggregatorArn: Swift.String? = nil,
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.findingAggregationRegion = findingAggregationRegion
        self.findingAggregatorArn = findingAggregatorArn
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

struct CreateFindingAggregatorOutputResponseBody: Swift.Equatable {
    let findingAggregatorArn: Swift.String?
    let findingAggregationRegion: Swift.String?
    let regionLinkingMode: Swift.String?
    let regions: [Swift.String]?
}

extension CreateFindingAggregatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingAggregationRegion = "FindingAggregationRegion"
        case findingAggregatorArn = "FindingAggregatorArn"
        case regionLinkingMode = "RegionLinkingMode"
        case regions = "Regions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingAggregatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingAggregatorArn)
        findingAggregatorArn = findingAggregatorArnDecoded
        let findingAggregationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingAggregationRegion)
        findingAggregationRegion = findingAggregationRegionDecoded
        let regionLinkingModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionLinkingMode)
        regionLinkingMode = regionLinkingModeDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension CreateInsightInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByAttribute = self.groupByAttribute {
            try encodeContainer.encode(groupByAttribute, forKey: .groupByAttribute)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateInsightInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights"
    }
}

public struct CreateInsightInput: Swift.Equatable {
    /// One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.
    /// This member is required.
    public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    /// The attribute used to group the findings for the insight. The grouping attribute identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
    /// This member is required.
    public var groupByAttribute: Swift.String?
    /// The name of the custom insight to create.
    /// This member is required.
    public var name: Swift.String?

    public init (
        filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
        groupByAttribute: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.filters = filters
        self.groupByAttribute = groupByAttribute
        self.name = name
    }
}

struct CreateInsightInputBody: Swift.Equatable {
    let name: Swift.String?
    let filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    let groupByAttribute: Swift.String?
}

extension CreateInsightInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupByAttribute)
        groupByAttribute = groupByAttributeDecoded
    }
}

extension CreateInsightOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInsightOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateInsightOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInsightOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateInsightOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insightArn = output.insightArn
        } else {
            self.insightArn = nil
        }
    }
}

public struct CreateInsightOutputResponse: Swift.Equatable {
    /// The ARN of the insight created.
    /// This member is required.
    public var insightArn: Swift.String?

    public init (
        insightArn: Swift.String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

struct CreateInsightOutputResponseBody: Swift.Equatable {
    let insightArn: Swift.String?
}

extension CreateInsightOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightArn = "InsightArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightArn)
        insightArn = insightArnDecoded
    }
}

extension CreateMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountDetails = "AccountDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountDetails = accountDetails {
            var accountDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountDetails)
            for accountdetails0 in accountDetails {
                try accountDetailsContainer.encode(accountdetails0)
            }
        }
    }
}

extension CreateMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members"
    }
}

public struct CreateMembersInput: Swift.Equatable {
    /// The list of accounts to associate with the Security Hub administrator account. For each account, the list includes the account ID and optionally the email address.
    /// This member is required.
    public var accountDetails: [SecurityHubClientTypes.AccountDetails]?

    public init (
        accountDetails: [SecurityHubClientTypes.AccountDetails]? = nil
    )
    {
        self.accountDetails = accountDetails
    }
}

struct CreateMembersInputBody: Swift.Equatable {
    let accountDetails: [SecurityHubClientTypes.AccountDetails]?
}

extension CreateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountDetails = "AccountDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDetailsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AccountDetails?].self, forKey: .accountDetails)
        var accountDetailsDecoded0:[SecurityHubClientTypes.AccountDetails]? = nil
        if let accountDetailsContainer = accountDetailsContainer {
            accountDetailsDecoded0 = [SecurityHubClientTypes.AccountDetails]()
            for structure0 in accountDetailsContainer {
                if let structure0 = structure0 {
                    accountDetailsDecoded0?.append(structure0)
                }
            }
        }
        accountDetails = accountDetailsDecoded0
    }
}

extension CreateMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMembersOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateMembersOutputResponse: Swift.Equatable {
    /// The list of Amazon Web Services accounts that were not processed. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init (
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [SecurityHubClientTypes.Result]?
}

extension CreateMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[SecurityHubClientTypes.Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [SecurityHubClientTypes.Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension SecurityHubClientTypes.CustomDataIdentifiersDetections: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case count = "Count"
        case name = "Name"
        case occurrences = "Occurrences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let occurrences = self.occurrences {
            try encodeContainer.encode(occurrences, forKey: .occurrences)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let occurrencesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Occurrences.self, forKey: .occurrences)
        occurrences = occurrencesDecoded
    }
}

extension SecurityHubClientTypes {
    /// The list of detected instances of sensitive data.
    public struct CustomDataIdentifiersDetections: Swift.Equatable {
        /// The ARN of the custom identifier that was used to detect the sensitive data.
        public var arn: Swift.String?
        /// The total number of occurrences of sensitive data that were detected.
        public var count: Swift.Int
        /// he name of the custom identifier that detected the sensitive data.
        public var name: Swift.String?
        /// Details about the sensitive data that was detected.
        public var occurrences: SecurityHubClientTypes.Occurrences?

        public init (
            arn: Swift.String? = nil,
            count: Swift.Int = 0,
            name: Swift.String? = nil,
            occurrences: SecurityHubClientTypes.Occurrences? = nil
        )
        {
            self.arn = arn
            self.count = count
            self.name = name
            self.occurrences = occurrences
        }
    }

}

extension SecurityHubClientTypes.CustomDataIdentifiersResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detections = "Detections"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detections = detections {
            var detectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detections)
            for customdataidentifiersdetections0 in detections {
                try detectionsContainer.encode(customdataidentifiersdetections0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.CustomDataIdentifiersDetections?].self, forKey: .detections)
        var detectionsDecoded0:[SecurityHubClientTypes.CustomDataIdentifiersDetections]? = nil
        if let detectionsContainer = detectionsContainer {
            detectionsDecoded0 = [SecurityHubClientTypes.CustomDataIdentifiersDetections]()
            for structure0 in detectionsContainer {
                if let structure0 = structure0 {
                    detectionsDecoded0?.append(structure0)
                }
            }
        }
        detections = detectionsDecoded0
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount) ?? 0
        totalCount = totalCountDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains an instance of sensitive data that was detected by a customer-defined identifier.
    public struct CustomDataIdentifiersResult: Swift.Equatable {
        /// The list of detected instances of sensitive data.
        public var detections: [SecurityHubClientTypes.CustomDataIdentifiersDetections]?
        /// The total number of occurrences of sensitive data.
        public var totalCount: Swift.Int

        public init (
            detections: [SecurityHubClientTypes.CustomDataIdentifiersDetections]? = nil,
            totalCount: Swift.Int = 0
        )
        {
            self.detections = detections
            self.totalCount = totalCount
        }
    }

}

extension SecurityHubClientTypes.Cvss: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustments = "Adjustments"
        case baseScore = "BaseScore"
        case baseVector = "BaseVector"
        case source = "Source"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjustments = adjustments {
            var adjustmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adjustments)
            for adjustment0 in adjustments {
                try adjustmentsContainer.encode(adjustment0)
            }
        }
        if baseScore != 0.0 {
            try encodeContainer.encode(baseScore, forKey: .baseScore)
        }
        if let baseVector = self.baseVector {
            try encodeContainer.encode(baseVector, forKey: .baseVector)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let baseScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .baseScore) ?? 0.0
        baseScore = baseScoreDecoded
        let baseVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseVector)
        baseVector = baseVectorDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let adjustmentsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Adjustment?].self, forKey: .adjustments)
        var adjustmentsDecoded0:[SecurityHubClientTypes.Adjustment]? = nil
        if let adjustmentsContainer = adjustmentsContainer {
            adjustmentsDecoded0 = [SecurityHubClientTypes.Adjustment]()
            for structure0 in adjustmentsContainer {
                if let structure0 = structure0 {
                    adjustmentsDecoded0?.append(structure0)
                }
            }
        }
        adjustments = adjustmentsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// CVSS scores from the advisory related to the vulnerability.
    public struct Cvss: Swift.Equatable {
        /// Adjustments to the CVSS metrics.
        public var adjustments: [SecurityHubClientTypes.Adjustment]?
        /// The base CVSS score.
        public var baseScore: Swift.Double
        /// The base scoring vector for the CVSS score.
        public var baseVector: Swift.String?
        /// The origin of the original CVSS score and vector.
        public var source: Swift.String?
        /// The version of CVSS for the CVSS score.
        public var version: Swift.String?

        public init (
            adjustments: [SecurityHubClientTypes.Adjustment]? = nil,
            baseScore: Swift.Double = 0.0,
            baseVector: Swift.String? = nil,
            source: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.adjustments = adjustments
            self.baseScore = baseScore
            self.baseVector = baseVector
            self.source = source
            self.version = version
        }
    }

}

extension SecurityHubClientTypes.DataClassificationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailedResultsLocation = "DetailedResultsLocation"
        case result = "Result"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedResultsLocation = self.detailedResultsLocation {
            try encodeContainer.encode(detailedResultsLocation, forKey: .detailedResultsLocation)
        }
        if let result = self.result {
            try encodeContainer.encode(result, forKey: .result)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedResultsLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedResultsLocation)
        detailedResultsLocation = detailedResultsLocationDecoded
        let resultDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ClassificationResult.self, forKey: .result)
        result = resultDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about sensitive data that was detected on a resource.
    public struct DataClassificationDetails: Swift.Equatable {
        /// The path to the folder or file that contains the sensitive data.
        public var detailedResultsLocation: Swift.String?
        /// The details about the sensitive data that was detected on the resource.
        public var result: SecurityHubClientTypes.ClassificationResult?

        public init (
            detailedResultsLocation: Swift.String? = nil,
            result: SecurityHubClientTypes.ClassificationResult? = nil
        )
        {
            self.detailedResultsLocation = detailedResultsLocation
            self.result = result
        }
    }

}

extension SecurityHubClientTypes.DateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .end)
        end = endDecoded
        let dateRangeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.DateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension SecurityHubClientTypes {
    /// A date filter for querying findings.
    public struct DateFilter: Swift.Equatable {
        /// A date range for the date filter.
        public var dateRange: SecurityHubClientTypes.DateRange?
        /// An end date for the date filter.
        public var end: Swift.String?
        /// A start date for the date filter.
        public var start: Swift.String?

        public init (
            dateRange: SecurityHubClientTypes.DateRange? = nil,
            end: Swift.String? = nil,
            start: Swift.String? = nil
        )
        {
            self.dateRange = dateRange
            self.end = end
            self.start = start
        }
    }

}

extension SecurityHubClientTypes.DateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value) ?? 0
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.DateRangeUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension SecurityHubClientTypes {
    /// A date range for the date filter.
    public struct DateRange: Swift.Equatable {
        /// A date range unit for the date filter.
        public var unit: SecurityHubClientTypes.DateRangeUnit?
        /// A date range value for the date filter.
        public var value: Swift.Int

        public init (
            unit: SecurityHubClientTypes.DateRangeUnit? = nil,
            value: Swift.Int = 0
        )
        {
            self.unit = unit
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    public enum DateRangeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case days
        case sdkUnknown(Swift.String)

        public static var allCases: [DateRangeUnit] {
            return [
                .days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DateRangeUnit(rawValue: rawValue) ?? DateRangeUnit.sdkUnknown(rawValue)
        }
    }
}

extension DeclineInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for nonemptystring0 in accountIds {
                try accountIdsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension DeclineInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations/decline"
    }
}

public struct DeclineInvitationsInput: Swift.Equatable {
    /// The list of account IDs for the accounts from which to decline the invitations to Security Hub.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeclineInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeclineInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeclineInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeclineInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeclineInvitationsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeclineInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeclineInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeclineInvitationsOutputResponse: Swift.Equatable {
    /// The list of Amazon Web Services accounts that were not processed. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init (
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeclineInvitationsOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [SecurityHubClientTypes.Result]?
}

extension DeclineInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[SecurityHubClientTypes.Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [SecurityHubClientTypes.Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DeleteActionTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let actionTargetArn = actionTargetArn else {
            return nil
        }
        return "/actionTargets/\(actionTargetArn)"
    }
}

public struct DeleteActionTargetInput: Swift.Equatable {
    /// The ARN of the custom action target to delete.
    /// This member is required.
    public var actionTargetArn: Swift.String?

    public init (
        actionTargetArn: Swift.String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
    }
}

struct DeleteActionTargetInputBody: Swift.Equatable {
}

extension DeleteActionTargetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteActionTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteActionTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteActionTargetOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteActionTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteActionTargetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionTargetArn = output.actionTargetArn
        } else {
            self.actionTargetArn = nil
        }
    }
}

public struct DeleteActionTargetOutputResponse: Swift.Equatable {
    /// The ARN of the custom action target that was deleted.
    /// This member is required.
    public var actionTargetArn: Swift.String?

    public init (
        actionTargetArn: Swift.String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
    }
}

struct DeleteActionTargetOutputResponseBody: Swift.Equatable {
    let actionTargetArn: Swift.String?
}

extension DeleteActionTargetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTargetArn = "ActionTargetArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionTargetArn)
        actionTargetArn = actionTargetArnDecoded
    }
}

extension DeleteFindingAggregatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let findingAggregatorArn = findingAggregatorArn else {
            return nil
        }
        return "/findingAggregator/delete/\(findingAggregatorArn)"
    }
}

public struct DeleteFindingAggregatorInput: Swift.Equatable {
    /// The ARN of the finding aggregator to delete. To obtain the ARN, use ListFindingAggregators.
    /// This member is required.
    public var findingAggregatorArn: Swift.String?

    public init (
        findingAggregatorArn: Swift.String? = nil
    )
    {
        self.findingAggregatorArn = findingAggregatorArn
    }
}

struct DeleteFindingAggregatorInputBody: Swift.Equatable {
}

extension DeleteFindingAggregatorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFindingAggregatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFindingAggregatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFindingAggregatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFindingAggregatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFindingAggregatorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteInsightInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let insightArn = insightArn else {
            return nil
        }
        return "/insights/\(insightArn)"
    }
}

public struct DeleteInsightInput: Swift.Equatable {
    /// The ARN of the insight to delete.
    /// This member is required.
    public var insightArn: Swift.String?

    public init (
        insightArn: Swift.String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

struct DeleteInsightInputBody: Swift.Equatable {
}

extension DeleteInsightInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInsightOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInsightOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteInsightOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInsightOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteInsightOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insightArn = output.insightArn
        } else {
            self.insightArn = nil
        }
    }
}

public struct DeleteInsightOutputResponse: Swift.Equatable {
    /// The ARN of the insight that was deleted.
    /// This member is required.
    public var insightArn: Swift.String?

    public init (
        insightArn: Swift.String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

struct DeleteInsightOutputResponseBody: Swift.Equatable {
    let insightArn: Swift.String?
}

extension DeleteInsightOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightArn = "InsightArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightArn)
        insightArn = insightArnDecoded
    }
}

extension DeleteInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for nonemptystring0 in accountIds {
                try accountIdsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension DeleteInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations/delete"
    }
}

public struct DeleteInvitationsInput: Swift.Equatable {
    /// The list of the account IDs that sent the invitations to delete.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeleteInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteInvitationsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteInvitationsOutputResponse: Swift.Equatable {
    /// The list of Amazon Web Services accounts for which the invitations were not deleted. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init (
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteInvitationsOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [SecurityHubClientTypes.Result]?
}

extension DeleteInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[SecurityHubClientTypes.Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [SecurityHubClientTypes.Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DeleteMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for nonemptystring0 in accountIds {
                try accountIdsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension DeleteMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/delete"
    }
}

public struct DeleteMembersInput: Swift.Equatable {
    /// The list of account IDs for the member accounts to delete.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeleteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMembersOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteMembersOutputResponse: Swift.Equatable {
    /// The list of Amazon Web Services accounts that were not deleted. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init (
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [SecurityHubClientTypes.Result]?
}

extension DeleteMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[SecurityHubClientTypes.Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [SecurityHubClientTypes.Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DescribeActionTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTargetArns = "ActionTargetArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTargetArns = actionTargetArns {
            var actionTargetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionTargetArns)
            for nonemptystring0 in actionTargetArns {
                try actionTargetArnsContainer.encode(nonemptystring0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeActionTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/actionTargets/get"
    }
}

public struct DescribeActionTargetsInput: Swift.Equatable {
    /// A list of custom action target ARNs for the custom action targets to retrieve.
    public var actionTargetArns: [Swift.String]?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the DescribeActionTargets operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init (
        actionTargetArns: [Swift.String]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.actionTargetArns = actionTargetArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeActionTargetsInputBody: Swift.Equatable {
    let actionTargetArns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension DescribeActionTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTargetArns = "ActionTargetArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actionTargetArns)
        var actionTargetArnsDecoded0:[Swift.String]? = nil
        if let actionTargetArnsContainer = actionTargetArnsContainer {
            actionTargetArnsDecoded0 = [Swift.String]()
            for string0 in actionTargetArnsContainer {
                if let string0 = string0 {
                    actionTargetArnsDecoded0?.append(string0)
                }
            }
        }
        actionTargetArns = actionTargetArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension DescribeActionTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeActionTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeActionTargetsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActionTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeActionTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionTargets = output.actionTargets
            self.nextToken = output.nextToken
        } else {
            self.actionTargets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeActionTargetsOutputResponse: Swift.Equatable {
    /// A list of ActionTarget objects. Each object includes the ActionTargetArn, Description, and Name of a custom action target available in Security Hub.
    /// This member is required.
    public var actionTargets: [SecurityHubClientTypes.ActionTarget]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        actionTargets: [SecurityHubClientTypes.ActionTarget]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionTargets = actionTargets
        self.nextToken = nextToken
    }
}

struct DescribeActionTargetsOutputResponseBody: Swift.Equatable {
    let actionTargets: [SecurityHubClientTypes.ActionTarget]?
    let nextToken: Swift.String?
}

extension DescribeActionTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTargets = "ActionTargets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTargetsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.ActionTarget?].self, forKey: .actionTargets)
        var actionTargetsDecoded0:[SecurityHubClientTypes.ActionTarget]? = nil
        if let actionTargetsContainer = actionTargetsContainer {
            actionTargetsDecoded0 = [SecurityHubClientTypes.ActionTarget]()
            for structure0 in actionTargetsContainer {
                if let structure0 = structure0 {
                    actionTargetsDecoded0?.append(structure0)
                }
            }
        }
        actionTargets = actionTargetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeHubInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let hubArn = hubArn {
                let hubArnQueryItem = ClientRuntime.URLQueryItem(name: "HubArn".urlPercentEncoding(), value: Swift.String(hubArn).urlPercentEncoding())
                items.append(hubArnQueryItem)
            }
            return items
        }
    }
}

extension DescribeHubInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts"
    }
}

public struct DescribeHubInput: Swift.Equatable {
    /// The ARN of the Hub resource to retrieve.
    public var hubArn: Swift.String?

    public init (
        hubArn: Swift.String? = nil
    )
    {
        self.hubArn = hubArn
    }
}

struct DescribeHubInputBody: Swift.Equatable {
}

extension DescribeHubInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHubOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHubOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeHubOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHubOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeHubOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoEnableControls = output.autoEnableControls
            self.hubArn = output.hubArn
            self.subscribedAt = output.subscribedAt
        } else {
            self.autoEnableControls = false
            self.hubArn = nil
            self.subscribedAt = nil
        }
    }
}

public struct DescribeHubOutputResponse: Swift.Equatable {
    /// Whether to automatically enable new controls when they are added to standards that are enabled. If set to true, then new controls for enabled standards are enabled automatically. If set to false, then new controls are not enabled.
    public var autoEnableControls: Swift.Bool
    /// The ARN of the Hub resource that was retrieved.
    public var hubArn: Swift.String?
    /// The date and time when Security Hub was enabled in the account.
    public var subscribedAt: Swift.String?

    public init (
        autoEnableControls: Swift.Bool = false,
        hubArn: Swift.String? = nil,
        subscribedAt: Swift.String? = nil
    )
    {
        self.autoEnableControls = autoEnableControls
        self.hubArn = hubArn
        self.subscribedAt = subscribedAt
    }
}

struct DescribeHubOutputResponseBody: Swift.Equatable {
    let hubArn: Swift.String?
    let subscribedAt: Swift.String?
    let autoEnableControls: Swift.Bool
}

extension DescribeHubOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnableControls = "AutoEnableControls"
        case hubArn = "HubArn"
        case subscribedAt = "SubscribedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hubArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hubArn)
        hubArn = hubArnDecoded
        let subscribedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscribedAt)
        subscribedAt = subscribedAtDecoded
        let autoEnableControlsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnableControls) ?? false
        autoEnableControls = autoEnableControlsDecoded
    }
}

extension DescribeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/configuration"
    }
}

public struct DescribeOrganizationConfigurationInput: Swift.Equatable {

    public init () { }
}

struct DescribeOrganizationConfigurationInputBody: Swift.Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeOrganizationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
            self.autoEnableStandards = output.autoEnableStandards
            self.memberAccountLimitReached = output.memberAccountLimitReached
        } else {
            self.autoEnable = false
            self.autoEnableStandards = nil
            self.memberAccountLimitReached = false
        }
    }
}

public struct DescribeOrganizationConfigurationOutputResponse: Swift.Equatable {
    /// Whether to automatically enable Security Hub for new accounts in the organization. If set to true, then Security Hub is enabled for new accounts. If set to false, then new accounts are not added automatically.
    public var autoEnable: Swift.Bool
    /// Whether to automatically enable Security Hub [default standards](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-enable-disable.html) for new member accounts in the organization. The default value of this parameter is equal to DEFAULT. If equal to DEFAULT, then Security Hub default standards are automatically enabled for new member accounts. If equal to NONE, then default standards are not automatically enabled for new member accounts.
    public var autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards?
    /// Whether the maximum number of allowed member accounts are already associated with the Security Hub administrator account.
    public var memberAccountLimitReached: Swift.Bool

    public init (
        autoEnable: Swift.Bool = false,
        autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards? = nil,
        memberAccountLimitReached: Swift.Bool = false
    )
    {
        self.autoEnable = autoEnable
        self.autoEnableStandards = autoEnableStandards
        self.memberAccountLimitReached = memberAccountLimitReached
    }
}

struct DescribeOrganizationConfigurationOutputResponseBody: Swift.Equatable {
    let autoEnable: Swift.Bool
    let memberAccountLimitReached: Swift.Bool
    let autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards?
}

extension DescribeOrganizationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "AutoEnable"
        case autoEnableStandards = "AutoEnableStandards"
        case memberAccountLimitReached = "MemberAccountLimitReached"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
        let memberAccountLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .memberAccountLimitReached) ?? false
        memberAccountLimitReached = memberAccountLimitReachedDecoded
        let autoEnableStandardsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AutoEnableStandards.self, forKey: .autoEnableStandards)
        autoEnableStandards = autoEnableStandardsDecoded
    }
}

extension DescribeProductsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let productArn = productArn {
                let productArnQueryItem = ClientRuntime.URLQueryItem(name: "ProductArn".urlPercentEncoding(), value: Swift.String(productArn).urlPercentEncoding())
                items.append(productArnQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension DescribeProductsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/products"
    }
}

public struct DescribeProductsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the DescribeProducts operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// The ARN of the integration to return.
    public var productArn: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        productArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.productArn = productArn
    }
}

struct DescribeProductsInputBody: Swift.Equatable {
}

extension DescribeProductsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProductsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProductsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProductsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProductsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProductsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.products = output.products
        } else {
            self.nextToken = nil
            self.products = nil
        }
    }
}

public struct DescribeProductsOutputResponse: Swift.Equatable {
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?
    /// A list of products, including details for each product.
    /// This member is required.
    public var products: [SecurityHubClientTypes.Product]?

    public init (
        nextToken: Swift.String? = nil,
        products: [SecurityHubClientTypes.Product]? = nil
    )
    {
        self.nextToken = nextToken
        self.products = products
    }
}

struct DescribeProductsOutputResponseBody: Swift.Equatable {
    let products: [SecurityHubClientTypes.Product]?
    let nextToken: Swift.String?
}

extension DescribeProductsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case products = "Products"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Product?].self, forKey: .products)
        var productsDecoded0:[SecurityHubClientTypes.Product]? = nil
        if let productsContainer = productsContainer {
            productsDecoded0 = [SecurityHubClientTypes.Product]()
            for structure0 in productsContainer {
                if let structure0 = structure0 {
                    productsDecoded0?.append(structure0)
                }
            }
        }
        products = productsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeStandardsControlsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension DescribeStandardsControlsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let standardsSubscriptionArn = standardsSubscriptionArn else {
            return nil
        }
        return "/standards/controls/\(standardsSubscriptionArn)"
    }
}

public struct DescribeStandardsControlsInput: Swift.Equatable {
    /// The maximum number of security standard controls to return.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the DescribeStandardsControls operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// The ARN of a resource that represents your subscription to a supported standard. To get the subscription ARNs of the standards you have enabled, use the GetEnabledStandards operation.
    /// This member is required.
    public var standardsSubscriptionArn: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        standardsSubscriptionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.standardsSubscriptionArn = standardsSubscriptionArn
    }
}

struct DescribeStandardsControlsInputBody: Swift.Equatable {
}

extension DescribeStandardsControlsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeStandardsControlsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStandardsControlsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeStandardsControlsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStandardsControlsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeStandardsControlsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.controls = output.controls
            self.nextToken = output.nextToken
        } else {
            self.controls = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeStandardsControlsOutputResponse: Swift.Equatable {
    /// A list of security standards controls.
    public var controls: [SecurityHubClientTypes.StandardsControl]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        controls: [SecurityHubClientTypes.StandardsControl]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controls = controls
        self.nextToken = nextToken
    }
}

struct DescribeStandardsControlsOutputResponseBody: Swift.Equatable {
    let controls: [SecurityHubClientTypes.StandardsControl]?
    let nextToken: Swift.String?
}

extension DescribeStandardsControlsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controls = "Controls"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StandardsControl?].self, forKey: .controls)
        var controlsDecoded0:[SecurityHubClientTypes.StandardsControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [SecurityHubClientTypes.StandardsControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeStandardsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension DescribeStandardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/standards"
    }
}

public struct DescribeStandardsInput: Swift.Equatable {
    /// The maximum number of standards to return.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the DescribeStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeStandardsInputBody: Swift.Equatable {
}

extension DescribeStandardsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeStandardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStandardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeStandardsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStandardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeStandardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.standards = output.standards
        } else {
            self.nextToken = nil
            self.standards = nil
        }
    }
}

public struct DescribeStandardsOutputResponse: Swift.Equatable {
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?
    /// A list of available standards.
    public var standards: [SecurityHubClientTypes.Standard]?

    public init (
        nextToken: Swift.String? = nil,
        standards: [SecurityHubClientTypes.Standard]? = nil
    )
    {
        self.nextToken = nextToken
        self.standards = standards
    }
}

struct DescribeStandardsOutputResponseBody: Swift.Equatable {
    let standards: [SecurityHubClientTypes.Standard]?
    let nextToken: Swift.String?
}

extension DescribeStandardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case standards = "Standards"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Standard?].self, forKey: .standards)
        var standardsDecoded0:[SecurityHubClientTypes.Standard]? = nil
        if let standardsContainer = standardsContainer {
            standardsDecoded0 = [SecurityHubClientTypes.Standard]()
            for structure0 in standardsContainer {
                if let structure0 = structure0 {
                    standardsDecoded0?.append(structure0)
                }
            }
        }
        standards = standardsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DisableImportFindingsForProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let productSubscriptionArn = productSubscriptionArn else {
            return nil
        }
        return "/productSubscriptions/\(productSubscriptionArn)"
    }
}

public struct DisableImportFindingsForProductInput: Swift.Equatable {
    /// The ARN of the integrated product to disable the integration for.
    /// This member is required.
    public var productSubscriptionArn: Swift.String?

    public init (
        productSubscriptionArn: Swift.String? = nil
    )
    {
        self.productSubscriptionArn = productSubscriptionArn
    }
}

struct DisableImportFindingsForProductInputBody: Swift.Equatable {
}

extension DisableImportFindingsForProductInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableImportFindingsForProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableImportFindingsForProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableImportFindingsForProductOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableImportFindingsForProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableImportFindingsForProductOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "AdminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension DisableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/admin/disable"
    }
}

public struct DisableOrganizationAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account identifier of the Security Hub administrator account.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DisableOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension DisableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "AdminAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension DisableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableOrganizationAdminAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisableSecurityHubInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts"
    }
}

public struct DisableSecurityHubInput: Swift.Equatable {

    public init () { }
}

struct DisableSecurityHubInputBody: Swift.Equatable {
}

extension DisableSecurityHubInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableSecurityHubOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableSecurityHubOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableSecurityHubOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableSecurityHubOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableSecurityHubOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateFromAdministratorAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/administrator/disassociate"
    }
}

public struct DisassociateFromAdministratorAccountInput: Swift.Equatable {

    public init () { }
}

struct DisassociateFromAdministratorAccountInputBody: Swift.Equatable {
}

extension DisassociateFromAdministratorAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFromAdministratorAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromAdministratorAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateFromAdministratorAccountOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromAdministratorAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFromAdministratorAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateFromMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/master/disassociate"
    }
}

public struct DisassociateFromMasterAccountInput: Swift.Equatable {

    public init () { }
}

struct DisassociateFromMasterAccountInputBody: Swift.Equatable {
}

extension DisassociateFromMasterAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFromMasterAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromMasterAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateFromMasterAccountOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromMasterAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFromMasterAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for nonemptystring0 in accountIds {
                try accountIdsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension DisassociateMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/disassociate"
    }
}

public struct DisassociateMembersInput: Swift.Equatable {
    /// The account IDs of the member accounts to disassociate from the administrator account.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DisassociateMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DisassociateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DisassociateMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateMembersOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMembersOutputResponse: Swift.Equatable {

    public init () { }
}

extension SecurityHubClientTypes.DnsRequestAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "Blocked"
        case domain = "Domain"
        case `protocol` = "Protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let blockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blocked) ?? false
        blocked = blockedDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provided if ActionType is DNS_REQUEST. It provides details about the DNS request that was detected.
    public struct DnsRequestAction: Swift.Equatable {
        /// Indicates whether the DNS request was blocked.
        public var blocked: Swift.Bool
        /// The DNS domain that is associated with the DNS request.
        public var domain: Swift.String?
        /// The protocol that was used for the DNS request.
        public var `protocol`: Swift.String?

        public init (
            blocked: Swift.Bool = false,
            domain: Swift.String? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.blocked = blocked
            self.domain = domain
            self.`protocol` = `protocol`
        }
    }

}

extension EnableImportFindingsForProductInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productArn = "ProductArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productArn = self.productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
    }
}

extension EnableImportFindingsForProductInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/productSubscriptions"
    }
}

public struct EnableImportFindingsForProductInput: Swift.Equatable {
    /// The ARN of the product to enable the integration for.
    /// This member is required.
    public var productArn: Swift.String?

    public init (
        productArn: Swift.String? = nil
    )
    {
        self.productArn = productArn
    }
}

struct EnableImportFindingsForProductInputBody: Swift.Equatable {
    let productArn: Swift.String?
}

extension EnableImportFindingsForProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productArn = "ProductArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productArn)
        productArn = productArnDecoded
    }
}

extension EnableImportFindingsForProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableImportFindingsForProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableImportFindingsForProductOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableImportFindingsForProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EnableImportFindingsForProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.productSubscriptionArn = output.productSubscriptionArn
        } else {
            self.productSubscriptionArn = nil
        }
    }
}

public struct EnableImportFindingsForProductOutputResponse: Swift.Equatable {
    /// The ARN of your subscription to the product to enable integrations for.
    public var productSubscriptionArn: Swift.String?

    public init (
        productSubscriptionArn: Swift.String? = nil
    )
    {
        self.productSubscriptionArn = productSubscriptionArn
    }
}

struct EnableImportFindingsForProductOutputResponseBody: Swift.Equatable {
    let productSubscriptionArn: Swift.String?
}

extension EnableImportFindingsForProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productSubscriptionArn = "ProductSubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productSubscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSubscriptionArn)
        productSubscriptionArn = productSubscriptionArnDecoded
    }
}

extension EnableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "AdminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension EnableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/admin/enable"
    }
}

public struct EnableOrganizationAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account identifier of the account to designate as the Security Hub administrator account.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct EnableOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension EnableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "AdminAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension EnableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableOrganizationAdminAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension EnableSecurityHubInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableDefaultStandards = "EnableDefaultStandards"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enableDefaultStandards != false {
            try encodeContainer.encode(enableDefaultStandards, forKey: .enableDefaultStandards)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension EnableSecurityHubInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts"
    }
}

public struct EnableSecurityHubInput: Swift.Equatable {
    /// Whether to enable the security standards that Security Hub has designated as automatically enabled. If you do not provide a value for EnableDefaultStandards, it is set to true. To not enable the automatically enabled standards, set EnableDefaultStandards to false.
    public var enableDefaultStandards: Swift.Bool
    /// The tags to add to the hub resource when you enable Security Hub.
    public var tags: [Swift.String:Swift.String]?

    public init (
        enableDefaultStandards: Swift.Bool = false,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.enableDefaultStandards = enableDefaultStandards
        self.tags = tags
    }
}

struct EnableSecurityHubInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let enableDefaultStandards: Swift.Bool
}

extension EnableSecurityHubInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enableDefaultStandards = "EnableDefaultStandards"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let enableDefaultStandardsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultStandards) ?? false
        enableDefaultStandards = enableDefaultStandardsDecoded
    }
}

extension EnableSecurityHubOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableSecurityHubOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableSecurityHubOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case limitExceededException(LimitExceededException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableSecurityHubOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableSecurityHubOutputResponse: Swift.Equatable {

    public init () { }
}

extension SecurityHubClientTypes.FilePaths: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileName = "FileName"
        case filePath = "FilePath"
        case hash = "Hash"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileName = self.fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let hash = self.hash {
            try encodeContainer.encode(hash, forKey: .hash)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let hashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hash)
        hash = hashDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the file paths that were affected by the threat.
    public struct FilePaths: Swift.Equatable {
        /// The name of the infected or suspicious file corresponding to the hash.
        public var fileName: Swift.String?
        /// Path to the infected or suspicious file on the resource it was detected on.
        public var filePath: Swift.String?
        /// The hash value for the infected or suspicious file.
        public var hash: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource on which the threat was detected.
        public var resourceId: Swift.String?

        public init (
            fileName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            hash: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.fileName = fileName
            self.filePath = filePath
            self.hash = hash
            self.resourceId = resourceId
        }
    }

}

extension SecurityHubClientTypes.FindingAggregator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingAggregatorArn = "FindingAggregatorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingAggregatorArn = self.findingAggregatorArn {
            try encodeContainer.encode(findingAggregatorArn, forKey: .findingAggregatorArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingAggregatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingAggregatorArn)
        findingAggregatorArn = findingAggregatorArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// A finding aggregator. A finding aggregator contains the configuration for finding aggregation.
    public struct FindingAggregator: Swift.Equatable {
        /// The ARN of the finding aggregator. You use the finding aggregator ARN to retrieve details for, update, and delete the finding aggregator.
        public var findingAggregatorArn: Swift.String?

        public init (
            findingAggregatorArn: Swift.String? = nil
        )
        {
            self.findingAggregatorArn = findingAggregatorArn
        }
    }

}

extension SecurityHubClientTypes.FindingProviderFields: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confidence = "Confidence"
        case criticality = "Criticality"
        case relatedFindings = "RelatedFindings"
        case severity = "Severity"
        case types = "Types"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if criticality != 0 {
            try encodeContainer.encode(criticality, forKey: .criticality)
        }
        if let relatedFindings = relatedFindings {
            var relatedFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedFindings)
            for relatedfinding0 in relatedFindings {
                try relatedFindingsContainer.encode(relatedfinding0)
            }
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for nonemptystring0 in types {
                try typesContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .confidence) ?? 0
        confidence = confidenceDecoded
        let criticalityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .criticality) ?? 0
        criticality = criticalityDecoded
        let relatedFindingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RelatedFinding?].self, forKey: .relatedFindings)
        var relatedFindingsDecoded0:[SecurityHubClientTypes.RelatedFinding]? = nil
        if let relatedFindingsContainer = relatedFindingsContainer {
            relatedFindingsDecoded0 = [SecurityHubClientTypes.RelatedFinding]()
            for structure0 in relatedFindingsContainer {
                if let structure0 = structure0 {
                    relatedFindingsDecoded0?.append(structure0)
                }
            }
        }
        relatedFindings = relatedFindingsDecoded0
        let severityDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.FindingProviderSeverity.self, forKey: .severity)
        severity = severityDecoded
        let typesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .types)
        var typesDecoded0:[Swift.String]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [Swift.String]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// In a BatchImportFindings request, finding providers use FindingProviderFields to provide and update values for confidence, criticality, related findings, severity, and types.
    public struct FindingProviderFields: Swift.Equatable {
        /// A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence.
        public var confidence: Swift.Int
        /// The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources.
        public var criticality: Swift.Int
        /// A list of findings that are related to the current finding.
        public var relatedFindings: [SecurityHubClientTypes.RelatedFinding]?
        /// The severity of a finding.
        public var severity: SecurityHubClientTypes.FindingProviderSeverity?
        /// One or more finding types in the format of namespace/category/classifier that classify a finding. Valid namespace values are: Software and Configuration Checks | TTPs | Effects | Unusual Behaviors | Sensitive Data Identifications
        public var types: [Swift.String]?

        public init (
            confidence: Swift.Int = 0,
            criticality: Swift.Int = 0,
            relatedFindings: [SecurityHubClientTypes.RelatedFinding]? = nil,
            severity: SecurityHubClientTypes.FindingProviderSeverity? = nil,
            types: [Swift.String]? = nil
        )
        {
            self.confidence = confidence
            self.criticality = criticality
            self.relatedFindings = relatedFindings
            self.severity = severity
            self.types = types
        }
    }

}

extension SecurityHubClientTypes.FindingProviderSeverity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
        case original = "Original"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = self.label {
            try encodeContainer.encode(label.rawValue, forKey: .label)
        }
        if let original = self.original {
            try encodeContainer.encode(original, forKey: .original)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.SeverityLabel.self, forKey: .label)
        label = labelDecoded
        let originalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .original)
        original = originalDecoded
    }
}

extension SecurityHubClientTypes {
    /// The severity assigned to the finding by the finding provider.
    public struct FindingProviderSeverity: Swift.Equatable {
        /// The severity label assigned to the finding by the finding provider.
        public var label: SecurityHubClientTypes.SeverityLabel?
        /// The finding provider's original value for the severity.
        public var original: Swift.String?

        public init (
            label: SecurityHubClientTypes.SeverityLabel? = nil,
            original: Swift.String? = nil
        )
        {
            self.label = label
            self.original = original
        }
    }

}

extension SecurityHubClientTypes.FirewallPolicyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statefulRuleGroupReferences = "StatefulRuleGroupReferences"
        case statelessCustomActions = "StatelessCustomActions"
        case statelessDefaultActions = "StatelessDefaultActions"
        case statelessFragmentDefaultActions = "StatelessFragmentDefaultActions"
        case statelessRuleGroupReferences = "StatelessRuleGroupReferences"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statefulRuleGroupReferences = statefulRuleGroupReferences {
            var statefulRuleGroupReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statefulRuleGroupReferences)
            for firewallpolicystatefulrulegroupreferencesdetails0 in statefulRuleGroupReferences {
                try statefulRuleGroupReferencesContainer.encode(firewallpolicystatefulrulegroupreferencesdetails0)
            }
        }
        if let statelessCustomActions = statelessCustomActions {
            var statelessCustomActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessCustomActions)
            for firewallpolicystatelesscustomactionsdetails0 in statelessCustomActions {
                try statelessCustomActionsContainer.encode(firewallpolicystatelesscustomactionsdetails0)
            }
        }
        if let statelessDefaultActions = statelessDefaultActions {
            var statelessDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessDefaultActions)
            for nonemptystring0 in statelessDefaultActions {
                try statelessDefaultActionsContainer.encode(nonemptystring0)
            }
        }
        if let statelessFragmentDefaultActions = statelessFragmentDefaultActions {
            var statelessFragmentDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessFragmentDefaultActions)
            for nonemptystring0 in statelessFragmentDefaultActions {
                try statelessFragmentDefaultActionsContainer.encode(nonemptystring0)
            }
        }
        if let statelessRuleGroupReferences = statelessRuleGroupReferences {
            var statelessRuleGroupReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessRuleGroupReferences)
            for firewallpolicystatelessrulegroupreferencesdetails0 in statelessRuleGroupReferences {
                try statelessRuleGroupReferencesContainer.encode(firewallpolicystatelessrulegroupreferencesdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statefulRuleGroupReferencesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails?].self, forKey: .statefulRuleGroupReferences)
        var statefulRuleGroupReferencesDecoded0:[SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails]? = nil
        if let statefulRuleGroupReferencesContainer = statefulRuleGroupReferencesContainer {
            statefulRuleGroupReferencesDecoded0 = [SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails]()
            for structure0 in statefulRuleGroupReferencesContainer {
                if let structure0 = structure0 {
                    statefulRuleGroupReferencesDecoded0?.append(structure0)
                }
            }
        }
        statefulRuleGroupReferences = statefulRuleGroupReferencesDecoded0
        let statelessCustomActionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails?].self, forKey: .statelessCustomActions)
        var statelessCustomActionsDecoded0:[SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails]? = nil
        if let statelessCustomActionsContainer = statelessCustomActionsContainer {
            statelessCustomActionsDecoded0 = [SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails]()
            for structure0 in statelessCustomActionsContainer {
                if let structure0 = structure0 {
                    statelessCustomActionsDecoded0?.append(structure0)
                }
            }
        }
        statelessCustomActions = statelessCustomActionsDecoded0
        let statelessDefaultActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statelessDefaultActions)
        var statelessDefaultActionsDecoded0:[Swift.String]? = nil
        if let statelessDefaultActionsContainer = statelessDefaultActionsContainer {
            statelessDefaultActionsDecoded0 = [Swift.String]()
            for string0 in statelessDefaultActionsContainer {
                if let string0 = string0 {
                    statelessDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessDefaultActions = statelessDefaultActionsDecoded0
        let statelessFragmentDefaultActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .statelessFragmentDefaultActions)
        var statelessFragmentDefaultActionsDecoded0:[Swift.String]? = nil
        if let statelessFragmentDefaultActionsContainer = statelessFragmentDefaultActionsContainer {
            statelessFragmentDefaultActionsDecoded0 = [Swift.String]()
            for string0 in statelessFragmentDefaultActionsContainer {
                if let string0 = string0 {
                    statelessFragmentDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessFragmentDefaultActions = statelessFragmentDefaultActionsDecoded0
        let statelessRuleGroupReferencesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails?].self, forKey: .statelessRuleGroupReferences)
        var statelessRuleGroupReferencesDecoded0:[SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails]? = nil
        if let statelessRuleGroupReferencesContainer = statelessRuleGroupReferencesContainer {
            statelessRuleGroupReferencesDecoded0 = [SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails]()
            for structure0 in statelessRuleGroupReferencesContainer {
                if let structure0 = structure0 {
                    statelessRuleGroupReferencesDecoded0?.append(structure0)
                }
            }
        }
        statelessRuleGroupReferences = statelessRuleGroupReferencesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Defines the behavior of the firewall.
    public struct FirewallPolicyDetails: Swift.Equatable {
        /// The stateful rule groups that are used in the firewall policy.
        public var statefulRuleGroupReferences: [SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails]?
        /// The custom action definitions that are available to use in the firewall policy's StatelessDefaultActions setting.
        public var statelessCustomActions: [SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails]?
        /// The actions to take on a packet if it doesn't match any of the stateless rules in the policy. You must specify a standard action (aws:pass, aws:drop, aws:forward_to_sfe), and can optionally include a custom action from StatelessCustomActions.
        public var statelessDefaultActions: [Swift.String]?
        /// The actions to take on a fragmented UDP packet if it doesn't match any of the stateless rules in the policy. You must specify a standard action (aws:pass, aws:drop, aws:forward_to_sfe), and can optionally include a custom action from StatelessCustomActions.
        public var statelessFragmentDefaultActions: [Swift.String]?
        /// The stateless rule groups that are used in the firewall policy.
        public var statelessRuleGroupReferences: [SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails]?

        public init (
            statefulRuleGroupReferences: [SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails]? = nil,
            statelessCustomActions: [SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails]? = nil,
            statelessDefaultActions: [Swift.String]? = nil,
            statelessFragmentDefaultActions: [Swift.String]? = nil,
            statelessRuleGroupReferences: [SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails]? = nil
        )
        {
            self.statefulRuleGroupReferences = statefulRuleGroupReferences
            self.statelessCustomActions = statelessCustomActions
            self.statelessDefaultActions = statelessDefaultActions
            self.statelessFragmentDefaultActions = statelessFragmentDefaultActions
            self.statelessRuleGroupReferences = statelessRuleGroupReferences
        }
    }

}

extension SecurityHubClientTypes.FirewallPolicyStatefulRuleGroupReferencesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// A stateful rule group that is used by the firewall policy.
    public struct FirewallPolicyStatefulRuleGroupReferencesDetails: Swift.Equatable {
        /// The ARN of the stateful rule group.
        public var resourceArn: Swift.String?

        public init (
            resourceArn: Swift.String? = nil
        )
        {
            self.resourceArn = resourceArn
        }
    }

}

extension SecurityHubClientTypes.FirewallPolicyStatelessCustomActionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionDefinition = "ActionDefinition"
        case actionName = "ActionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionDefinition = self.actionDefinition {
            try encodeContainer.encode(actionDefinition, forKey: .actionDefinition)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDefinitionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.StatelessCustomActionDefinition.self, forKey: .actionDefinition)
        actionDefinition = actionDefinitionDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// A custom action that can be used for stateless packet handling.
    public struct FirewallPolicyStatelessCustomActionsDetails: Swift.Equatable {
        /// The definition of the custom action.
        public var actionDefinition: SecurityHubClientTypes.StatelessCustomActionDefinition?
        /// The name of the custom action.
        public var actionName: Swift.String?

        public init (
            actionDefinition: SecurityHubClientTypes.StatelessCustomActionDefinition? = nil,
            actionName: Swift.String? = nil
        )
        {
            self.actionDefinition = actionDefinition
            self.actionName = actionName
        }
    }

}

extension SecurityHubClientTypes.FirewallPolicyStatelessRuleGroupReferencesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// A stateless rule group that is used by the firewall policy.
    public struct FirewallPolicyStatelessRuleGroupReferencesDetails: Swift.Equatable {
        /// The order in which to run the stateless rule group.
        public var priority: Swift.Int
        /// The ARN of the stateless rule group.
        public var resourceArn: Swift.String?

        public init (
            priority: Swift.Int = 0,
            resourceArn: Swift.String? = nil
        )
        {
            self.priority = priority
            self.resourceArn = resourceArn
        }
    }

}

extension SecurityHubClientTypes.GeoLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lat = "Lat"
        case lon = "Lon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if lat != 0.0 {
            try encodeContainer.encode(lat, forKey: .lat)
        }
        if lon != 0.0 {
            try encodeContainer.encode(lon, forKey: .lon)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lonDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lon) ?? 0.0
        lon = lonDecoded
        let latDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lat) ?? 0.0
        lat = latDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides the latitude and longitude coordinates of a location.
    public struct GeoLocation: Swift.Equatable {
        /// The latitude of the location.
        public var lat: Swift.Double
        /// The longitude of the location.
        public var lon: Swift.Double

        public init (
            lat: Swift.Double = 0.0,
            lon: Swift.Double = 0.0
        )
        {
            self.lat = lat
            self.lon = lon
        }
    }

}

extension GetAdministratorAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/administrator"
    }
}

public struct GetAdministratorAccountInput: Swift.Equatable {

    public init () { }
}

struct GetAdministratorAccountInputBody: Swift.Equatable {
}

extension GetAdministratorAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAdministratorAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAdministratorAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAdministratorAccountOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAdministratorAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAdministratorAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.administrator = output.administrator
        } else {
            self.administrator = nil
        }
    }
}

public struct GetAdministratorAccountOutputResponse: Swift.Equatable {
    /// Details about an invitation.
    public var administrator: SecurityHubClientTypes.Invitation?

    public init (
        administrator: SecurityHubClientTypes.Invitation? = nil
    )
    {
        self.administrator = administrator
    }
}

struct GetAdministratorAccountOutputResponseBody: Swift.Equatable {
    let administrator: SecurityHubClientTypes.Invitation?
}

extension GetAdministratorAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administrator = "Administrator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Invitation.self, forKey: .administrator)
        administrator = administratorDecoded
    }
}

extension GetEnabledStandardsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case standardsSubscriptionArns = "StandardsSubscriptionArns"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let standardsSubscriptionArns = standardsSubscriptionArns {
            var standardsSubscriptionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .standardsSubscriptionArns)
            for nonemptystring0 in standardsSubscriptionArns {
                try standardsSubscriptionArnsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension GetEnabledStandardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/standards/get"
    }
}

public struct GetEnabledStandardsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the GetEnabledStandards operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// The list of the standards subscription ARNs for the standards to retrieve.
    public var standardsSubscriptionArns: [Swift.String]?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        standardsSubscriptionArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.standardsSubscriptionArns = standardsSubscriptionArns
    }
}

struct GetEnabledStandardsInputBody: Swift.Equatable {
    let standardsSubscriptionArns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension GetEnabledStandardsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case standardsSubscriptionArns = "StandardsSubscriptionArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .standardsSubscriptionArns)
        var standardsSubscriptionArnsDecoded0:[Swift.String]? = nil
        if let standardsSubscriptionArnsContainer = standardsSubscriptionArnsContainer {
            standardsSubscriptionArnsDecoded0 = [Swift.String]()
            for string0 in standardsSubscriptionArnsContainer {
                if let string0 = string0 {
                    standardsSubscriptionArnsDecoded0?.append(string0)
                }
            }
        }
        standardsSubscriptionArns = standardsSubscriptionArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension GetEnabledStandardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnabledStandardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEnabledStandardsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnabledStandardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEnabledStandardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.standardsSubscriptions = output.standardsSubscriptions
        } else {
            self.nextToken = nil
            self.standardsSubscriptions = nil
        }
    }
}

public struct GetEnabledStandardsOutputResponse: Swift.Equatable {
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?
    /// The list of StandardsSubscriptions objects that include information about the enabled standards.
    public var standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]?

    public init (
        nextToken: Swift.String? = nil,
        standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.standardsSubscriptions = standardsSubscriptions
    }
}

struct GetEnabledStandardsOutputResponseBody: Swift.Equatable {
    let standardsSubscriptions: [SecurityHubClientTypes.StandardsSubscription]?
    let nextToken: Swift.String?
}

extension GetEnabledStandardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case standardsSubscriptions = "StandardsSubscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StandardsSubscription?].self, forKey: .standardsSubscriptions)
        var standardsSubscriptionsDecoded0:[SecurityHubClientTypes.StandardsSubscription]? = nil
        if let standardsSubscriptionsContainer = standardsSubscriptionsContainer {
            standardsSubscriptionsDecoded0 = [SecurityHubClientTypes.StandardsSubscription]()
            for structure0 in standardsSubscriptionsContainer {
                if let structure0 = structure0 {
                    standardsSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        standardsSubscriptions = standardsSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetFindingAggregatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let findingAggregatorArn = findingAggregatorArn else {
            return nil
        }
        return "/findingAggregator/get/\(findingAggregatorArn)"
    }
}

public struct GetFindingAggregatorInput: Swift.Equatable {
    /// The ARN of the finding aggregator to return details for. To obtain the ARN, use ListFindingAggregators.
    /// This member is required.
    public var findingAggregatorArn: Swift.String?

    public init (
        findingAggregatorArn: Swift.String? = nil
    )
    {
        self.findingAggregatorArn = findingAggregatorArn
    }
}

struct GetFindingAggregatorInputBody: Swift.Equatable {
}

extension GetFindingAggregatorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFindingAggregatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingAggregatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFindingAggregatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingAggregatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFindingAggregatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingAggregationRegion = output.findingAggregationRegion
            self.findingAggregatorArn = output.findingAggregatorArn
            self.regionLinkingMode = output.regionLinkingMode
            self.regions = output.regions
        } else {
            self.findingAggregationRegion = nil
            self.findingAggregatorArn = nil
            self.regionLinkingMode = nil
            self.regions = nil
        }
    }
}

public struct GetFindingAggregatorOutputResponse: Swift.Equatable {
    /// The aggregation Region.
    public var findingAggregationRegion: Swift.String?
    /// The ARN of the finding aggregator.
    public var findingAggregatorArn: Swift.String?
    /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
    public var regionLinkingMode: Swift.String?
    /// The list of excluded Regions or included Regions.
    public var regions: [Swift.String]?

    public init (
        findingAggregationRegion: Swift.String? = nil,
        findingAggregatorArn: Swift.String? = nil,
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.findingAggregationRegion = findingAggregationRegion
        self.findingAggregatorArn = findingAggregatorArn
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

struct GetFindingAggregatorOutputResponseBody: Swift.Equatable {
    let findingAggregatorArn: Swift.String?
    let findingAggregationRegion: Swift.String?
    let regionLinkingMode: Swift.String?
    let regions: [Swift.String]?
}

extension GetFindingAggregatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingAggregationRegion = "FindingAggregationRegion"
        case findingAggregatorArn = "FindingAggregatorArn"
        case regionLinkingMode = "RegionLinkingMode"
        case regions = "Regions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingAggregatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingAggregatorArn)
        findingAggregatorArn = findingAggregatorArnDecoded
        let findingAggregationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingAggregationRegion)
        findingAggregationRegion = findingAggregationRegionDecoded
        let regionLinkingModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionLinkingMode)
        regionLinkingMode = regionLinkingModeDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension GetFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortcriterion0 in sortCriteria {
                try sortCriteriaContainer.encode(sortcriterion0)
            }
        }
    }
}

extension GetFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings"
    }
}

public struct GetFindingsInput: Swift.Equatable {
    /// The finding attributes used to define a condition to filter the returned findings. You can filter by up to 10 finding attributes. For each attribute, you can provide up to 20 filter values. Note that in the available filter fields, WorkflowState is deprecated. To search for a finding based on its workflow status, use WorkflowStatus.
    public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    /// The maximum number of findings to return.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the GetFindings operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// The finding attributes used to sort the list of returned findings.
    public var sortCriteria: [SecurityHubClientTypes.SortCriterion]?

    public init (
        filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sortCriteria: [SecurityHubClientTypes.SortCriterion]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingsInputBody: Swift.Equatable {
    let filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    let sortCriteria: [SecurityHubClientTypes.SortCriterion]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension GetFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let sortCriteriaContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.SortCriterion?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[SecurityHubClientTypes.SortCriterion]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [SecurityHubClientTypes.SortCriterion]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension GetFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFindingsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct GetFindingsOutputResponse: Swift.Equatable {
    /// The findings that matched the filters specified in the request.
    /// This member is required.
    public var findings: [SecurityHubClientTypes.AwsSecurityFinding]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        findings: [SecurityHubClientTypes.AwsSecurityFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct GetFindingsOutputResponseBody: Swift.Equatable {
    let findings: [SecurityHubClientTypes.AwsSecurityFinding]?
    let nextToken: Swift.String?
}

extension GetFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings = "Findings"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AwsSecurityFinding?].self, forKey: .findings)
        var findingsDecoded0:[SecurityHubClientTypes.AwsSecurityFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [SecurityHubClientTypes.AwsSecurityFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInsightResultsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let insightArn = insightArn else {
            return nil
        }
        return "/insights/results/\(insightArn)"
    }
}

public struct GetInsightResultsInput: Swift.Equatable {
    /// The ARN of the insight for which to return results.
    /// This member is required.
    public var insightArn: Swift.String?

    public init (
        insightArn: Swift.String? = nil
    )
    {
        self.insightArn = insightArn
    }
}

struct GetInsightResultsInputBody: Swift.Equatable {
}

extension GetInsightResultsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInsightResultsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightResultsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInsightResultsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightResultsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInsightResultsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insightResults = output.insightResults
        } else {
            self.insightResults = nil
        }
    }
}

public struct GetInsightResultsOutputResponse: Swift.Equatable {
    /// The insight results returned by the operation.
    /// This member is required.
    public var insightResults: SecurityHubClientTypes.InsightResults?

    public init (
        insightResults: SecurityHubClientTypes.InsightResults? = nil
    )
    {
        self.insightResults = insightResults
    }
}

struct GetInsightResultsOutputResponseBody: Swift.Equatable {
    let insightResults: SecurityHubClientTypes.InsightResults?
}

extension GetInsightResultsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightResults = "InsightResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightResultsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.InsightResults.self, forKey: .insightResults)
        insightResults = insightResultsDecoded
    }
}

extension GetInsightsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightArns = "InsightArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightArns = insightArns {
            var insightArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insightArns)
            for nonemptystring0 in insightArns {
                try insightArnsContainer.encode(nonemptystring0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetInsightsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/insights/get"
    }
}

public struct GetInsightsInput: Swift.Equatable {
    /// The ARNs of the insights to describe. If you do not provide any insight ARNs, then GetInsights returns all of your custom insights. It does not return any managed insights.
    public var insightArns: [Swift.String]?
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the GetInsights operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init (
        insightArns: [Swift.String]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.insightArns = insightArns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetInsightsInputBody: Swift.Equatable {
    let insightArns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension GetInsightsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insightArns = "InsightArns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .insightArns)
        var insightArnsDecoded0:[Swift.String]? = nil
        if let insightArnsContainer = insightArnsContainer {
            insightArnsDecoded0 = [Swift.String]()
            for string0 in insightArnsContainer {
                if let string0 = string0 {
                    insightArnsDecoded0?.append(string0)
                }
            }
        }
        insightArns = insightArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension GetInsightsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInsightsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInsightsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.insights = output.insights
            self.nextToken = output.nextToken
        } else {
            self.insights = nil
            self.nextToken = nil
        }
    }
}

public struct GetInsightsOutputResponse: Swift.Equatable {
    /// The insights returned by the operation.
    /// This member is required.
    public var insights: [SecurityHubClientTypes.Insight]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        insights: [SecurityHubClientTypes.Insight]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.insights = insights
        self.nextToken = nextToken
    }
}

struct GetInsightsOutputResponseBody: Swift.Equatable {
    let insights: [SecurityHubClientTypes.Insight]?
    let nextToken: Swift.String?
}

extension GetInsightsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insights = "Insights"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Insight?].self, forKey: .insights)
        var insightsDecoded0:[SecurityHubClientTypes.Insight]? = nil
        if let insightsContainer = insightsContainer {
            insightsDecoded0 = [SecurityHubClientTypes.Insight]()
            for structure0 in insightsContainer {
                if let structure0 = structure0 {
                    insightsDecoded0?.append(structure0)
                }
            }
        }
        insights = insightsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInvitationsCountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations/count"
    }
}

public struct GetInvitationsCountInput: Swift.Equatable {

    public init () { }
}

struct GetInvitationsCountInputBody: Swift.Equatable {
}

extension GetInvitationsCountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInvitationsCountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInvitationsCountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInvitationsCountOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvitationsCountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInvitationsCountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitationsCount = output.invitationsCount
        } else {
            self.invitationsCount = 0
        }
    }
}

public struct GetInvitationsCountOutputResponse: Swift.Equatable {
    /// The number of all membership invitations sent to this Security Hub member account, not including the currently accepted invitation.
    public var invitationsCount: Swift.Int

    public init (
        invitationsCount: Swift.Int = 0
    )
    {
        self.invitationsCount = invitationsCount
    }
}

struct GetInvitationsCountOutputResponseBody: Swift.Equatable {
    let invitationsCount: Swift.Int
}

extension GetInvitationsCountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationsCount = "InvitationsCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invitationsCount) ?? 0
        invitationsCount = invitationsCountDecoded
    }
}

extension GetMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/master"
    }
}

public struct GetMasterAccountInput: Swift.Equatable {

    public init () { }
}

struct GetMasterAccountInputBody: Swift.Equatable {
}

extension GetMasterAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMasterAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMasterAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMasterAccountOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMasterAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMasterAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.master = output.master
        } else {
            self.master = nil
        }
    }
}

public struct GetMasterAccountOutputResponse: Swift.Equatable {
    /// A list of details about the Security Hub administrator account for the current member account.
    public var master: SecurityHubClientTypes.Invitation?

    public init (
        master: SecurityHubClientTypes.Invitation? = nil
    )
    {
        self.master = master
    }
}

struct GetMasterAccountOutputResponseBody: Swift.Equatable {
    let master: SecurityHubClientTypes.Invitation?
}

extension GetMasterAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case master = "Master"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Invitation.self, forKey: .master)
        master = masterDecoded
    }
}

extension GetMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for nonemptystring0 in accountIds {
                try accountIdsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension GetMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/get"
    }
}

public struct GetMembersInput: Swift.Equatable {
    /// The list of account IDs for the Security Hub member accounts to return the details for.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct GetMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension GetMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMembersOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.members = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMembersOutputResponse: Swift.Equatable {
    /// The list of details about the Security Hub member accounts.
    public var members: [SecurityHubClientTypes.Member]?
    /// The list of Amazon Web Services accounts that could not be processed. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init (
        members: [SecurityHubClientTypes.Member]? = nil,
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMembersOutputResponseBody: Swift.Equatable {
    let members: [SecurityHubClientTypes.Member]?
    let unprocessedAccounts: [SecurityHubClientTypes.Result]?
}

extension GetMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "Members"
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[SecurityHubClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [SecurityHubClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[SecurityHubClientTypes.Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [SecurityHubClientTypes.Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension SecurityHubClientTypes.IcmpTypeCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if type != 0 {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .type) ?? 0
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// An Internet Control Message Protocol (ICMP) type and code.
    public struct IcmpTypeCode: Swift.Equatable {
        /// The ICMP code for which to deny or allow access. To deny or allow all codes, use the value -1.
        public var code: Swift.Int
        /// The ICMP type for which to deny or allow access. To deny or allow all types, use the value -1.
        public var type: Swift.Int

        public init (
            code: Swift.Int = 0,
            type: Swift.Int = 0
        )
        {
            self.code = code
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.ImportFindingsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension SecurityHubClientTypes {
    /// The list of the findings that cannot be imported. For each finding, the list provides the error.
    public struct ImportFindingsError: Swift.Equatable {
        /// The code of the error returned by the BatchImportFindings operation.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message of the error returned by the BatchImportFindings operation.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The identifier of the finding that could not be updated.
        /// This member is required.
        public var id: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }

}

extension SecurityHubClientTypes.Insight: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case insightArn = "InsightArn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByAttribute = self.groupByAttribute {
            try encodeContainer.encode(groupByAttribute, forKey: .groupByAttribute)
        }
        if let insightArn = self.insightArn {
            try encodeContainer.encode(insightArn, forKey: .insightArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightArn)
        insightArn = insightArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupByAttribute)
        groupByAttribute = groupByAttributeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains information about a Security Hub insight.
    public struct Insight: Swift.Equatable {
        /// One or more attributes used to filter the findings included in the insight. The insight only includes findings that match the criteria defined in the filters.
        /// This member is required.
        public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
        /// The grouping attribute for the insight's findings. Indicates how to group the matching findings, and identifies the type of item that the insight applies to. For example, if an insight is grouped by resource identifier, then the insight produces a list of resource identifiers.
        /// This member is required.
        public var groupByAttribute: Swift.String?
        /// The ARN of a Security Hub insight.
        /// This member is required.
        public var insightArn: Swift.String?
        /// The name of a Security Hub insight.
        /// This member is required.
        public var name: Swift.String?

        public init (
            filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
            groupByAttribute: Swift.String? = nil,
            insightArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.filters = filters
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.name = name
        }
    }

}

extension SecurityHubClientTypes.InsightResultValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case groupByAttributeValue = "GroupByAttributeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let groupByAttributeValue = self.groupByAttributeValue {
            try encodeContainer.encode(groupByAttributeValue, forKey: .groupByAttributeValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupByAttributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupByAttributeValue)
        groupByAttributeValue = groupByAttributeValueDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
    }
}

extension SecurityHubClientTypes {
    /// The insight result values returned by the GetInsightResults operation.
    public struct InsightResultValue: Swift.Equatable {
        /// The number of findings returned for each GroupByAttributeValue.
        /// This member is required.
        public var count: Swift.Int
        /// The value of the attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        /// This member is required.
        public var groupByAttributeValue: Swift.String?

        public init (
            count: Swift.Int = 0,
            groupByAttributeValue: Swift.String? = nil
        )
        {
            self.count = count
            self.groupByAttributeValue = groupByAttributeValue
        }
    }

}

extension SecurityHubClientTypes.InsightResults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupByAttribute = "GroupByAttribute"
        case insightArn = "InsightArn"
        case resultValues = "ResultValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupByAttribute = self.groupByAttribute {
            try encodeContainer.encode(groupByAttribute, forKey: .groupByAttribute)
        }
        if let insightArn = self.insightArn {
            try encodeContainer.encode(insightArn, forKey: .insightArn)
        }
        if let resultValues = resultValues {
            var resultValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultValues)
            for insightresultvalue0 in resultValues {
                try resultValuesContainer.encode(insightresultvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .insightArn)
        insightArn = insightArnDecoded
        let groupByAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupByAttribute)
        groupByAttribute = groupByAttributeDecoded
        let resultValuesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.InsightResultValue?].self, forKey: .resultValues)
        var resultValuesDecoded0:[SecurityHubClientTypes.InsightResultValue]? = nil
        if let resultValuesContainer = resultValuesContainer {
            resultValuesDecoded0 = [SecurityHubClientTypes.InsightResultValue]()
            for structure0 in resultValuesContainer {
                if let structure0 = structure0 {
                    resultValuesDecoded0?.append(structure0)
                }
            }
        }
        resultValues = resultValuesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// The insight results returned by the GetInsightResults operation.
    public struct InsightResults: Swift.Equatable {
        /// The attribute that the findings are grouped by for the insight whose results are returned by the GetInsightResults operation.
        /// This member is required.
        public var groupByAttribute: Swift.String?
        /// The ARN of the insight whose results are returned by the GetInsightResults operation.
        /// This member is required.
        public var insightArn: Swift.String?
        /// The list of insight result values returned by the GetInsightResults operation.
        /// This member is required.
        public var resultValues: [SecurityHubClientTypes.InsightResultValue]?

        public init (
            groupByAttribute: Swift.String? = nil,
            insightArn: Swift.String? = nil,
            resultValues: [SecurityHubClientTypes.InsightResultValue]? = nil
        )
        {
            self.groupByAttribute = groupByAttribute
            self.insightArn = insightArn
            self.resultValues = resultValues
        }
    }

}

extension SecurityHubClientTypes {
    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case receiveFindingsFromSecurityHub
        case sendFindingsToSecurityHub
        case updateFindingsInSecurityHub
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .receiveFindingsFromSecurityHub,
                .sendFindingsToSecurityHub,
                .updateFindingsInSecurityHub,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .receiveFindingsFromSecurityHub: return "RECEIVE_FINDINGS_FROM_SECURITY_HUB"
            case .sendFindingsToSecurityHub: return "SEND_FINDINGS_TO_SECURITY_HUB"
            case .updateFindingsInSecurityHub: return "UPDATE_FINDINGS_IN_SECURITY_HUB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
        }
    }
}

extension InternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Internal server error.
public struct InternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension InternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidAccessException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidAccessExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The account doesn't have permission to perform this action.
public struct InvalidAccessException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidAccessExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension InvalidAccessExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because you supplied an invalid or out-of-range value for an input parameter.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SecurityHubClientTypes.Invitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case invitationId = "InvitationId"
        case invitedAt = "InvitedAt"
        case memberStatus = "MemberStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encodeTimestamp(invitedAt, format: .dateTime, forKey: .invitedAt)
        }
        if let memberStatus = self.memberStatus {
            try encodeContainer.encode(memberStatus, forKey: .memberStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let invitedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let memberStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberStatus)
        memberStatus = memberStatusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an invitation.
    public struct Invitation: Swift.Equatable {
        /// The account ID of the Security Hub administrator account that the invitation was sent from.
        public var accountId: Swift.String?
        /// The ID of the invitation sent to the member account.
        public var invitationId: Swift.String?
        /// The timestamp of when the invitation was sent.
        public var invitedAt: ClientRuntime.Date?
        /// The current status of the association between the member and administrator accounts.
        public var memberStatus: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: ClientRuntime.Date? = nil,
            memberStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.memberStatus = memberStatus
        }
    }

}

extension InviteMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for nonemptystring0 in accountIds {
                try accountIdsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension InviteMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members/invite"
    }
}

public struct InviteMembersInput: Swift.Equatable {
    /// The list of account IDs of the Amazon Web Services accounts to invite to Security Hub as members.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct InviteMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension InviteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension InviteMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InviteMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InviteMembersOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InviteMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InviteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct InviteMembersOutputResponse: Swift.Equatable {
    /// The list of Amazon Web Services accounts that could not be processed. For each account, the list includes the account ID and the email address.
    public var unprocessedAccounts: [SecurityHubClientTypes.Result]?

    public init (
        unprocessedAccounts: [SecurityHubClientTypes.Result]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct InviteMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [SecurityHubClientTypes.Result]?
}

extension InviteMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "UnprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Result?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[SecurityHubClientTypes.Result]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [SecurityHubClientTypes.Result]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension SecurityHubClientTypes.IpFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidr = "Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidr = self.cidr {
            try encodeContainer.encode(cidr, forKey: .cidr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidr)
        cidr = cidrDecoded
    }
}

extension SecurityHubClientTypes {
    /// The IP filter for querying findings.
    public struct IpFilter: Swift.Equatable {
        /// A finding's CIDR value.
        public var cidr: Swift.String?

        public init (
            cidr: Swift.String? = nil
        )
        {
            self.cidr = cidr
        }
    }

}

extension SecurityHubClientTypes.IpOrganizationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn = "Asn"
        case asnOrg = "AsnOrg"
        case isp = "Isp"
        case org = "Org"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if asn != 0 {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let asnOrg = self.asnOrg {
            try encodeContainer.encode(asnOrg, forKey: .asnOrg)
        }
        if let isp = self.isp {
            try encodeContainer.encode(isp, forKey: .isp)
        }
        if let org = self.org {
            try encodeContainer.encode(org, forKey: .org)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asn) ?? 0
        asn = asnDecoded
        let asnOrgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asnOrg)
        asnOrg = asnOrgDecoded
        let ispDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isp)
        isp = ispDecoded
        let orgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .org)
        org = orgDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about an internet provider.
    public struct IpOrganizationDetails: Swift.Equatable {
        /// The Autonomous System Number (ASN) of the internet provider
        public var asn: Swift.Int
        /// The name of the organization that registered the ASN.
        public var asnOrg: Swift.String?
        /// The ISP information for the internet provider.
        public var isp: Swift.String?
        /// The name of the internet provider.
        public var org: Swift.String?

        public init (
            asn: Swift.Int = 0,
            asnOrg: Swift.String? = nil,
            isp: Swift.String? = nil,
            org: Swift.String? = nil
        )
        {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }
    }

}

extension SecurityHubClientTypes.Ipv6CidrBlockAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationId = "AssociationId"
        case cidrBlockState = "CidrBlockState"
        case ipv6CidrBlock = "Ipv6CidrBlock"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationId = self.associationId {
            try encodeContainer.encode(associationId, forKey: .associationId)
        }
        if let cidrBlockState = self.cidrBlockState {
            try encodeContainer.encode(cidrBlockState, forKey: .cidrBlockState)
        }
        if let ipv6CidrBlock = self.ipv6CidrBlock {
            try encodeContainer.encode(ipv6CidrBlock, forKey: .ipv6CidrBlock)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associationId)
        associationId = associationIdDecoded
        let ipv6CidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6CidrBlock)
        ipv6CidrBlock = ipv6CidrBlockDecoded
        let cidrBlockStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlockState)
        cidrBlockState = cidrBlockStateDecoded
    }
}

extension SecurityHubClientTypes {
    /// An IPV6 CIDR block association.
    public struct Ipv6CidrBlockAssociation: Swift.Equatable {
        /// The association ID for the IPv6 CIDR block.
        public var associationId: Swift.String?
        /// Information about the state of the CIDR block. Valid values are as follows:
        ///
        /// * associating
        ///
        /// * associated
        ///
        /// * disassociating
        ///
        /// * disassociated
        ///
        /// * failed
        ///
        /// * failing
        public var cidrBlockState: Swift.String?
        /// The IPv6 CIDR block.
        public var ipv6CidrBlock: Swift.String?

        public init (
            associationId: Swift.String? = nil,
            cidrBlockState: Swift.String? = nil,
            ipv6CidrBlock: Swift.String? = nil
        )
        {
            self.associationId = associationId
            self.cidrBlockState = cidrBlockState
            self.ipv6CidrBlock = ipv6CidrBlock
        }
    }

}

extension SecurityHubClientTypes.KeywordFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// A keyword filter for querying findings.
    public struct KeywordFilter: Swift.Equatable {
        /// A value for the keyword.
        public var value: Swift.String?

        public init (
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account or throttling limits. The error code describes the limit exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension ListEnabledProductsForImportInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListEnabledProductsForImportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/productSubscriptions"
    }
}

public struct ListEnabledProductsForImportInput: Swift.Equatable {
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the ListEnabledProductsForImport operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnabledProductsForImportInputBody: Swift.Equatable {
}

extension ListEnabledProductsForImportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEnabledProductsForImportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnabledProductsForImportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEnabledProductsForImportOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnabledProductsForImportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEnabledProductsForImportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.productSubscriptions = output.productSubscriptions
        } else {
            self.nextToken = nil
            self.productSubscriptions = nil
        }
    }
}

public struct ListEnabledProductsForImportOutputResponse: Swift.Equatable {
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?
    /// The list of ARNs for the resources that represent your subscriptions to products.
    public var productSubscriptions: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        productSubscriptions: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.productSubscriptions = productSubscriptions
    }
}

struct ListEnabledProductsForImportOutputResponseBody: Swift.Equatable {
    let productSubscriptions: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListEnabledProductsForImportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case productSubscriptions = "ProductSubscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productSubscriptionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .productSubscriptions)
        var productSubscriptionsDecoded0:[Swift.String]? = nil
        if let productSubscriptionsContainer = productSubscriptionsContainer {
            productSubscriptionsDecoded0 = [Swift.String]()
            for string0 in productSubscriptionsContainer {
                if let string0 = string0 {
                    productSubscriptionsDecoded0?.append(string0)
                }
            }
        }
        productSubscriptions = productSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingAggregatorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFindingAggregatorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findingAggregator/list"
    }
}

public struct ListFindingAggregatorsInput: Swift.Equatable {
    /// The maximum number of results to return. This operation currently only returns a single result.
    public var maxResults: Swift.Int
    /// The token returned with the previous set of results. Identifies the next set of results to return.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFindingAggregatorsInputBody: Swift.Equatable {
}

extension ListFindingAggregatorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFindingAggregatorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingAggregatorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFindingAggregatorsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingAggregatorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFindingAggregatorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingAggregators = output.findingAggregators
            self.nextToken = output.nextToken
        } else {
            self.findingAggregators = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingAggregatorsOutputResponse: Swift.Equatable {
    /// The list of finding aggregators. This operation currently only returns a single result.
    public var findingAggregators: [SecurityHubClientTypes.FindingAggregator]?
    /// If there are more results, this is the token to provide in the next call to ListFindingAggregators. This operation currently only returns a single result.
    public var nextToken: Swift.String?

    public init (
        findingAggregators: [SecurityHubClientTypes.FindingAggregator]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingAggregators = findingAggregators
        self.nextToken = nextToken
    }
}

struct ListFindingAggregatorsOutputResponseBody: Swift.Equatable {
    let findingAggregators: [SecurityHubClientTypes.FindingAggregator]?
    let nextToken: Swift.String?
}

extension ListFindingAggregatorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingAggregators = "FindingAggregators"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingAggregatorsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.FindingAggregator?].self, forKey: .findingAggregators)
        var findingAggregatorsDecoded0:[SecurityHubClientTypes.FindingAggregator]? = nil
        if let findingAggregatorsContainer = findingAggregatorsContainer {
            findingAggregatorsDecoded0 = [SecurityHubClientTypes.FindingAggregator]()
            for structure0 in findingAggregatorsContainer {
                if let structure0 = structure0 {
                    findingAggregatorsDecoded0?.append(structure0)
                }
            }
        }
        findingAggregators = findingAggregatorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInvitationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitations"
    }
}

public struct ListInvitationsInput: Swift.Equatable {
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the ListInvitations operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Swift.Equatable {
}

extension ListInvitationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInvitationsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutputResponse: Swift.Equatable {
    /// The details of the invitations returned by the operation.
    public var invitations: [SecurityHubClientTypes.Invitation]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        invitations: [SecurityHubClientTypes.Invitation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputResponseBody: Swift.Equatable {
    let invitations: [SecurityHubClientTypes.Invitation]?
    let nextToken: Swift.String?
}

extension ListInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitations = "Invitations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Invitation?].self, forKey: .invitations)
        var invitationsDecoded0:[SecurityHubClientTypes.Invitation]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [SecurityHubClientTypes.Invitation]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if onlyAssociated != false {
                let onlyAssociatedQueryItem = ClientRuntime.URLQueryItem(name: "OnlyAssociated".urlPercentEncoding(), value: Swift.String(onlyAssociated).urlPercentEncoding())
                items.append(onlyAssociatedQueryItem)
            }
            return items
        }
    }
}

extension ListMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/members"
    }
}

public struct ListMembersInput: Swift.Equatable {
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the ListMembers operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?
    /// Specifies which member accounts to include in the response based on their relationship status with the administrator account. The default value is TRUE. If OnlyAssociated is set to TRUE, the response includes member accounts whose relationship status with the administrator account is set to ENABLED. If OnlyAssociated is set to FALSE, the response includes all existing member accounts.
    public var onlyAssociated: Swift.Bool

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        onlyAssociated: Swift.Bool = false
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Swift.Equatable {
}

extension ListMembersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMembersOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Swift.Equatable {
    /// Member details returned by the operation.
    public var members: [SecurityHubClientTypes.Member]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        members: [SecurityHubClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Swift.Equatable {
    let members: [SecurityHubClientTypes.Member]?
    let nextToken: Swift.String?
}

extension ListMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "Members"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[SecurityHubClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [SecurityHubClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/admin"
    }
}

public struct ListOrganizationAdminAccountsInput: Swift.Equatable {
    /// The maximum number of items to return in the response.
    public var maxResults: Swift.Int
    /// The token that is required for pagination. On your first call to the ListOrganizationAdminAccounts operation, set the value of this parameter to NULL. For subsequent calls to the operation, to continue listing data, set the value of this parameter to the value returned from the previous response.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsInputBody: Swift.Equatable {
}

extension ListOrganizationAdminAccountsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOrganizationAdminAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationAdminAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOrganizationAdminAccountsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationAdminAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOrganizationAdminAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccounts = output.adminAccounts
            self.nextToken = output.nextToken
        } else {
            self.adminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationAdminAccountsOutputResponse: Swift.Equatable {
    /// The list of Security Hub administrator accounts.
    public var adminAccounts: [SecurityHubClientTypes.AdminAccount]?
    /// The pagination token to use to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        adminAccounts: [SecurityHubClientTypes.AdminAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsOutputResponseBody: Swift.Equatable {
    let adminAccounts: [SecurityHubClientTypes.AdminAccount]?
    let nextToken: Swift.String?
}

extension ListOrganizationAdminAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccounts = "AdminAccounts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.AdminAccount?].self, forKey: .adminAccounts)
        var adminAccountsDecoded0:[SecurityHubClientTypes.AdminAccount]? = nil
        if let adminAccountsContainer = adminAccountsContainer {
            adminAccountsDecoded0 = [SecurityHubClientTypes.AdminAccount]()
            for structure0 in adminAccountsContainer {
                if let structure0 = structure0 {
                    adminAccountsDecoded0?.append(structure0)
                }
            }
        }
        adminAccounts = adminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to retrieve tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with a resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SecurityHubClientTypes.LoadBalancerState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about the state of the load balancer.
    public struct LoadBalancerState: Swift.Equatable {
        /// The state code. The initial state of the load balancer is provisioning. After the load balancer is fully set up and ready to route traffic, its state is active. If the load balancer could not be set up, its state is failed.
        public var code: Swift.String?
        /// A description of the state.
        public var reason: Swift.String?

        public init (
            code: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.code = code
            self.reason = reason
        }
    }

}

extension SecurityHubClientTypes.Malware: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case path = "Path"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.MalwareType.self, forKey: .type)
        type = typeDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.MalwareState.self, forKey: .state)
        state = stateDecoded
    }
}

extension SecurityHubClientTypes {
    /// A list of malware related to a finding.
    public struct Malware: Swift.Equatable {
        /// The name of the malware that was observed.
        /// This member is required.
        public var name: Swift.String?
        /// The file system path of the malware that was observed.
        public var path: Swift.String?
        /// The state of the malware that was observed.
        public var state: SecurityHubClientTypes.MalwareState?
        /// The type of the malware that was observed.
        public var type: SecurityHubClientTypes.MalwareType?

        public init (
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            state: SecurityHubClientTypes.MalwareState? = nil,
            type: SecurityHubClientTypes.MalwareType? = nil
        )
        {
            self.name = name
            self.path = path
            self.state = state
            self.type = type
        }
    }

}

extension SecurityHubClientTypes {
    public enum MalwareState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case observed
        case removalFailed
        case removed
        case sdkUnknown(Swift.String)

        public static var allCases: [MalwareState] {
            return [
                .observed,
                .removalFailed,
                .removed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .observed: return "OBSERVED"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removed: return "REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MalwareState(rawValue: rawValue) ?? MalwareState.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes {
    public enum MalwareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case adware
        case blendedThreat
        case botnetAgent
        case coinMiner
        case exploitKit
        case keylogger
        case macro
        case potentiallyUnwanted
        case ransomware
        case remoteAccess
        case rootkit
        case spyware
        case trojan
        case virus
        case worm
        case sdkUnknown(Swift.String)

        public static var allCases: [MalwareType] {
            return [
                .adware,
                .blendedThreat,
                .botnetAgent,
                .coinMiner,
                .exploitKit,
                .keylogger,
                .macro,
                .potentiallyUnwanted,
                .ransomware,
                .remoteAccess,
                .rootkit,
                .spyware,
                .trojan,
                .virus,
                .worm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .adware: return "ADWARE"
            case .blendedThreat: return "BLENDED_THREAT"
            case .botnetAgent: return "BOTNET_AGENT"
            case .coinMiner: return "COIN_MINER"
            case .exploitKit: return "EXPLOIT_KIT"
            case .keylogger: return "KEYLOGGER"
            case .macro: return "MACRO"
            case .potentiallyUnwanted: return "POTENTIALLY_UNWANTED"
            case .ransomware: return "RANSOMWARE"
            case .remoteAccess: return "REMOTE_ACCESS"
            case .rootkit: return "ROOTKIT"
            case .spyware: return "SPYWARE"
            case .trojan: return "TROJAN"
            case .virus: return "VIRUS"
            case .worm: return "WORM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MalwareType(rawValue: rawValue) ?? MalwareType.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.MapFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison = "Comparison"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let comparisonDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.MapFilterComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
    }
}

extension SecurityHubClientTypes {
    /// A map filter for querying findings. Each map filter provides the field to check, the value to look for, and the comparison operator.
    public struct MapFilter: Swift.Equatable {
        /// The condition to apply to the key value when querying for findings with a map filter. To search for values that exactly match the filter value, use EQUALS. For example, for the ResourceTags field, the filter Department EQUALS Security matches findings that have the value Security for the tag Department. To search for values other than the filter value, use NOT_EQUALS. For example, for the ResourceTags field, the filter Department NOT_EQUALS Finance matches findings that do not have the value Finance for the tag Department. EQUALS filters on the same field are joined by OR. A finding matches if it matches any one of those filters. NOT_EQUALS filters on the same field are joined by AND. A finding matches only if it matches all of those filters. You cannot have both an EQUALS filter and a NOT_EQUALS filter on the same field.
        public var comparison: SecurityHubClientTypes.MapFilterComparison?
        /// The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field.
        public var key: Swift.String?
        /// The value for the key in the map filter. Filter values are case sensitive. For example, one of the values for a tag called Department might be Security. If you provide security as the filter value, then there is no match.
        public var value: Swift.String?

        public init (
            comparison: SecurityHubClientTypes.MapFilterComparison? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.key = key
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    public enum MapFilterComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [MapFilterComparison] {
            return [
                .equals,
                .notEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MapFilterComparison(rawValue: rawValue) ?? MapFilterComparison.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case administratorId = "AdministratorId"
        case email = "Email"
        case invitedAt = "InvitedAt"
        case masterId = "MasterId"
        case memberStatus = "MemberStatus"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let administratorId = self.administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encodeTimestamp(invitedAt, format: .dateTime, forKey: .invitedAt)
        }
        if let masterId = self.masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
        if let memberStatus = self.memberStatus {
            try encodeContainer.encode(memberStatus, forKey: .memberStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let administratorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
        let memberStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberStatus)
        memberStatus = memberStatusDecoded
        let invitedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension SecurityHubClientTypes {
    /// The details about a member account.
    public struct Member: Swift.Equatable {
        /// The Amazon Web Services account ID of the member account.
        public var accountId: Swift.String?
        /// The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.
        public var administratorId: Swift.String?
        /// The email address of the member account.
        public var email: Swift.String?
        /// A timestamp for the date and time when the invitation was sent to the member account.
        public var invitedAt: ClientRuntime.Date?
        /// This is replaced by AdministratorID. The Amazon Web Services account ID of the Security Hub administrator account associated with this member account.
        @available(*, deprecated, message: "This field is deprecated, use AdministratorId instead.")
        public var masterId: Swift.String?
        /// The status of the relationship between the member account and its administrator account. The status can have one of the following values:
        ///
        /// * CREATED - Indicates that the administrator account added the member account, but has not yet invited the member account.
        ///
        /// * INVITED - Indicates that the administrator account invited the member account. The member account has not yet responded to the invitation.
        ///
        /// * ENABLED - Indicates that the member account is currently active. For manually invited member accounts, indicates that the member account accepted the invitation.
        ///
        /// * REMOVED - Indicates that the administrator account disassociated the member account.
        ///
        /// * RESIGNED - Indicates that the member account disassociated themselves from the administrator account.
        ///
        /// * DELETED - Indicates that the administrator account deleted the member account.
        ///
        /// * ACCOUNT_SUSPENDED - Indicates that an organization account was suspended from Amazon Web Services at the same time that the administrator account tried to enable the organization account as a member account.
        public var memberStatus: Swift.String?
        /// The timestamp for the date and time when the member account was updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            accountId: Swift.String? = nil,
            administratorId: Swift.String? = nil,
            email: Swift.String? = nil,
            invitedAt: ClientRuntime.Date? = nil,
            masterId: Swift.String? = nil,
            memberStatus: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.administratorId = administratorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.memberStatus = memberStatus
            self.updatedAt = updatedAt
        }
    }

}

extension SecurityHubClientTypes.Network: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationDomain = "DestinationDomain"
        case destinationIpV4 = "DestinationIpV4"
        case destinationIpV6 = "DestinationIpV6"
        case destinationPort = "DestinationPort"
        case direction = "Direction"
        case openPortRange = "OpenPortRange"
        case `protocol` = "Protocol"
        case sourceDomain = "SourceDomain"
        case sourceIpV4 = "SourceIpV4"
        case sourceIpV6 = "SourceIpV6"
        case sourceMac = "SourceMac"
        case sourcePort = "SourcePort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationDomain = self.destinationDomain {
            try encodeContainer.encode(destinationDomain, forKey: .destinationDomain)
        }
        if let destinationIpV4 = self.destinationIpV4 {
            try encodeContainer.encode(destinationIpV4, forKey: .destinationIpV4)
        }
        if let destinationIpV6 = self.destinationIpV6 {
            try encodeContainer.encode(destinationIpV6, forKey: .destinationIpV6)
        }
        if destinationPort != 0 {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let direction = self.direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let openPortRange = self.openPortRange {
            try encodeContainer.encode(openPortRange, forKey: .openPortRange)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let sourceDomain = self.sourceDomain {
            try encodeContainer.encode(sourceDomain, forKey: .sourceDomain)
        }
        if let sourceIpV4 = self.sourceIpV4 {
            try encodeContainer.encode(sourceIpV4, forKey: .sourceIpV4)
        }
        if let sourceIpV6 = self.sourceIpV6 {
            try encodeContainer.encode(sourceIpV6, forKey: .sourceIpV6)
        }
        if let sourceMac = self.sourceMac {
            try encodeContainer.encode(sourceMac, forKey: .sourceMac)
        }
        if sourcePort != 0 {
            try encodeContainer.encode(sourcePort, forKey: .sourcePort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.NetworkDirection.self, forKey: .direction)
        direction = directionDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let openPortRangeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.PortRange.self, forKey: .openPortRange)
        openPortRange = openPortRangeDecoded
        let sourceIpV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIpV4)
        sourceIpV4 = sourceIpV4Decoded
        let sourceIpV6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceIpV6)
        sourceIpV6 = sourceIpV6Decoded
        let sourcePortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sourcePort) ?? 0
        sourcePort = sourcePortDecoded
        let sourceDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDomain)
        sourceDomain = sourceDomainDecoded
        let sourceMacDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceMac)
        sourceMac = sourceMacDecoded
        let destinationIpV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIpV4)
        destinationIpV4 = destinationIpV4Decoded
        let destinationIpV6Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIpV6)
        destinationIpV6 = destinationIpV6Decoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort) ?? 0
        destinationPort = destinationPortDecoded
        let destinationDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationDomain)
        destinationDomain = destinationDomainDecoded
    }
}

extension SecurityHubClientTypes {
    /// The details of network-related information about a finding.
    public struct Network: Swift.Equatable {
        /// The destination domain of network-related information about a finding.
        public var destinationDomain: Swift.String?
        /// The destination IPv4 address of network-related information about a finding.
        public var destinationIpV4: Swift.String?
        /// The destination IPv6 address of network-related information about a finding.
        public var destinationIpV6: Swift.String?
        /// The destination port of network-related information about a finding.
        public var destinationPort: Swift.Int
        /// The direction of network traffic associated with a finding.
        public var direction: SecurityHubClientTypes.NetworkDirection?
        /// The range of open ports that is present on the network.
        public var openPortRange: SecurityHubClientTypes.PortRange?
        /// The protocol of network-related information about a finding.
        public var `protocol`: Swift.String?
        /// The source domain of network-related information about a finding.
        public var sourceDomain: Swift.String?
        /// The source IPv4 address of network-related information about a finding.
        public var sourceIpV4: Swift.String?
        /// The source IPv6 address of network-related information about a finding.
        public var sourceIpV6: Swift.String?
        /// The source media access control (MAC) address of network-related information about a finding.
        public var sourceMac: Swift.String?
        /// The source port of network-related information about a finding.
        public var sourcePort: Swift.Int

        public init (
            destinationDomain: Swift.String? = nil,
            destinationIpV4: Swift.String? = nil,
            destinationIpV6: Swift.String? = nil,
            destinationPort: Swift.Int = 0,
            direction: SecurityHubClientTypes.NetworkDirection? = nil,
            openPortRange: SecurityHubClientTypes.PortRange? = nil,
            `protocol`: Swift.String? = nil,
            sourceDomain: Swift.String? = nil,
            sourceIpV4: Swift.String? = nil,
            sourceIpV6: Swift.String? = nil,
            sourceMac: Swift.String? = nil,
            sourcePort: Swift.Int = 0
        )
        {
            self.destinationDomain = destinationDomain
            self.destinationIpV4 = destinationIpV4
            self.destinationIpV6 = destinationIpV6
            self.destinationPort = destinationPort
            self.direction = direction
            self.openPortRange = openPortRange
            self.`protocol` = `protocol`
            self.sourceDomain = sourceDomain
            self.sourceIpV4 = sourceIpV4
            self.sourceIpV6 = sourceIpV6
            self.sourceMac = sourceMac
            self.sourcePort = sourcePort
        }
    }

}

extension SecurityHubClientTypes.NetworkConnectionAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "Blocked"
        case connectionDirection = "ConnectionDirection"
        case localPortDetails = "LocalPortDetails"
        case `protocol` = "Protocol"
        case remoteIpDetails = "RemoteIpDetails"
        case remotePortDetails = "RemotePortDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let connectionDirection = self.connectionDirection {
            try encodeContainer.encode(connectionDirection, forKey: .connectionDirection)
        }
        if let localPortDetails = self.localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let remotePortDetails = self.remotePortDetails {
            try encodeContainer.encode(remotePortDetails, forKey: .remotePortDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDirectionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionDirection)
        connectionDirection = connectionDirectionDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ActionRemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let remotePortDetailsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ActionRemotePortDetails.self, forKey: .remotePortDetails)
        remotePortDetails = remotePortDetailsDecoded
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ActionLocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let blockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blocked) ?? false
        blocked = blockedDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provided if ActionType is NETWORK_CONNECTION. It provides details about the attempted network connection that was detected.
    public struct NetworkConnectionAction: Swift.Equatable {
        /// Indicates whether the network connection attempt was blocked.
        public var blocked: Swift.Bool
        /// The direction of the network connection request (IN or OUT).
        public var connectionDirection: Swift.String?
        /// Information about the port on the EC2 instance.
        public var localPortDetails: SecurityHubClientTypes.ActionLocalPortDetails?
        /// The protocol used to make the network connection request.
        public var `protocol`: Swift.String?
        /// Information about the remote IP address that issued the network connection request.
        public var remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails?
        /// Information about the port on the remote IP address.
        public var remotePortDetails: SecurityHubClientTypes.ActionRemotePortDetails?

        public init (
            blocked: Swift.Bool = false,
            connectionDirection: Swift.String? = nil,
            localPortDetails: SecurityHubClientTypes.ActionLocalPortDetails? = nil,
            `protocol`: Swift.String? = nil,
            remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails? = nil,
            remotePortDetails: SecurityHubClientTypes.ActionRemotePortDetails? = nil
        )
        {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }
    }

}

extension SecurityHubClientTypes {
    public enum NetworkDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `in`
        case out
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkDirection] {
            return [
                .in,
                .out,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .in: return "IN"
            case .out: return "OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkDirection(rawValue: rawValue) ?? NetworkDirection.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.NetworkHeader: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case `protocol` = "Protocol"
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.NetworkPathComponentDetails.self, forKey: .destination)
        destination = destinationDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.NetworkPathComponentDetails.self, forKey: .source)
        source = sourceDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about a network path component that occurs before or after the current component.
    public struct NetworkHeader: Swift.Equatable {
        /// Information about the destination of the component.
        public var destination: SecurityHubClientTypes.NetworkPathComponentDetails?
        /// The protocol used for the component.
        public var `protocol`: Swift.String?
        /// Information about the origin of the component.
        public var source: SecurityHubClientTypes.NetworkPathComponentDetails?

        public init (
            destination: SecurityHubClientTypes.NetworkPathComponentDetails? = nil,
            `protocol`: Swift.String? = nil,
            source: SecurityHubClientTypes.NetworkPathComponentDetails? = nil
        )
        {
            self.destination = destination
            self.`protocol` = `protocol`
            self.source = source
        }
    }

}

extension SecurityHubClientTypes.NetworkPathComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentId = "ComponentId"
        case componentType = "ComponentType"
        case egress = "Egress"
        case ingress = "Ingress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentId = self.componentId {
            try encodeContainer.encode(componentId, forKey: .componentId)
        }
        if let componentType = self.componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let egress = self.egress {
            try encodeContainer.encode(egress, forKey: .egress)
        }
        if let ingress = self.ingress {
            try encodeContainer.encode(ingress, forKey: .ingress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentId)
        componentId = componentIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let egressDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.NetworkHeader.self, forKey: .egress)
        egress = egressDecoded
        let ingressDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.NetworkHeader.self, forKey: .ingress)
        ingress = ingressDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a network path component.
    public struct NetworkPathComponent: Swift.Equatable {
        /// The identifier of a component in the network path.
        public var componentId: Swift.String?
        /// The type of component.
        public var componentType: Swift.String?
        /// Information about the component that comes after the current component in the network path.
        public var egress: SecurityHubClientTypes.NetworkHeader?
        /// Information about the component that comes before the current node in the network path.
        public var ingress: SecurityHubClientTypes.NetworkHeader?

        public init (
            componentId: Swift.String? = nil,
            componentType: Swift.String? = nil,
            egress: SecurityHubClientTypes.NetworkHeader? = nil,
            ingress: SecurityHubClientTypes.NetworkHeader? = nil
        )
        {
            self.componentId = componentId
            self.componentType = componentType
            self.egress = egress
            self.ingress = ingress
        }
    }

}

extension SecurityHubClientTypes.NetworkPathComponentDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case portRanges = "PortRanges"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            var addressContainer = encodeContainer.nestedUnkeyedContainer(forKey: .address)
            for nonemptystring0 in address {
                try addressContainer.encode(nonemptystring0)
            }
        }
        if let portRanges = portRanges {
            var portRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portRanges)
            for portrange0 in portRanges {
                try portRangesContainer.encode(portrange0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .address)
        var addressDecoded0:[Swift.String]? = nil
        if let addressContainer = addressContainer {
            addressDecoded0 = [Swift.String]()
            for string0 in addressContainer {
                if let string0 = string0 {
                    addressDecoded0?.append(string0)
                }
            }
        }
        address = addressDecoded0
        let portRangesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.PortRange?].self, forKey: .portRanges)
        var portRangesDecoded0:[SecurityHubClientTypes.PortRange]? = nil
        if let portRangesContainer = portRangesContainer {
            portRangesDecoded0 = [SecurityHubClientTypes.PortRange]()
            for structure0 in portRangesContainer {
                if let structure0 = structure0 {
                    portRangesDecoded0?.append(structure0)
                }
            }
        }
        portRanges = portRangesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Information about the destination of the next component in the network path.
    public struct NetworkPathComponentDetails: Swift.Equatable {
        /// The IP addresses of the destination.
        public var address: [Swift.String]?
        /// A list of port ranges for the destination.
        public var portRanges: [SecurityHubClientTypes.PortRange]?

        public init (
            address: [Swift.String]? = nil,
            portRanges: [SecurityHubClientTypes.PortRange]? = nil
        )
        {
            self.address = address
            self.portRanges = portRanges
        }
    }

}

extension SecurityHubClientTypes.Note: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
        case updatedAt = "UpdatedAt"
        case updatedBy = "UpdatedBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension SecurityHubClientTypes {
    /// A user-defined note added to a finding.
    public struct Note: Swift.Equatable {
        /// The text of a note.
        /// This member is required.
        public var text: Swift.String?
        /// The timestamp of when the note was updated. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        /// This member is required.
        public var updatedAt: Swift.String?
        /// The principal that created a note.
        /// This member is required.
        public var updatedBy: Swift.String?

        public init (
            text: Swift.String? = nil,
            updatedAt: Swift.String? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.text = text
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension SecurityHubClientTypes.NoteUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
        case updatedBy = "UpdatedBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension SecurityHubClientTypes {
    /// The updated note.
    public struct NoteUpdate: Swift.Equatable {
        /// The updated note text.
        /// This member is required.
        public var text: Swift.String?
        /// The principal that updated the note.
        /// This member is required.
        public var updatedBy: Swift.String?

        public init (
            text: Swift.String? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.text = text
            self.updatedBy = updatedBy
        }
    }

}

extension SecurityHubClientTypes.NumberFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eq = "Eq"
        case gte = "Gte"
        case lte = "Lte"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if eq != 0.0 {
            try encodeContainer.encode(eq, forKey: .eq)
        }
        if gte != 0.0 {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if lte != 0.0 {
            try encodeContainer.encode(lte, forKey: .lte)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gteDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .gte) ?? 0.0
        gte = gteDecoded
        let lteDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lte) ?? 0.0
        lte = lteDecoded
        let eqDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .eq) ?? 0.0
        eq = eqDecoded
    }
}

extension SecurityHubClientTypes {
    /// A number filter for querying findings.
    public struct NumberFilter: Swift.Equatable {
        /// The equal-to condition to be applied to a single field when querying for findings.
        public var eq: Swift.Double
        /// The greater-than-equal condition to be applied to a single field when querying for findings.
        public var gte: Swift.Double
        /// The less-than-equal condition to be applied to a single field when querying for findings.
        public var lte: Swift.Double

        public init (
            eq: Swift.Double = 0.0,
            gte: Swift.Double = 0.0,
            lte: Swift.Double = 0.0
        )
        {
            self.eq = eq
            self.gte = gte
            self.lte = lte
        }
    }

}

extension SecurityHubClientTypes.Occurrences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells = "Cells"
        case lineRanges = "LineRanges"
        case offsetRanges = "OffsetRanges"
        case pages = "Pages"
        case records = "Records"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for cell0 in cells {
                try cellsContainer.encode(cell0)
            }
        }
        if let lineRanges = lineRanges {
            var lineRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineRanges)
            for range0 in lineRanges {
                try lineRangesContainer.encode(range0)
            }
        }
        if let offsetRanges = offsetRanges {
            var offsetRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .offsetRanges)
            for range0 in offsetRanges {
                try offsetRangesContainer.encode(range0)
            }
        }
        if let pages = pages {
            var pagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pages)
            for page0 in pages {
                try pagesContainer.encode(page0)
            }
        }
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for record0 in records {
                try recordsContainer.encode(record0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineRangesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Range?].self, forKey: .lineRanges)
        var lineRangesDecoded0:[SecurityHubClientTypes.Range]? = nil
        if let lineRangesContainer = lineRangesContainer {
            lineRangesDecoded0 = [SecurityHubClientTypes.Range]()
            for structure0 in lineRangesContainer {
                if let structure0 = structure0 {
                    lineRangesDecoded0?.append(structure0)
                }
            }
        }
        lineRanges = lineRangesDecoded0
        let offsetRangesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Range?].self, forKey: .offsetRanges)
        var offsetRangesDecoded0:[SecurityHubClientTypes.Range]? = nil
        if let offsetRangesContainer = offsetRangesContainer {
            offsetRangesDecoded0 = [SecurityHubClientTypes.Range]()
            for structure0 in offsetRangesContainer {
                if let structure0 = structure0 {
                    offsetRangesDecoded0?.append(structure0)
                }
            }
        }
        offsetRanges = offsetRangesDecoded0
        let pagesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Page?].self, forKey: .pages)
        var pagesDecoded0:[SecurityHubClientTypes.Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [SecurityHubClientTypes.Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
        let recordsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[SecurityHubClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [SecurityHubClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
        let cellsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Cell?].self, forKey: .cells)
        var cellsDecoded0:[SecurityHubClientTypes.Cell]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [SecurityHubClientTypes.Cell]()
            for structure0 in cellsContainer {
                if let structure0 = structure0 {
                    cellsDecoded0?.append(structure0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// The detected occurrences of sensitive data.
    public struct Occurrences: Swift.Equatable {
        /// Occurrences of sensitive data detected in Microsoft Excel workbooks, comma-separated value (CSV) files, or tab-separated value (TSV) files.
        public var cells: [SecurityHubClientTypes.Cell]?
        /// Occurrences of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.
        public var lineRanges: [SecurityHubClientTypes.Range]?
        /// Occurrences of sensitive data detected in a binary text file.
        public var offsetRanges: [SecurityHubClientTypes.Range]?
        /// Occurrences of sensitive data in an Adobe Portable Document Format (PDF) file.
        public var pages: [SecurityHubClientTypes.Page]?
        /// Occurrences of sensitive data in an Apache Avro object container or an Apache Parquet file.
        public var records: [SecurityHubClientTypes.Record]?

        public init (
            cells: [SecurityHubClientTypes.Cell]? = nil,
            lineRanges: [SecurityHubClientTypes.Range]? = nil,
            offsetRanges: [SecurityHubClientTypes.Range]? = nil,
            pages: [SecurityHubClientTypes.Page]? = nil,
            records: [SecurityHubClientTypes.Record]? = nil
        )
        {
            self.cells = cells
            self.lineRanges = lineRanges
            self.offsetRanges = offsetRanges
            self.pages = pages
            self.records = records
        }
    }

}

extension SecurityHubClientTypes.Page: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lineRange = "LineRange"
        case offsetRange = "OffsetRange"
        case pageNumber = "PageNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lineRange = self.lineRange {
            try encodeContainer.encode(lineRange, forKey: .lineRange)
        }
        if let offsetRange = self.offsetRange {
            try encodeContainer.encode(offsetRange, forKey: .offsetRange)
        }
        if pageNumber != 0 {
            try encodeContainer.encode(pageNumber, forKey: .pageNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageNumber) ?? 0
        pageNumber = pageNumberDecoded
        let lineRangeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Range.self, forKey: .lineRange)
        lineRange = lineRangeDecoded
        let offsetRangeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Range.self, forKey: .offsetRange)
        offsetRange = offsetRangeDecoded
    }
}

extension SecurityHubClientTypes {
    /// An occurrence of sensitive data in an Adobe Portable Document Format (PDF) file.
    public struct Page: Swift.Equatable {
        /// An occurrence of sensitive data detected in a non-binary text file or a Microsoft Word file. Non-binary text files include files such as HTML, XML, JSON, and TXT files.
        public var lineRange: SecurityHubClientTypes.Range?
        /// An occurrence of sensitive data detected in a binary text file.
        public var offsetRange: SecurityHubClientTypes.Range?
        /// The page number of the page that contains the sensitive data.
        public var pageNumber: Swift.Int

        public init (
            lineRange: SecurityHubClientTypes.Range? = nil,
            offsetRange: SecurityHubClientTypes.Range? = nil,
            pageNumber: Swift.Int = 0
        )
        {
            self.lineRange = lineRange
            self.offsetRange = offsetRange
            self.pageNumber = pageNumber
        }
    }

}

extension SecurityHubClientTypes {
    public enum Partition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case awsCn
        case awsUsGov
        case sdkUnknown(Swift.String)

        public static var allCases: [Partition] {
            return [
                .aws,
                .awsCn,
                .awsUsGov,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "aws"
            case .awsCn: return "aws-cn"
            case .awsUsGov: return "aws-us-gov"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Partition(rawValue: rawValue) ?? Partition.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.PatchSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedCount = "FailedCount"
        case id = "Id"
        case installedCount = "InstalledCount"
        case installedOtherCount = "InstalledOtherCount"
        case installedPendingReboot = "InstalledPendingReboot"
        case installedRejectedCount = "InstalledRejectedCount"
        case missingCount = "MissingCount"
        case operation = "Operation"
        case operationEndTime = "OperationEndTime"
        case operationStartTime = "OperationStartTime"
        case rebootOption = "RebootOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if failedCount != 0 {
            try encodeContainer.encode(failedCount, forKey: .failedCount)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if installedCount != 0 {
            try encodeContainer.encode(installedCount, forKey: .installedCount)
        }
        if installedOtherCount != 0 {
            try encodeContainer.encode(installedOtherCount, forKey: .installedOtherCount)
        }
        if installedPendingReboot != 0 {
            try encodeContainer.encode(installedPendingReboot, forKey: .installedPendingReboot)
        }
        if installedRejectedCount != 0 {
            try encodeContainer.encode(installedRejectedCount, forKey: .installedRejectedCount)
        }
        if missingCount != 0 {
            try encodeContainer.encode(missingCount, forKey: .missingCount)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let operationEndTime = self.operationEndTime {
            try encodeContainer.encode(operationEndTime, forKey: .operationEndTime)
        }
        if let operationStartTime = self.operationStartTime {
            try encodeContainer.encode(operationStartTime, forKey: .operationStartTime)
        }
        if let rebootOption = self.rebootOption {
            try encodeContainer.encode(rebootOption, forKey: .rebootOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let installedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .installedCount) ?? 0
        installedCount = installedCountDecoded
        let missingCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .missingCount) ?? 0
        missingCount = missingCountDecoded
        let failedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedCount) ?? 0
        failedCount = failedCountDecoded
        let installedOtherCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .installedOtherCount) ?? 0
        installedOtherCount = installedOtherCountDecoded
        let installedRejectedCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .installedRejectedCount) ?? 0
        installedRejectedCount = installedRejectedCountDecoded
        let installedPendingRebootDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .installedPendingReboot) ?? 0
        installedPendingReboot = installedPendingRebootDecoded
        let operationStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationStartTime)
        operationStartTime = operationStartTimeDecoded
        let operationEndTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationEndTime)
        operationEndTime = operationEndTimeDecoded
        let rebootOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rebootOption)
        rebootOption = rebootOptionDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides an overview of the patch compliance status for an instance against a selected compliance standard.
    public struct PatchSummary: Swift.Equatable {
        /// The number of patches from the compliance standard that failed to install.
        public var failedCount: Swift.Int
        /// The identifier of the compliance standard that was used to determine the patch compliance status.
        /// This member is required.
        public var id: Swift.String?
        /// The number of patches from the compliance standard that were installed successfully.
        public var installedCount: Swift.Int
        /// The number of installed patches that are not part of the compliance standard.
        public var installedOtherCount: Swift.Int
        /// The number of patches that were applied, but that require the instance to be rebooted in order to be marked as installed.
        public var installedPendingReboot: Swift.Int
        /// The number of patches that are installed but are also on a list of patches that the customer rejected.
        public var installedRejectedCount: Swift.Int
        /// The number of patches that are part of the compliance standard but are not installed. The count includes patches that failed to install.
        public var missingCount: Swift.Int
        /// The type of patch operation performed. For Patch Manager, the values are SCAN and INSTALL.
        public var operation: Swift.String?
        /// Indicates when the operation completed. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var operationEndTime: Swift.String?
        /// Indicates when the operation started. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var operationStartTime: Swift.String?
        /// The reboot option specified for the instance.
        public var rebootOption: Swift.String?

        public init (
            failedCount: Swift.Int = 0,
            id: Swift.String? = nil,
            installedCount: Swift.Int = 0,
            installedOtherCount: Swift.Int = 0,
            installedPendingReboot: Swift.Int = 0,
            installedRejectedCount: Swift.Int = 0,
            missingCount: Swift.Int = 0,
            operation: Swift.String? = nil,
            operationEndTime: Swift.String? = nil,
            operationStartTime: Swift.String? = nil,
            rebootOption: Swift.String? = nil
        )
        {
            self.failedCount = failedCount
            self.id = id
            self.installedCount = installedCount
            self.installedOtherCount = installedOtherCount
            self.installedPendingReboot = installedPendingReboot
            self.installedRejectedCount = installedRejectedCount
            self.missingCount = missingCount
            self.operation = operation
            self.operationEndTime = operationEndTime
            self.operationStartTime = operationStartTime
            self.rebootOption = rebootOption
        }
    }

}

extension SecurityHubClientTypes.PortProbeAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "Blocked"
        case portProbeDetails = "PortProbeDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let portProbeDetails = portProbeDetails {
            var portProbeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portProbeDetails)
            for portprobedetail0 in portProbeDetails {
                try portProbeDetailsContainer.encode(portprobedetail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portProbeDetailsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.PortProbeDetail?].self, forKey: .portProbeDetails)
        var portProbeDetailsDecoded0:[SecurityHubClientTypes.PortProbeDetail]? = nil
        if let portProbeDetailsContainer = portProbeDetailsContainer {
            portProbeDetailsDecoded0 = [SecurityHubClientTypes.PortProbeDetail]()
            for structure0 in portProbeDetailsContainer {
                if let structure0 = structure0 {
                    portProbeDetailsDecoded0?.append(structure0)
                }
            }
        }
        portProbeDetails = portProbeDetailsDecoded0
        let blockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blocked) ?? false
        blocked = blockedDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provided if ActionType is PORT_PROBE. It provides details about the attempted port probe that was detected.
    public struct PortProbeAction: Swift.Equatable {
        /// Indicates whether the port probe was blocked.
        public var blocked: Swift.Bool
        /// Information about the ports affected by the port probe.
        public var portProbeDetails: [SecurityHubClientTypes.PortProbeDetail]?

        public init (
            blocked: Swift.Bool = false,
            portProbeDetails: [SecurityHubClientTypes.PortProbeDetail]? = nil
        )
        {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }
    }

}

extension SecurityHubClientTypes.PortProbeDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case localIpDetails = "LocalIpDetails"
        case localPortDetails = "LocalPortDetails"
        case remoteIpDetails = "RemoteIpDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localIpDetails = self.localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = self.localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ActionLocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ActionLocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ActionRemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
    }
}

extension SecurityHubClientTypes {
    /// A port scan that was part of the port probe. For each scan, PortProbeDetails provides information about the local IP address and port that were scanned, and the remote IP address that the scan originated from.
    public struct PortProbeDetail: Swift.Equatable {
        /// Provides information about the IP address where the scanned port is located.
        public var localIpDetails: SecurityHubClientTypes.ActionLocalIpDetails?
        /// Provides information about the port that was scanned.
        public var localPortDetails: SecurityHubClientTypes.ActionLocalPortDetails?
        /// Provides information about the remote IP address that performed the scan.
        public var remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails?

        public init (
            localIpDetails: SecurityHubClientTypes.ActionLocalIpDetails? = nil,
            localPortDetails: SecurityHubClientTypes.ActionLocalPortDetails? = nil,
            remoteIpDetails: SecurityHubClientTypes.ActionRemoteIpDetails? = nil
        )
        {
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }
    }

}

extension SecurityHubClientTypes.PortRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case begin = "Begin"
        case end = "End"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if begin != 0 {
            try encodeContainer.encode(begin, forKey: .begin)
        }
        if end != 0 {
            try encodeContainer.encode(end, forKey: .end)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .begin) ?? 0
        begin = beginDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .end) ?? 0
        end = endDecoded
    }
}

extension SecurityHubClientTypes {
    /// A range of ports.
    public struct PortRange: Swift.Equatable {
        /// The first port in the port range.
        public var begin: Swift.Int
        /// The last port in the port range.
        public var end: Swift.Int

        public init (
            begin: Swift.Int = 0,
            end: Swift.Int = 0
        )
        {
            self.begin = begin
            self.end = end
        }
    }

}

extension SecurityHubClientTypes.PortRangeFromTo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from = "From"
        case to = "To"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if from != 0 {
            try encodeContainer.encode(from, forKey: .from)
        }
        if to != 0 {
            try encodeContainer.encode(to, forKey: .to)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .from) ?? 0
        from = fromDecoded
        let toDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .to) ?? 0
        to = toDecoded
    }
}

extension SecurityHubClientTypes {
    /// A range of ports.
    public struct PortRangeFromTo: Swift.Equatable {
        /// The first port in the port range.
        public var from: Swift.Int
        /// The last port in the port range.
        public var to: Swift.Int

        public init (
            from: Swift.Int = 0,
            to: Swift.Int = 0
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension SecurityHubClientTypes.ProcessDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchedAt = "LaunchedAt"
        case name = "Name"
        case parentPid = "ParentPid"
        case path = "Path"
        case pid = "Pid"
        case terminatedAt = "TerminatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchedAt = self.launchedAt {
            try encodeContainer.encode(launchedAt, forKey: .launchedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if parentPid != 0 {
            try encodeContainer.encode(parentPid, forKey: .parentPid)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if pid != 0 {
            try encodeContainer.encode(pid, forKey: .pid)
        }
        if let terminatedAt = self.terminatedAt {
            try encodeContainer.encode(terminatedAt, forKey: .terminatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let pidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pid) ?? 0
        pid = pidDecoded
        let parentPidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parentPid) ?? 0
        parentPid = parentPidDecoded
        let launchedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchedAt)
        launchedAt = launchedAtDecoded
        let terminatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .terminatedAt)
        terminatedAt = terminatedAtDecoded
    }
}

extension SecurityHubClientTypes {
    /// The details of process-related information about a finding.
    public struct ProcessDetails: Swift.Equatable {
        /// Indicates when the process was launched. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var launchedAt: Swift.String?
        /// The name of the process.
        public var name: Swift.String?
        /// The parent process ID.
        public var parentPid: Swift.Int
        /// The path to the process executable.
        public var path: Swift.String?
        /// The process ID.
        public var pid: Swift.Int
        /// Indicates when the process was terminated. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var terminatedAt: Swift.String?

        public init (
            launchedAt: Swift.String? = nil,
            name: Swift.String? = nil,
            parentPid: Swift.Int = 0,
            path: Swift.String? = nil,
            pid: Swift.Int = 0,
            terminatedAt: Swift.String? = nil
        )
        {
            self.launchedAt = launchedAt
            self.name = name
            self.parentPid = parentPid
            self.path = path
            self.pid = pid
            self.terminatedAt = terminatedAt
        }
    }

}

extension SecurityHubClientTypes.Product: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationUrl = "ActivationUrl"
        case categories = "Categories"
        case companyName = "CompanyName"
        case description = "Description"
        case integrationTypes = "IntegrationTypes"
        case marketplaceUrl = "MarketplaceUrl"
        case productArn = "ProductArn"
        case productName = "ProductName"
        case productSubscriptionResourcePolicy = "ProductSubscriptionResourcePolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationUrl = self.activationUrl {
            try encodeContainer.encode(activationUrl, forKey: .activationUrl)
        }
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for nonemptystring0 in categories {
                try categoriesContainer.encode(nonemptystring0)
            }
        }
        if let companyName = self.companyName {
            try encodeContainer.encode(companyName, forKey: .companyName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let integrationTypes = integrationTypes {
            var integrationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integrationTypes)
            for integrationtype0 in integrationTypes {
                try integrationTypesContainer.encode(integrationtype0.rawValue)
            }
        }
        if let marketplaceUrl = self.marketplaceUrl {
            try encodeContainer.encode(marketplaceUrl, forKey: .marketplaceUrl)
        }
        if let productArn = self.productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let productSubscriptionResourcePolicy = self.productSubscriptionResourcePolicy {
            try encodeContainer.encode(productSubscriptionResourcePolicy, forKey: .productSubscriptionResourcePolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productArn)
        productArn = productArnDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let companyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyName)
        companyName = companyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .categories)
        var categoriesDecoded0:[Swift.String]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [Swift.String]()
            for string0 in categoriesContainer {
                if let string0 = string0 {
                    categoriesDecoded0?.append(string0)
                }
            }
        }
        categories = categoriesDecoded0
        let integrationTypesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.IntegrationType?].self, forKey: .integrationTypes)
        var integrationTypesDecoded0:[SecurityHubClientTypes.IntegrationType]? = nil
        if let integrationTypesContainer = integrationTypesContainer {
            integrationTypesDecoded0 = [SecurityHubClientTypes.IntegrationType]()
            for enum0 in integrationTypesContainer {
                if let enum0 = enum0 {
                    integrationTypesDecoded0?.append(enum0)
                }
            }
        }
        integrationTypes = integrationTypesDecoded0
        let marketplaceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marketplaceUrl)
        marketplaceUrl = marketplaceUrlDecoded
        let activationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationUrl)
        activationUrl = activationUrlDecoded
        let productSubscriptionResourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productSubscriptionResourcePolicy)
        productSubscriptionResourcePolicy = productSubscriptionResourcePolicyDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains details about a product.
    public struct Product: Swift.Equatable {
        /// The URL to the service or product documentation about the integration with Security Hub, including how to activate the integration.
        public var activationUrl: Swift.String?
        /// The categories assigned to the product.
        public var categories: [Swift.String]?
        /// The name of the company that provides the product.
        public var companyName: Swift.String?
        /// A description of the product.
        public var description: Swift.String?
        /// The types of integration that the product supports. Available values are the following.
        ///
        /// * SEND_FINDINGS_TO_SECURITY_HUB - The integration sends findings to Security Hub.
        ///
        /// * RECEIVE_FINDINGS_FROM_SECURITY_HUB - The integration receives findings from Security Hub.
        ///
        /// * UPDATE_FINDINGS_IN_SECURITY_HUB - The integration does not send new findings to Security Hub, but does make updates to the findings that it receives from Security Hub.
        public var integrationTypes: [SecurityHubClientTypes.IntegrationType]?
        /// For integrations with Amazon Web Services services, the Amazon Web Services Console URL from which to activate the service. For integrations with third-party products, the Amazon Web Services Marketplace URL from which to subscribe to or purchase the product.
        public var marketplaceUrl: Swift.String?
        /// The ARN assigned to the product.
        /// This member is required.
        public var productArn: Swift.String?
        /// The name of the product.
        public var productName: Swift.String?
        /// The resource policy associated with the product.
        public var productSubscriptionResourcePolicy: Swift.String?

        public init (
            activationUrl: Swift.String? = nil,
            categories: [Swift.String]? = nil,
            companyName: Swift.String? = nil,
            description: Swift.String? = nil,
            integrationTypes: [SecurityHubClientTypes.IntegrationType]? = nil,
            marketplaceUrl: Swift.String? = nil,
            productArn: Swift.String? = nil,
            productName: Swift.String? = nil,
            productSubscriptionResourcePolicy: Swift.String? = nil
        )
        {
            self.activationUrl = activationUrl
            self.categories = categories
            self.companyName = companyName
            self.description = description
            self.integrationTypes = integrationTypes
            self.marketplaceUrl = marketplaceUrl
            self.productArn = productArn
            self.productName = productName
            self.productSubscriptionResourcePolicy = productSubscriptionResourcePolicy
        }
    }

}

extension SecurityHubClientTypes.Range: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case start = "Start"
        case startColumn = "StartColumn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if end != 0 {
            try encodeContainer.encode(end, forKey: .end)
        }
        if start != 0 {
            try encodeContainer.encode(start, forKey: .start)
        }
        if startColumn != 0 {
            try encodeContainer.encode(startColumn, forKey: .startColumn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .start) ?? 0
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .end) ?? 0
        end = endDecoded
        let startColumnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startColumn) ?? 0
        startColumn = startColumnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Identifies where the sensitive data begins and ends.
    public struct Range: Swift.Equatable {
        /// The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.
        public var end: Swift.Int
        /// The number of lines (for a line range) or characters (for an offset range) from the beginning of the file to the end of the sensitive data.
        public var start: Swift.Int
        /// In the line where the sensitive data starts, the column within the line where the sensitive data starts.
        public var startColumn: Swift.Int

        public init (
            end: Swift.Int = 0,
            start: Swift.Int = 0,
            startColumn: Swift.Int = 0
        )
        {
            self.end = end
            self.start = start
            self.startColumn = startColumn
        }
    }

}

extension SecurityHubClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension SecurityHubClientTypes {
    /// A recommendation on how to remediate the issue identified in a finding.
    public struct Recommendation: Swift.Equatable {
        /// Describes the recommended steps to take to remediate an issue identified in a finding.
        public var text: Swift.String?
        /// A URL to a page or site that contains information about how to remediate a finding.
        public var url: Swift.String?

        public init (
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }

}

extension SecurityHubClientTypes.Record: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jsonPath = "JsonPath"
        case recordIndex = "RecordIndex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = self.jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
        if recordIndex != 0 {
            try encodeContainer.encode(recordIndex, forKey: .recordIndex)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
        let recordIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordIndex) ?? 0
        recordIndex = recordIndexDecoded
    }
}

extension SecurityHubClientTypes {
    /// An occurrence of sensitive data in an Apache Avro object container or an Apache Parquet file.
    public struct Record: Swift.Equatable {
        /// The path, as a JSONPath expression, to the field in the record that contains the data. If the field name is longer than 20 characters, it is truncated. If the path is longer than 250 characters, it is truncated.
        public var jsonPath: Swift.String?
        /// The record index, starting from 0, for the record that contains the data.
        public var recordIndex: Swift.Int

        public init (
            jsonPath: Swift.String? = nil,
            recordIndex: Swift.Int = 0
        )
        {
            self.jsonPath = jsonPath
            self.recordIndex = recordIndex
        }
    }

}

extension SecurityHubClientTypes {
    public enum RecordState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordState] {
            return [
                .active,
                .archived,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordState(rawValue: rawValue) ?? RecordState.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.RelatedFinding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case productArn = "ProductArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let productArn = self.productArn {
            try encodeContainer.encode(productArn, forKey: .productArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productArn)
        productArn = productArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about a related finding.
    public struct RelatedFinding: Swift.Equatable {
        /// The product-generated identifier for a related finding.
        /// This member is required.
        public var id: Swift.String?
        /// The ARN of the product that generated a related finding.
        /// This member is required.
        public var productArn: Swift.String?

        public init (
            id: Swift.String? = nil,
            productArn: Swift.String? = nil
        )
        {
            self.id = id
            self.productArn = productArn
        }
    }

}

extension SecurityHubClientTypes.Remediation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendation = "Recommendation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Recommendation.self, forKey: .recommendation)
        recommendation = recommendationDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the remediation steps for a finding.
    public struct Remediation: Swift.Equatable {
        /// A recommendation on the steps to take to remediate the issue identified by a finding.
        public var recommendation: SecurityHubClientTypes.Recommendation?

        public init (
            recommendation: SecurityHubClientTypes.Recommendation? = nil
        )
        {
            self.recommendation = recommendation
        }
    }

}

extension SecurityHubClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataClassification = "DataClassification"
        case details = "Details"
        case id = "Id"
        case partition = "Partition"
        case region = "Region"
        case resourceRole = "ResourceRole"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataClassification = self.dataClassification {
            try encodeContainer.encode(dataClassification, forKey: .dataClassification)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = self.partition {
            try encodeContainer.encode(partition.rawValue, forKey: .partition)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceRole = self.resourceRole {
            try encodeContainer.encode(resourceRole, forKey: .resourceRole)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, fieldMap0) in tags {
                try tagsContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Partition.self, forKey: .partition)
        partition = partitionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceRole)
        resourceRole = resourceRoleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in tagsContainer {
                if let nonemptystring0 = nonemptystring0 {
                    tagsDecoded0?[key0] = nonemptystring0
                }
            }
        }
        tags = tagsDecoded0
        let dataClassificationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.DataClassificationDetails.self, forKey: .dataClassification)
        dataClassification = dataClassificationDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ResourceDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension SecurityHubClientTypes {
    /// A resource related to a finding.
    public struct Resource: Swift.Equatable {
        /// Contains information about sensitive data that was detected on the resource.
        public var dataClassification: SecurityHubClientTypes.DataClassificationDetails?
        /// Additional details about the resource related to a finding.
        public var details: SecurityHubClientTypes.ResourceDetails?
        /// The canonical identifier for the given resource type.
        /// This member is required.
        public var id: Swift.String?
        /// The canonical Amazon Web Services partition name that the Region is assigned to.
        public var partition: SecurityHubClientTypes.Partition?
        /// The canonical Amazon Web Services external Region name where this resource is located.
        public var region: Swift.String?
        /// Identifies the role of the resource in the finding. A resource is either the actor or target of the finding activity,
        public var resourceRole: Swift.String?
        /// A list of Amazon Web Services tags associated with a resource at the time the finding was processed.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the resource that details are provided for. If possible, set Type to one of the supported resource types. For example, if the resource is an EC2 instance, then set Type to AwsEc2Instance. If the resource does not match any of the provided types, then set Type to Other.
        /// This member is required.
        public var type: Swift.String?

        public init (
            dataClassification: SecurityHubClientTypes.DataClassificationDetails? = nil,
            details: SecurityHubClientTypes.ResourceDetails? = nil,
            id: Swift.String? = nil,
            partition: SecurityHubClientTypes.Partition? = nil,
            region: Swift.String? = nil,
            resourceRole: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.dataClassification = dataClassification
            self.details = details
            self.id = id
            self.partition = partition
            self.region = region
            self.resourceRole = resourceRole
            self.tags = tags
            self.type = type
        }
    }

}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request conflicts with an existing resource.
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SecurityHubClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsApiGatewayRestApi = "AwsApiGatewayRestApi"
        case awsApiGatewayStage = "AwsApiGatewayStage"
        case awsApiGatewayV2Api = "AwsApiGatewayV2Api"
        case awsApiGatewayV2Stage = "AwsApiGatewayV2Stage"
        case awsAutoScalingAutoScalingGroup = "AwsAutoScalingAutoScalingGroup"
        case awsAutoScalingLaunchConfiguration = "AwsAutoScalingLaunchConfiguration"
        case awsBackupBackupPlan = "AwsBackupBackupPlan"
        case awsBackupBackupVault = "AwsBackupBackupVault"
        case awsBackupRecoveryPoint = "AwsBackupRecoveryPoint"
        case awsCertificateManagerCertificate = "AwsCertificateManagerCertificate"
        case awsCloudFormationStack = "AwsCloudFormationStack"
        case awsCloudFrontDistribution = "AwsCloudFrontDistribution"
        case awsCloudTrailTrail = "AwsCloudTrailTrail"
        case awsCloudWatchAlarm = "AwsCloudWatchAlarm"
        case awsCodeBuildProject = "AwsCodeBuildProject"
        case awsDynamoDbTable = "AwsDynamoDbTable"
        case awsEc2Eip = "AwsEc2Eip"
        case awsEc2Instance = "AwsEc2Instance"
        case awsEc2LaunchTemplate = "AwsEc2LaunchTemplate"
        case awsEc2NetworkAcl = "AwsEc2NetworkAcl"
        case awsEc2NetworkInterface = "AwsEc2NetworkInterface"
        case awsEc2SecurityGroup = "AwsEc2SecurityGroup"
        case awsEc2Subnet = "AwsEc2Subnet"
        case awsEc2TransitGateway = "AwsEc2TransitGateway"
        case awsEc2Volume = "AwsEc2Volume"
        case awsEc2Vpc = "AwsEc2Vpc"
        case awsEc2VpcEndpointService = "AwsEc2VpcEndpointService"
        case awsEc2VpcPeeringConnection = "AwsEc2VpcPeeringConnection"
        case awsEc2VpnConnection = "AwsEc2VpnConnection"
        case awsEcrContainerImage = "AwsEcrContainerImage"
        case awsEcrRepository = "AwsEcrRepository"
        case awsEcsCluster = "AwsEcsCluster"
        case awsEcsContainer = "AwsEcsContainer"
        case awsEcsService = "AwsEcsService"
        case awsEcsTask = "AwsEcsTask"
        case awsEcsTaskDefinition = "AwsEcsTaskDefinition"
        case awsEfsAccessPoint = "AwsEfsAccessPoint"
        case awsEksCluster = "AwsEksCluster"
        case awsElasticBeanstalkEnvironment = "AwsElasticBeanstalkEnvironment"
        case awsElasticsearchDomain = "AwsElasticsearchDomain"
        case awsElbLoadBalancer = "AwsElbLoadBalancer"
        case awsElbv2LoadBalancer = "AwsElbv2LoadBalancer"
        case awsIamAccessKey = "AwsIamAccessKey"
        case awsIamGroup = "AwsIamGroup"
        case awsIamPolicy = "AwsIamPolicy"
        case awsIamRole = "AwsIamRole"
        case awsIamUser = "AwsIamUser"
        case awsKinesisStream = "AwsKinesisStream"
        case awsKmsKey = "AwsKmsKey"
        case awsLambdaFunction = "AwsLambdaFunction"
        case awsLambdaLayerVersion = "AwsLambdaLayerVersion"
        case awsNetworkFirewallFirewall = "AwsNetworkFirewallFirewall"
        case awsNetworkFirewallFirewallPolicy = "AwsNetworkFirewallFirewallPolicy"
        case awsNetworkFirewallRuleGroup = "AwsNetworkFirewallRuleGroup"
        case awsOpenSearchServiceDomain = "AwsOpenSearchServiceDomain"
        case awsRdsDbCluster = "AwsRdsDbCluster"
        case awsRdsDbClusterSnapshot = "AwsRdsDbClusterSnapshot"
        case awsRdsDbInstance = "AwsRdsDbInstance"
        case awsRdsDbSecurityGroup = "AwsRdsDbSecurityGroup"
        case awsRdsDbSnapshot = "AwsRdsDbSnapshot"
        case awsRdsEventSubscription = "AwsRdsEventSubscription"
        case awsRedshiftCluster = "AwsRedshiftCluster"
        case awsS3AccountPublicAccessBlock = "AwsS3AccountPublicAccessBlock"
        case awsS3Bucket = "AwsS3Bucket"
        case awsS3Object = "AwsS3Object"
        case awsSageMakerNotebookInstance = "AwsSageMakerNotebookInstance"
        case awsSecretsManagerSecret = "AwsSecretsManagerSecret"
        case awsSnsTopic = "AwsSnsTopic"
        case awsSqsQueue = "AwsSqsQueue"
        case awsSsmPatchCompliance = "AwsSsmPatchCompliance"
        case awsWafRateBasedRule = "AwsWafRateBasedRule"
        case awsWafRegionalRateBasedRule = "AwsWafRegionalRateBasedRule"
        case awsWafRegionalRule = "AwsWafRegionalRule"
        case awsWafRegionalRuleGroup = "AwsWafRegionalRuleGroup"
        case awsWafRegionalWebAcl = "AwsWafRegionalWebAcl"
        case awsWafRule = "AwsWafRule"
        case awsWafRuleGroup = "AwsWafRuleGroup"
        case awsWafWebAcl = "AwsWafWebAcl"
        case awsWafv2RuleGroup = "AwsWafv2RuleGroup"
        case awsWafv2WebAcl = "AwsWafv2WebAcl"
        case awsXrayEncryptionConfig = "AwsXrayEncryptionConfig"
        case container = "Container"
        case other = "Other"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsApiGatewayRestApi = self.awsApiGatewayRestApi {
            try encodeContainer.encode(awsApiGatewayRestApi, forKey: .awsApiGatewayRestApi)
        }
        if let awsApiGatewayStage = self.awsApiGatewayStage {
            try encodeContainer.encode(awsApiGatewayStage, forKey: .awsApiGatewayStage)
        }
        if let awsApiGatewayV2Api = self.awsApiGatewayV2Api {
            try encodeContainer.encode(awsApiGatewayV2Api, forKey: .awsApiGatewayV2Api)
        }
        if let awsApiGatewayV2Stage = self.awsApiGatewayV2Stage {
            try encodeContainer.encode(awsApiGatewayV2Stage, forKey: .awsApiGatewayV2Stage)
        }
        if let awsAutoScalingAutoScalingGroup = self.awsAutoScalingAutoScalingGroup {
            try encodeContainer.encode(awsAutoScalingAutoScalingGroup, forKey: .awsAutoScalingAutoScalingGroup)
        }
        if let awsAutoScalingLaunchConfiguration = self.awsAutoScalingLaunchConfiguration {
            try encodeContainer.encode(awsAutoScalingLaunchConfiguration, forKey: .awsAutoScalingLaunchConfiguration)
        }
        if let awsBackupBackupPlan = self.awsBackupBackupPlan {
            try encodeContainer.encode(awsBackupBackupPlan, forKey: .awsBackupBackupPlan)
        }
        if let awsBackupBackupVault = self.awsBackupBackupVault {
            try encodeContainer.encode(awsBackupBackupVault, forKey: .awsBackupBackupVault)
        }
        if let awsBackupRecoveryPoint = self.awsBackupRecoveryPoint {
            try encodeContainer.encode(awsBackupRecoveryPoint, forKey: .awsBackupRecoveryPoint)
        }
        if let awsCertificateManagerCertificate = self.awsCertificateManagerCertificate {
            try encodeContainer.encode(awsCertificateManagerCertificate, forKey: .awsCertificateManagerCertificate)
        }
        if let awsCloudFormationStack = self.awsCloudFormationStack {
            try encodeContainer.encode(awsCloudFormationStack, forKey: .awsCloudFormationStack)
        }
        if let awsCloudFrontDistribution = self.awsCloudFrontDistribution {
            try encodeContainer.encode(awsCloudFrontDistribution, forKey: .awsCloudFrontDistribution)
        }
        if let awsCloudTrailTrail = self.awsCloudTrailTrail {
            try encodeContainer.encode(awsCloudTrailTrail, forKey: .awsCloudTrailTrail)
        }
        if let awsCloudWatchAlarm = self.awsCloudWatchAlarm {
            try encodeContainer.encode(awsCloudWatchAlarm, forKey: .awsCloudWatchAlarm)
        }
        if let awsCodeBuildProject = self.awsCodeBuildProject {
            try encodeContainer.encode(awsCodeBuildProject, forKey: .awsCodeBuildProject)
        }
        if let awsDynamoDbTable = self.awsDynamoDbTable {
            try encodeContainer.encode(awsDynamoDbTable, forKey: .awsDynamoDbTable)
        }
        if let awsEc2Eip = self.awsEc2Eip {
            try encodeContainer.encode(awsEc2Eip, forKey: .awsEc2Eip)
        }
        if let awsEc2Instance = self.awsEc2Instance {
            try encodeContainer.encode(awsEc2Instance, forKey: .awsEc2Instance)
        }
        if let awsEc2LaunchTemplate = self.awsEc2LaunchTemplate {
            try encodeContainer.encode(awsEc2LaunchTemplate, forKey: .awsEc2LaunchTemplate)
        }
        if let awsEc2NetworkAcl = self.awsEc2NetworkAcl {
            try encodeContainer.encode(awsEc2NetworkAcl, forKey: .awsEc2NetworkAcl)
        }
        if let awsEc2NetworkInterface = self.awsEc2NetworkInterface {
            try encodeContainer.encode(awsEc2NetworkInterface, forKey: .awsEc2NetworkInterface)
        }
        if let awsEc2SecurityGroup = self.awsEc2SecurityGroup {
            try encodeContainer.encode(awsEc2SecurityGroup, forKey: .awsEc2SecurityGroup)
        }
        if let awsEc2Subnet = self.awsEc2Subnet {
            try encodeContainer.encode(awsEc2Subnet, forKey: .awsEc2Subnet)
        }
        if let awsEc2TransitGateway = self.awsEc2TransitGateway {
            try encodeContainer.encode(awsEc2TransitGateway, forKey: .awsEc2TransitGateway)
        }
        if let awsEc2Volume = self.awsEc2Volume {
            try encodeContainer.encode(awsEc2Volume, forKey: .awsEc2Volume)
        }
        if let awsEc2Vpc = self.awsEc2Vpc {
            try encodeContainer.encode(awsEc2Vpc, forKey: .awsEc2Vpc)
        }
        if let awsEc2VpcEndpointService = self.awsEc2VpcEndpointService {
            try encodeContainer.encode(awsEc2VpcEndpointService, forKey: .awsEc2VpcEndpointService)
        }
        if let awsEc2VpcPeeringConnection = self.awsEc2VpcPeeringConnection {
            try encodeContainer.encode(awsEc2VpcPeeringConnection, forKey: .awsEc2VpcPeeringConnection)
        }
        if let awsEc2VpnConnection = self.awsEc2VpnConnection {
            try encodeContainer.encode(awsEc2VpnConnection, forKey: .awsEc2VpnConnection)
        }
        if let awsEcrContainerImage = self.awsEcrContainerImage {
            try encodeContainer.encode(awsEcrContainerImage, forKey: .awsEcrContainerImage)
        }
        if let awsEcrRepository = self.awsEcrRepository {
            try encodeContainer.encode(awsEcrRepository, forKey: .awsEcrRepository)
        }
        if let awsEcsCluster = self.awsEcsCluster {
            try encodeContainer.encode(awsEcsCluster, forKey: .awsEcsCluster)
        }
        if let awsEcsContainer = self.awsEcsContainer {
            try encodeContainer.encode(awsEcsContainer, forKey: .awsEcsContainer)
        }
        if let awsEcsService = self.awsEcsService {
            try encodeContainer.encode(awsEcsService, forKey: .awsEcsService)
        }
        if let awsEcsTask = self.awsEcsTask {
            try encodeContainer.encode(awsEcsTask, forKey: .awsEcsTask)
        }
        if let awsEcsTaskDefinition = self.awsEcsTaskDefinition {
            try encodeContainer.encode(awsEcsTaskDefinition, forKey: .awsEcsTaskDefinition)
        }
        if let awsEfsAccessPoint = self.awsEfsAccessPoint {
            try encodeContainer.encode(awsEfsAccessPoint, forKey: .awsEfsAccessPoint)
        }
        if let awsEksCluster = self.awsEksCluster {
            try encodeContainer.encode(awsEksCluster, forKey: .awsEksCluster)
        }
        if let awsElasticBeanstalkEnvironment = self.awsElasticBeanstalkEnvironment {
            try encodeContainer.encode(awsElasticBeanstalkEnvironment, forKey: .awsElasticBeanstalkEnvironment)
        }
        if let awsElasticsearchDomain = self.awsElasticsearchDomain {
            try encodeContainer.encode(awsElasticsearchDomain, forKey: .awsElasticsearchDomain)
        }
        if let awsElbLoadBalancer = self.awsElbLoadBalancer {
            try encodeContainer.encode(awsElbLoadBalancer, forKey: .awsElbLoadBalancer)
        }
        if let awsElbv2LoadBalancer = self.awsElbv2LoadBalancer {
            try encodeContainer.encode(awsElbv2LoadBalancer, forKey: .awsElbv2LoadBalancer)
        }
        if let awsIamAccessKey = self.awsIamAccessKey {
            try encodeContainer.encode(awsIamAccessKey, forKey: .awsIamAccessKey)
        }
        if let awsIamGroup = self.awsIamGroup {
            try encodeContainer.encode(awsIamGroup, forKey: .awsIamGroup)
        }
        if let awsIamPolicy = self.awsIamPolicy {
            try encodeContainer.encode(awsIamPolicy, forKey: .awsIamPolicy)
        }
        if let awsIamRole = self.awsIamRole {
            try encodeContainer.encode(awsIamRole, forKey: .awsIamRole)
        }
        if let awsIamUser = self.awsIamUser {
            try encodeContainer.encode(awsIamUser, forKey: .awsIamUser)
        }
        if let awsKinesisStream = self.awsKinesisStream {
            try encodeContainer.encode(awsKinesisStream, forKey: .awsKinesisStream)
        }
        if let awsKmsKey = self.awsKmsKey {
            try encodeContainer.encode(awsKmsKey, forKey: .awsKmsKey)
        }
        if let awsLambdaFunction = self.awsLambdaFunction {
            try encodeContainer.encode(awsLambdaFunction, forKey: .awsLambdaFunction)
        }
        if let awsLambdaLayerVersion = self.awsLambdaLayerVersion {
            try encodeContainer.encode(awsLambdaLayerVersion, forKey: .awsLambdaLayerVersion)
        }
        if let awsNetworkFirewallFirewall = self.awsNetworkFirewallFirewall {
            try encodeContainer.encode(awsNetworkFirewallFirewall, forKey: .awsNetworkFirewallFirewall)
        }
        if let awsNetworkFirewallFirewallPolicy = self.awsNetworkFirewallFirewallPolicy {
            try encodeContainer.encode(awsNetworkFirewallFirewallPolicy, forKey: .awsNetworkFirewallFirewallPolicy)
        }
        if let awsNetworkFirewallRuleGroup = self.awsNetworkFirewallRuleGroup {
            try encodeContainer.encode(awsNetworkFirewallRuleGroup, forKey: .awsNetworkFirewallRuleGroup)
        }
        if let awsOpenSearchServiceDomain = self.awsOpenSearchServiceDomain {
            try encodeContainer.encode(awsOpenSearchServiceDomain, forKey: .awsOpenSearchServiceDomain)
        }
        if let awsRdsDbCluster = self.awsRdsDbCluster {
            try encodeContainer.encode(awsRdsDbCluster, forKey: .awsRdsDbCluster)
        }
        if let awsRdsDbClusterSnapshot = self.awsRdsDbClusterSnapshot {
            try encodeContainer.encode(awsRdsDbClusterSnapshot, forKey: .awsRdsDbClusterSnapshot)
        }
        if let awsRdsDbInstance = self.awsRdsDbInstance {
            try encodeContainer.encode(awsRdsDbInstance, forKey: .awsRdsDbInstance)
        }
        if let awsRdsDbSecurityGroup = self.awsRdsDbSecurityGroup {
            try encodeContainer.encode(awsRdsDbSecurityGroup, forKey: .awsRdsDbSecurityGroup)
        }
        if let awsRdsDbSnapshot = self.awsRdsDbSnapshot {
            try encodeContainer.encode(awsRdsDbSnapshot, forKey: .awsRdsDbSnapshot)
        }
        if let awsRdsEventSubscription = self.awsRdsEventSubscription {
            try encodeContainer.encode(awsRdsEventSubscription, forKey: .awsRdsEventSubscription)
        }
        if let awsRedshiftCluster = self.awsRedshiftCluster {
            try encodeContainer.encode(awsRedshiftCluster, forKey: .awsRedshiftCluster)
        }
        if let awsS3AccountPublicAccessBlock = self.awsS3AccountPublicAccessBlock {
            try encodeContainer.encode(awsS3AccountPublicAccessBlock, forKey: .awsS3AccountPublicAccessBlock)
        }
        if let awsS3Bucket = self.awsS3Bucket {
            try encodeContainer.encode(awsS3Bucket, forKey: .awsS3Bucket)
        }
        if let awsS3Object = self.awsS3Object {
            try encodeContainer.encode(awsS3Object, forKey: .awsS3Object)
        }
        if let awsSageMakerNotebookInstance = self.awsSageMakerNotebookInstance {
            try encodeContainer.encode(awsSageMakerNotebookInstance, forKey: .awsSageMakerNotebookInstance)
        }
        if let awsSecretsManagerSecret = self.awsSecretsManagerSecret {
            try encodeContainer.encode(awsSecretsManagerSecret, forKey: .awsSecretsManagerSecret)
        }
        if let awsSnsTopic = self.awsSnsTopic {
            try encodeContainer.encode(awsSnsTopic, forKey: .awsSnsTopic)
        }
        if let awsSqsQueue = self.awsSqsQueue {
            try encodeContainer.encode(awsSqsQueue, forKey: .awsSqsQueue)
        }
        if let awsSsmPatchCompliance = self.awsSsmPatchCompliance {
            try encodeContainer.encode(awsSsmPatchCompliance, forKey: .awsSsmPatchCompliance)
        }
        if let awsWafRateBasedRule = self.awsWafRateBasedRule {
            try encodeContainer.encode(awsWafRateBasedRule, forKey: .awsWafRateBasedRule)
        }
        if let awsWafRegionalRateBasedRule = self.awsWafRegionalRateBasedRule {
            try encodeContainer.encode(awsWafRegionalRateBasedRule, forKey: .awsWafRegionalRateBasedRule)
        }
        if let awsWafRegionalRule = self.awsWafRegionalRule {
            try encodeContainer.encode(awsWafRegionalRule, forKey: .awsWafRegionalRule)
        }
        if let awsWafRegionalRuleGroup = self.awsWafRegionalRuleGroup {
            try encodeContainer.encode(awsWafRegionalRuleGroup, forKey: .awsWafRegionalRuleGroup)
        }
        if let awsWafRegionalWebAcl = self.awsWafRegionalWebAcl {
            try encodeContainer.encode(awsWafRegionalWebAcl, forKey: .awsWafRegionalWebAcl)
        }
        if let awsWafRule = self.awsWafRule {
            try encodeContainer.encode(awsWafRule, forKey: .awsWafRule)
        }
        if let awsWafRuleGroup = self.awsWafRuleGroup {
            try encodeContainer.encode(awsWafRuleGroup, forKey: .awsWafRuleGroup)
        }
        if let awsWafWebAcl = self.awsWafWebAcl {
            try encodeContainer.encode(awsWafWebAcl, forKey: .awsWafWebAcl)
        }
        if let awsWafv2RuleGroup = self.awsWafv2RuleGroup {
            try encodeContainer.encode(awsWafv2RuleGroup, forKey: .awsWafv2RuleGroup)
        }
        if let awsWafv2WebAcl = self.awsWafv2WebAcl {
            try encodeContainer.encode(awsWafv2WebAcl, forKey: .awsWafv2WebAcl)
        }
        if let awsXrayEncryptionConfig = self.awsXrayEncryptionConfig {
            try encodeContainer.encode(awsXrayEncryptionConfig, forKey: .awsXrayEncryptionConfig)
        }
        if let container = self.container {
            try encodeContainer.encode(container, forKey: .container)
        }
        if let other = other {
            var otherContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .other)
            for (dictKey0, fieldMap0) in other {
                try otherContainer.encode(fieldMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAutoScalingAutoScalingGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails.self, forKey: .awsAutoScalingAutoScalingGroup)
        awsAutoScalingAutoScalingGroup = awsAutoScalingAutoScalingGroupDecoded
        let awsCodeBuildProjectDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCodeBuildProjectDetails.self, forKey: .awsCodeBuildProject)
        awsCodeBuildProject = awsCodeBuildProjectDecoded
        let awsCloudFrontDistributionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFrontDistributionDetails.self, forKey: .awsCloudFrontDistribution)
        awsCloudFrontDistribution = awsCloudFrontDistributionDecoded
        let awsEc2InstanceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2InstanceDetails.self, forKey: .awsEc2Instance)
        awsEc2Instance = awsEc2InstanceDecoded
        let awsEc2NetworkInterfaceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails.self, forKey: .awsEc2NetworkInterface)
        awsEc2NetworkInterface = awsEc2NetworkInterfaceDecoded
        let awsEc2SecurityGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2SecurityGroupDetails.self, forKey: .awsEc2SecurityGroup)
        awsEc2SecurityGroup = awsEc2SecurityGroupDecoded
        let awsEc2VolumeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2VolumeDetails.self, forKey: .awsEc2Volume)
        awsEc2Volume = awsEc2VolumeDecoded
        let awsEc2VpcDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2VpcDetails.self, forKey: .awsEc2Vpc)
        awsEc2Vpc = awsEc2VpcDecoded
        let awsEc2EipDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2EipDetails.self, forKey: .awsEc2Eip)
        awsEc2Eip = awsEc2EipDecoded
        let awsEc2SubnetDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2SubnetDetails.self, forKey: .awsEc2Subnet)
        awsEc2Subnet = awsEc2SubnetDecoded
        let awsEc2NetworkAclDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2NetworkAclDetails.self, forKey: .awsEc2NetworkAcl)
        awsEc2NetworkAcl = awsEc2NetworkAclDecoded
        let awsElbv2LoadBalancerDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbv2LoadBalancerDetails.self, forKey: .awsElbv2LoadBalancer)
        awsElbv2LoadBalancer = awsElbv2LoadBalancerDecoded
        let awsElasticBeanstalkEnvironmentDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails.self, forKey: .awsElasticBeanstalkEnvironment)
        awsElasticBeanstalkEnvironment = awsElasticBeanstalkEnvironmentDecoded
        let awsElasticsearchDomainDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElasticsearchDomainDetails.self, forKey: .awsElasticsearchDomain)
        awsElasticsearchDomain = awsElasticsearchDomainDecoded
        let awsS3BucketDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3BucketDetails.self, forKey: .awsS3Bucket)
        awsS3Bucket = awsS3BucketDecoded
        let awsS3AccountPublicAccessBlockDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails.self, forKey: .awsS3AccountPublicAccessBlock)
        awsS3AccountPublicAccessBlock = awsS3AccountPublicAccessBlockDecoded
        let awsS3ObjectDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsS3ObjectDetails.self, forKey: .awsS3Object)
        awsS3Object = awsS3ObjectDecoded
        let awsSecretsManagerSecretDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSecretsManagerSecretDetails.self, forKey: .awsSecretsManagerSecret)
        awsSecretsManagerSecret = awsSecretsManagerSecretDecoded
        let awsIamAccessKeyDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamAccessKeyDetails.self, forKey: .awsIamAccessKey)
        awsIamAccessKey = awsIamAccessKeyDecoded
        let awsIamUserDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamUserDetails.self, forKey: .awsIamUser)
        awsIamUser = awsIamUserDecoded
        let awsIamPolicyDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamPolicyDetails.self, forKey: .awsIamPolicy)
        awsIamPolicy = awsIamPolicyDecoded
        let awsApiGatewayV2StageDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayV2StageDetails.self, forKey: .awsApiGatewayV2Stage)
        awsApiGatewayV2Stage = awsApiGatewayV2StageDecoded
        let awsApiGatewayV2ApiDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayV2ApiDetails.self, forKey: .awsApiGatewayV2Api)
        awsApiGatewayV2Api = awsApiGatewayV2ApiDecoded
        let awsDynamoDbTableDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsDynamoDbTableDetails.self, forKey: .awsDynamoDbTable)
        awsDynamoDbTable = awsDynamoDbTableDecoded
        let awsApiGatewayStageDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayStageDetails.self, forKey: .awsApiGatewayStage)
        awsApiGatewayStage = awsApiGatewayStageDecoded
        let awsApiGatewayRestApiDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsApiGatewayRestApiDetails.self, forKey: .awsApiGatewayRestApi)
        awsApiGatewayRestApi = awsApiGatewayRestApiDecoded
        let awsCloudTrailTrailDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudTrailTrailDetails.self, forKey: .awsCloudTrailTrail)
        awsCloudTrailTrail = awsCloudTrailTrailDecoded
        let awsSsmPatchComplianceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSsmPatchComplianceDetails.self, forKey: .awsSsmPatchCompliance)
        awsSsmPatchCompliance = awsSsmPatchComplianceDecoded
        let awsCertificateManagerCertificateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCertificateManagerCertificateDetails.self, forKey: .awsCertificateManagerCertificate)
        awsCertificateManagerCertificate = awsCertificateManagerCertificateDecoded
        let awsRedshiftClusterDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRedshiftClusterDetails.self, forKey: .awsRedshiftCluster)
        awsRedshiftCluster = awsRedshiftClusterDecoded
        let awsElbLoadBalancerDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsElbLoadBalancerDetails.self, forKey: .awsElbLoadBalancer)
        awsElbLoadBalancer = awsElbLoadBalancerDecoded
        let awsIamGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamGroupDetails.self, forKey: .awsIamGroup)
        awsIamGroup = awsIamGroupDecoded
        let awsIamRoleDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsIamRoleDetails.self, forKey: .awsIamRole)
        awsIamRole = awsIamRoleDecoded
        let awsKmsKeyDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsKmsKeyDetails.self, forKey: .awsKmsKey)
        awsKmsKey = awsKmsKeyDecoded
        let awsLambdaFunctionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsLambdaFunctionDetails.self, forKey: .awsLambdaFunction)
        awsLambdaFunction = awsLambdaFunctionDecoded
        let awsLambdaLayerVersionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsLambdaLayerVersionDetails.self, forKey: .awsLambdaLayerVersion)
        awsLambdaLayerVersion = awsLambdaLayerVersionDecoded
        let awsRdsDbInstanceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbInstanceDetails.self, forKey: .awsRdsDbInstance)
        awsRdsDbInstance = awsRdsDbInstanceDecoded
        let awsSnsTopicDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSnsTopicDetails.self, forKey: .awsSnsTopic)
        awsSnsTopic = awsSnsTopicDecoded
        let awsSqsQueueDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSqsQueueDetails.self, forKey: .awsSqsQueue)
        awsSqsQueue = awsSqsQueueDecoded
        let awsWafWebAclDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafWebAclDetails.self, forKey: .awsWafWebAcl)
        awsWafWebAcl = awsWafWebAclDecoded
        let awsRdsDbSnapshotDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbSnapshotDetails.self, forKey: .awsRdsDbSnapshot)
        awsRdsDbSnapshot = awsRdsDbSnapshotDecoded
        let awsRdsDbClusterSnapshotDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails.self, forKey: .awsRdsDbClusterSnapshot)
        awsRdsDbClusterSnapshot = awsRdsDbClusterSnapshotDecoded
        let awsRdsDbClusterDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbClusterDetails.self, forKey: .awsRdsDbCluster)
        awsRdsDbCluster = awsRdsDbClusterDecoded
        let awsEcsClusterDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsClusterDetails.self, forKey: .awsEcsCluster)
        awsEcsCluster = awsEcsClusterDecoded
        let awsEcsContainerDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsContainerDetails.self, forKey: .awsEcsContainer)
        awsEcsContainer = awsEcsContainerDecoded
        let awsEcsTaskDefinitionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDefinitionDetails.self, forKey: .awsEcsTaskDefinition)
        awsEcsTaskDefinition = awsEcsTaskDefinitionDecoded
        let containerDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ContainerDetails.self, forKey: .container)
        container = containerDecoded
        let otherContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .other)
        var otherDecoded0: [Swift.String:Swift.String]? = nil
        if let otherContainer = otherContainer {
            otherDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in otherContainer {
                if let nonemptystring0 = nonemptystring0 {
                    otherDecoded0?[key0] = nonemptystring0
                }
            }
        }
        other = otherDecoded0
        let awsRdsEventSubscriptionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsEventSubscriptionDetails.self, forKey: .awsRdsEventSubscription)
        awsRdsEventSubscription = awsRdsEventSubscriptionDecoded
        let awsEcsServiceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsServiceDetails.self, forKey: .awsEcsService)
        awsEcsService = awsEcsServiceDecoded
        let awsAutoScalingLaunchConfigurationDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails.self, forKey: .awsAutoScalingLaunchConfiguration)
        awsAutoScalingLaunchConfiguration = awsAutoScalingLaunchConfigurationDecoded
        let awsEc2VpnConnectionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2VpnConnectionDetails.self, forKey: .awsEc2VpnConnection)
        awsEc2VpnConnection = awsEc2VpnConnectionDecoded
        let awsEcrContainerImageDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcrContainerImageDetails.self, forKey: .awsEcrContainerImage)
        awsEcrContainerImage = awsEcrContainerImageDecoded
        let awsOpenSearchServiceDomainDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails.self, forKey: .awsOpenSearchServiceDomain)
        awsOpenSearchServiceDomain = awsOpenSearchServiceDomainDecoded
        let awsEc2VpcEndpointServiceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails.self, forKey: .awsEc2VpcEndpointService)
        awsEc2VpcEndpointService = awsEc2VpcEndpointServiceDecoded
        let awsXrayEncryptionConfigDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsXrayEncryptionConfigDetails.self, forKey: .awsXrayEncryptionConfig)
        awsXrayEncryptionConfig = awsXrayEncryptionConfigDecoded
        let awsWafRateBasedRuleDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRateBasedRuleDetails.self, forKey: .awsWafRateBasedRule)
        awsWafRateBasedRule = awsWafRateBasedRuleDecoded
        let awsWafRegionalRateBasedRuleDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails.self, forKey: .awsWafRegionalRateBasedRule)
        awsWafRegionalRateBasedRule = awsWafRegionalRateBasedRuleDecoded
        let awsEcrRepositoryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcrRepositoryDetails.self, forKey: .awsEcrRepository)
        awsEcrRepository = awsEcrRepositoryDecoded
        let awsEksClusterDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEksClusterDetails.self, forKey: .awsEksCluster)
        awsEksCluster = awsEksClusterDecoded
        let awsNetworkFirewallFirewallPolicyDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails.self, forKey: .awsNetworkFirewallFirewallPolicy)
        awsNetworkFirewallFirewallPolicy = awsNetworkFirewallFirewallPolicyDecoded
        let awsNetworkFirewallFirewallDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails.self, forKey: .awsNetworkFirewallFirewall)
        awsNetworkFirewallFirewall = awsNetworkFirewallFirewallDecoded
        let awsNetworkFirewallRuleGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails.self, forKey: .awsNetworkFirewallRuleGroup)
        awsNetworkFirewallRuleGroup = awsNetworkFirewallRuleGroupDecoded
        let awsRdsDbSecurityGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails.self, forKey: .awsRdsDbSecurityGroup)
        awsRdsDbSecurityGroup = awsRdsDbSecurityGroupDecoded
        let awsKinesisStreamDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsKinesisStreamDetails.self, forKey: .awsKinesisStream)
        awsKinesisStream = awsKinesisStreamDecoded
        let awsEc2TransitGatewayDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2TransitGatewayDetails.self, forKey: .awsEc2TransitGateway)
        awsEc2TransitGateway = awsEc2TransitGatewayDecoded
        let awsEfsAccessPointDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEfsAccessPointDetails.self, forKey: .awsEfsAccessPoint)
        awsEfsAccessPoint = awsEfsAccessPointDecoded
        let awsCloudFormationStackDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudFormationStackDetails.self, forKey: .awsCloudFormationStack)
        awsCloudFormationStack = awsCloudFormationStackDecoded
        let awsCloudWatchAlarmDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsCloudWatchAlarmDetails.self, forKey: .awsCloudWatchAlarm)
        awsCloudWatchAlarm = awsCloudWatchAlarmDecoded
        let awsEc2VpcPeeringConnectionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails.self, forKey: .awsEc2VpcPeeringConnection)
        awsEc2VpcPeeringConnection = awsEc2VpcPeeringConnectionDecoded
        let awsWafRegionalRuleGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails.self, forKey: .awsWafRegionalRuleGroup)
        awsWafRegionalRuleGroup = awsWafRegionalRuleGroupDecoded
        let awsWafRegionalRuleDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRegionalRuleDetails.self, forKey: .awsWafRegionalRule)
        awsWafRegionalRule = awsWafRegionalRuleDecoded
        let awsWafRegionalWebAclDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRegionalWebAclDetails.self, forKey: .awsWafRegionalWebAcl)
        awsWafRegionalWebAcl = awsWafRegionalWebAclDecoded
        let awsWafRuleDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRuleDetails.self, forKey: .awsWafRule)
        awsWafRule = awsWafRuleDecoded
        let awsWafRuleGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafRuleGroupDetails.self, forKey: .awsWafRuleGroup)
        awsWafRuleGroup = awsWafRuleGroupDecoded
        let awsEcsTaskDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEcsTaskDetails.self, forKey: .awsEcsTask)
        awsEcsTask = awsEcsTaskDecoded
        let awsBackupBackupVaultDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupBackupVaultDetails.self, forKey: .awsBackupBackupVault)
        awsBackupBackupVault = awsBackupBackupVaultDecoded
        let awsBackupBackupPlanDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupBackupPlanDetails.self, forKey: .awsBackupBackupPlan)
        awsBackupBackupPlan = awsBackupBackupPlanDecoded
        let awsBackupRecoveryPointDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsBackupRecoveryPointDetails.self, forKey: .awsBackupRecoveryPoint)
        awsBackupRecoveryPoint = awsBackupRecoveryPointDecoded
        let awsEc2LaunchTemplateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsEc2LaunchTemplateDetails.self, forKey: .awsEc2LaunchTemplate)
        awsEc2LaunchTemplate = awsEc2LaunchTemplateDecoded
        let awsSageMakerNotebookInstanceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails.self, forKey: .awsSageMakerNotebookInstance)
        awsSageMakerNotebookInstance = awsSageMakerNotebookInstanceDecoded
        let awsWafv2WebAclDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2WebAclDetails.self, forKey: .awsWafv2WebAcl)
        awsWafv2WebAcl = awsWafv2WebAclDecoded
        let awsWafv2RuleGroupDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsWafv2RuleGroupDetails.self, forKey: .awsWafv2RuleGroup)
        awsWafv2RuleGroup = awsWafv2RuleGroupDecoded
    }
}

extension SecurityHubClientTypes {
    /// Additional details about a resource related to a finding. To provide the details, use the object that corresponds to the resource type. For example, if the resource type is AwsEc2Instance, then you use the AwsEc2Instance object to provide the details. If the type-specific object does not contain all of the fields you want to populate, then you use the Other object to populate those additional fields. You also use the Other object to populate the details when the selected type does not have a corresponding object.
    public struct ResourceDetails: Swift.Equatable {
        /// Provides information about a REST API in version 1 of Amazon API Gateway.
        public var awsApiGatewayRestApi: SecurityHubClientTypes.AwsApiGatewayRestApiDetails?
        /// Provides information about a version 1 Amazon API Gateway stage.
        public var awsApiGatewayStage: SecurityHubClientTypes.AwsApiGatewayStageDetails?
        /// Provides information about a version 2 API in Amazon API Gateway.
        public var awsApiGatewayV2Api: SecurityHubClientTypes.AwsApiGatewayV2ApiDetails?
        /// Provides information about a version 2 stage for Amazon API Gateway.
        public var awsApiGatewayV2Stage: SecurityHubClientTypes.AwsApiGatewayV2StageDetails?
        /// Details for an autoscaling group.
        public var awsAutoScalingAutoScalingGroup: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails?
        /// Provides details about a launch configuration.
        public var awsAutoScalingLaunchConfiguration: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails?
        /// Provides details about an Backup backup plan.
        public var awsBackupBackupPlan: SecurityHubClientTypes.AwsBackupBackupPlanDetails?
        /// Provides details about an Backup backup vault.
        public var awsBackupBackupVault: SecurityHubClientTypes.AwsBackupBackupVaultDetails?
        /// Provides details about an Backup backup, or recovery point.
        public var awsBackupRecoveryPoint: SecurityHubClientTypes.AwsBackupRecoveryPointDetails?
        /// Provides details about an Certificate Manager certificate.
        public var awsCertificateManagerCertificate: SecurityHubClientTypes.AwsCertificateManagerCertificateDetails?
        /// Details about an CloudFormation stack. A stack is a collection of Amazon Web Services resources that you can manage as a single unit.
        public var awsCloudFormationStack: SecurityHubClientTypes.AwsCloudFormationStackDetails?
        /// Details about a CloudFront distribution.
        public var awsCloudFrontDistribution: SecurityHubClientTypes.AwsCloudFrontDistributionDetails?
        /// Provides details about a CloudTrail trail.
        public var awsCloudTrailTrail: SecurityHubClientTypes.AwsCloudTrailTrailDetails?
        /// Details about an Amazon CloudWatch alarm. An alarm allows you to monitor and receive alerts about your Amazon Web Services resources and applications across multiple Regions.
        public var awsCloudWatchAlarm: SecurityHubClientTypes.AwsCloudWatchAlarmDetails?
        /// Details for an CodeBuild project.
        public var awsCodeBuildProject: SecurityHubClientTypes.AwsCodeBuildProjectDetails?
        /// Details about a DynamoDB table.
        public var awsDynamoDbTable: SecurityHubClientTypes.AwsDynamoDbTableDetails?
        /// Details about an Elastic IP address.
        public var awsEc2Eip: SecurityHubClientTypes.AwsEc2EipDetails?
        /// Details about an EC2 instance related to a finding.
        public var awsEc2Instance: SecurityHubClientTypes.AwsEc2InstanceDetails?
        /// Specifies the properties for creating an Amazon Elastic Compute Cloud (Amazon EC2) launch template.
        public var awsEc2LaunchTemplate: SecurityHubClientTypes.AwsEc2LaunchTemplateDetails?
        /// Details about an EC2 network access control list (ACL).
        public var awsEc2NetworkAcl: SecurityHubClientTypes.AwsEc2NetworkAclDetails?
        /// Details for an EC2 network interface.
        public var awsEc2NetworkInterface: SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails?
        /// Details for an EC2 security group.
        public var awsEc2SecurityGroup: SecurityHubClientTypes.AwsEc2SecurityGroupDetails?
        /// Details about a subnet in Amazon EC2.
        public var awsEc2Subnet: SecurityHubClientTypes.AwsEc2SubnetDetails?
        /// Details about an Amazon EC2 transit gateway that interconnects your virtual private clouds (VPC) and on-premises networks.
        public var awsEc2TransitGateway: SecurityHubClientTypes.AwsEc2TransitGatewayDetails?
        /// Details for an Amazon EC2 volume.
        public var awsEc2Volume: SecurityHubClientTypes.AwsEc2VolumeDetails?
        /// Details for an Amazon EC2 VPC.
        public var awsEc2Vpc: SecurityHubClientTypes.AwsEc2VpcDetails?
        /// Details about the service configuration for a VPC endpoint service.
        public var awsEc2VpcEndpointService: SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails?
        /// Details about an Amazon EC2 VPC peering connection. A VPC peering connection is a networking connection between two VPCs that enables you to route traffic between them privately.
        public var awsEc2VpcPeeringConnection: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails?
        /// Details about an Amazon EC2 VPN connection.
        public var awsEc2VpnConnection: SecurityHubClientTypes.AwsEc2VpnConnectionDetails?
        /// Information about an Amazon ECR image.
        public var awsEcrContainerImage: SecurityHubClientTypes.AwsEcrContainerImageDetails?
        /// Information about an Amazon Elastic Container Registry repository.
        public var awsEcrRepository: SecurityHubClientTypes.AwsEcrRepositoryDetails?
        /// Details about an Amazon ECS cluster.
        public var awsEcsCluster: SecurityHubClientTypes.AwsEcsClusterDetails?
        /// Provides information about a Docker container that's part of a task.
        public var awsEcsContainer: SecurityHubClientTypes.AwsEcsContainerDetails?
        /// Details about a service within an ECS cluster.
        public var awsEcsService: SecurityHubClientTypes.AwsEcsServiceDetails?
        /// Details about a task in a cluster.
        public var awsEcsTask: SecurityHubClientTypes.AwsEcsTaskDetails?
        /// Details about a task definition. A task definition describes the container and volume definitions of an Amazon Elastic Container Service task.
        public var awsEcsTaskDefinition: SecurityHubClientTypes.AwsEcsTaskDefinitionDetails?
        /// Details about an Amazon EFS access point. An access point is an application-specific view into an EFS file system that applies an operating system user and group, and a file system path, to any file system request made through the access point.
        public var awsEfsAccessPoint: SecurityHubClientTypes.AwsEfsAccessPointDetails?
        /// Details about an Amazon EKS cluster.
        public var awsEksCluster: SecurityHubClientTypes.AwsEksClusterDetails?
        /// Details about an Elastic Beanstalk environment.
        public var awsElasticBeanstalkEnvironment: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails?
        /// Details for an Elasticsearch domain.
        public var awsElasticsearchDomain: SecurityHubClientTypes.AwsElasticsearchDomainDetails?
        /// Contains details about a Classic Load Balancer.
        public var awsElbLoadBalancer: SecurityHubClientTypes.AwsElbLoadBalancerDetails?
        /// Details about a load balancer.
        public var awsElbv2LoadBalancer: SecurityHubClientTypes.AwsElbv2LoadBalancerDetails?
        /// Details about an IAM access key related to a finding.
        public var awsIamAccessKey: SecurityHubClientTypes.AwsIamAccessKeyDetails?
        /// Contains details about an IAM group.
        public var awsIamGroup: SecurityHubClientTypes.AwsIamGroupDetails?
        /// Details about an IAM permissions policy.
        public var awsIamPolicy: SecurityHubClientTypes.AwsIamPolicyDetails?
        /// Details about an IAM role.
        public var awsIamRole: SecurityHubClientTypes.AwsIamRoleDetails?
        /// Details about an IAM user.
        public var awsIamUser: SecurityHubClientTypes.AwsIamUserDetails?
        /// Details about an Amazon Kinesis data stream.
        public var awsKinesisStream: SecurityHubClientTypes.AwsKinesisStreamDetails?
        /// Details about an KMS key.
        public var awsKmsKey: SecurityHubClientTypes.AwsKmsKeyDetails?
        /// Details about a Lambda function.
        public var awsLambdaFunction: SecurityHubClientTypes.AwsLambdaFunctionDetails?
        /// Details for a Lambda layer version.
        public var awsLambdaLayerVersion: SecurityHubClientTypes.AwsLambdaLayerVersionDetails?
        /// Details about an Network Firewall firewall.
        public var awsNetworkFirewallFirewall: SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails?
        /// Details about an Network Firewall firewall policy.
        public var awsNetworkFirewallFirewallPolicy: SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails?
        /// Details about an Network Firewall rule group.
        public var awsNetworkFirewallRuleGroup: SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails?
        /// Details about an Amazon OpenSearch Service domain.
        public var awsOpenSearchServiceDomain: SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails?
        /// Details about an Amazon RDS database cluster.
        public var awsRdsDbCluster: SecurityHubClientTypes.AwsRdsDbClusterDetails?
        /// Details about an Amazon RDS database cluster snapshot.
        public var awsRdsDbClusterSnapshot: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails?
        /// Details about an Amazon RDS database instance.
        public var awsRdsDbInstance: SecurityHubClientTypes.AwsRdsDbInstanceDetails?
        /// Details about an Amazon RDS DB security group.
        public var awsRdsDbSecurityGroup: SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails?
        /// Details about an Amazon RDS database snapshot.
        public var awsRdsDbSnapshot: SecurityHubClientTypes.AwsRdsDbSnapshotDetails?
        /// Details about an RDS event notification subscription.
        public var awsRdsEventSubscription: SecurityHubClientTypes.AwsRdsEventSubscriptionDetails?
        /// Contains details about an Amazon Redshift cluster.
        public var awsRedshiftCluster: SecurityHubClientTypes.AwsRedshiftClusterDetails?
        /// Details about the Amazon S3 Public Access Block configuration for an account.
        public var awsS3AccountPublicAccessBlock: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails?
        /// Details about an S3 bucket related to a finding.
        public var awsS3Bucket: SecurityHubClientTypes.AwsS3BucketDetails?
        /// Details about an S3 object related to a finding.
        public var awsS3Object: SecurityHubClientTypes.AwsS3ObjectDetails?
        /// Provides details about an Amazon SageMaker notebook instance.
        public var awsSageMakerNotebookInstance: SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails?
        /// Details about a Secrets Manager secret.
        public var awsSecretsManagerSecret: SecurityHubClientTypes.AwsSecretsManagerSecretDetails?
        /// Details about an SNS topic.
        public var awsSnsTopic: SecurityHubClientTypes.AwsSnsTopicDetails?
        /// Details about an SQS queue.
        public var awsSqsQueue: SecurityHubClientTypes.AwsSqsQueueDetails?
        /// Provides information about the state of a patch on an instance based on the patch baseline that was used to patch the instance.
        public var awsSsmPatchCompliance: SecurityHubClientTypes.AwsSsmPatchComplianceDetails?
        /// Details about a rate-based rule for global resources.
        public var awsWafRateBasedRule: SecurityHubClientTypes.AwsWafRateBasedRuleDetails?
        /// Details about a rate-based rule for Regional resources.
        public var awsWafRegionalRateBasedRule: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails?
        /// Details about an WAF rule for Regional resources.
        public var awsWafRegionalRule: SecurityHubClientTypes.AwsWafRegionalRuleDetails?
        /// Details about an WAF rule group for Regional resources.
        public var awsWafRegionalRuleGroup: SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails?
        /// Details about an WAF web access control list (web ACL) for Regional resources.
        public var awsWafRegionalWebAcl: SecurityHubClientTypes.AwsWafRegionalWebAclDetails?
        /// Details about an WAF rule for global resources.
        public var awsWafRule: SecurityHubClientTypes.AwsWafRuleDetails?
        /// Details about an WAF rule group for global resources.
        public var awsWafRuleGroup: SecurityHubClientTypes.AwsWafRuleGroupDetails?
        /// Details for an WAF web ACL.
        public var awsWafWebAcl: SecurityHubClientTypes.AwsWafWebAclDetails?
        /// Details about an WAFv2 rule group.
        public var awsWafv2RuleGroup: SecurityHubClientTypes.AwsWafv2RuleGroupDetails?
        /// Details about an WAFv2 web Access Control List (ACL).
        public var awsWafv2WebAcl: SecurityHubClientTypes.AwsWafv2WebAclDetails?
        /// Information about the encryption configuration for X-Ray.
        public var awsXrayEncryptionConfig: SecurityHubClientTypes.AwsXrayEncryptionConfigDetails?
        /// Details about a container resource related to a finding.
        public var container: SecurityHubClientTypes.ContainerDetails?
        /// Details about a resource that are not available in a type-specific details object. Use the Other object in the following cases.
        ///
        /// * The type-specific object does not contain all of the fields that you want to populate. In this case, first use the type-specific object to populate those fields. Use the Other object to populate the fields that are missing from the type-specific object.
        ///
        /// * The resource type does not have a corresponding object. This includes resources for which the type is Other.
        public var other: [Swift.String:Swift.String]?

        public init (
            awsApiGatewayRestApi: SecurityHubClientTypes.AwsApiGatewayRestApiDetails? = nil,
            awsApiGatewayStage: SecurityHubClientTypes.AwsApiGatewayStageDetails? = nil,
            awsApiGatewayV2Api: SecurityHubClientTypes.AwsApiGatewayV2ApiDetails? = nil,
            awsApiGatewayV2Stage: SecurityHubClientTypes.AwsApiGatewayV2StageDetails? = nil,
            awsAutoScalingAutoScalingGroup: SecurityHubClientTypes.AwsAutoScalingAutoScalingGroupDetails? = nil,
            awsAutoScalingLaunchConfiguration: SecurityHubClientTypes.AwsAutoScalingLaunchConfigurationDetails? = nil,
            awsBackupBackupPlan: SecurityHubClientTypes.AwsBackupBackupPlanDetails? = nil,
            awsBackupBackupVault: SecurityHubClientTypes.AwsBackupBackupVaultDetails? = nil,
            awsBackupRecoveryPoint: SecurityHubClientTypes.AwsBackupRecoveryPointDetails? = nil,
            awsCertificateManagerCertificate: SecurityHubClientTypes.AwsCertificateManagerCertificateDetails? = nil,
            awsCloudFormationStack: SecurityHubClientTypes.AwsCloudFormationStackDetails? = nil,
            awsCloudFrontDistribution: SecurityHubClientTypes.AwsCloudFrontDistributionDetails? = nil,
            awsCloudTrailTrail: SecurityHubClientTypes.AwsCloudTrailTrailDetails? = nil,
            awsCloudWatchAlarm: SecurityHubClientTypes.AwsCloudWatchAlarmDetails? = nil,
            awsCodeBuildProject: SecurityHubClientTypes.AwsCodeBuildProjectDetails? = nil,
            awsDynamoDbTable: SecurityHubClientTypes.AwsDynamoDbTableDetails? = nil,
            awsEc2Eip: SecurityHubClientTypes.AwsEc2EipDetails? = nil,
            awsEc2Instance: SecurityHubClientTypes.AwsEc2InstanceDetails? = nil,
            awsEc2LaunchTemplate: SecurityHubClientTypes.AwsEc2LaunchTemplateDetails? = nil,
            awsEc2NetworkAcl: SecurityHubClientTypes.AwsEc2NetworkAclDetails? = nil,
            awsEc2NetworkInterface: SecurityHubClientTypes.AwsEc2NetworkInterfaceDetails? = nil,
            awsEc2SecurityGroup: SecurityHubClientTypes.AwsEc2SecurityGroupDetails? = nil,
            awsEc2Subnet: SecurityHubClientTypes.AwsEc2SubnetDetails? = nil,
            awsEc2TransitGateway: SecurityHubClientTypes.AwsEc2TransitGatewayDetails? = nil,
            awsEc2Volume: SecurityHubClientTypes.AwsEc2VolumeDetails? = nil,
            awsEc2Vpc: SecurityHubClientTypes.AwsEc2VpcDetails? = nil,
            awsEc2VpcEndpointService: SecurityHubClientTypes.AwsEc2VpcEndpointServiceDetails? = nil,
            awsEc2VpcPeeringConnection: SecurityHubClientTypes.AwsEc2VpcPeeringConnectionDetails? = nil,
            awsEc2VpnConnection: SecurityHubClientTypes.AwsEc2VpnConnectionDetails? = nil,
            awsEcrContainerImage: SecurityHubClientTypes.AwsEcrContainerImageDetails? = nil,
            awsEcrRepository: SecurityHubClientTypes.AwsEcrRepositoryDetails? = nil,
            awsEcsCluster: SecurityHubClientTypes.AwsEcsClusterDetails? = nil,
            awsEcsContainer: SecurityHubClientTypes.AwsEcsContainerDetails? = nil,
            awsEcsService: SecurityHubClientTypes.AwsEcsServiceDetails? = nil,
            awsEcsTask: SecurityHubClientTypes.AwsEcsTaskDetails? = nil,
            awsEcsTaskDefinition: SecurityHubClientTypes.AwsEcsTaskDefinitionDetails? = nil,
            awsEfsAccessPoint: SecurityHubClientTypes.AwsEfsAccessPointDetails? = nil,
            awsEksCluster: SecurityHubClientTypes.AwsEksClusterDetails? = nil,
            awsElasticBeanstalkEnvironment: SecurityHubClientTypes.AwsElasticBeanstalkEnvironmentDetails? = nil,
            awsElasticsearchDomain: SecurityHubClientTypes.AwsElasticsearchDomainDetails? = nil,
            awsElbLoadBalancer: SecurityHubClientTypes.AwsElbLoadBalancerDetails? = nil,
            awsElbv2LoadBalancer: SecurityHubClientTypes.AwsElbv2LoadBalancerDetails? = nil,
            awsIamAccessKey: SecurityHubClientTypes.AwsIamAccessKeyDetails? = nil,
            awsIamGroup: SecurityHubClientTypes.AwsIamGroupDetails? = nil,
            awsIamPolicy: SecurityHubClientTypes.AwsIamPolicyDetails? = nil,
            awsIamRole: SecurityHubClientTypes.AwsIamRoleDetails? = nil,
            awsIamUser: SecurityHubClientTypes.AwsIamUserDetails? = nil,
            awsKinesisStream: SecurityHubClientTypes.AwsKinesisStreamDetails? = nil,
            awsKmsKey: SecurityHubClientTypes.AwsKmsKeyDetails? = nil,
            awsLambdaFunction: SecurityHubClientTypes.AwsLambdaFunctionDetails? = nil,
            awsLambdaLayerVersion: SecurityHubClientTypes.AwsLambdaLayerVersionDetails? = nil,
            awsNetworkFirewallFirewall: SecurityHubClientTypes.AwsNetworkFirewallFirewallDetails? = nil,
            awsNetworkFirewallFirewallPolicy: SecurityHubClientTypes.AwsNetworkFirewallFirewallPolicyDetails? = nil,
            awsNetworkFirewallRuleGroup: SecurityHubClientTypes.AwsNetworkFirewallRuleGroupDetails? = nil,
            awsOpenSearchServiceDomain: SecurityHubClientTypes.AwsOpenSearchServiceDomainDetails? = nil,
            awsRdsDbCluster: SecurityHubClientTypes.AwsRdsDbClusterDetails? = nil,
            awsRdsDbClusterSnapshot: SecurityHubClientTypes.AwsRdsDbClusterSnapshotDetails? = nil,
            awsRdsDbInstance: SecurityHubClientTypes.AwsRdsDbInstanceDetails? = nil,
            awsRdsDbSecurityGroup: SecurityHubClientTypes.AwsRdsDbSecurityGroupDetails? = nil,
            awsRdsDbSnapshot: SecurityHubClientTypes.AwsRdsDbSnapshotDetails? = nil,
            awsRdsEventSubscription: SecurityHubClientTypes.AwsRdsEventSubscriptionDetails? = nil,
            awsRedshiftCluster: SecurityHubClientTypes.AwsRedshiftClusterDetails? = nil,
            awsS3AccountPublicAccessBlock: SecurityHubClientTypes.AwsS3AccountPublicAccessBlockDetails? = nil,
            awsS3Bucket: SecurityHubClientTypes.AwsS3BucketDetails? = nil,
            awsS3Object: SecurityHubClientTypes.AwsS3ObjectDetails? = nil,
            awsSageMakerNotebookInstance: SecurityHubClientTypes.AwsSageMakerNotebookInstanceDetails? = nil,
            awsSecretsManagerSecret: SecurityHubClientTypes.AwsSecretsManagerSecretDetails? = nil,
            awsSnsTopic: SecurityHubClientTypes.AwsSnsTopicDetails? = nil,
            awsSqsQueue: SecurityHubClientTypes.AwsSqsQueueDetails? = nil,
            awsSsmPatchCompliance: SecurityHubClientTypes.AwsSsmPatchComplianceDetails? = nil,
            awsWafRateBasedRule: SecurityHubClientTypes.AwsWafRateBasedRuleDetails? = nil,
            awsWafRegionalRateBasedRule: SecurityHubClientTypes.AwsWafRegionalRateBasedRuleDetails? = nil,
            awsWafRegionalRule: SecurityHubClientTypes.AwsWafRegionalRuleDetails? = nil,
            awsWafRegionalRuleGroup: SecurityHubClientTypes.AwsWafRegionalRuleGroupDetails? = nil,
            awsWafRegionalWebAcl: SecurityHubClientTypes.AwsWafRegionalWebAclDetails? = nil,
            awsWafRule: SecurityHubClientTypes.AwsWafRuleDetails? = nil,
            awsWafRuleGroup: SecurityHubClientTypes.AwsWafRuleGroupDetails? = nil,
            awsWafWebAcl: SecurityHubClientTypes.AwsWafWebAclDetails? = nil,
            awsWafv2RuleGroup: SecurityHubClientTypes.AwsWafv2RuleGroupDetails? = nil,
            awsWafv2WebAcl: SecurityHubClientTypes.AwsWafv2WebAclDetails? = nil,
            awsXrayEncryptionConfig: SecurityHubClientTypes.AwsXrayEncryptionConfigDetails? = nil,
            container: SecurityHubClientTypes.ContainerDetails? = nil,
            other: [Swift.String:Swift.String]? = nil
        )
        {
            self.awsApiGatewayRestApi = awsApiGatewayRestApi
            self.awsApiGatewayStage = awsApiGatewayStage
            self.awsApiGatewayV2Api = awsApiGatewayV2Api
            self.awsApiGatewayV2Stage = awsApiGatewayV2Stage
            self.awsAutoScalingAutoScalingGroup = awsAutoScalingAutoScalingGroup
            self.awsAutoScalingLaunchConfiguration = awsAutoScalingLaunchConfiguration
            self.awsBackupBackupPlan = awsBackupBackupPlan
            self.awsBackupBackupVault = awsBackupBackupVault
            self.awsBackupRecoveryPoint = awsBackupRecoveryPoint
            self.awsCertificateManagerCertificate = awsCertificateManagerCertificate
            self.awsCloudFormationStack = awsCloudFormationStack
            self.awsCloudFrontDistribution = awsCloudFrontDistribution
            self.awsCloudTrailTrail = awsCloudTrailTrail
            self.awsCloudWatchAlarm = awsCloudWatchAlarm
            self.awsCodeBuildProject = awsCodeBuildProject
            self.awsDynamoDbTable = awsDynamoDbTable
            self.awsEc2Eip = awsEc2Eip
            self.awsEc2Instance = awsEc2Instance
            self.awsEc2LaunchTemplate = awsEc2LaunchTemplate
            self.awsEc2NetworkAcl = awsEc2NetworkAcl
            self.awsEc2NetworkInterface = awsEc2NetworkInterface
            self.awsEc2SecurityGroup = awsEc2SecurityGroup
            self.awsEc2Subnet = awsEc2Subnet
            self.awsEc2TransitGateway = awsEc2TransitGateway
            self.awsEc2Volume = awsEc2Volume
            self.awsEc2Vpc = awsEc2Vpc
            self.awsEc2VpcEndpointService = awsEc2VpcEndpointService
            self.awsEc2VpcPeeringConnection = awsEc2VpcPeeringConnection
            self.awsEc2VpnConnection = awsEc2VpnConnection
            self.awsEcrContainerImage = awsEcrContainerImage
            self.awsEcrRepository = awsEcrRepository
            self.awsEcsCluster = awsEcsCluster
            self.awsEcsContainer = awsEcsContainer
            self.awsEcsService = awsEcsService
            self.awsEcsTask = awsEcsTask
            self.awsEcsTaskDefinition = awsEcsTaskDefinition
            self.awsEfsAccessPoint = awsEfsAccessPoint
            self.awsEksCluster = awsEksCluster
            self.awsElasticBeanstalkEnvironment = awsElasticBeanstalkEnvironment
            self.awsElasticsearchDomain = awsElasticsearchDomain
            self.awsElbLoadBalancer = awsElbLoadBalancer
            self.awsElbv2LoadBalancer = awsElbv2LoadBalancer
            self.awsIamAccessKey = awsIamAccessKey
            self.awsIamGroup = awsIamGroup
            self.awsIamPolicy = awsIamPolicy
            self.awsIamRole = awsIamRole
            self.awsIamUser = awsIamUser
            self.awsKinesisStream = awsKinesisStream
            self.awsKmsKey = awsKmsKey
            self.awsLambdaFunction = awsLambdaFunction
            self.awsLambdaLayerVersion = awsLambdaLayerVersion
            self.awsNetworkFirewallFirewall = awsNetworkFirewallFirewall
            self.awsNetworkFirewallFirewallPolicy = awsNetworkFirewallFirewallPolicy
            self.awsNetworkFirewallRuleGroup = awsNetworkFirewallRuleGroup
            self.awsOpenSearchServiceDomain = awsOpenSearchServiceDomain
            self.awsRdsDbCluster = awsRdsDbCluster
            self.awsRdsDbClusterSnapshot = awsRdsDbClusterSnapshot
            self.awsRdsDbInstance = awsRdsDbInstance
            self.awsRdsDbSecurityGroup = awsRdsDbSecurityGroup
            self.awsRdsDbSnapshot = awsRdsDbSnapshot
            self.awsRdsEventSubscription = awsRdsEventSubscription
            self.awsRedshiftCluster = awsRedshiftCluster
            self.awsS3AccountPublicAccessBlock = awsS3AccountPublicAccessBlock
            self.awsS3Bucket = awsS3Bucket
            self.awsS3Object = awsS3Object
            self.awsSageMakerNotebookInstance = awsSageMakerNotebookInstance
            self.awsSecretsManagerSecret = awsSecretsManagerSecret
            self.awsSnsTopic = awsSnsTopic
            self.awsSqsQueue = awsSqsQueue
            self.awsSsmPatchCompliance = awsSsmPatchCompliance
            self.awsWafRateBasedRule = awsWafRateBasedRule
            self.awsWafRegionalRateBasedRule = awsWafRegionalRateBasedRule
            self.awsWafRegionalRule = awsWafRegionalRule
            self.awsWafRegionalRuleGroup = awsWafRegionalRuleGroup
            self.awsWafRegionalWebAcl = awsWafRegionalWebAcl
            self.awsWafRule = awsWafRule
            self.awsWafRuleGroup = awsWafRuleGroup
            self.awsWafWebAcl = awsWafWebAcl
            self.awsWafv2RuleGroup = awsWafv2RuleGroup
            self.awsWafv2WebAcl = awsWafv2WebAcl
            self.awsXrayEncryptionConfig = awsXrayEncryptionConfig
            self.container = container
            self.other = other
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was rejected because we can't find the specified resource.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension SecurityHubClientTypes.Result: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case processingResult = "ProcessingResult"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let processingResult = self.processingResult {
            try encodeContainer.encode(processingResult, forKey: .processingResult)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let processingResultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .processingResult)
        processingResult = processingResultDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the account that was not processed.
    public struct Result: Swift.Equatable {
        /// An Amazon Web Services account ID of the account that was not processed.
        public var accountId: Swift.String?
        /// The reason that the account was not processed.
        public var processingResult: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            processingResult: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.processingResult = processingResult
        }
    }

}

extension SecurityHubClientTypes.RuleGroupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleVariables = "RuleVariables"
        case rulesSource = "RulesSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleVariables = self.ruleVariables {
            try encodeContainer.encode(ruleVariables, forKey: .ruleVariables)
        }
        if let rulesSource = self.rulesSource {
            try encodeContainer.encode(rulesSource, forKey: .rulesSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleVariablesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupVariables.self, forKey: .ruleVariables)
        ruleVariables = ruleVariablesDecoded
        let rulesSourceDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupSource.self, forKey: .rulesSource)
        rulesSource = rulesSourceDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the rule group.
    public struct RuleGroupDetails: Swift.Equatable {
        /// Additional settings to use in the specified rules.
        public var ruleVariables: SecurityHubClientTypes.RuleGroupVariables?
        /// The rules and actions for the rule group. For stateful rule groups, can contain RulesString, RulesSourceList, or StatefulRules. For stateless rule groups, contains StatelessRulesAndCustomActions.
        public var rulesSource: SecurityHubClientTypes.RuleGroupSource?

        public init (
            ruleVariables: SecurityHubClientTypes.RuleGroupVariables? = nil,
            rulesSource: SecurityHubClientTypes.RuleGroupSource? = nil
        )
        {
            self.ruleVariables = ruleVariables
            self.rulesSource = rulesSource
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rulesSourceList = "RulesSourceList"
        case rulesString = "RulesString"
        case statefulRules = "StatefulRules"
        case statelessRulesAndCustomActions = "StatelessRulesAndCustomActions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rulesSourceList = self.rulesSourceList {
            try encodeContainer.encode(rulesSourceList, forKey: .rulesSourceList)
        }
        if let rulesString = self.rulesString {
            try encodeContainer.encode(rulesString, forKey: .rulesString)
        }
        if let statefulRules = statefulRules {
            var statefulRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statefulRules)
            for rulegroupsourcestatefulrulesdetails0 in statefulRules {
                try statefulRulesContainer.encode(rulegroupsourcestatefulrulesdetails0)
            }
        }
        if let statelessRulesAndCustomActions = self.statelessRulesAndCustomActions {
            try encodeContainer.encode(statelessRulesAndCustomActions, forKey: .statelessRulesAndCustomActions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesSourceListDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupSourceListDetails.self, forKey: .rulesSourceList)
        rulesSourceList = rulesSourceListDecoded
        let rulesStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rulesString)
        rulesString = rulesStringDecoded
        let statefulRulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails?].self, forKey: .statefulRules)
        var statefulRulesDecoded0:[SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails]? = nil
        if let statefulRulesContainer = statefulRulesContainer {
            statefulRulesDecoded0 = [SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails]()
            for structure0 in statefulRulesContainer {
                if let structure0 = structure0 {
                    statefulRulesDecoded0?.append(structure0)
                }
            }
        }
        statefulRules = statefulRulesDecoded0
        let statelessRulesAndCustomActionsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails.self, forKey: .statelessRulesAndCustomActions)
        statelessRulesAndCustomActions = statelessRulesAndCustomActionsDecoded
    }
}

extension SecurityHubClientTypes {
    /// The rules and actions for the rule group.
    public struct RuleGroupSource: Swift.Equatable {
        /// Stateful inspection criteria for a domain list rule group. A domain list rule group determines access by specific protocols to specific domains.
        public var rulesSourceList: SecurityHubClientTypes.RuleGroupSourceListDetails?
        /// Stateful inspection criteria, provided in Suricata compatible intrusion prevention system (IPS) rules.
        public var rulesString: Swift.String?
        /// Suricata rule specifications.
        public var statefulRules: [SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails]?
        /// The stateless rules and custom actions used by a stateless rule group.
        public var statelessRulesAndCustomActions: SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails?

        public init (
            rulesSourceList: SecurityHubClientTypes.RuleGroupSourceListDetails? = nil,
            rulesString: Swift.String? = nil,
            statefulRules: [SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails]? = nil,
            statelessRulesAndCustomActions: SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails? = nil
        )
        {
            self.rulesSourceList = rulesSourceList
            self.rulesString = rulesString
            self.statefulRules = statefulRules
            self.statelessRulesAndCustomActions = statelessRulesAndCustomActions
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionDefinition = "ActionDefinition"
        case actionName = "ActionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionDefinition = self.actionDefinition {
            try encodeContainer.encode(actionDefinition, forKey: .actionDefinition)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDefinitionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.StatelessCustomActionDefinition.self, forKey: .actionDefinition)
        actionDefinition = actionDefinitionDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
    }
}

extension SecurityHubClientTypes {
    /// A custom action definition. A custom action is an optional, non-standard action to use for stateless packet handling.
    public struct RuleGroupSourceCustomActionsDetails: Swift.Equatable {
        /// The definition of a custom action.
        public var actionDefinition: SecurityHubClientTypes.StatelessCustomActionDefinition?
        /// A descriptive name of the custom action.
        public var actionName: Swift.String?

        public init (
            actionDefinition: SecurityHubClientTypes.StatelessCustomActionDefinition? = nil,
            actionName: Swift.String? = nil
        )
        {
            self.actionDefinition = actionDefinition
            self.actionName = actionName
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceListDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedRulesType = "GeneratedRulesType"
        case targetTypes = "TargetTypes"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedRulesType = self.generatedRulesType {
            try encodeContainer.encode(generatedRulesType, forKey: .generatedRulesType)
        }
        if let targetTypes = targetTypes {
            var targetTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetTypes)
            for nonemptystring0 in targetTypes {
                try targetTypesContainer.encode(nonemptystring0)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for nonemptystring0 in targets {
                try targetsContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedRulesTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedRulesType)
        generatedRulesType = generatedRulesTypeDecoded
        let targetTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetTypes)
        var targetTypesDecoded0:[Swift.String]? = nil
        if let targetTypesContainer = targetTypesContainer {
            targetTypesDecoded0 = [Swift.String]()
            for string0 in targetTypesContainer {
                if let string0 = string0 {
                    targetTypesDecoded0?.append(string0)
                }
            }
        }
        targetTypes = targetTypesDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Stateful inspection criteria for a domain list rule group.
    public struct RuleGroupSourceListDetails: Swift.Equatable {
        /// Indicates whether to allow or deny access to the domains listed in Targets.
        public var generatedRulesType: Swift.String?
        /// The protocols that you want to inspect. Specify LS_SNI for HTTPS. Specify HTTP_HOST for HTTP. You can specify either or both.
        public var targetTypes: [Swift.String]?
        /// The domains that you want to inspect for in your traffic flows. You can provide full domain names, or use the '.' prefix as a wildcard. For example, .example.com matches all domains that end with example.com.
        public var targets: [Swift.String]?

        public init (
            generatedRulesType: Swift.String? = nil,
            targetTypes: [Swift.String]? = nil,
            targets: [Swift.String]? = nil
        )
        {
            self.generatedRulesType = generatedRulesType
            self.targetTypes = targetTypes
            self.targets = targets
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatefulRulesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case header = "Header"
        case ruleOptions = "RuleOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let header = self.header {
            try encodeContainer.encode(header, forKey: .header)
        }
        if let ruleOptions = ruleOptions {
            var ruleOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ruleOptions)
            for rulegroupsourcestatefulrulesoptionsdetails0 in ruleOptions {
                try ruleOptionsContainer.encode(rulegroupsourcestatefulrulesoptionsdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let headerDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails.self, forKey: .header)
        header = headerDecoded
        let ruleOptionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails?].self, forKey: .ruleOptions)
        var ruleOptionsDecoded0:[SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails]? = nil
        if let ruleOptionsContainer = ruleOptionsContainer {
            ruleOptionsDecoded0 = [SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails]()
            for structure0 in ruleOptionsContainer {
                if let structure0 = structure0 {
                    ruleOptionsDecoded0?.append(structure0)
                }
            }
        }
        ruleOptions = ruleOptionsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// A Suricata rule specification.
    public struct RuleGroupSourceStatefulRulesDetails: Swift.Equatable {
        /// Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria.
        public var action: Swift.String?
        /// The stateful inspection criteria for the rule.
        public var header: SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails?
        /// Additional options for the rule.
        public var ruleOptions: [SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails]?

        public init (
            action: Swift.String? = nil,
            header: SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails? = nil,
            ruleOptions: [SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails]? = nil
        )
        {
            self.action = action
            self.header = header
            self.ruleOptions = ruleOptions
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatefulRulesHeaderDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination = "Destination"
        case destinationPort = "DestinationPort"
        case direction = "Direction"
        case `protocol` = "Protocol"
        case source = "Source"
        case sourcePort = "SourcePort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationPort = self.destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let direction = self.direction {
            try encodeContainer.encode(direction, forKey: .direction)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourcePort = self.sourcePort {
            try encodeContainer.encode(sourcePort, forKey: .sourcePort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let directionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .direction)
        direction = directionDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let sourcePortDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePort)
        sourcePort = sourcePortDecoded
    }
}

extension SecurityHubClientTypes {
    /// The inspection criteria for a stateful rule.
    public struct RuleGroupSourceStatefulRulesHeaderDetails: Swift.Equatable {
        /// The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify ANY.
        public var destination: Swift.String?
        /// The destination port to inspect for. You can specify an individual port, such as 1994. You also can specify a port range, such as 1990:1994. To match with any port, specify ANY.
        public var destinationPort: Swift.String?
        /// The direction of traffic flow to inspect. If set to ANY, the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to FORWARD, the inspection only matches traffic going from the source to the destination.
        public var direction: Swift.String?
        /// The protocol to inspect for. To inspector for all protocols, use IP.
        public var `protocol`: Swift.String?
        /// The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify ANY.
        public var source: Swift.String?
        /// The source port to inspect for. You can specify an individual port, such as 1994. You also can specify a port range, such as 1990:1994. To match with any port, specify ANY.
        public var sourcePort: Swift.String?

        public init (
            destination: Swift.String? = nil,
            destinationPort: Swift.String? = nil,
            direction: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            source: Swift.String? = nil,
            sourcePort: Swift.String? = nil
        )
        {
            self.destination = destination
            self.destinationPort = destinationPort
            self.direction = direction
            self.`protocol` = `protocol`
            self.source = source
            self.sourcePort = sourcePort
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatefulRulesOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyword = "Keyword"
        case settings = "Settings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = self.keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let settings = settings {
            var settingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .settings)
            for nonemptystring0 in settings {
                try settingsContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyword)
        keyword = keywordDecoded
        let settingsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .settings)
        var settingsDecoded0:[Swift.String]? = nil
        if let settingsContainer = settingsContainer {
            settingsDecoded0 = [Swift.String]()
            for string0 in settingsContainer {
                if let string0 = string0 {
                    settingsDecoded0?.append(string0)
                }
            }
        }
        settings = settingsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// A rule option for a stateful rule.
    public struct RuleGroupSourceStatefulRulesOptionsDetails: Swift.Equatable {
        /// A keyword to look for.
        public var keyword: Swift.String?
        /// A list of settings.
        public var settings: [Swift.String]?

        public init (
            keyword: Swift.String? = nil,
            settings: [Swift.String]? = nil
        )
        {
            self.keyword = keyword
            self.settings = settings
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case matchAttributes = "MatchAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for nonemptystring0 in actions {
                try actionsContainer.encode(nonemptystring0)
            }
        }
        if let matchAttributes = self.matchAttributes {
            try encodeContainer.encode(matchAttributes, forKey: .matchAttributes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let matchAttributesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes.self, forKey: .matchAttributes)
        matchAttributes = matchAttributesDecoded
    }
}

extension SecurityHubClientTypes {
    /// The definition of the stateless rule.
    public struct RuleGroupSourceStatelessRuleDefinition: Swift.Equatable {
        /// The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action (aws:pass, aws:drop, or aws:forward_to_sfe). You can then add custom actions.
        public var actions: [Swift.String]?
        /// The criteria for Network Firewall to use to inspect an individual packet in a stateless rule inspection.
        public var matchAttributes: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes?

        public init (
            actions: [Swift.String]? = nil,
            matchAttributes: SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes? = nil
        )
        {
            self.actions = actions
            self.matchAttributes = matchAttributes
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPorts = "DestinationPorts"
        case destinations = "Destinations"
        case protocols = "Protocols"
        case sourcePorts = "SourcePorts"
        case sources = "Sources"
        case tcpFlags = "TcpFlags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for rulegroupsourcestatelessrulematchattributesdestinationports0 in destinationPorts {
                try destinationPortsContainer.encode(rulegroupsourcestatelessrulematchattributesdestinationports0)
            }
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for rulegroupsourcestatelessrulematchattributesdestinations0 in destinations {
                try destinationsContainer.encode(rulegroupsourcestatelessrulematchattributesdestinations0)
            }
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for integer0 in protocols {
                try protocolsContainer.encode(integer0)
            }
        }
        if let sourcePorts = sourcePorts {
            var sourcePortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourcePorts)
            for rulegroupsourcestatelessrulematchattributessourceports0 in sourcePorts {
                try sourcePortsContainer.encode(rulegroupsourcestatelessrulematchattributessourceports0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for rulegroupsourcestatelessrulematchattributessources0 in sources {
                try sourcesContainer.encode(rulegroupsourcestatelessrulematchattributessources0)
            }
        }
        if let tcpFlags = tcpFlags {
            var tcpFlagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tcpFlags)
            for rulegroupsourcestatelessrulematchattributestcpflags0 in tcpFlags {
                try tcpFlagsContainer.encode(rulegroupsourcestatelessrulematchattributestcpflags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPortsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]()
            for structure0 in destinationPortsContainer {
                if let structure0 = structure0 {
                    destinationPortsDecoded0?.append(structure0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let destinationsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations?].self, forKey: .destinations)
        var destinationsDecoded0:[SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let protocolsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .protocols)
        var protocolsDecoded0:[Swift.Int]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [Swift.Int]()
            for integer0 in protocolsContainer {
                if let integer0 = integer0 {
                    protocolsDecoded0?.append(integer0)
                }
            }
        }
        protocols = protocolsDecoded0
        let sourcePortsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts?].self, forKey: .sourcePorts)
        var sourcePortsDecoded0:[SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]? = nil
        if let sourcePortsContainer = sourcePortsContainer {
            sourcePortsDecoded0 = [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]()
            for structure0 in sourcePortsContainer {
                if let structure0 = structure0 {
                    sourcePortsDecoded0?.append(structure0)
                }
            }
        }
        sourcePorts = sourcePortsDecoded0
        let sourcesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources?].self, forKey: .sources)
        var sourcesDecoded0:[SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let tcpFlagsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags?].self, forKey: .tcpFlags)
        var tcpFlagsDecoded0:[SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]? = nil
        if let tcpFlagsContainer = tcpFlagsContainer {
            tcpFlagsDecoded0 = [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]()
            for structure0 in tcpFlagsContainer {
                if let structure0 = structure0 {
                    tcpFlagsDecoded0?.append(structure0)
                }
            }
        }
        tcpFlags = tcpFlagsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Criteria for the stateless rule.
    public struct RuleGroupSourceStatelessRuleMatchAttributes: Swift.Equatable {
        /// A list of port ranges to specify the destination ports to inspect for.
        public var destinationPorts: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]?
        /// The destination IP addresses and address ranges to inspect for, in CIDR notation.
        public var destinations: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations]?
        /// The protocols to inspect for.
        public var protocols: [Swift.Int]?
        /// A list of port ranges to specify the source ports to inspect for.
        public var sourcePorts: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]?
        /// The source IP addresses and address ranges to inspect for, in CIDR notation.
        public var sources: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources]?
        /// The TCP flags and masks to inspect for.
        public var tcpFlags: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]?

        public init (
            destinationPorts: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts]? = nil,
            destinations: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations]? = nil,
            protocols: [Swift.Int]? = nil,
            sourcePorts: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts]? = nil,
            sources: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources]? = nil,
            tcpFlags: [SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags]? = nil
        )
        {
            self.destinationPorts = destinationPorts
            self.destinations = destinations
            self.protocols = protocols
            self.sourcePorts = sourcePorts
            self.sources = sources
            self.tcpFlags = tcpFlags
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if fromPort != 0 {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if toPort != 0 {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort) ?? 0
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort) ?? 0
        toPort = toPortDecoded
    }
}

extension SecurityHubClientTypes {
    /// A port range to specify the destination ports to inspect for.
    public struct RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts: Swift.Equatable {
        /// The starting port value for the port range.
        public var fromPort: Swift.Int
        /// The ending port value for the port range.
        public var toPort: Swift.Int

        public init (
            fromPort: Swift.Int = 0,
            toPort: Swift.Int = 0
        )
        {
            self.fromPort = fromPort
            self.toPort = toPort
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesDestinations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressDefinition = "AddressDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressDefinition = self.addressDefinition {
            try encodeContainer.encode(addressDefinition, forKey: .addressDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressDefinition)
        addressDefinition = addressDefinitionDecoded
    }
}

extension SecurityHubClientTypes {
    /// A destination IP address or range.
    public struct RuleGroupSourceStatelessRuleMatchAttributesDestinations: Swift.Equatable {
        /// An IP address or a block of IP addresses.
        public var addressDefinition: Swift.String?

        public init (
            addressDefinition: Swift.String? = nil
        )
        {
            self.addressDefinition = addressDefinition
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSourcePorts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromPort = "FromPort"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if fromPort != 0 {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if toPort != 0 {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPort) ?? 0
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .toPort) ?? 0
        toPort = toPortDecoded
    }
}

extension SecurityHubClientTypes {
    /// A port range to specify the source ports to inspect for.
    public struct RuleGroupSourceStatelessRuleMatchAttributesSourcePorts: Swift.Equatable {
        /// The starting port value for the port range.
        public var fromPort: Swift.Int
        /// The ending port value for the port range.
        public var toPort: Swift.Int

        public init (
            fromPort: Swift.Int = 0,
            toPort: Swift.Int = 0
        )
        {
            self.fromPort = fromPort
            self.toPort = toPort
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesSources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressDefinition = "AddressDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressDefinition = self.addressDefinition {
            try encodeContainer.encode(addressDefinition, forKey: .addressDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressDefinition)
        addressDefinition = addressDefinitionDecoded
    }
}

extension SecurityHubClientTypes {
    /// A source IP addresses and address range to inspect for.
    public struct RuleGroupSourceStatelessRuleMatchAttributesSources: Swift.Equatable {
        /// An IP address or a block of IP addresses.
        public var addressDefinition: Swift.String?

        public init (
            addressDefinition: Swift.String? = nil
        )
        {
            self.addressDefinition = addressDefinition
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRuleMatchAttributesTcpFlags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flags = "Flags"
        case masks = "Masks"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flags = flags {
            var flagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .flags)
            for nonemptystring0 in flags {
                try flagsContainer.encode(nonemptystring0)
            }
        }
        if let masks = masks {
            var masksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .masks)
            for nonemptystring0 in masks {
                try masksContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .flags)
        var flagsDecoded0:[Swift.String]? = nil
        if let flagsContainer = flagsContainer {
            flagsDecoded0 = [Swift.String]()
            for string0 in flagsContainer {
                if let string0 = string0 {
                    flagsDecoded0?.append(string0)
                }
            }
        }
        flags = flagsDecoded0
        let masksContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .masks)
        var masksDecoded0:[Swift.String]? = nil
        if let masksContainer = masksContainer {
            masksDecoded0 = [Swift.String]()
            for string0 in masksContainer {
                if let string0 = string0 {
                    masksDecoded0?.append(string0)
                }
            }
        }
        masks = masksDecoded0
    }
}

extension SecurityHubClientTypes {
    /// A set of TCP flags and masks to inspect for.
    public struct RuleGroupSourceStatelessRuleMatchAttributesTcpFlags: Swift.Equatable {
        /// Defines the flags from the Masks setting that must be set in order for the packet to match. Flags that are listed must be set. Flags that are not listed must not be set.
        public var flags: [Swift.String]?
        /// The set of flags to consider in the inspection. If not specified, then all flags are inspected.
        public var masks: [Swift.String]?

        public init (
            flags: [Swift.String]? = nil,
            masks: [Swift.String]? = nil
        )
        {
            self.flags = flags
            self.masks = masks
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRulesAndCustomActionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customActions = "CustomActions"
        case statelessRules = "StatelessRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customActions = customActions {
            var customActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customActions)
            for rulegroupsourcecustomactionsdetails0 in customActions {
                try customActionsContainer.encode(rulegroupsourcecustomactionsdetails0)
            }
        }
        if let statelessRules = statelessRules {
            var statelessRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessRules)
            for rulegroupsourcestatelessrulesdetails0 in statelessRules {
                try statelessRulesContainer.encode(rulegroupsourcestatelessrulesdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customActionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails?].self, forKey: .customActions)
        var customActionsDecoded0:[SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails]? = nil
        if let customActionsContainer = customActionsContainer {
            customActionsDecoded0 = [SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails]()
            for structure0 in customActionsContainer {
                if let structure0 = structure0 {
                    customActionsDecoded0?.append(structure0)
                }
            }
        }
        customActions = customActionsDecoded0
        let statelessRulesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails?].self, forKey: .statelessRules)
        var statelessRulesDecoded0:[SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails]? = nil
        if let statelessRulesContainer = statelessRulesContainer {
            statelessRulesDecoded0 = [SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails]()
            for structure0 in statelessRulesContainer {
                if let structure0 = structure0 {
                    statelessRulesDecoded0?.append(structure0)
                }
            }
        }
        statelessRules = statelessRulesDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Stateless rules and custom actions for a stateless rule group.
    public struct RuleGroupSourceStatelessRulesAndCustomActionsDetails: Swift.Equatable {
        /// Custom actions for the rule group.
        public var customActions: [SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails]?
        /// Stateless rules for the rule group.
        public var statelessRules: [SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails]?

        public init (
            customActions: [SecurityHubClientTypes.RuleGroupSourceCustomActionsDetails]? = nil,
            statelessRules: [SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails]? = nil
        )
        {
            self.customActions = customActions
            self.statelessRules = statelessRules
        }
    }

}

extension SecurityHubClientTypes.RuleGroupSourceStatelessRulesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case priority = "Priority"
        case ruleDefinition = "RuleDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleDefinition = self.ruleDefinition {
            try encodeContainer.encode(ruleDefinition, forKey: .ruleDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority) ?? 0
        priority = priorityDecoded
        let ruleDefinitionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition.self, forKey: .ruleDefinition)
        ruleDefinition = ruleDefinitionDecoded
    }
}

extension SecurityHubClientTypes {
    /// A stateless rule in the rule group.
    public struct RuleGroupSourceStatelessRulesDetails: Swift.Equatable {
        /// Indicates the order in which to run this rule relative to all of the rules in the stateless rule group.
        public var priority: Swift.Int
        /// Provides the definition of the stateless rule.
        public var ruleDefinition: SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition?

        public init (
            priority: Swift.Int = 0,
            ruleDefinition: SecurityHubClientTypes.RuleGroupSourceStatelessRuleDefinition? = nil
        )
        {
            self.priority = priority
            self.ruleDefinition = ruleDefinition
        }
    }

}

extension SecurityHubClientTypes.RuleGroupVariables: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipSets = "IpSets"
        case portSets = "PortSets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipSets = self.ipSets {
            try encodeContainer.encode(ipSets, forKey: .ipSets)
        }
        if let portSets = self.portSets {
            try encodeContainer.encode(portSets, forKey: .portSets)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipSetsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails.self, forKey: .ipSets)
        ipSets = ipSetsDecoded
        let portSetsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails.self, forKey: .portSets)
        portSets = portSetsDecoded
    }
}

extension SecurityHubClientTypes {
    /// Additional settings to use in the specified rules.
    public struct RuleGroupVariables: Swift.Equatable {
        /// A list of IP addresses and address ranges, in CIDR notation.
        public var ipSets: SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails?
        /// A list of port ranges.
        public var portSets: SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails?

        public init (
            ipSets: SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails? = nil,
            portSets: SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails? = nil
        )
        {
            self.ipSets = ipSets
            self.portSets = portSets
        }
    }

}

extension SecurityHubClientTypes.RuleGroupVariablesIpSetsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .definition)
            for nonemptystring0 in definition {
                try definitionContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .definition)
        var definitionDecoded0:[Swift.String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [Swift.String]()
            for string0 in definitionContainer {
                if let string0 = string0 {
                    definitionDecoded0?.append(string0)
                }
            }
        }
        definition = definitionDecoded0
    }
}

extension SecurityHubClientTypes {
    /// A list of IP addresses and address ranges, in CIDR notation.
    public struct RuleGroupVariablesIpSetsDetails: Swift.Equatable {
        /// The list of IP addresses and ranges.
        public var definition: [Swift.String]?

        public init (
            definition: [Swift.String]? = nil
        )
        {
            self.definition = definition
        }
    }

}

extension SecurityHubClientTypes.RuleGroupVariablesPortSetsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .definition)
            for nonemptystring0 in definition {
                try definitionContainer.encode(nonemptystring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .definition)
        var definitionDecoded0:[Swift.String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [Swift.String]()
            for string0 in definitionContainer {
                if let string0 = string0 {
                    definitionDecoded0?.append(string0)
                }
            }
        }
        definition = definitionDecoded0
    }
}

extension SecurityHubClientTypes {
    /// A list of port ranges.
    public struct RuleGroupVariablesPortSetsDetails: Swift.Equatable {
        /// The list of port ranges.
        public var definition: [Swift.String]?

        public init (
            definition: [Swift.String]? = nil
        )
        {
            self.definition = definition
        }
    }

}

extension SecurityHubClientTypes.SensitiveDataDetections: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "Count"
        case occurrences = "Occurrences"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let occurrences = self.occurrences {
            try encodeContainer.encode(occurrences, forKey: .occurrences)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let occurrencesDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.Occurrences.self, forKey: .occurrences)
        occurrences = occurrencesDecoded
    }
}

extension SecurityHubClientTypes {
    /// The list of detected instances of sensitive data.
    public struct SensitiveDataDetections: Swift.Equatable {
        /// The total number of occurrences of sensitive data that were detected.
        public var count: Swift.Int
        /// Details about the sensitive data that was detected.
        public var occurrences: SecurityHubClientTypes.Occurrences?
        /// The type of sensitive data that was detected. For example, the type might indicate that the data is an email address.
        public var type: Swift.String?

        public init (
            count: Swift.Int = 0,
            occurrences: SecurityHubClientTypes.Occurrences? = nil,
            type: Swift.String? = nil
        )
        {
            self.count = count
            self.occurrences = occurrences
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.SensitiveDataResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case detections = "Detections"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let detections = detections {
            var detectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detections)
            for sensitivedatadetections0 in detections {
                try detectionsContainer.encode(sensitivedatadetections0)
            }
        }
        if totalCount != 0 {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .category)
        category = categoryDecoded
        let detectionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.SensitiveDataDetections?].self, forKey: .detections)
        var detectionsDecoded0:[SecurityHubClientTypes.SensitiveDataDetections]? = nil
        if let detectionsContainer = detectionsContainer {
            detectionsDecoded0 = [SecurityHubClientTypes.SensitiveDataDetections]()
            for structure0 in detectionsContainer {
                if let structure0 = structure0 {
                    detectionsDecoded0?.append(structure0)
                }
            }
        }
        detections = detectionsDecoded0
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount) ?? 0
        totalCount = totalCountDecoded
    }
}

extension SecurityHubClientTypes {
    /// Contains a detected instance of sensitive data that are based on built-in identifiers.
    public struct SensitiveDataResult: Swift.Equatable {
        /// The category of sensitive data that was detected. For example, the category can indicate that the sensitive data involved credentials, financial information, or personal information.
        public var category: Swift.String?
        /// The list of detected instances of sensitive data.
        public var detections: [SecurityHubClientTypes.SensitiveDataDetections]?
        /// The total number of occurrences of sensitive data.
        public var totalCount: Swift.Int

        public init (
            category: Swift.String? = nil,
            detections: [SecurityHubClientTypes.SensitiveDataDetections]? = nil,
            totalCount: Swift.Int = 0
        )
        {
            self.category = category
            self.detections = detections
            self.totalCount = totalCount
        }
    }

}

extension SecurityHubClientTypes.Severity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
        case normalized = "Normalized"
        case original = "Original"
        case product = "Product"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = self.label {
            try encodeContainer.encode(label.rawValue, forKey: .label)
        }
        if normalized != 0 {
            try encodeContainer.encode(normalized, forKey: .normalized)
        }
        if let original = self.original {
            try encodeContainer.encode(original, forKey: .original)
        }
        if product != 0.0 {
            try encodeContainer.encode(product, forKey: .product)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .product) ?? 0.0
        product = productDecoded
        let labelDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.SeverityLabel.self, forKey: .label)
        label = labelDecoded
        let normalizedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .normalized) ?? 0
        normalized = normalizedDecoded
        let originalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .original)
        original = originalDecoded
    }
}

extension SecurityHubClientTypes {
    /// The severity of the finding. The finding provider can provide the initial severity. The finding provider can only update the severity if it has not been updated using BatchUpdateFindings. The finding must have either Label or Normalized populated. If only one of these attributes is populated, then Security Hub automatically populates the other one. If neither attribute is populated, then the finding is invalid. Label is the preferred attribute.
    public struct Severity: Swift.Equatable {
        /// The severity value of the finding. The allowed values are the following.
        ///
        /// * INFORMATIONAL - No issue was found.
        ///
        /// * LOW - The issue does not require action on its own.
        ///
        /// * MEDIUM - The issue must be addressed but not urgently.
        ///
        /// * HIGH - The issue must be addressed as a priority.
        ///
        /// * CRITICAL - The issue must be remediated immediately to avoid it escalating.
        ///
        ///
        /// If you provide Normalized and do not provide Label, then Label is set automatically as follows.
        ///
        /// * 0 - INFORMATIONAL
        ///
        /// * 139 - LOW
        ///
        /// * 4069 - MEDIUM
        ///
        /// * 7089 - HIGH
        ///
        /// * 90100 - CRITICAL
        public var label: SecurityHubClientTypes.SeverityLabel?
        /// Deprecated. The normalized severity of a finding. This attribute is being deprecated. Instead of providing Normalized, provide Label. If you provide Label and do not provide Normalized, then Normalized is set automatically as follows.
        ///
        /// * INFORMATIONAL - 0
        ///
        /// * LOW - 1
        ///
        /// * MEDIUM - 40
        ///
        /// * HIGH - 70
        ///
        /// * CRITICAL - 90
        public var normalized: Swift.Int
        /// The native severity from the finding product that generated the finding.
        public var original: Swift.String?
        /// Deprecated. This attribute is being deprecated. Instead of providing Product, provide Original. The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.
        public var product: Swift.Double

        public init (
            label: SecurityHubClientTypes.SeverityLabel? = nil,
            normalized: Swift.Int = 0,
            original: Swift.String? = nil,
            product: Swift.Double = 0.0
        )
        {
            self.label = label
            self.normalized = normalized
            self.original = original
            self.product = product
        }
    }

}

extension SecurityHubClientTypes {
    public enum SeverityLabel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [SeverityLabel] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SeverityLabel(rawValue: rawValue) ?? SeverityLabel.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes {
    public enum SeverityRating: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [SeverityRating] {
            return [
                .critical,
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SeverityRating(rawValue: rawValue) ?? SeverityRating.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.SeverityUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
        case normalized = "Normalized"
        case product = "Product"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let label = self.label {
            try encodeContainer.encode(label.rawValue, forKey: .label)
        }
        if normalized != 0 {
            try encodeContainer.encode(normalized, forKey: .normalized)
        }
        if product != 0.0 {
            try encodeContainer.encode(product, forKey: .product)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let normalizedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .normalized) ?? 0
        normalized = normalizedDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .product) ?? 0.0
        product = productDecoded
        let labelDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.SeverityLabel.self, forKey: .label)
        label = labelDecoded
    }
}

extension SecurityHubClientTypes {
    /// Updates to the severity information for a finding.
    public struct SeverityUpdate: Swift.Equatable {
        /// The severity value of the finding. The allowed values are the following.
        ///
        /// * INFORMATIONAL - No issue was found.
        ///
        /// * LOW - The issue does not require action on its own.
        ///
        /// * MEDIUM - The issue must be addressed but not urgently.
        ///
        /// * HIGH - The issue must be addressed as a priority.
        ///
        /// * CRITICAL - The issue must be remediated immediately to avoid it escalating.
        public var label: SecurityHubClientTypes.SeverityLabel?
        /// The normalized severity for the finding. This attribute is to be deprecated in favor of Label. If you provide Normalized and do not provide Label, Label is set automatically as follows.
        ///
        /// * 0 - INFORMATIONAL
        ///
        /// * 139 - LOW
        ///
        /// * 4069 - MEDIUM
        ///
        /// * 7089 - HIGH
        ///
        /// * 90100 - CRITICAL
        public var normalized: Swift.Int
        /// The native severity as defined by the Amazon Web Services service or integrated partner product that generated the finding.
        public var product: Swift.Double

        public init (
            label: SecurityHubClientTypes.SeverityLabel? = nil,
            normalized: Swift.Int = 0,
            product: Swift.Double = 0.0
        )
        {
            self.label = label
            self.normalized = normalized
            self.product = product
        }
    }

}

extension SecurityHubClientTypes.SoftwarePackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture = "Architecture"
        case epoch = "Epoch"
        case filePath = "FilePath"
        case fixedInVersion = "FixedInVersion"
        case name = "Name"
        case packageManager = "PackageManager"
        case release = "Release"
        case remediation = "Remediation"
        case sourceLayerArn = "SourceLayerArn"
        case sourceLayerHash = "SourceLayerHash"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let epoch = self.epoch {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let fixedInVersion = self.fixedInVersion {
            try encodeContainer.encode(fixedInVersion, forKey: .fixedInVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageManager = self.packageManager {
            try encodeContainer.encode(packageManager, forKey: .packageManager)
        }
        if let release = self.release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let sourceLayerArn = self.sourceLayerArn {
            try encodeContainer.encode(sourceLayerArn, forKey: .sourceLayerArn)
        }
        if let sourceLayerHash = self.sourceLayerHash {
            try encodeContainer.encode(sourceLayerHash, forKey: .sourceLayerHash)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let epochDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .epoch)
        epoch = epochDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .release)
        release = releaseDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let packageManagerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageManager)
        packageManager = packageManagerDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let fixedInVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fixedInVersion)
        fixedInVersion = fixedInVersionDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remediation)
        remediation = remediationDecoded
        let sourceLayerHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLayerHash)
        sourceLayerHash = sourceLayerHashDecoded
        let sourceLayerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLayerArn)
        sourceLayerArn = sourceLayerArnDecoded
    }
}

extension SecurityHubClientTypes {
    /// Information about a software package.
    public struct SoftwarePackage: Swift.Equatable {
        /// The architecture used for the software package.
        public var architecture: Swift.String?
        /// The epoch of the software package.
        public var epoch: Swift.String?
        /// The file system path to the package manager inventory file.
        public var filePath: Swift.String?
        /// The version of the software package in which the vulnerability has been resolved.
        public var fixedInVersion: Swift.String?
        /// The name of the software package.
        public var name: Swift.String?
        /// The source of the package.
        public var packageManager: Swift.String?
        /// The release of the software package.
        public var release: Swift.String?
        /// Describes the actions a customer can take to resolve the vulnerability in the software package.
        public var remediation: Swift.String?
        /// The Amazon Resource Name (ARN) of the source layer.
        public var sourceLayerArn: Swift.String?
        /// The source layer hash of the vulnerable package.
        public var sourceLayerHash: Swift.String?
        /// The version of the software package.
        public var version: Swift.String?

        public init (
            architecture: Swift.String? = nil,
            epoch: Swift.String? = nil,
            filePath: Swift.String? = nil,
            fixedInVersion: Swift.String? = nil,
            name: Swift.String? = nil,
            packageManager: Swift.String? = nil,
            release: Swift.String? = nil,
            remediation: Swift.String? = nil,
            sourceLayerArn: Swift.String? = nil,
            sourceLayerHash: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.epoch = epoch
            self.filePath = filePath
            self.fixedInVersion = fixedInVersion
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.remediation = remediation
            self.sourceLayerArn = sourceLayerArn
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}

extension SecurityHubClientTypes.SortCriterion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field = "Field"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = self.field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension SecurityHubClientTypes {
    /// A collection of finding attributes used to sort findings.
    public struct SortCriterion: Swift.Equatable {
        /// The finding attribute used to sort findings.
        public var field: Swift.String?
        /// The order used to sort findings.
        public var sortOrder: SecurityHubClientTypes.SortOrder?

        public init (
            field: Swift.String? = nil,
            sortOrder: SecurityHubClientTypes.SortOrder? = nil
        )
        {
            self.field = field
            self.sortOrder = sortOrder
        }
    }

}

extension SecurityHubClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "asc"
            case .descending: return "desc"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.Standard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case enabledByDefault = "EnabledByDefault"
        case name = "Name"
        case standardsArn = "StandardsArn"
        case standardsManagedBy = "StandardsManagedBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabledByDefault != false {
            try encodeContainer.encode(enabledByDefault, forKey: .enabledByDefault)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let standardsArn = self.standardsArn {
            try encodeContainer.encode(standardsArn, forKey: .standardsArn)
        }
        if let standardsManagedBy = self.standardsManagedBy {
            try encodeContainer.encode(standardsManagedBy, forKey: .standardsManagedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardsArn)
        standardsArn = standardsArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledByDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabledByDefault) ?? false
        enabledByDefault = enabledByDefaultDecoded
        let standardsManagedByDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.StandardsManagedBy.self, forKey: .standardsManagedBy)
        standardsManagedBy = standardsManagedByDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about a specific security standard.
    public struct Standard: Swift.Equatable {
        /// A description of the standard.
        public var description: Swift.String?
        /// Whether the standard is enabled by default. When Security Hub is enabled from the console, if a standard is enabled by default, the check box for that standard is selected by default. When Security Hub is enabled using the EnableSecurityHub API operation, the standard is enabled by default unless EnableDefaultStandards is set to false.
        public var enabledByDefault: Swift.Bool
        /// The name of the standard.
        public var name: Swift.String?
        /// The ARN of a standard.
        public var standardsArn: Swift.String?
        /// Provides details about the management of a standard.
        public var standardsManagedBy: SecurityHubClientTypes.StandardsManagedBy?

        public init (
            description: Swift.String? = nil,
            enabledByDefault: Swift.Bool = false,
            name: Swift.String? = nil,
            standardsArn: Swift.String? = nil,
            standardsManagedBy: SecurityHubClientTypes.StandardsManagedBy? = nil
        )
        {
            self.description = description
            self.enabledByDefault = enabledByDefault
            self.name = name
            self.standardsArn = standardsArn
            self.standardsManagedBy = standardsManagedBy
        }
    }

}

extension SecurityHubClientTypes.StandardsControl: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlId = "ControlId"
        case controlStatus = "ControlStatus"
        case controlStatusUpdatedAt = "ControlStatusUpdatedAt"
        case description = "Description"
        case disabledReason = "DisabledReason"
        case relatedRequirements = "RelatedRequirements"
        case remediationUrl = "RemediationUrl"
        case severityRating = "SeverityRating"
        case standardsControlArn = "StandardsControlArn"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlId = self.controlId {
            try encodeContainer.encode(controlId, forKey: .controlId)
        }
        if let controlStatus = self.controlStatus {
            try encodeContainer.encode(controlStatus.rawValue, forKey: .controlStatus)
        }
        if let controlStatusUpdatedAt = self.controlStatusUpdatedAt {
            try encodeContainer.encodeTimestamp(controlStatusUpdatedAt, format: .dateTime, forKey: .controlStatusUpdatedAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disabledReason = self.disabledReason {
            try encodeContainer.encode(disabledReason, forKey: .disabledReason)
        }
        if let relatedRequirements = relatedRequirements {
            var relatedRequirementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedRequirements)
            for nonemptystring0 in relatedRequirements {
                try relatedRequirementsContainer.encode(nonemptystring0)
            }
        }
        if let remediationUrl = self.remediationUrl {
            try encodeContainer.encode(remediationUrl, forKey: .remediationUrl)
        }
        if let severityRating = self.severityRating {
            try encodeContainer.encode(severityRating.rawValue, forKey: .severityRating)
        }
        if let standardsControlArn = self.standardsControlArn {
            try encodeContainer.encode(standardsControlArn, forKey: .standardsControlArn)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsControlArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardsControlArn)
        standardsControlArn = standardsControlArnDecoded
        let controlStatusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ControlStatus.self, forKey: .controlStatus)
        controlStatus = controlStatusDecoded
        let disabledReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disabledReason)
        disabledReason = disabledReasonDecoded
        let controlStatusUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .controlStatusUpdatedAt)
        controlStatusUpdatedAt = controlStatusUpdatedAtDecoded
        let controlIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .controlId)
        controlId = controlIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let remediationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remediationUrl)
        remediationUrl = remediationUrlDecoded
        let severityRatingDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.SeverityRating.self, forKey: .severityRating)
        severityRating = severityRatingDecoded
        let relatedRequirementsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedRequirements)
        var relatedRequirementsDecoded0:[Swift.String]? = nil
        if let relatedRequirementsContainer = relatedRequirementsContainer {
            relatedRequirementsDecoded0 = [Swift.String]()
            for string0 in relatedRequirementsContainer {
                if let string0 = string0 {
                    relatedRequirementsDecoded0?.append(string0)
                }
            }
        }
        relatedRequirements = relatedRequirementsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Details for an individual security standard control.
    public struct StandardsControl: Swift.Equatable {
        /// The identifier of the security standard control.
        public var controlId: Swift.String?
        /// The current status of the security standard control. Indicates whether the control is enabled or disabled. Security Hub does not check against disabled controls.
        public var controlStatus: SecurityHubClientTypes.ControlStatus?
        /// The date and time that the status of the security standard control was most recently updated.
        public var controlStatusUpdatedAt: ClientRuntime.Date?
        /// The longer description of the security standard control. Provides information about what the control is checking for.
        public var description: Swift.String?
        /// The reason provided for the most recent change in status for the control.
        public var disabledReason: Swift.String?
        /// The list of requirements that are related to this control.
        public var relatedRequirements: [Swift.String]?
        /// A link to remediation information for the control in the Security Hub user documentation.
        public var remediationUrl: Swift.String?
        /// The severity of findings generated from this security standard control. The finding severity is based on an assessment of how easy it would be to compromise Amazon Web Services resources if the issue is detected.
        public var severityRating: SecurityHubClientTypes.SeverityRating?
        /// The ARN of the security standard control.
        public var standardsControlArn: Swift.String?
        /// The title of the security standard control.
        public var title: Swift.String?

        public init (
            controlId: Swift.String? = nil,
            controlStatus: SecurityHubClientTypes.ControlStatus? = nil,
            controlStatusUpdatedAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            disabledReason: Swift.String? = nil,
            relatedRequirements: [Swift.String]? = nil,
            remediationUrl: Swift.String? = nil,
            severityRating: SecurityHubClientTypes.SeverityRating? = nil,
            standardsControlArn: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.controlId = controlId
            self.controlStatus = controlStatus
            self.controlStatusUpdatedAt = controlStatusUpdatedAt
            self.description = description
            self.disabledReason = disabledReason
            self.relatedRequirements = relatedRequirements
            self.remediationUrl = remediationUrl
            self.severityRating = severityRating
            self.standardsControlArn = standardsControlArn
            self.title = title
        }
    }

}

extension SecurityHubClientTypes.StandardsManagedBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case company = "Company"
        case product = "Product"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let company = self.company {
            try encodeContainer.encode(company, forKey: .company)
        }
        if let product = self.product {
            try encodeContainer.encode(product, forKey: .product)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let companyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .company)
        company = companyDecoded
        let productDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .product)
        product = productDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the management of a security standard.
    public struct StandardsManagedBy: Swift.Equatable {
        /// An identifier for the company that manages a specific security standard. For existing standards, the value is equal to Amazon Web Services.
        public var company: Swift.String?
        /// An identifier for the product that manages a specific security standard. For existing standards, the value is equal to the Amazon Web Services service that manages the standard.
        public var product: Swift.String?

        public init (
            company: Swift.String? = nil,
            product: Swift.String? = nil
        )
        {
            self.company = company
            self.product = product
        }
    }

}

extension SecurityHubClientTypes {
    public enum StandardsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case failed
        case incomplete
        case pending
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [StandardsStatus] {
            return [
                .deleting,
                .failed,
                .incomplete,
                .pending,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .incomplete: return "INCOMPLETE"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StandardsStatus(rawValue: rawValue) ?? StandardsStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.StandardsStatusReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusReasonCode = "StatusReasonCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusReasonCode = self.statusReasonCode {
            try encodeContainer.encode(statusReasonCode.rawValue, forKey: .statusReasonCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusReasonCodeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.StatusReasonCode.self, forKey: .statusReasonCode)
        statusReasonCode = statusReasonCodeDecoded
    }
}

extension SecurityHubClientTypes {
    /// The reason for the current status of a standard subscription.
    public struct StandardsStatusReason: Swift.Equatable {
        /// The reason code that represents the reason for the current status of a standard subscription.
        /// This member is required.
        public var statusReasonCode: SecurityHubClientTypes.StatusReasonCode?

        public init (
            statusReasonCode: SecurityHubClientTypes.StatusReasonCode? = nil
        )
        {
            self.statusReasonCode = statusReasonCode
        }
    }

}

extension SecurityHubClientTypes.StandardsSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case standardsArn = "StandardsArn"
        case standardsInput = "StandardsInput"
        case standardsStatus = "StandardsStatus"
        case standardsStatusReason = "StandardsStatusReason"
        case standardsSubscriptionArn = "StandardsSubscriptionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let standardsArn = self.standardsArn {
            try encodeContainer.encode(standardsArn, forKey: .standardsArn)
        }
        if let standardsInput = standardsInput {
            var standardsInputContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .standardsInput)
            for (dictKey0, standardsInputParameterMap0) in standardsInput {
                try standardsInputContainer.encode(standardsInputParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let standardsStatus = self.standardsStatus {
            try encodeContainer.encode(standardsStatus.rawValue, forKey: .standardsStatus)
        }
        if let standardsStatusReason = self.standardsStatusReason {
            try encodeContainer.encode(standardsStatusReason, forKey: .standardsStatusReason)
        }
        if let standardsSubscriptionArn = self.standardsSubscriptionArn {
            try encodeContainer.encode(standardsSubscriptionArn, forKey: .standardsSubscriptionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsSubscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardsSubscriptionArn)
        standardsSubscriptionArn = standardsSubscriptionArnDecoded
        let standardsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardsArn)
        standardsArn = standardsArnDecoded
        let standardsInputContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .standardsInput)
        var standardsInputDecoded0: [Swift.String:Swift.String]? = nil
        if let standardsInputContainer = standardsInputContainer {
            standardsInputDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in standardsInputContainer {
                if let nonemptystring0 = nonemptystring0 {
                    standardsInputDecoded0?[key0] = nonemptystring0
                }
            }
        }
        standardsInput = standardsInputDecoded0
        let standardsStatusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.StandardsStatus.self, forKey: .standardsStatus)
        standardsStatus = standardsStatusDecoded
        let standardsStatusReasonDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.StandardsStatusReason.self, forKey: .standardsStatusReason)
        standardsStatusReason = standardsStatusReasonDecoded
    }
}

extension SecurityHubClientTypes {
    /// A resource that represents your subscription to a supported standard.
    public struct StandardsSubscription: Swift.Equatable {
        /// The ARN of a standard.
        /// This member is required.
        public var standardsArn: Swift.String?
        /// A key-value pair of input for the standard.
        /// This member is required.
        public var standardsInput: [Swift.String:Swift.String]?
        /// The status of the standard subscription. The status values are as follows:
        ///
        /// * PENDING - Standard is in the process of being enabled.
        ///
        /// * READY - Standard is enabled.
        ///
        /// * INCOMPLETE - Standard could not be enabled completely. Some controls may not be available.
        ///
        /// * DELETING - Standard is in the process of being disabled.
        ///
        /// * FAILED - Standard could not be disabled.
        /// This member is required.
        public var standardsStatus: SecurityHubClientTypes.StandardsStatus?
        /// The reason for the current status.
        public var standardsStatusReason: SecurityHubClientTypes.StandardsStatusReason?
        /// The ARN of a resource that represents your subscription to a supported standard.
        /// This member is required.
        public var standardsSubscriptionArn: Swift.String?

        public init (
            standardsArn: Swift.String? = nil,
            standardsInput: [Swift.String:Swift.String]? = nil,
            standardsStatus: SecurityHubClientTypes.StandardsStatus? = nil,
            standardsStatusReason: SecurityHubClientTypes.StandardsStatusReason? = nil,
            standardsSubscriptionArn: Swift.String? = nil
        )
        {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
            self.standardsStatus = standardsStatus
            self.standardsStatusReason = standardsStatusReason
            self.standardsSubscriptionArn = standardsSubscriptionArn
        }
    }

}

extension SecurityHubClientTypes.StandardsSubscriptionRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case standardsArn = "StandardsArn"
        case standardsInput = "StandardsInput"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let standardsArn = self.standardsArn {
            try encodeContainer.encode(standardsArn, forKey: .standardsArn)
        }
        if let standardsInput = standardsInput {
            var standardsInputContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .standardsInput)
            for (dictKey0, standardsInputParameterMap0) in standardsInput {
                try standardsInputContainer.encode(standardsInputParameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .standardsArn)
        standardsArn = standardsArnDecoded
        let standardsInputContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .standardsInput)
        var standardsInputDecoded0: [Swift.String:Swift.String]? = nil
        if let standardsInputContainer = standardsInputContainer {
            standardsInputDecoded0 = [Swift.String:Swift.String]()
            for (key0, nonemptystring0) in standardsInputContainer {
                if let nonemptystring0 = nonemptystring0 {
                    standardsInputDecoded0?[key0] = nonemptystring0
                }
            }
        }
        standardsInput = standardsInputDecoded0
    }
}

extension SecurityHubClientTypes {
    /// The standard that you want to enable.
    public struct StandardsSubscriptionRequest: Swift.Equatable {
        /// The ARN of the standard that you want to enable. To view the list of available standards and their ARNs, use the DescribeStandards operation.
        /// This member is required.
        public var standardsArn: Swift.String?
        /// A key-value pair of input for the standard.
        public var standardsInput: [Swift.String:Swift.String]?

        public init (
            standardsArn: Swift.String? = nil,
            standardsInput: [Swift.String:Swift.String]? = nil
        )
        {
            self.standardsArn = standardsArn
            self.standardsInput = standardsInput
        }
    }

}

extension SecurityHubClientTypes.StatelessCustomActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishMetricAction = "PublishMetricAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publishMetricAction = self.publishMetricAction {
            try encodeContainer.encode(publishMetricAction, forKey: .publishMetricAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishMetricActionDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.StatelessCustomPublishMetricAction.self, forKey: .publishMetricAction)
        publishMetricAction = publishMetricActionDecoded
    }
}

extension SecurityHubClientTypes {
    /// The definition of a custom action that can be used for stateless packet handling.
    public struct StatelessCustomActionDefinition: Swift.Equatable {
        /// Information about metrics to publish to CloudWatch.
        public var publishMetricAction: SecurityHubClientTypes.StatelessCustomPublishMetricAction?

        public init (
            publishMetricAction: SecurityHubClientTypes.StatelessCustomPublishMetricAction? = nil
        )
        {
            self.publishMetricAction = publishMetricAction
        }
    }

}

extension SecurityHubClientTypes.StatelessCustomPublishMetricAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for statelesscustompublishmetricactiondimension0 in dimensions {
                try dimensionsContainer.encode(statelesscustompublishmetricactiondimension0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Information about metrics to publish to CloudWatch.
    public struct StatelessCustomPublishMetricAction: Swift.Equatable {
        /// Defines CloudWatch dimension values to publish.
        public var dimensions: [SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension]?

        public init (
            dimensions: [SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension]? = nil
        )
        {
            self.dimensions = dimensions
        }
    }

}

extension SecurityHubClientTypes.StatelessCustomPublishMetricActionDimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SecurityHubClientTypes {
    /// Defines a CloudWatch dimension value to publish.
    public struct StatelessCustomPublishMetricActionDimension: Swift.Equatable {
        /// The value to use for the custom metric dimension.
        public var value: Swift.String?

        public init (
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension SecurityHubClientTypes.StatusReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case reasonCode = "ReasonCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let reasonCode = self.reasonCode {
            try encodeContainer.encode(reasonCode, forKey: .reasonCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides additional context for the value of Compliance.Status.
    public struct StatusReason: Swift.Equatable {
        /// The corresponding description for the status reason code.
        public var description: Swift.String?
        /// A code that represents a reason for the control status. For the list of status reason codes and their meanings, see [Standards-related information in the ASFF](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff) in the Security Hub User Guide.
        /// This member is required.
        public var reasonCode: Swift.String?

        public init (
            description: Swift.String? = nil,
            reasonCode: Swift.String? = nil
        )
        {
            self.description = description
            self.reasonCode = reasonCode
        }
    }

}

extension SecurityHubClientTypes {
    public enum StatusReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case noAvailableConfigurationRecorder
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusReasonCode] {
            return [
                .internalError,
                .noAvailableConfigurationRecorder,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .noAvailableConfigurationRecorder: return "NO_AVAILABLE_CONFIGURATION_RECORDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusReasonCode(rawValue: rawValue) ?? StatusReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.StringFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparison = "Comparison"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparison = self.comparison {
            try encodeContainer.encode(comparison.rawValue, forKey: .comparison)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let comparisonDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.StringFilterComparison.self, forKey: .comparison)
        comparison = comparisonDecoded
    }
}

extension SecurityHubClientTypes {
    /// A string filter for querying findings.
    public struct StringFilter: Swift.Equatable {
        /// The condition to apply to a string value when querying for findings. To search for values that contain the filter criteria value, use one of the following comparison operators:
        ///
        /// * To search for values that exactly match the filter value, use EQUALS. For example, the filter ResourceType EQUALS AwsEc2SecurityGroup only matches findings that have a resource type of AwsEc2SecurityGroup.
        ///
        /// * To search for values that start with the filter value, use PREFIX. For example, the filter ResourceType PREFIX AwsIam matches findings that have a resource type that starts with AwsIam. Findings with a resource type of AwsIamPolicy, AwsIamRole, or AwsIamUser would all match.
        ///
        ///
        /// EQUALS and PREFIX filters on the same field are joined by OR. A finding matches if it matches any one of those filters. To search for values that do not contain the filter criteria value, use one of the following comparison operators:
        ///
        /// * To search for values that do not exactly match the filter value, use NOT_EQUALS. For example, the filter ResourceType NOT_EQUALS AwsIamPolicy matches findings that have a resource type other than AwsIamPolicy.
        ///
        /// * To search for values that do not start with the filter value, use PREFIX_NOT_EQUALS. For example, the filter ResourceType PREFIX_NOT_EQUALS AwsIam matches findings that have a resource type that does not start with AwsIam. Findings with a resource type of AwsIamPolicy, AwsIamRole, or AwsIamUser would all be excluded from the results.
        ///
        ///
        /// NOT_EQUALS and PREFIX_NOT_EQUALS filters on the same field are joined by AND. A finding matches only if it matches all of those filters. For filters on the same field, you cannot provide both an EQUALS filter and a NOT_EQUALS or PREFIX_NOT_EQUALS filter. Combining filters in this way always returns an error, even if the provided filter values would return valid results. You can combine PREFIX filters with NOT_EQUALS or PREFIX_NOT_EQUALS filters for the same field. Security Hub first processes the PREFIX filters, then the NOT_EQUALS or PREFIX_NOT_EQUALS filters. For example, for the following filter, Security Hub first identifies findings that have resource types that start with either AwsIAM or AwsEc2. It then excludes findings that have a resource type of AwsIamPolicy and findings that have a resource type of AwsEc2NetworkInterface.
        ///
        /// * ResourceType PREFIX AwsIam
        ///
        /// * ResourceType PREFIX AwsEc2
        ///
        /// * ResourceType NOT_EQUALS AwsIamPolicy
        ///
        /// * ResourceType NOT_EQUALS AwsEc2NetworkInterface
        public var comparison: SecurityHubClientTypes.StringFilterComparison?
        /// The string filter value. Filter values are case sensitive. For example, the product name for control-based findings is Security Hub. If you provide security hub as the filter text, then there is no match.
        public var value: Swift.String?

        public init (
            comparison: SecurityHubClientTypes.StringFilterComparison? = nil,
            value: Swift.String? = nil
        )
        {
            self.comparison = comparison
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    public enum StringFilterComparison: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equals
        case notEquals
        case `prefix`
        case prefixNotEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [StringFilterComparison] {
            return [
                .equals,
                .notEquals,
                .prefix,
                .prefixNotEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .notEquals: return "NOT_EQUALS"
            case .prefix: return "PREFIX"
            case .prefixNotEquals: return "PREFIX_NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StringFilterComparison(rawValue: rawValue) ?? StringFilterComparison.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to apply the tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. You can add up to 50 tags at a time. The tag keys can be no longer than 128 characters. The tag values can be no longer than 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension SecurityHubClientTypes.Threat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePaths = "FilePaths"
        case itemCount = "ItemCount"
        case name = "Name"
        case severity = "Severity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePaths = filePaths {
            var filePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filePaths)
            for filepaths0 in filePaths {
                try filePathsContainer.encode(filepaths0)
            }
        }
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount) ?? 0
        itemCount = itemCountDecoded
        let filePathsContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.FilePaths?].self, forKey: .filePaths)
        var filePathsDecoded0:[SecurityHubClientTypes.FilePaths]? = nil
        if let filePathsContainer = filePathsContainer {
            filePathsDecoded0 = [SecurityHubClientTypes.FilePaths]()
            for structure0 in filePathsContainer {
                if let structure0 = structure0 {
                    filePathsDecoded0?.append(structure0)
                }
            }
        }
        filePaths = filePathsDecoded0
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the threat detected in a security finding and the file paths that were affected by the threat.
    public struct Threat: Swift.Equatable {
        /// Provides information about the file paths that were affected by the threat.
        public var filePaths: [SecurityHubClientTypes.FilePaths]?
        /// This total number of items in which the threat has been detected.
        public var itemCount: Swift.Int
        /// The name of the threat.
        public var name: Swift.String?
        /// The severity of the threat.
        public var severity: Swift.String?

        public init (
            filePaths: [SecurityHubClientTypes.FilePaths]? = nil,
            itemCount: Swift.Int = 0,
            name: Swift.String? = nil,
            severity: Swift.String? = nil
        )
        {
            self.filePaths = filePaths
            self.itemCount = itemCount
            self.name = name
            self.severity = severity
        }
    }

}

extension SecurityHubClientTypes.ThreatIntelIndicator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case lastObservedAt = "LastObservedAt"
        case source = "Source"
        case sourceUrl = "SourceUrl"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let lastObservedAt = self.lastObservedAt {
            try encodeContainer.encode(lastObservedAt, forKey: .lastObservedAt)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceUrl = self.sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ThreatIntelIndicatorType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ThreatIntelIndicatorCategory.self, forKey: .category)
        category = categoryDecoded
        let lastObservedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastObservedAt)
        lastObservedAt = lastObservedAtDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the threat intelligence related to a finding.
    public struct ThreatIntelIndicator: Swift.Equatable {
        /// The category of a threat intelligence indicator.
        public var category: SecurityHubClientTypes.ThreatIntelIndicatorCategory?
        /// Indicates when the most recent instance of a threat intelligence indicator was observed. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var lastObservedAt: Swift.String?
        /// The source of the threat intelligence indicator.
        public var source: Swift.String?
        /// The URL to the page or site where you can get more information about the threat intelligence indicator.
        public var sourceUrl: Swift.String?
        /// The type of threat intelligence indicator.
        public var type: SecurityHubClientTypes.ThreatIntelIndicatorType?
        /// The value of a threat intelligence indicator.
        public var value: Swift.String?

        public init (
            category: SecurityHubClientTypes.ThreatIntelIndicatorCategory? = nil,
            lastObservedAt: Swift.String? = nil,
            source: Swift.String? = nil,
            sourceUrl: Swift.String? = nil,
            type: SecurityHubClientTypes.ThreatIntelIndicatorType? = nil,
            value: Swift.String? = nil
        )
        {
            self.category = category
            self.lastObservedAt = lastObservedAt
            self.source = source
            self.sourceUrl = sourceUrl
            self.type = type
            self.value = value
        }
    }

}

extension SecurityHubClientTypes {
    public enum ThreatIntelIndicatorCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backdoor
        case cardStealer
        case commandAndControl
        case dropSite
        case exploitSite
        case keylogger
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelIndicatorCategory] {
            return [
                .backdoor,
                .cardStealer,
                .commandAndControl,
                .dropSite,
                .exploitSite,
                .keylogger,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backdoor: return "BACKDOOR"
            case .cardStealer: return "CARD_STEALER"
            case .commandAndControl: return "COMMAND_AND_CONTROL"
            case .dropSite: return "DROP_SITE"
            case .exploitSite: return "EXPLOIT_SITE"
            case .keylogger: return "KEYLOGGER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThreatIntelIndicatorCategory(rawValue: rawValue) ?? ThreatIntelIndicatorCategory.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes {
    public enum ThreatIntelIndicatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domain
        case emailAddress
        case hashMd5
        case hashSha1
        case hashSha256
        case hashSha512
        case ipv4Address
        case ipv6Address
        case mutex
        case process
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelIndicatorType] {
            return [
                .domain,
                .emailAddress,
                .hashMd5,
                .hashSha1,
                .hashSha256,
                .hashSha512,
                .ipv4Address,
                .ipv6Address,
                .mutex,
                .process,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domain: return "DOMAIN"
            case .emailAddress: return "EMAIL_ADDRESS"
            case .hashMd5: return "HASH_MD5"
            case .hashSha1: return "HASH_SHA1"
            case .hashSha256: return "HASH_SHA256"
            case .hashSha512: return "HASH_SHA512"
            case .ipv4Address: return "IPV4_ADDRESS"
            case .ipv6Address: return "IPV6_ADDRESS"
            case .mutex: return "MUTEX"
            case .process: return "PROCESS"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThreatIntelIndicatorType(rawValue: rawValue) ?? ThreatIntelIndicatorType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to remove the tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys associated with the tags to remove from the resource. You can remove up to 50 tags at a time.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateActionTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateActionTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let actionTargetArn = actionTargetArn else {
            return nil
        }
        return "/actionTargets/\(actionTargetArn)"
    }
}

public struct UpdateActionTargetInput: Swift.Equatable {
    /// The ARN of the custom action target to update.
    /// This member is required.
    public var actionTargetArn: Swift.String?
    /// The updated description for the custom action target.
    public var description: Swift.String?
    /// The updated name of the custom action target.
    public var name: Swift.String?

    public init (
        actionTargetArn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.actionTargetArn = actionTargetArn
        self.description = description
        self.name = name
    }
}

struct UpdateActionTargetInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateActionTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateActionTargetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateActionTargetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateActionTargetOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateActionTargetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateActionTargetOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateFindingAggregatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingAggregatorArn = "FindingAggregatorArn"
        case regionLinkingMode = "RegionLinkingMode"
        case regions = "Regions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingAggregatorArn = self.findingAggregatorArn {
            try encodeContainer.encode(findingAggregatorArn, forKey: .findingAggregatorArn)
        }
        if let regionLinkingMode = self.regionLinkingMode {
            try encodeContainer.encode(regionLinkingMode, forKey: .regionLinkingMode)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for nonemptystring0 in regions {
                try regionsContainer.encode(nonemptystring0)
            }
        }
    }
}

extension UpdateFindingAggregatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findingAggregator/update"
    }
}

public struct UpdateFindingAggregatorInput: Swift.Equatable {
    /// The ARN of the finding aggregator. To obtain the ARN, use ListFindingAggregators.
    /// This member is required.
    public var findingAggregatorArn: Swift.String?
    /// Indicates whether to aggregate findings from all of the available Regions in the current partition. Also determines whether to automatically aggregate findings from new Regions as Security Hub supports them and you opt into them. The selected option also determines how to use the Regions provided in the Regions list. The options are as follows:
    ///
    /// * ALL_REGIONS - Indicates to aggregate findings from all of the Regions where Security Hub is enabled. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.
    ///
    /// * ALL_REGIONS_EXCEPT_SPECIFIED - Indicates to aggregate findings from all of the Regions where Security Hub is enabled, except for the Regions listed in the Regions parameter. When you choose this option, Security Hub also automatically aggregates findings from new Regions as Security Hub supports them and you opt into them.
    ///
    /// * SPECIFIED_REGIONS - Indicates to aggregate findings only from the Regions listed in the Regions parameter. Security Hub does not automatically aggregate findings from new Regions.
    /// This member is required.
    public var regionLinkingMode: Swift.String?
    /// If RegionLinkingMode is ALL_REGIONS_EXCEPT_SPECIFIED, then this is a space-separated list of Regions that do not aggregate findings to the aggregation Region. If RegionLinkingMode is SPECIFIED_REGIONS, then this is a space-separated list of Regions that do aggregate findings to the aggregation Region.
    public var regions: [Swift.String]?

    public init (
        findingAggregatorArn: Swift.String? = nil,
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.findingAggregatorArn = findingAggregatorArn
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

struct UpdateFindingAggregatorInputBody: Swift.Equatable {
    let findingAggregatorArn: Swift.String?
    let regionLinkingMode: Swift.String?
    let regions: [Swift.String]?
}

extension UpdateFindingAggregatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingAggregatorArn = "FindingAggregatorArn"
        case regionLinkingMode = "RegionLinkingMode"
        case regions = "Regions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingAggregatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingAggregatorArn)
        findingAggregatorArn = findingAggregatorArnDecoded
        let regionLinkingModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionLinkingMode)
        regionLinkingMode = regionLinkingModeDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension UpdateFindingAggregatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingAggregatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFindingAggregatorOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingAggregatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateFindingAggregatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingAggregationRegion = output.findingAggregationRegion
            self.findingAggregatorArn = output.findingAggregatorArn
            self.regionLinkingMode = output.regionLinkingMode
            self.regions = output.regions
        } else {
            self.findingAggregationRegion = nil
            self.findingAggregatorArn = nil
            self.regionLinkingMode = nil
            self.regions = nil
        }
    }
}

public struct UpdateFindingAggregatorOutputResponse: Swift.Equatable {
    /// The aggregation Region.
    public var findingAggregationRegion: Swift.String?
    /// The ARN of the finding aggregator.
    public var findingAggregatorArn: Swift.String?
    /// Indicates whether to link all Regions, all Regions except for a list of excluded Regions, or a list of included Regions.
    public var regionLinkingMode: Swift.String?
    /// The list of excluded Regions or included Regions.
    public var regions: [Swift.String]?

    public init (
        findingAggregationRegion: Swift.String? = nil,
        findingAggregatorArn: Swift.String? = nil,
        regionLinkingMode: Swift.String? = nil,
        regions: [Swift.String]? = nil
    )
    {
        self.findingAggregationRegion = findingAggregationRegion
        self.findingAggregatorArn = findingAggregatorArn
        self.regionLinkingMode = regionLinkingMode
        self.regions = regions
    }
}

struct UpdateFindingAggregatorOutputResponseBody: Swift.Equatable {
    let findingAggregatorArn: Swift.String?
    let findingAggregationRegion: Swift.String?
    let regionLinkingMode: Swift.String?
    let regions: [Swift.String]?
}

extension UpdateFindingAggregatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingAggregationRegion = "FindingAggregationRegion"
        case findingAggregatorArn = "FindingAggregatorArn"
        case regionLinkingMode = "RegionLinkingMode"
        case regions = "Regions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingAggregatorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingAggregatorArn)
        findingAggregatorArn = findingAggregatorArnDecoded
        let findingAggregationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingAggregationRegion)
        findingAggregationRegion = findingAggregationRegionDecoded
        let regionLinkingModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionLinkingMode)
        regionLinkingMode = regionLinkingModeDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension UpdateFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case note = "Note"
        case recordState = "RecordState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let recordState = self.recordState {
            try encodeContainer.encode(recordState.rawValue, forKey: .recordState)
        }
    }
}

extension UpdateFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/findings"
    }
}

public struct UpdateFindingsInput: Swift.Equatable {
    /// A collection of attributes that specify which findings you want to update.
    /// This member is required.
    public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    /// The updated note for the finding.
    public var note: SecurityHubClientTypes.NoteUpdate?
    /// The updated record state for the finding.
    public var recordState: SecurityHubClientTypes.RecordState?

    public init (
        filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
        note: SecurityHubClientTypes.NoteUpdate? = nil,
        recordState: SecurityHubClientTypes.RecordState? = nil
    )
    {
        self.filters = filters
        self.note = note
        self.recordState = recordState
    }
}

struct UpdateFindingsInputBody: Swift.Equatable {
    let filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    let note: SecurityHubClientTypes.NoteUpdate?
    let recordState: SecurityHubClientTypes.RecordState?
}

extension UpdateFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case note = "Note"
        case recordState = "RecordState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let noteDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.NoteUpdate.self, forKey: .note)
        note = noteDecoded
        let recordStateDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.RecordState.self, forKey: .recordState)
        recordState = recordStateDecoded
    }
}

extension UpdateFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFindingsOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFindingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateInsightInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let groupByAttribute = self.groupByAttribute {
            try encodeContainer.encode(groupByAttribute, forKey: .groupByAttribute)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateInsightInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let insightArn = insightArn else {
            return nil
        }
        return "/insights/\(insightArn)"
    }
}

public struct UpdateInsightInput: Swift.Equatable {
    /// The updated filters that define this insight.
    public var filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    /// The updated GroupBy attribute that defines this insight.
    public var groupByAttribute: Swift.String?
    /// The ARN of the insight that you want to update.
    /// This member is required.
    public var insightArn: Swift.String?
    /// The updated name for the insight.
    public var name: Swift.String?

    public init (
        filters: SecurityHubClientTypes.AwsSecurityFindingFilters? = nil,
        groupByAttribute: Swift.String? = nil,
        insightArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.filters = filters
        self.groupByAttribute = groupByAttribute
        self.insightArn = insightArn
        self.name = name
    }
}

struct UpdateInsightInputBody: Swift.Equatable {
    let name: Swift.String?
    let filters: SecurityHubClientTypes.AwsSecurityFindingFilters?
    let groupByAttribute: Swift.String?
}

extension UpdateInsightInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case groupByAttribute = "GroupByAttribute"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AwsSecurityFindingFilters.self, forKey: .filters)
        filters = filtersDecoded
        let groupByAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupByAttribute)
        groupByAttribute = groupByAttributeDecoded
    }
}

extension UpdateInsightOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInsightOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateInsightOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInsightOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInsightOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "AutoEnable"
        case autoEnableStandards = "AutoEnableStandards"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
        if let autoEnableStandards = self.autoEnableStandards {
            try encodeContainer.encode(autoEnableStandards.rawValue, forKey: .autoEnableStandards)
        }
    }
}

extension UpdateOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/organization/configuration"
    }
}

public struct UpdateOrganizationConfigurationInput: Swift.Equatable {
    /// Whether to automatically enable Security Hub for new accounts in the organization. By default, this is false, and new accounts are not added automatically. To automatically enable Security Hub for new accounts, set this to true.
    /// This member is required.
    public var autoEnable: Swift.Bool
    /// Whether to automatically enable Security Hub [default standards](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-enable-disable.html) for new member accounts in the organization. By default, this parameter is equal to DEFAULT, and new member accounts are automatically enabled with default Security Hub standards. To opt out of enabling default standards for new member accounts, set this parameter equal to NONE.
    public var autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards?

    public init (
        autoEnable: Swift.Bool = false,
        autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards? = nil
    )
    {
        self.autoEnable = autoEnable
        self.autoEnableStandards = autoEnableStandards
    }
}

struct UpdateOrganizationConfigurationInputBody: Swift.Equatable {
    let autoEnable: Swift.Bool
    let autoEnableStandards: SecurityHubClientTypes.AutoEnableStandards?
}

extension UpdateOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "AutoEnable"
        case autoEnableStandards = "AutoEnableStandards"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
        let autoEnableStandardsDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.AutoEnableStandards.self, forKey: .autoEnableStandards)
        autoEnableStandards = autoEnableStandardsDecoded
    }
}

extension UpdateOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOrganizationConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateSecurityHubConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnableControls = "AutoEnableControls"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnableControls != false {
            try encodeContainer.encode(autoEnableControls, forKey: .autoEnableControls)
        }
    }
}

extension UpdateSecurityHubConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accounts"
    }
}

public struct UpdateSecurityHubConfigurationInput: Swift.Equatable {
    /// Whether to automatically enable new controls when they are added to standards that are enabled. By default, this is set to true, and new controls are enabled automatically. To not automatically enable new controls, set this to false.
    public var autoEnableControls: Swift.Bool

    public init (
        autoEnableControls: Swift.Bool = false
    )
    {
        self.autoEnableControls = autoEnableControls
    }
}

struct UpdateSecurityHubConfigurationInputBody: Swift.Equatable {
    let autoEnableControls: Swift.Bool
}

extension UpdateSecurityHubConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnableControls = "AutoEnableControls"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableControlsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnableControls) ?? false
        autoEnableControls = autoEnableControlsDecoded
    }
}

extension UpdateSecurityHubConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSecurityHubConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSecurityHubConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSecurityHubConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSecurityHubConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateStandardsControlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlStatus = "ControlStatus"
        case disabledReason = "DisabledReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controlStatus = self.controlStatus {
            try encodeContainer.encode(controlStatus.rawValue, forKey: .controlStatus)
        }
        if let disabledReason = self.disabledReason {
            try encodeContainer.encode(disabledReason, forKey: .disabledReason)
        }
    }
}

extension UpdateStandardsControlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let standardsControlArn = standardsControlArn else {
            return nil
        }
        return "/standards/control/\(standardsControlArn)"
    }
}

public struct UpdateStandardsControlInput: Swift.Equatable {
    /// The updated status of the security standard control.
    public var controlStatus: SecurityHubClientTypes.ControlStatus?
    /// A description of the reason why you are disabling a security standard control. If you are disabling a control, then this is required.
    public var disabledReason: Swift.String?
    /// The ARN of the security standard control to enable or disable.
    /// This member is required.
    public var standardsControlArn: Swift.String?

    public init (
        controlStatus: SecurityHubClientTypes.ControlStatus? = nil,
        disabledReason: Swift.String? = nil,
        standardsControlArn: Swift.String? = nil
    )
    {
        self.controlStatus = controlStatus
        self.disabledReason = disabledReason
        self.standardsControlArn = standardsControlArn
    }
}

struct UpdateStandardsControlInputBody: Swift.Equatable {
    let controlStatus: SecurityHubClientTypes.ControlStatus?
    let disabledReason: Swift.String?
}

extension UpdateStandardsControlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case controlStatus = "ControlStatus"
        case disabledReason = "DisabledReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlStatusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.ControlStatus.self, forKey: .controlStatus)
        controlStatus = controlStatusDecoded
        let disabledReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disabledReason)
        disabledReason = disabledReasonDecoded
    }
}

extension UpdateStandardsControlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStandardsControlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccessException" : self = .invalidAccessException(try InvalidAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateStandardsControlOutputError: Swift.Error, Swift.Equatable {
    case internalException(InternalException)
    case invalidAccessException(InvalidAccessException)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStandardsControlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateStandardsControlOutputResponse: Swift.Equatable {

    public init () { }
}

extension SecurityHubClientTypes {
    public enum VerificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case benignPositive
        case falsePositive
        case truePositive
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationState] {
            return [
                .benignPositive,
                .falsePositive,
                .truePositive,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .benignPositive: return "BENIGN_POSITIVE"
            case .falsePositive: return "FALSE_POSITIVE"
            case .truePositive: return "TRUE_POSITIVE"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VerificationState(rawValue: rawValue) ?? VerificationState.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.VolumeMount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mountPath = "MountPath"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mountPath = self.mountPath {
            try encodeContainer.encode(mountPath, forKey: .mountPath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mountPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPath)
        mountPath = mountPathDecoded
    }
}

extension SecurityHubClientTypes {
    /// Describes the mounting of a volume in a container.
    public struct VolumeMount: Swift.Equatable {
        /// The path in the container at which the volume should be mounted.
        public var mountPath: Swift.String?
        /// The name of the volume.
        public var name: Swift.String?

        public init (
            mountPath: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.mountPath = mountPath
            self.name = name
        }
    }

}

extension SecurityHubClientTypes.VpcInfoCidrBlockSetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrBlock = "CidrBlock"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrBlock = self.cidrBlock {
            try encodeContainer.encode(cidrBlock, forKey: .cidrBlock)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the IPv4 CIDR blocks for the VPC.
    public struct VpcInfoCidrBlockSetDetails: Swift.Equatable {
        /// The IPv4 CIDR block for the VPC.
        public var cidrBlock: Swift.String?

        public init (
            cidrBlock: Swift.String? = nil
        )
        {
            self.cidrBlock = cidrBlock
        }
    }

}

extension SecurityHubClientTypes.VpcInfoIpv6CidrBlockSetDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv6CidrBlock = "Ipv6CidrBlock"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6CidrBlock = self.ipv6CidrBlock {
            try encodeContainer.encode(ipv6CidrBlock, forKey: .ipv6CidrBlock)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv6CidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6CidrBlock)
        ipv6CidrBlock = ipv6CidrBlockDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides details about the IPv6 CIDR blocks for the VPC.
    public struct VpcInfoIpv6CidrBlockSetDetails: Swift.Equatable {
        /// The IPv6 CIDR block for the VPC.
        public var ipv6CidrBlock: Swift.String?

        public init (
            ipv6CidrBlock: Swift.String? = nil
        )
        {
            self.ipv6CidrBlock = ipv6CidrBlock
        }
    }

}

extension SecurityHubClientTypes.VpcInfoPeeringOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowDnsResolutionFromRemoteVpc = "AllowDnsResolutionFromRemoteVpc"
        case allowEgressFromLocalClassicLinkToRemoteVpc = "AllowEgressFromLocalClassicLinkToRemoteVpc"
        case allowEgressFromLocalVpcToRemoteClassicLink = "AllowEgressFromLocalVpcToRemoteClassicLink"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowDnsResolutionFromRemoteVpc != false {
            try encodeContainer.encode(allowDnsResolutionFromRemoteVpc, forKey: .allowDnsResolutionFromRemoteVpc)
        }
        if allowEgressFromLocalClassicLinkToRemoteVpc != false {
            try encodeContainer.encode(allowEgressFromLocalClassicLinkToRemoteVpc, forKey: .allowEgressFromLocalClassicLinkToRemoteVpc)
        }
        if allowEgressFromLocalVpcToRemoteClassicLink != false {
            try encodeContainer.encode(allowEgressFromLocalVpcToRemoteClassicLink, forKey: .allowEgressFromLocalVpcToRemoteClassicLink)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowDnsResolutionFromRemoteVpcDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowDnsResolutionFromRemoteVpc) ?? false
        allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpcDecoded
        let allowEgressFromLocalClassicLinkToRemoteVpcDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowEgressFromLocalClassicLinkToRemoteVpc) ?? false
        allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpcDecoded
        let allowEgressFromLocalVpcToRemoteClassicLinkDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowEgressFromLocalVpcToRemoteClassicLink) ?? false
        allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLinkDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the VPC peering connection options for the accepter or requester VPC.
    public struct VpcInfoPeeringOptionsDetails: Swift.Equatable {
        /// Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.
        public var allowDnsResolutionFromRemoteVpc: Swift.Bool
        /// Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.
        public var allowEgressFromLocalClassicLinkToRemoteVpc: Swift.Bool
        /// Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.
        public var allowEgressFromLocalVpcToRemoteClassicLink: Swift.Bool

        public init (
            allowDnsResolutionFromRemoteVpc: Swift.Bool = false,
            allowEgressFromLocalClassicLinkToRemoteVpc: Swift.Bool = false,
            allowEgressFromLocalVpcToRemoteClassicLink: Swift.Bool = false
        )
        {
            self.allowDnsResolutionFromRemoteVpc = allowDnsResolutionFromRemoteVpc
            self.allowEgressFromLocalClassicLinkToRemoteVpc = allowEgressFromLocalClassicLinkToRemoteVpc
            self.allowEgressFromLocalVpcToRemoteClassicLink = allowEgressFromLocalVpcToRemoteClassicLink
        }
    }

}

extension SecurityHubClientTypes.Vulnerability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cvss = "Cvss"
        case fixAvailable = "FixAvailable"
        case id = "Id"
        case referenceUrls = "ReferenceUrls"
        case relatedVulnerabilities = "RelatedVulnerabilities"
        case vendor = "Vendor"
        case vulnerablePackages = "VulnerablePackages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cvss = cvss {
            var cvssContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cvss)
            for cvss0 in cvss {
                try cvssContainer.encode(cvss0)
            }
        }
        if let fixAvailable = self.fixAvailable {
            try encodeContainer.encode(fixAvailable.rawValue, forKey: .fixAvailable)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for nonemptystring0 in referenceUrls {
                try referenceUrlsContainer.encode(nonemptystring0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for nonemptystring0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(nonemptystring0)
            }
        }
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
        if let vulnerablePackages = vulnerablePackages {
            var vulnerablePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerablePackages)
            for softwarepackage0 in vulnerablePackages {
                try vulnerablePackagesContainer.encode(softwarepackage0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let vulnerablePackagesContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.SoftwarePackage?].self, forKey: .vulnerablePackages)
        var vulnerablePackagesDecoded0:[SecurityHubClientTypes.SoftwarePackage]? = nil
        if let vulnerablePackagesContainer = vulnerablePackagesContainer {
            vulnerablePackagesDecoded0 = [SecurityHubClientTypes.SoftwarePackage]()
            for structure0 in vulnerablePackagesContainer {
                if let structure0 = structure0 {
                    vulnerablePackagesDecoded0?.append(structure0)
                }
            }
        }
        vulnerablePackages = vulnerablePackagesDecoded0
        let cvssContainer = try containerValues.decodeIfPresent([SecurityHubClientTypes.Cvss?].self, forKey: .cvss)
        var cvssDecoded0:[SecurityHubClientTypes.Cvss]? = nil
        if let cvssContainer = cvssContainer {
            cvssDecoded0 = [SecurityHubClientTypes.Cvss]()
            for structure0 in cvssContainer {
                if let structure0 = structure0 {
                    cvssDecoded0?.append(structure0)
                }
            }
        }
        cvss = cvssDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Swift.String]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Swift.String]()
            for string0 in relatedVulnerabilitiesContainer {
                if let string0 = string0 {
                    relatedVulnerabilitiesDecoded0?.append(string0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let vendorDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.VulnerabilityVendor.self, forKey: .vendor)
        vendor = vendorDecoded
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
        let fixAvailableDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.VulnerabilityFixAvailable.self, forKey: .fixAvailable)
        fixAvailable = fixAvailableDecoded
    }
}

extension SecurityHubClientTypes {
    /// A vulnerability associated with a finding.
    public struct Vulnerability: Swift.Equatable {
        /// CVSS scores from the advisory related to the vulnerability.
        public var cvss: [SecurityHubClientTypes.Cvss]?
        /// Specifies if all vulnerable packages in a finding have a value for FixedInVersion and Remediation. This field is evaluated for each vulnerability Id based on the number of vulnerable packages that have a value for both FixedInVersion and Remediation. Valid values are as follows:
        ///
        /// * YES if all vulnerable packages have a value for both FixedInVersion and Remediation
        ///
        /// * NO if no vulnerable packages have a value for FixedInVersion and Remediation
        ///
        /// * PARTIAL otherwise
        public var fixAvailable: SecurityHubClientTypes.VulnerabilityFixAvailable?
        /// The identifier of the vulnerability.
        /// This member is required.
        public var id: Swift.String?
        /// A list of URLs that provide additional information about the vulnerability.
        public var referenceUrls: [Swift.String]?
        /// List of vulnerabilities that are related to this vulnerability.
        public var relatedVulnerabilities: [Swift.String]?
        /// Information about the vendor that generates the vulnerability report.
        public var vendor: SecurityHubClientTypes.VulnerabilityVendor?
        /// List of software packages that have the vulnerability.
        public var vulnerablePackages: [SecurityHubClientTypes.SoftwarePackage]?

        public init (
            cvss: [SecurityHubClientTypes.Cvss]? = nil,
            fixAvailable: SecurityHubClientTypes.VulnerabilityFixAvailable? = nil,
            id: Swift.String? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            vendor: SecurityHubClientTypes.VulnerabilityVendor? = nil,
            vulnerablePackages: [SecurityHubClientTypes.SoftwarePackage]? = nil
        )
        {
            self.cvss = cvss
            self.fixAvailable = fixAvailable
            self.id = id
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.vendor = vendor
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

extension SecurityHubClientTypes {
    public enum VulnerabilityFixAvailable: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case partial
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [VulnerabilityFixAvailable] {
            return [
                .no,
                .partial,
                .yes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .partial: return "PARTIAL"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VulnerabilityFixAvailable(rawValue: rawValue) ?? VulnerabilityFixAvailable.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.VulnerabilityVendor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case url = "Url"
        case vendorCreatedAt = "VendorCreatedAt"
        case vendorSeverity = "VendorSeverity"
        case vendorUpdatedAt = "VendorUpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let vendorCreatedAt = self.vendorCreatedAt {
            try encodeContainer.encode(vendorCreatedAt, forKey: .vendorCreatedAt)
        }
        if let vendorSeverity = self.vendorSeverity {
            try encodeContainer.encode(vendorSeverity, forKey: .vendorSeverity)
        }
        if let vendorUpdatedAt = self.vendorUpdatedAt {
            try encodeContainer.encode(vendorUpdatedAt, forKey: .vendorUpdatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let vendorSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorSeverity)
        vendorSeverity = vendorSeverityDecoded
        let vendorCreatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorCreatedAt)
        vendorCreatedAt = vendorCreatedAtDecoded
        let vendorUpdatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorUpdatedAt)
        vendorUpdatedAt = vendorUpdatedAtDecoded
    }
}

extension SecurityHubClientTypes {
    /// A vendor that generates a vulnerability report.
    public struct VulnerabilityVendor: Swift.Equatable {
        /// The name of the vendor.
        /// This member is required.
        public var name: Swift.String?
        /// The URL of the vulnerability advisory.
        public var url: Swift.String?
        /// Indicates when the vulnerability advisory was created. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var vendorCreatedAt: Swift.String?
        /// The severity that the vendor assigned to the vulnerability.
        public var vendorSeverity: Swift.String?
        /// Indicates when the vulnerability advisory was last updated. Uses the date-time format specified in [RFC 3339 section 5.6, Internet Date/Time Format](https://tools.ietf.org/html/rfc3339#section-5.6). The value cannot contain spaces. For example, 2020-03-22T13:22:13.933Z.
        public var vendorUpdatedAt: Swift.String?

        public init (
            name: Swift.String? = nil,
            url: Swift.String? = nil,
            vendorCreatedAt: Swift.String? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: Swift.String? = nil
        )
        {
            self.name = name
            self.url = url
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
        }
    }

}

extension SecurityHubClientTypes.WafAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about the action that CloudFront or WAF takes when a web request matches the conditions in the rule.
    public struct WafAction: Swift.Equatable {
        /// Specifies how you want WAF to respond to requests that match the settings in a rule. Valid settings include the following:
        ///
        /// * ALLOW - WAF allows requests
        ///
        /// * BLOCK - WAF blocks requests
        ///
        /// * COUNT - WAF increments a counter of the requests that match all of the conditions in the rule. WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify COUNT for the default action for a web ACL.
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.WafExcludedRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about a rule to exclude from a rule group.
    public struct WafExcludedRule: Swift.Equatable {
        /// The unique identifier for the rule to exclude from the rule group.
        public var ruleId: Swift.String?

        public init (
            ruleId: Swift.String? = nil
        )
        {
            self.ruleId = ruleId
        }
    }

}

extension SecurityHubClientTypes.WafOverrideAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension SecurityHubClientTypes {
    /// Details about an override action for a rule.
    public struct WafOverrideAction: Swift.Equatable {
        /// COUNT overrides the action specified by the individual rule within a RuleGroup . If set to NONE, the rule's action takes place.
        public var type: Swift.String?

        public init (
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension SecurityHubClientTypes.Workflow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Provides information about the status of the investigation into a finding.
    public struct Workflow: Swift.Equatable {
        /// The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to SUPPRESSED or RESOLVED does not prevent a new finding for the same issue. The allowed values are the following.
        ///
        /// * NEW - The initial state of a finding, before it is reviewed. Security Hub also resets the workflow status from NOTIFIED or RESOLVED to NEW in the following cases:
        ///
        /// * RecordState changes from ARCHIVED to ACTIVE.
        ///
        /// * ComplianceStatus changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.
        ///
        ///
        ///
        ///
        /// * NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.
        ///
        /// * SUPPRESSED - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.
        ///
        /// * RESOLVED - The finding was reviewed and remediated and is now considered resolved.
        public var status: SecurityHubClientTypes.WorkflowStatus?

        public init (
            status: SecurityHubClientTypes.WorkflowStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension SecurityHubClientTypes {
    @available(*, deprecated, message: "This filter is deprecated. Instead, use SeverityLabel or FindingProviderFieldsSeverityLabel.")
    public enum WorkflowState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assigned
        case deferred
        case inProgress
        case new
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowState] {
            return [
                .assigned,
                .deferred,
                .inProgress,
                .new,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .deferred: return "DEFERRED"
            case .inProgress: return "IN_PROGRESS"
            case .new: return "NEW"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowState(rawValue: rawValue) ?? WorkflowState.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes {
    public enum WorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case new
        case notified
        case resolved
        case suppressed
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStatus] {
            return [
                .new,
                .notified,
                .resolved,
                .suppressed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .new: return "NEW"
            case .notified: return "NOTIFIED"
            case .resolved: return "RESOLVED"
            case .suppressed: return "SUPPRESSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowStatus(rawValue: rawValue) ?? WorkflowStatus.sdkUnknown(rawValue)
        }
    }
}

extension SecurityHubClientTypes.WorkflowUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SecurityHubClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityHubClientTypes {
    /// Used to update information about the investigation into the finding.
    public struct WorkflowUpdate: Swift.Equatable {
        /// The status of the investigation into the finding. The workflow status is specific to an individual finding. It does not affect the generation of new findings. For example, setting the workflow status to SUPPRESSED or RESOLVED does not prevent a new finding for the same issue. The allowed values are the following.
        ///
        /// * NEW - The initial state of a finding, before it is reviewed. Security Hub also resets WorkFlowStatus from NOTIFIED or RESOLVED to NEW in the following cases:
        ///
        /// * The record state changes from ARCHIVED to ACTIVE.
        ///
        /// * The compliance status changes from PASSED to either WARNING, FAILED, or NOT_AVAILABLE.
        ///
        ///
        ///
        ///
        /// * NOTIFIED - Indicates that you notified the resource owner about the security issue. Used when the initial reviewer is not the resource owner, and needs intervention from the resource owner.
        ///
        /// * RESOLVED - The finding was reviewed and remediated and is now considered resolved.
        ///
        /// * SUPPRESSED - Indicates that you reviewed the finding and do not believe that any action is needed. The finding is no longer updated.
        public var status: SecurityHubClientTypes.WorkflowStatus?

        public init (
            status: SecurityHubClientTypes.WorkflowStatus? = nil
        )
        {
            self.status = status
        }
    }

}
