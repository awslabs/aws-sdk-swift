// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because the calling identity doesn't have the minimum required permissions.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountClientTypes.AlternateContact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateContactType = "AlternateContactType"
        case emailAddress = "EmailAddress"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alternateContactType = self.alternateContactType {
            try encodeContainer.encode(alternateContactType.rawValue, forKey: .alternateContactType)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let alternateContactTypeDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContactType.self, forKey: .alternateContactType)
        alternateContactType = alternateContactTypeDecoded
    }
}

extension AccountClientTypes.AlternateContact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AlternateContact(alternateContactType: \(Swift.String(describing: alternateContactType)), emailAddress: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

extension AccountClientTypes {
    /// A structure that contains the details of an alternate contact associated with an Amazon Web Services account
    public struct AlternateContact: Swift.Equatable {
        /// The type of alternate contact.
        public var alternateContactType: AccountClientTypes.AlternateContactType?
        /// The email address associated with this alternate contact.
        public var emailAddress: Swift.String?
        /// The name associated with this alternate contact.
        public var name: Swift.String?
        /// The phone number associated with this alternate contact.
        public var phoneNumber: Swift.String?
        /// The title associated with this alternate contact.
        public var title: Swift.String?

        public init (
            alternateContactType: AccountClientTypes.AlternateContactType? = nil,
            emailAddress: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.alternateContactType = alternateContactType
            self.emailAddress = emailAddress
            self.name = name
            self.phoneNumber = phoneNumber
            self.title = title
        }
    }

}

extension AccountClientTypes {
    public enum AlternateContactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case billing
        case operations
        case security
        case sdkUnknown(Swift.String)

        public static var allCases: [AlternateContactType] {
            return [
                .billing,
                .operations,
                .security,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .billing: return "BILLING"
            case .operations: return "OPERATIONS"
            case .security: return "SECURITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AlternateContactType(rawValue: rawValue) ?? AlternateContactType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of a conflict in the current status of the resource. For example, this happens if you try to enable a Region that is currently being disabled (in a status of DISABLING).
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountClientTypes.ContactInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressLine1 = "AddressLine1"
        case addressLine2 = "AddressLine2"
        case addressLine3 = "AddressLine3"
        case city = "City"
        case companyName = "CompanyName"
        case countryCode = "CountryCode"
        case districtOrCounty = "DistrictOrCounty"
        case fullName = "FullName"
        case phoneNumber = "PhoneNumber"
        case postalCode = "PostalCode"
        case stateOrRegion = "StateOrRegion"
        case websiteUrl = "WebsiteUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressLine1 = self.addressLine1 {
            try encodeContainer.encode(addressLine1, forKey: .addressLine1)
        }
        if let addressLine2 = self.addressLine2 {
            try encodeContainer.encode(addressLine2, forKey: .addressLine2)
        }
        if let addressLine3 = self.addressLine3 {
            try encodeContainer.encode(addressLine3, forKey: .addressLine3)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let companyName = self.companyName {
            try encodeContainer.encode(companyName, forKey: .companyName)
        }
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let districtOrCounty = self.districtOrCounty {
            try encodeContainer.encode(districtOrCounty, forKey: .districtOrCounty)
        }
        if let fullName = self.fullName {
            try encodeContainer.encode(fullName, forKey: .fullName)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let stateOrRegion = self.stateOrRegion {
            try encodeContainer.encode(stateOrRegion, forKey: .stateOrRegion)
        }
        if let websiteUrl = self.websiteUrl {
            try encodeContainer.encode(websiteUrl, forKey: .websiteUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullName)
        fullName = fullNameDecoded
        let addressLine1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressLine1)
        addressLine1 = addressLine1Decoded
        let addressLine2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressLine2)
        addressLine2 = addressLine2Decoded
        let addressLine3Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressLine3)
        addressLine3 = addressLine3Decoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateOrRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateOrRegion)
        stateOrRegion = stateOrRegionDecoded
        let districtOrCountyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .districtOrCounty)
        districtOrCounty = districtOrCountyDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let companyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .companyName)
        companyName = companyNameDecoded
        let websiteUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .websiteUrl)
        websiteUrl = websiteUrlDecoded
    }
}

extension AccountClientTypes.ContactInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContactInformation(addressLine1: \"CONTENT_REDACTED\", addressLine2: \"CONTENT_REDACTED\", addressLine3: \"CONTENT_REDACTED\", city: \"CONTENT_REDACTED\", companyName: \"CONTENT_REDACTED\", countryCode: \"CONTENT_REDACTED\", districtOrCounty: \"CONTENT_REDACTED\", fullName: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", stateOrRegion: \"CONTENT_REDACTED\", websiteUrl: \"CONTENT_REDACTED\")"}
}

extension AccountClientTypes {
    /// Contains the details of the primary contact information associated with an Amazon Web Services account.
    public struct ContactInformation: Swift.Equatable {
        /// The first line of the primary contact address.
        /// This member is required.
        public var addressLine1: Swift.String?
        /// The second line of the primary contact address, if any.
        public var addressLine2: Swift.String?
        /// The third line of the primary contact address, if any.
        public var addressLine3: Swift.String?
        /// The city of the primary contact address.
        /// This member is required.
        public var city: Swift.String?
        /// The name of the company associated with the primary contact information, if any.
        public var companyName: Swift.String?
        /// The ISO-3166 two-letter country code for the primary contact address.
        /// This member is required.
        public var countryCode: Swift.String?
        /// The district or county of the primary contact address, if any.
        public var districtOrCounty: Swift.String?
        /// The full name of the primary contact address.
        /// This member is required.
        public var fullName: Swift.String?
        /// The phone number of the primary contact information. The number will be validated and, in some countries, checked for activation.
        /// This member is required.
        public var phoneNumber: Swift.String?
        /// The postal code of the primary contact address.
        /// This member is required.
        public var postalCode: Swift.String?
        /// The state or region of the primary contact address. This field is required in selected countries.
        public var stateOrRegion: Swift.String?
        /// The URL of the website associated with the primary contact information, if any.
        public var websiteUrl: Swift.String?

        public init (
            addressLine1: Swift.String? = nil,
            addressLine2: Swift.String? = nil,
            addressLine3: Swift.String? = nil,
            city: Swift.String? = nil,
            companyName: Swift.String? = nil,
            countryCode: Swift.String? = nil,
            districtOrCounty: Swift.String? = nil,
            fullName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil,
            websiteUrl: Swift.String? = nil
        )
        {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.companyName = companyName
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.fullName = fullName
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
            self.websiteUrl = websiteUrl
        }
    }

}

extension DeleteAlternateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let alternateContactType = self.alternateContactType {
            try encodeContainer.encode(alternateContactType.rawValue, forKey: .alternateContactType)
        }
    }
}

extension DeleteAlternateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteAlternateContact"
    }
}

public struct DeleteAlternateContactInput: Swift.Equatable {
    /// Specifies the 12 digit account ID number of the Amazon Web Services account that you want to access or modify with this operation. If you do not specify this parameter, it defaults to the Amazon Web Services account of the identity used to call the operation. To use this parameter, the caller must be an identity in the [organization's management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account) or a delegated administrator account, and the specified account ID must be a member account in the same organization. The organization must have [all features enabled](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html), and the organization must have [trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html) enabled for the Account Management service, and optionally a [delegated admin](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html) account assigned. The management account can't specify its own AccountId; it must call the operation in standalone context by not including the AccountId parameter. To call this operation on an account that is not a member of an organization, then don't specify this parameter, and call the operation using an identity belonging to the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Specifies which of the alternate contacts to delete.
    /// This member is required.
    public var alternateContactType: AccountClientTypes.AlternateContactType?

    public init (
        accountId: Swift.String? = nil,
        alternateContactType: AccountClientTypes.AlternateContactType? = nil
    )
    {
        self.accountId = accountId
        self.alternateContactType = alternateContactType
    }
}

struct DeleteAlternateContactInputBody: Swift.Equatable {
    let alternateContactType: AccountClientTypes.AlternateContactType?
    let accountId: Swift.String?
}

extension DeleteAlternateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alternateContactTypeDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContactType.self, forKey: .alternateContactType)
        alternateContactType = alternateContactTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension DeleteAlternateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAlternateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAlternateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAlternateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAlternateContactOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisableRegionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case regionName = "RegionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
    }
}

extension DisableRegionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disableRegion"
    }
}

public struct DisableRegionInput: Swift.Equatable {
    /// Specifies the 12-digit account ID number of the Amazon Web Services account that you want to access or modify with this operation. If you don't specify this parameter, it defaults to the Amazon Web Services account of the identity used to call the operation. To use this parameter, the caller must be an identity in the [organization's management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account) or a delegated administrator account. The specified account ID must also be a member account in the same organization. The organization must have [all features enabled](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html), and the organization must have [trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html) enabled for the Account Management service, and optionally a [delegated admin](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html) account assigned. The management account can't specify its own AccountId. It must call the operation in standalone context by not including the AccountId parameter. To call this operation on an account that is not a member of an organization, don't specify this parameter. Instead, call the operation using an identity belonging to the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Specifies the Region-code for a given Region name (for example, af-south-1). When you disable a Region, AWS performs actions to deactivate that Region in your account, such as destroying IAM resources in the Region. This process takes a few minutes for most accounts, but this can take several hours. You cannot enable the Region until the disabling process is fully completed.
    /// This member is required.
    public var regionName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        regionName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.regionName = regionName
    }
}

struct DisableRegionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let regionName: Swift.String?
}

extension DisableRegionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case regionName = "RegionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
    }
}

extension DisableRegionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableRegionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableRegionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableRegionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableRegionOutputResponse: Swift.Equatable {

    public init () { }
}

extension EnableRegionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case regionName = "RegionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
    }
}

extension EnableRegionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/enableRegion"
    }
}

public struct EnableRegionInput: Swift.Equatable {
    /// Specifies the 12-digit account ID number of the Amazon Web Services account that you want to access or modify with this operation. If you don't specify this parameter, it defaults to the Amazon Web Services account of the identity used to call the operation. To use this parameter, the caller must be an identity in the [organization's management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account) or a delegated administrator account. The specified account ID must also be a member account in the same organization. The organization must have [all features enabled](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html), and the organization must have [trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html) enabled for the Account Management service, and optionally a [delegated admin](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html) account assigned. The management account can't specify its own AccountId. It must call the operation in standalone context by not including the AccountId parameter. To call this operation on an account that is not a member of an organization, don't specify this parameter. Instead, call the operation using an identity belonging to the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Specifies the Region-code for a given Region name (for example, af-south-1). When you enable a Region, AWS performs actions to prepare your account in that Region, such as distributing your IAM resources to the Region. This process takes a few minutes for most accounts, but it can take several hours. You cannot use the Region until this process is complete. Furthermore, you cannot disable the Region until the enabling process is fully completed.
    /// This member is required.
    public var regionName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        regionName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.regionName = regionName
    }
}

struct EnableRegionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let regionName: Swift.String?
}

extension EnableRegionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case regionName = "RegionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
    }
}

extension EnableRegionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableRegionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableRegionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableRegionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableRegionOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetAlternateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let alternateContactType = self.alternateContactType {
            try encodeContainer.encode(alternateContactType.rawValue, forKey: .alternateContactType)
        }
    }
}

extension GetAlternateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getAlternateContact"
    }
}

public struct GetAlternateContactInput: Swift.Equatable {
    /// Specifies the 12 digit account ID number of the Amazon Web Services account that you want to access or modify with this operation. If you do not specify this parameter, it defaults to the Amazon Web Services account of the identity used to call the operation. To use this parameter, the caller must be an identity in the [organization's management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account) or a delegated administrator account, and the specified account ID must be a member account in the same organization. The organization must have [all features enabled](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html), and the organization must have [trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html) enabled for the Account Management service, and optionally a [delegated admin](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html) account assigned. The management account can't specify its own AccountId; it must call the operation in standalone context by not including the AccountId parameter. To call this operation on an account that is not a member of an organization, then don't specify this parameter, and call the operation using an identity belonging to the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Specifies which alternate contact you want to retrieve.
    /// This member is required.
    public var alternateContactType: AccountClientTypes.AlternateContactType?

    public init (
        accountId: Swift.String? = nil,
        alternateContactType: AccountClientTypes.AlternateContactType? = nil
    )
    {
        self.accountId = accountId
        self.alternateContactType = alternateContactType
    }
}

struct GetAlternateContactInputBody: Swift.Equatable {
    let alternateContactType: AccountClientTypes.AlternateContactType?
    let accountId: Swift.String?
}

extension GetAlternateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alternateContactTypeDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContactType.self, forKey: .alternateContactType)
        alternateContactType = alternateContactTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension GetAlternateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAlternateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAlternateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAlternateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAlternateContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alternateContact = output.alternateContact
        } else {
            self.alternateContact = nil
        }
    }
}

public struct GetAlternateContactOutputResponse: Swift.Equatable {
    /// A structure that contains the details for the specified alternate contact.
    public var alternateContact: AccountClientTypes.AlternateContact?

    public init (
        alternateContact: AccountClientTypes.AlternateContact? = nil
    )
    {
        self.alternateContact = alternateContact
    }
}

struct GetAlternateContactOutputResponseBody: Swift.Equatable {
    let alternateContact: AccountClientTypes.AlternateContact?
}

extension GetAlternateContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateContact = "AlternateContact"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alternateContactDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContact.self, forKey: .alternateContact)
        alternateContact = alternateContactDecoded
    }
}

extension GetContactInformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }
}

extension GetContactInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getContactInformation"
    }
}

public struct GetContactInformationInput: Swift.Equatable {
    /// Specifies the 12-digit account ID number of the Amazon Web Services account that you want to access or modify with this operation. If you don't specify this parameter, it defaults to the Amazon Web Services account of the identity used to call the operation. To use this parameter, the caller must be an identity in the [organization's management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account) or a delegated administrator account. The specified account ID must also be a member account in the same organization. The organization must have [all features enabled](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html), and the organization must have [trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html) enabled for the Account Management service, and optionally a [delegated admin](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html) account assigned. The management account can't specify its own AccountId. It must call the operation in standalone context by not including the AccountId parameter. To call this operation on an account that is not a member of an organization, don't specify this parameter. Instead, call the operation using an identity belonging to the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?

    public init (
        accountId: Swift.String? = nil
    )
    {
        self.accountId = accountId
    }
}

struct GetContactInformationInputBody: Swift.Equatable {
    let accountId: Swift.String?
}

extension GetContactInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension GetContactInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetContactInformationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetContactInformationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactInformation = output.contactInformation
        } else {
            self.contactInformation = nil
        }
    }
}

public struct GetContactInformationOutputResponse: Swift.Equatable {
    /// Contains the details of the primary contact information associated with an Amazon Web Services account.
    public var contactInformation: AccountClientTypes.ContactInformation?

    public init (
        contactInformation: AccountClientTypes.ContactInformation? = nil
    )
    {
        self.contactInformation = contactInformation
    }
}

struct GetContactInformationOutputResponseBody: Swift.Equatable {
    let contactInformation: AccountClientTypes.ContactInformation?
}

extension GetContactInformationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactInformation = "ContactInformation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactInformationDecoded = try containerValues.decodeIfPresent(AccountClientTypes.ContactInformation.self, forKey: .contactInformation)
        contactInformation = contactInformationDecoded
    }
}

extension GetRegionOptStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case regionName = "RegionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
    }
}

extension GetRegionOptStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getRegionOptStatus"
    }
}

public struct GetRegionOptStatusInput: Swift.Equatable {
    /// Specifies the 12-digit account ID number of the Amazon Web Services account that you want to access or modify with this operation. If you don't specify this parameter, it defaults to the Amazon Web Services account of the identity used to call the operation. To use this parameter, the caller must be an identity in the [organization's management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account) or a delegated administrator account. The specified account ID must also be a member account in the same organization. The organization must have [all features enabled](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html), and the organization must have [trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html) enabled for the Account Management service, and optionally a [delegated admin](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html) account assigned. The management account can't specify its own AccountId. It must call the operation in standalone context by not including the AccountId parameter. To call this operation on an account that is not a member of an organization, don't specify this parameter. Instead, call the operation using an identity belonging to the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Specifies the Region-code for a given Region name (for example, af-south-1). This function will return the status of whatever Region you pass into this parameter.
    /// This member is required.
    public var regionName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        regionName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.regionName = regionName
    }
}

struct GetRegionOptStatusInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let regionName: Swift.String?
}

extension GetRegionOptStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case regionName = "RegionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
    }
}

extension GetRegionOptStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegionOptStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRegionOptStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegionOptStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRegionOptStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.regionName = output.regionName
            self.regionOptStatus = output.regionOptStatus
        } else {
            self.regionName = nil
            self.regionOptStatus = nil
        }
    }
}

public struct GetRegionOptStatusOutputResponse: Swift.Equatable {
    /// The Region code that was passed in.
    public var regionName: Swift.String?
    /// One of the potential statuses a Region can undergo (Enabled, Enabling, Disabled, Disabling, Enabled_By_Default).
    public var regionOptStatus: AccountClientTypes.RegionOptStatus?

    public init (
        regionName: Swift.String? = nil,
        regionOptStatus: AccountClientTypes.RegionOptStatus? = nil
    )
    {
        self.regionName = regionName
        self.regionOptStatus = regionOptStatus
    }
}

struct GetRegionOptStatusOutputResponseBody: Swift.Equatable {
    let regionName: Swift.String?
    let regionOptStatus: AccountClientTypes.RegionOptStatus?
}

extension GetRegionOptStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regionName = "RegionName"
        case regionOptStatus = "RegionOptStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let regionOptStatusDecoded = try containerValues.decodeIfPresent(AccountClientTypes.RegionOptStatus.self, forKey: .regionOptStatus)
        regionOptStatus = regionOptStatusDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because of an error internal to Amazon Web Services. Try your operation again later.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListRegionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case regionOptStatusContains = "RegionOptStatusContains"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regionOptStatusContains = regionOptStatusContains {
            var regionOptStatusContainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regionOptStatusContains)
            for regionoptstatus0 in regionOptStatusContains {
                try regionOptStatusContainsContainer.encode(regionoptstatus0.rawValue)
            }
        }
    }
}

extension ListRegionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listRegions"
    }
}

public struct ListRegionsInput: Swift.Equatable {
    /// Specifies the 12-digit account ID number of the Amazon Web Services account that you want to access or modify with this operation. If you don't specify this parameter, it defaults to the Amazon Web Services account of the identity used to call the operation. To use this parameter, the caller must be an identity in the [organization's management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account) or a delegated administrator account. The specified account ID must also be a member account in the same organization. The organization must have [all features enabled](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html), and the organization must have [trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html) enabled for the Account Management service, and optionally a [delegated admin](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html) account assigned. The management account can't specify its own AccountId. It must call the operation in standalone context by not including the AccountId parameter. To call this operation on an account that is not a member of an organization, don't specify this parameter. Instead, call the operation using an identity belonging to the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// The total number of items to return in the commands output. If the total number of items available is more than the value specified, a NextToken is provided in the commands output. To resume pagination, provide the NextToken value in the starting-token argument of a subsequent command. Do not use the NextToken response element directly outside of the Amazon Web Services CLI. For usage examples, see [Pagination](http://docs.aws.amazon.com/cli/latest/userguide/pagination.html) in the Amazon Web Services Command Line Interface User Guide.
    public var maxResults: Swift.Int?
    /// A token used to specify where to start paginating. This is the NextToken from a previously truncated response. For usage examples, see [Pagination](http://docs.aws.amazon.com/cli/latest/userguide/pagination.html) in the Amazon Web Services Command Line Interface User Guide.
    public var nextToken: Swift.String?
    /// A list of Region statuses (Enabling, Enabled, Disabling, Disabled, Enabled_by_default) to use to filter the list of Regions for a given account. For example, passing in a value of ENABLING will only return a list of Regions with a Region status of ENABLING.
    public var regionOptStatusContains: [AccountClientTypes.RegionOptStatus]?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        regionOptStatusContains: [AccountClientTypes.RegionOptStatus]? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.regionOptStatusContains = regionOptStatusContains
    }
}

struct ListRegionsInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let regionOptStatusContains: [AccountClientTypes.RegionOptStatus]?
}

extension ListRegionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case regionOptStatusContains = "RegionOptStatusContains"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let regionOptStatusContainsContainer = try containerValues.decodeIfPresent([AccountClientTypes.RegionOptStatus?].self, forKey: .regionOptStatusContains)
        var regionOptStatusContainsDecoded0:[AccountClientTypes.RegionOptStatus]? = nil
        if let regionOptStatusContainsContainer = regionOptStatusContainsContainer {
            regionOptStatusContainsDecoded0 = [AccountClientTypes.RegionOptStatus]()
            for string0 in regionOptStatusContainsContainer {
                if let string0 = string0 {
                    regionOptStatusContainsDecoded0?.append(string0)
                }
            }
        }
        regionOptStatusContains = regionOptStatusContainsDecoded0
    }
}

extension ListRegionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRegionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRegionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRegionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRegionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.regions = output.regions
        } else {
            self.nextToken = nil
            self.regions = nil
        }
    }
}

public struct ListRegionsOutputResponse: Swift.Equatable {
    /// If there is more data to be returned, this will be populated. It should be passed into the next-token request parameter of list-regions.
    public var nextToken: Swift.String?
    /// This is a list of Regions for a given account, or if the filtered parameter was used, a list of Regions that match the filter criteria set in the filter parameter.
    public var regions: [AccountClientTypes.Region]?

    public init (
        nextToken: Swift.String? = nil,
        regions: [AccountClientTypes.Region]? = nil
    )
    {
        self.nextToken = nextToken
        self.regions = regions
    }
}

struct ListRegionsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let regions: [AccountClientTypes.Region]?
}

extension ListRegionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case regions = "Regions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let regionsContainer = try containerValues.decodeIfPresent([AccountClientTypes.Region?].self, forKey: .regions)
        var regionsDecoded0:[AccountClientTypes.Region]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [AccountClientTypes.Region]()
            for structure0 in regionsContainer {
                if let structure0 = structure0 {
                    regionsDecoded0?.append(structure0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension PutAlternateContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAlternateContactInput(accountId: \(Swift.String(describing: accountId)), alternateContactType: \(Swift.String(describing: alternateContactType)), emailAddress: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

extension PutAlternateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
        case emailAddress = "EmailAddress"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case title = "Title"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let alternateContactType = self.alternateContactType {
            try encodeContainer.encode(alternateContactType.rawValue, forKey: .alternateContactType)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

extension PutAlternateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/putAlternateContact"
    }
}

public struct PutAlternateContactInput: Swift.Equatable {
    /// Specifies the 12 digit account ID number of the Amazon Web Services account that you want to access or modify with this operation. If you do not specify this parameter, it defaults to the Amazon Web Services account of the identity used to call the operation. To use this parameter, the caller must be an identity in the [organization's management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account) or a delegated administrator account, and the specified account ID must be a member account in the same organization. The organization must have [all features enabled](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html), and the organization must have [trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html) enabled for the Account Management service, and optionally a [delegated admin](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html) account assigned. The management account can't specify its own AccountId; it must call the operation in standalone context by not including the AccountId parameter. To call this operation on an account that is not a member of an organization, then don't specify this parameter, and call the operation using an identity belonging to the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Specifies which alternate contact you want to create or update.
    /// This member is required.
    public var alternateContactType: AccountClientTypes.AlternateContactType?
    /// Specifies an email address for the alternate contact.
    /// This member is required.
    public var emailAddress: Swift.String?
    /// Specifies a name for the alternate contact.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies a phone number for the alternate contact.
    /// This member is required.
    public var phoneNumber: Swift.String?
    /// Specifies a title for the alternate contact.
    /// This member is required.
    public var title: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        alternateContactType: AccountClientTypes.AlternateContactType? = nil,
        emailAddress: Swift.String? = nil,
        name: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        title: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.alternateContactType = alternateContactType
        self.emailAddress = emailAddress
        self.name = name
        self.phoneNumber = phoneNumber
        self.title = title
    }
}

struct PutAlternateContactInputBody: Swift.Equatable {
    let name: Swift.String?
    let title: Swift.String?
    let emailAddress: Swift.String?
    let phoneNumber: Swift.String?
    let alternateContactType: AccountClientTypes.AlternateContactType?
    let accountId: Swift.String?
}

extension PutAlternateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case alternateContactType = "AlternateContactType"
        case emailAddress = "EmailAddress"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case title = "Title"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let alternateContactTypeDecoded = try containerValues.decodeIfPresent(AccountClientTypes.AlternateContactType.self, forKey: .alternateContactType)
        alternateContactType = alternateContactTypeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension PutAlternateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAlternateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutAlternateContactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAlternateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutAlternateContactOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutContactInformationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case contactInformation = "ContactInformation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let contactInformation = self.contactInformation {
            try encodeContainer.encode(contactInformation, forKey: .contactInformation)
        }
    }
}

extension PutContactInformationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/putContactInformation"
    }
}

public struct PutContactInformationInput: Swift.Equatable {
    /// Specifies the 12-digit account ID number of the Amazon Web Services account that you want to access or modify with this operation. If you don't specify this parameter, it defaults to the Amazon Web Services account of the identity used to call the operation. To use this parameter, the caller must be an identity in the [organization's management account](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html#account) or a delegated administrator account. The specified account ID must also be a member account in the same organization. The organization must have [all features enabled](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_org_support-all-features.html), and the organization must have [trusted access](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-trusted-access.html) enabled for the Account Management service, and optionally a [delegated admin](https://docs.aws.amazon.com/organizations/latest/userguide/using-orgs-delegated-admin.html) account assigned. The management account can't specify its own AccountId. It must call the operation in standalone context by not including the AccountId parameter. To call this operation on an account that is not a member of an organization, don't specify this parameter. Instead, call the operation using an identity belonging to the account whose contacts you wish to retrieve or modify.
    public var accountId: Swift.String?
    /// Contains the details of the primary contact information associated with an Amazon Web Services account.
    /// This member is required.
    public var contactInformation: AccountClientTypes.ContactInformation?

    public init (
        accountId: Swift.String? = nil,
        contactInformation: AccountClientTypes.ContactInformation? = nil
    )
    {
        self.accountId = accountId
        self.contactInformation = contactInformation
    }
}

struct PutContactInformationInputBody: Swift.Equatable {
    let contactInformation: AccountClientTypes.ContactInformation?
    let accountId: Swift.String?
}

extension PutContactInformationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case contactInformation = "ContactInformation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactInformationDecoded = try containerValues.decodeIfPresent(AccountClientTypes.ContactInformation.self, forKey: .contactInformation)
        contactInformation = contactInformationDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension PutContactInformationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutContactInformationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutContactInformationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case tooManyRequestsException(TooManyRequestsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutContactInformationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutContactInformationOutputResponse: Swift.Equatable {

    public init () { }
}

extension AccountClientTypes.Region: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case regionName = "RegionName"
        case regionOptStatus = "RegionOptStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regionName = self.regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let regionOptStatus = self.regionOptStatus {
            try encodeContainer.encode(regionOptStatus.rawValue, forKey: .regionOptStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let regionOptStatusDecoded = try containerValues.decodeIfPresent(AccountClientTypes.RegionOptStatus.self, forKey: .regionOptStatus)
        regionOptStatus = regionOptStatusDecoded
    }
}

extension AccountClientTypes {
    /// This is a structure that expresses the Region for a given account, consisting of a name and opt-in status.
    public struct Region: Swift.Equatable {
        /// The Region code of a given Region (for example, us-east-1).
        public var regionName: Swift.String?
        /// One of potential statuses a Region can undergo (Enabled, Enabling, Disabled, Disabling, Enabled_By_Default).
        public var regionOptStatus: AccountClientTypes.RegionOptStatus?

        public init (
            regionName: Swift.String? = nil,
            regionOptStatus: AccountClientTypes.RegionOptStatus? = nil
        )
        {
            self.regionName = regionName
            self.regionOptStatus = regionOptStatus
        }
    }

}

extension AccountClientTypes {
    public enum RegionOptStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabledByDefault
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [RegionOptStatus] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabledByDefault,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabledByDefault: return "ENABLED_BY_DEFAULT"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegionOptStatus(rawValue: rawValue) ?? RegionOptStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because it specified a resource that can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because it was called too frequently and exceeded a throttle limit.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(fieldList: \(Swift.String(describing: fieldList)), reason: \(Swift.String(describing: reason)), message: \"CONTENT_REDACTED\")"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed because one of the input parameters was invalid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The field where the invalid entry was detected.
    public var fieldList: [AccountClientTypes.ValidationExceptionField]?
    /// The message that informs you about what was invalid about the request.
    /// This member is required.
    public var message: Swift.String?
    /// The reason that validation failed.
    public var reason: AccountClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [AccountClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AccountClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AccountClientTypes.ValidationExceptionReason?
    let fieldList: [AccountClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AccountClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([AccountClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[AccountClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [AccountClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension AccountClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountClientTypes.ValidationExceptionField: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationExceptionField(name: \(Swift.String(describing: name)), message: \"CONTENT_REDACTED\")"}
}

extension AccountClientTypes {
    /// The input failed to meet the constraints specified by the AWS service in a specified field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension AccountClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fieldValidationFailed
        case invalidRegionOptTarget
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .invalidRegionOptTarget,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .invalidRegionOptTarget: return "invalidRegionOptTarget"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
