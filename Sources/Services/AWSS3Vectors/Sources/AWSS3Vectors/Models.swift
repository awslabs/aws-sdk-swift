//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// Access denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request failed because a vector bucket name or a vector index name already exists. Vector bucket names must be unique within your Amazon Web Services account for each Amazon Web Services Region. Vector index names must be unique within your vector bucket. Choose a different vector bucket name or vector index name, and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was rejected because the specified resource can't be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The service is unavailable. Wait briefly and retry your request. If it continues to fail, increase your waiting time between retries.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension S3VectorsClientTypes {

    public enum DataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case float32
        case sdkUnknown(Swift.String)

        public static var allCases: [DataType] {
            return [
                .float32
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .float32: return "float32"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3VectorsClientTypes {

    public enum DistanceMetric: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cosine
        case euclidean
        case sdkUnknown(Swift.String)

        public static var allCases: [DistanceMetric] {
            return [
                .cosine,
                .euclidean
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cosine: return "cosine"
            case .euclidean: return "euclidean"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. The metadata configuration for a vector index.
    public struct MetadataConfiguration: Swift.Sendable {
        /// Non-filterable metadata keys allow you to enrich vectors with additional context during storage and retrieval. Unlike default metadata keys, these keys can’t be used as query filters. Non-filterable metadata keys can be retrieved but can’t be searched, queried, or filtered. You can access non-filterable metadata keys of your vectors after finding the vectors. For more information about non-filterable metadata keys, see [Vectors](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-vectors-vectors.html) and [Limitations and restrictions](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-vectors-limitations.html) in the Amazon S3 User Guide.
        /// This member is required.
        public var nonFilterableMetadataKeys: [Swift.String]?

        public init(
            nonFilterableMetadataKeys: [Swift.String]? = nil
        ) {
            self.nonFilterableMetadataKeys = nonFilterableMetadataKeys
        }
    }
}

public struct CreateIndexInput: Swift.Sendable {
    /// The data type of the vectors to be inserted into the vector index.
    /// This member is required.
    public var dataType: S3VectorsClientTypes.DataType?
    /// The dimensions of the vectors to be inserted into the vector index.
    /// This member is required.
    public var dimension: Swift.Int?
    /// The distance metric to be used for similarity search.
    /// This member is required.
    public var distanceMetric: S3VectorsClientTypes.DistanceMetric?
    /// The name of the vector index to create.
    /// This member is required.
    public var indexName: Swift.String?
    /// The metadata configuration for the vector index.
    public var metadataConfiguration: S3VectorsClientTypes.MetadataConfiguration?
    /// The Amazon Resource Name (ARN) of the vector bucket to create the vector index in.
    public var vectorBucketArn: Swift.String?
    /// The name of the vector bucket to create the vector index in.
    public var vectorBucketName: Swift.String?

    public init(
        dataType: S3VectorsClientTypes.DataType? = nil,
        dimension: Swift.Int? = nil,
        distanceMetric: S3VectorsClientTypes.DistanceMetric? = nil,
        indexName: Swift.String? = nil,
        metadataConfiguration: S3VectorsClientTypes.MetadataConfiguration? = nil,
        vectorBucketArn: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.dataType = dataType
        self.dimension = dimension
        self.distanceMetric = distanceMetric
        self.indexName = indexName
        self.metadataConfiguration = metadataConfiguration
        self.vectorBucketArn = vectorBucketArn
        self.vectorBucketName = vectorBucketName
    }
}

public struct CreateIndexOutput: Swift.Sendable {

    public init() { }
}

extension S3VectorsClientTypes {

    public enum SseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aes256
        case awsKms
        case sdkUnknown(Swift.String)

        public static var allCases: [SseType] {
            return [
                .aes256,
                .awsKms
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .awsKms: return "aws:kms"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. The encryption configuration for a vector bucket. By default, if you don't specify, all new vectors in Amazon S3 vector buckets use server-side encryption with Amazon S3 managed keys (SSE-S3), specifically AES256.
    public struct EncryptionConfiguration: Swift.Sendable {
        /// Amazon Web Services Key Management Service (KMS) customer managed key ID to use for the encryption configuration. This parameter is allowed if and only if sseType is set to aws:kms. To specify the KMS key, you must use the format of the KMS key Amazon Resource Name (ARN). For example, specify Key ARN in the following format: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
        public var kmsKeyArn: Swift.String?
        /// The server-side encryption type to use for the encryption configuration of the vector bucket. By default, if you don't specify, all new vectors in Amazon S3 vector buckets use server-side encryption with Amazon S3 managed keys (SSE-S3), specifically AES256.
        public var sseType: S3VectorsClientTypes.SseType?

        public init(
            kmsKeyArn: Swift.String? = nil,
            sseType: S3VectorsClientTypes.SseType? = .aes256
        ) {
            self.kmsKeyArn = kmsKeyArn
            self.sseType = sseType
        }
    }
}

public struct CreateVectorBucketInput: Swift.Sendable {
    /// The encryption configuration for the vector bucket. By default, if you don't specify, all new vectors in Amazon S3 vector buckets use server-side encryption with Amazon S3 managed keys (SSE-S3), specifically AES256.
    public var encryptionConfiguration: S3VectorsClientTypes.EncryptionConfiguration?
    /// The name of the vector bucket to create.
    /// This member is required.
    public var vectorBucketName: Swift.String?

    public init(
        encryptionConfiguration: S3VectorsClientTypes.EncryptionConfiguration? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.encryptionConfiguration = encryptionConfiguration
        self.vectorBucketName = vectorBucketName
    }
}

public struct CreateVectorBucketOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteIndexInput: Swift.Sendable {
    /// The ARN of the vector index to delete.
    public var indexArn: Swift.String?
    /// The name of the vector index to delete.
    public var indexName: Swift.String?
    /// The name of the vector bucket that contains the vector index.
    public var vectorBucketName: Swift.String?

    public init(
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.indexArn = indexArn
        self.indexName = indexName
        self.vectorBucketName = vectorBucketName
    }
}

public struct DeleteIndexOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteVectorBucketInput: Swift.Sendable {
    /// The ARN of the vector bucket to delete.
    public var vectorBucketArn: Swift.String?
    /// The name of the vector bucket to delete.
    public var vectorBucketName: Swift.String?

    public init(
        vectorBucketArn: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.vectorBucketArn = vectorBucketArn
        self.vectorBucketName = vectorBucketName
    }
}

public struct DeleteVectorBucketOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteVectorBucketPolicyInput: Swift.Sendable {
    /// The ARN of the vector bucket to delete the policy from.
    public var vectorBucketArn: Swift.String?
    /// The name of the vector bucket to delete the policy from.
    public var vectorBucketName: Swift.String?

    public init(
        vectorBucketArn: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.vectorBucketArn = vectorBucketArn
        self.vectorBucketName = vectorBucketName
    }
}

public struct DeleteVectorBucketPolicyOutput: Swift.Sendable {

    public init() { }
}

/// The specified Amazon Web Services KMS key isn't enabled.
public struct KmsDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsDisabledException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was rejected for one of the following reasons:
///
/// * The KeyUsage value of the KMS key is incompatible with the API operation.
///
/// * The encryption algorithm or signing algorithm specified for the operation is incompatible with the type of key material in the KMS key (KeySpec).
///
///
/// For more information, see [InvalidKeyUsageException](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html#API_Encrypt_Errors) in the Amazon Web Services Key Management Service API Reference.
public struct KmsInvalidKeyUsageException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsInvalidKeyUsageException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The key state of the KMS key isn't compatible with the operation. For more information, see [KMSInvalidStateException](https://docs.aws.amazon.com/kms/latest/APIReference/API_Encrypt.html#API_Encrypt_Errors) in the Amazon Web Services Key Management Service API Reference.
public struct KmsInvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsInvalidStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The KMS key can't be found.
public struct KmsNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DeleteVectorsInput: Swift.Sendable {
    /// The ARN of the vector index that contains a vector you want to delete.
    public var indexArn: Swift.String?
    /// The name of the vector index that contains a vector you want to delete.
    public var indexName: Swift.String?
    /// The keys of the vectors to delete.
    /// This member is required.
    public var keys: [Swift.String]?
    /// The name of the vector bucket that contains the vector index.
    public var vectorBucketName: Swift.String?

    public init(
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        keys: [Swift.String]? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.indexArn = indexArn
        self.indexName = indexName
        self.keys = keys
        self.vectorBucketName = vectorBucketName
    }
}

public struct DeleteVectorsOutput: Swift.Sendable {

    public init() { }
}

public struct GetIndexInput: Swift.Sendable {
    /// The ARN of the vector index.
    public var indexArn: Swift.String?
    /// The name of the vector index.
    public var indexName: Swift.String?
    /// The name of the vector bucket that contains the vector index.
    public var vectorBucketName: Swift.String?

    public init(
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.indexArn = indexArn
        self.indexName = indexName
        self.vectorBucketName = vectorBucketName
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. The attributes of a vector index.
    public struct Index: Swift.Sendable {
        /// Date and time when the vector index was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The data type of the vectors inserted into the vector index.
        /// This member is required.
        public var dataType: S3VectorsClientTypes.DataType?
        /// The number of values in the vectors that are inserted into the vector index.
        /// This member is required.
        public var dimension: Swift.Int?
        /// The distance metric to be used for similarity search.
        /// This member is required.
        public var distanceMetric: S3VectorsClientTypes.DistanceMetric?
        /// The Amazon Resource Name (ARN) of the vector index.
        /// This member is required.
        public var indexArn: Swift.String?
        /// The name of the vector index.
        /// This member is required.
        public var indexName: Swift.String?
        /// The metadata configuration for the vector index.
        public var metadataConfiguration: S3VectorsClientTypes.MetadataConfiguration?
        /// The name of the vector bucket that contains the vector index.
        /// This member is required.
        public var vectorBucketName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            dataType: S3VectorsClientTypes.DataType? = nil,
            dimension: Swift.Int? = nil,
            distanceMetric: S3VectorsClientTypes.DistanceMetric? = nil,
            indexArn: Swift.String? = nil,
            indexName: Swift.String? = nil,
            metadataConfiguration: S3VectorsClientTypes.MetadataConfiguration? = nil,
            vectorBucketName: Swift.String? = nil
        ) {
            self.creationTime = creationTime
            self.dataType = dataType
            self.dimension = dimension
            self.distanceMetric = distanceMetric
            self.indexArn = indexArn
            self.indexName = indexName
            self.metadataConfiguration = metadataConfiguration
            self.vectorBucketName = vectorBucketName
        }
    }
}

public struct GetIndexOutput: Swift.Sendable {
    /// The attributes of the vector index.
    /// This member is required.
    public var index: S3VectorsClientTypes.Index?

    public init(
        index: S3VectorsClientTypes.Index? = nil
    ) {
        self.index = index
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. The vector data in different formats.
    public enum VectorData: Swift.Sendable {
        /// The vector data as 32-bit floating point numbers. The number of elements in this array must exactly match the dimension of the vector index where the operation is being performed.
        case float32([Swift.Float])
        case sdkUnknown(Swift.String)
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. The attributes of a vector returned by the GetVectors operation.
    public struct GetOutputVector: Swift.Sendable {
        /// The vector data of the vector.
        public var data: S3VectorsClientTypes.VectorData?
        /// The name of the vector.
        /// This member is required.
        public var key: Swift.String?
        /// Metadata about the vector.
        public var metadata: Smithy.Document?

        public init(
            data: S3VectorsClientTypes.VectorData? = nil,
            key: Swift.String? = nil,
            metadata: Smithy.Document? = nil
        ) {
            self.data = data
            self.key = key
            self.metadata = metadata
        }
    }
}

public struct GetVectorBucketInput: Swift.Sendable {
    /// The ARN of the vector bucket to retrieve information about.
    public var vectorBucketArn: Swift.String?
    /// The name of the vector bucket to retrieve information about.
    public var vectorBucketName: Swift.String?

    public init(
        vectorBucketArn: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.vectorBucketArn = vectorBucketArn
        self.vectorBucketName = vectorBucketName
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. The attributes of a vector bucket.
    public struct VectorBucket: Swift.Sendable {
        /// Date and time when the vector bucket was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The encryption configuration for the vector bucket.
        public var encryptionConfiguration: S3VectorsClientTypes.EncryptionConfiguration?
        /// The Amazon Resource Name (ARN) of the vector bucket.
        /// This member is required.
        public var vectorBucketArn: Swift.String?
        /// The name of the vector bucket.
        /// This member is required.
        public var vectorBucketName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            encryptionConfiguration: S3VectorsClientTypes.EncryptionConfiguration? = nil,
            vectorBucketArn: Swift.String? = nil,
            vectorBucketName: Swift.String? = nil
        ) {
            self.creationTime = creationTime
            self.encryptionConfiguration = encryptionConfiguration
            self.vectorBucketArn = vectorBucketArn
            self.vectorBucketName = vectorBucketName
        }
    }
}

public struct GetVectorBucketOutput: Swift.Sendable {
    /// The attributes of the vector bucket.
    /// This member is required.
    public var vectorBucket: S3VectorsClientTypes.VectorBucket?

    public init(
        vectorBucket: S3VectorsClientTypes.VectorBucket? = nil
    ) {
        self.vectorBucket = vectorBucket
    }
}

public struct GetVectorBucketPolicyInput: Swift.Sendable {
    /// The ARN of the vector bucket.
    public var vectorBucketArn: Swift.String?
    /// The name of the vector bucket.
    public var vectorBucketName: Swift.String?

    public init(
        vectorBucketArn: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.vectorBucketArn = vectorBucketArn
        self.vectorBucketName = vectorBucketName
    }
}

public struct GetVectorBucketPolicyOutput: Swift.Sendable {
    /// The JSON that defines the policy.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    ) {
        self.policy = policy
    }
}

public struct GetVectorsInput: Swift.Sendable {
    /// The ARN of the vector index.
    public var indexArn: Swift.String?
    /// The name of the vector index.
    public var indexName: Swift.String?
    /// The names of the vectors you want to return attributes for.
    /// This member is required.
    public var keys: [Swift.String]?
    /// Indicates whether to include the vector data in the response. The default value is false.
    public var returnData: Swift.Bool?
    /// Indicates whether to include metadata in the response. The default value is false.
    public var returnMetadata: Swift.Bool?
    /// The name of the vector bucket that contains the vector index.
    public var vectorBucketName: Swift.String?

    public init(
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        keys: [Swift.String]? = nil,
        returnData: Swift.Bool? = nil,
        returnMetadata: Swift.Bool? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.indexArn = indexArn
        self.indexName = indexName
        self.keys = keys
        self.returnData = returnData
        self.returnMetadata = returnMetadata
        self.vectorBucketName = vectorBucketName
    }
}

public struct GetVectorsOutput: Swift.Sendable {
    /// The attributes of the vectors.
    /// This member is required.
    public var vectors: [S3VectorsClientTypes.GetOutputVector]?

    public init(
        vectors: [S3VectorsClientTypes.GetOutputVector]? = nil
    ) {
        self.vectors = vectors
    }
}

public struct ListIndexesInput: Swift.Sendable {
    /// The maximum number of items to be returned in the response.
    public var maxResults: Swift.Int?
    /// The previous pagination token.
    public var nextToken: Swift.String?
    /// Limits the response to vector indexes that begin with the specified prefix.
    public var `prefix`: Swift.String?
    /// The ARN of the vector bucket that contains the vector indexes.
    public var vectorBucketArn: Swift.String?
    /// The name of the vector bucket that contains the vector indexes.
    public var vectorBucketName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        `prefix`: Swift.String? = nil,
        vectorBucketArn: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.`prefix` = `prefix`
        self.vectorBucketArn = vectorBucketArn
        self.vectorBucketName = vectorBucketName
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. Summary information about a vector index.
    public struct IndexSummary: Swift.Sendable {
        /// Date and time when the vector index was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the vector index.
        /// This member is required.
        public var indexArn: Swift.String?
        /// The name of the vector index.
        /// This member is required.
        public var indexName: Swift.String?
        /// The name of the vector bucket that contains the vector index.
        /// This member is required.
        public var vectorBucketName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            indexArn: Swift.String? = nil,
            indexName: Swift.String? = nil,
            vectorBucketName: Swift.String? = nil
        ) {
            self.creationTime = creationTime
            self.indexArn = indexArn
            self.indexName = indexName
            self.vectorBucketName = vectorBucketName
        }
    }
}

public struct ListIndexesOutput: Swift.Sendable {
    /// The attributes of the vector indexes
    /// This member is required.
    public var indexes: [S3VectorsClientTypes.IndexSummary]?
    /// The next pagination token.
    public var nextToken: Swift.String?

    public init(
        indexes: [S3VectorsClientTypes.IndexSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.indexes = indexes
        self.nextToken = nextToken
    }
}

public struct ListVectorsInput: Swift.Sendable {
    /// The Amazon resource Name (ARN) of the vector index.
    public var indexArn: Swift.String?
    /// The name of the vector index.
    public var indexName: Swift.String?
    /// The maximum number of vectors to return on a page. If you don't specify maxResults, the ListVectors operation uses a default value of 500. If the processed dataset size exceeds 1 MB before reaching the maxResults value, the operation stops and returns the vectors that are retrieved up to that point, along with a nextToken that you can use in a subsequent request to retrieve the next set of results.
    public var maxResults: Swift.Int?
    /// Pagination token from a previous request. The value of this field is empty for an initial request.
    public var nextToken: Swift.String?
    /// If true, the vector data of each vector will be included in the response. The default value is false.
    public var returnData: Swift.Bool?
    /// If true, the metadata associated with each vector will be included in the response. The default value is false.
    public var returnMetadata: Swift.Bool?
    /// For a parallel ListVectors request, segmentCount represents the total number of vector segments into which the ListVectors operation will be divided. The value of segmentCount corresponds to the number of application workers that will perform the parallel ListVectors operation. For example, if you want to use four application threads to list vectors in a vector index, specify a segmentCount value of 4. If you specify a segmentCount value of 1, the ListVectors operation will be sequential rather than parallel. If you specify segmentCount, you must also specify segmentIndex.
    public var segmentCount: Swift.Int?
    /// For a parallel ListVectors request, segmentIndex is the index of the segment from which to list vectors in the current request. It identifies an individual segment to be listed by an application worker. Segment IDs are zero-based, so the first segment is always 0. For example, if you want to use four application threads to list vectors in a vector index, then the first thread specifies a segmentIndex value of 0, the second thread specifies 1, and so on. The value of segmentIndex must be less than the value provided for segmentCount. If you provide segmentIndex, you must also provide segmentCount.
    public var segmentIndex: Swift.Int?
    /// The name of the vector bucket.
    public var vectorBucketName: Swift.String?

    public init(
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        returnData: Swift.Bool? = nil,
        returnMetadata: Swift.Bool? = nil,
        segmentCount: Swift.Int? = nil,
        segmentIndex: Swift.Int? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.indexArn = indexArn
        self.indexName = indexName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.returnData = returnData
        self.returnMetadata = returnMetadata
        self.segmentCount = segmentCount
        self.segmentIndex = segmentIndex
        self.vectorBucketName = vectorBucketName
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. The attributes of a vector returned by the ListVectors operation.
    public struct ListOutputVector: Swift.Sendable {
        /// The vector data of the vector.
        public var data: S3VectorsClientTypes.VectorData?
        /// The name of the vector.
        /// This member is required.
        public var key: Swift.String?
        /// Metadata about the vector.
        public var metadata: Smithy.Document?

        public init(
            data: S3VectorsClientTypes.VectorData? = nil,
            key: Swift.String? = nil,
            metadata: Smithy.Document? = nil
        ) {
            self.data = data
            self.key = key
            self.metadata = metadata
        }
    }
}

public struct ListVectorsOutput: Swift.Sendable {
    /// Pagination token to be used in the subsequent request. The field is empty if no further pagination is required.
    public var nextToken: Swift.String?
    /// Vectors in the current segment.
    /// This member is required.
    public var vectors: [S3VectorsClientTypes.ListOutputVector]?

    public init(
        nextToken: Swift.String? = nil,
        vectors: [S3VectorsClientTypes.ListOutputVector]? = nil
    ) {
        self.nextToken = nextToken
        self.vectors = vectors
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. The attributes of a vector to add to a vector index.
    public struct PutInputVector: Swift.Sendable {
        /// The vector data of the vector. Vector dimensions must match the dimension count that's configured for the vector index.
        ///
        /// * For the cosine distance metric, zero vectors (vectors containing all zeros) aren't allowed.
        ///
        /// * For both cosine and euclidean distance metrics, vector data must contain only valid floating-point values. Invalid values such as NaN (Not a Number) or Infinity aren't allowed.
        /// This member is required.
        public var data: S3VectorsClientTypes.VectorData?
        /// The name of the vector. The key uniquely identifies the vector in a vector index.
        /// This member is required.
        public var key: Swift.String?
        /// Metadata about the vector. All metadata entries undergo validation to ensure they meet the format requirements for size and data types.
        public var metadata: Smithy.Document?

        public init(
            data: S3VectorsClientTypes.VectorData? = nil,
            key: Swift.String? = nil,
            metadata: Smithy.Document? = [:]
        ) {
            self.data = data
            self.key = key
            self.metadata = metadata
        }
    }
}

public struct PutVectorsInput: Swift.Sendable {
    /// The ARN of the vector index where you want to write vectors.
    public var indexArn: Swift.String?
    /// The name of the vector index where you want to write vectors.
    public var indexName: Swift.String?
    /// The name of the vector bucket that contains the vector index.
    public var vectorBucketName: Swift.String?
    /// The vectors to add to a vector index. The number of vectors in a single request must not exceed the resource capacity, otherwise the request will be rejected with the error ServiceUnavailableException with the error message "Currently unable to handle the request".
    /// This member is required.
    public var vectors: [S3VectorsClientTypes.PutInputVector]?

    public init(
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil,
        vectors: [S3VectorsClientTypes.PutInputVector]? = nil
    ) {
        self.indexArn = indexArn
        self.indexName = indexName
        self.vectorBucketName = vectorBucketName
        self.vectors = vectors
    }
}

public struct PutVectorsOutput: Swift.Sendable {

    public init() { }
}

public struct QueryVectorsInput: Swift.Sendable {
    /// Metadata filter to apply during the query. For more information about metadata keys, see [Metadata filtering](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-vectors-metadata-filtering.html) in the Amazon S3 User Guide.
    public var filter: Smithy.Document?
    /// The ARN of the vector index that you want to query.
    public var indexArn: Swift.String?
    /// The name of the vector index that you want to query.
    public var indexName: Swift.String?
    /// The query vector. Ensure that the query vector has the same dimension as the dimension of the vector index that's being queried. For example, if your vector index contains vectors with 384 dimensions, your query vector must also have 384 dimensions.
    /// This member is required.
    public var queryVector: S3VectorsClientTypes.VectorData?
    /// Indicates whether to include the computed distance in the response. The default value is false.
    public var returnDistance: Swift.Bool?
    /// Indicates whether to include metadata in the response. The default value is false.
    public var returnMetadata: Swift.Bool?
    /// The number of results to return for each query.
    /// This member is required.
    public var topk: Swift.Int?
    /// The name of the vector bucket that contains the vector index.
    public var vectorBucketName: Swift.String?

    public init(
        filter: Smithy.Document? = nil,
        indexArn: Swift.String? = nil,
        indexName: Swift.String? = nil,
        queryVector: S3VectorsClientTypes.VectorData? = nil,
        returnDistance: Swift.Bool? = nil,
        returnMetadata: Swift.Bool? = nil,
        topk: Swift.Int? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.filter = filter
        self.indexArn = indexArn
        self.indexName = indexName
        self.queryVector = queryVector
        self.returnDistance = returnDistance
        self.returnMetadata = returnMetadata
        self.topk = topk
        self.vectorBucketName = vectorBucketName
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. The attributes of a vector in the approximate nearest neighbor search.
    public struct QueryOutputVector: Swift.Sendable {
        /// The vector data associated with the vector, if requested.
        public var data: S3VectorsClientTypes.VectorData?
        /// The measure of similarity between the vector in the response and the query vector.
        public var distance: Swift.Float?
        /// The key of the vector in the approximate nearest neighbor search.
        /// This member is required.
        public var key: Swift.String?
        /// The metadata associated with the vector, if requested.
        public var metadata: Smithy.Document?

        public init(
            data: S3VectorsClientTypes.VectorData? = nil,
            distance: Swift.Float? = nil,
            key: Swift.String? = nil,
            metadata: Smithy.Document? = nil
        ) {
            self.data = data
            self.distance = distance
            self.key = key
            self.metadata = metadata
        }
    }
}

public struct QueryVectorsOutput: Swift.Sendable {
    /// The vectors in the approximate nearest neighbor search.
    /// This member is required.
    public var vectors: [S3VectorsClientTypes.QueryOutputVector]?

    public init(
        vectors: [S3VectorsClientTypes.QueryOutputVector]? = nil
    ) {
        self.vectors = vectors
    }
}

/// The request failed due to an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct ListVectorBucketsInput: Swift.Sendable {
    /// The maximum number of vector buckets to be returned in the response.
    public var maxResults: Swift.Int?
    /// The previous pagination token.
    public var nextToken: Swift.String?
    /// Limits the response to vector buckets that begin with the specified prefix.
    public var `prefix`: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        `prefix`: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.`prefix` = `prefix`
    }
}

extension S3VectorsClientTypes {

    /// Amazon S3 Vectors is in preview release for Amazon S3 and is subject to change. Summary information about a vector bucket.
    public struct VectorBucketSummary: Swift.Sendable {
        /// Date and time when the vector bucket was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the vector bucket.
        /// This member is required.
        public var vectorBucketArn: Swift.String?
        /// The name of the vector bucket.
        /// This member is required.
        public var vectorBucketName: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            vectorBucketArn: Swift.String? = nil,
            vectorBucketName: Swift.String? = nil
        ) {
            self.creationTime = creationTime
            self.vectorBucketArn = vectorBucketArn
            self.vectorBucketName = vectorBucketName
        }
    }
}

public struct ListVectorBucketsOutput: Swift.Sendable {
    /// The element is included in the response when there are more buckets to be listed with pagination.
    public var nextToken: Swift.String?
    /// The list of vector buckets owned by the requester.
    /// This member is required.
    public var vectorBuckets: [S3VectorsClientTypes.VectorBucketSummary]?

    public init(
        nextToken: Swift.String? = nil,
        vectorBuckets: [S3VectorsClientTypes.VectorBucketSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.vectorBuckets = vectorBuckets
    }
}

public struct PutVectorBucketPolicyInput: Swift.Sendable {
    /// The JSON that defines the policy. For more information about bucket policies for S3 Vectors, see [Managing vector bucket policies](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-vectors-bucket-policy.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the vector bucket.
    public var vectorBucketArn: Swift.String?
    /// The name of the vector bucket.
    public var vectorBucketName: Swift.String?

    public init(
        policy: Swift.String? = nil,
        vectorBucketArn: Swift.String? = nil,
        vectorBucketName: Swift.String? = nil
    ) {
        self.policy = policy
        self.vectorBucketArn = vectorBucketArn
        self.vectorBucketName = vectorBucketName
    }
}

public struct PutVectorBucketPolicyOutput: Swift.Sendable {

    public init() { }
}

/// Your request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension S3VectorsClientTypes {

    /// Contains information about a validation exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// A path about the validation exception.
        /// This member is required.
        public var path: Swift.String?

        public init(
            message: Swift.String? = nil,
            path: Swift.String? = nil
        ) {
            self.message = message
            self.path = path
        }
    }
}

/// The requested action isn't valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A list of specific validation failures that are encountered during input processing. Each entry in the list contains a path to the field that failed validation and a detailed message that explains why the validation failed. To satisfy multiple constraints, a field can appear multiple times in this list if it failed. You can use the information to identify and fix the specific validation issues in your request.
        public internal(set) var fieldList: [S3VectorsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [S3VectorsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

extension CreateIndexInput {

    static func urlPathProvider(_ value: CreateIndexInput) -> Swift.String? {
        return "/CreateIndex"
    }
}

extension CreateVectorBucketInput {

    static func urlPathProvider(_ value: CreateVectorBucketInput) -> Swift.String? {
        return "/CreateVectorBucket"
    }
}

extension DeleteIndexInput {

    static func urlPathProvider(_ value: DeleteIndexInput) -> Swift.String? {
        return "/DeleteIndex"
    }
}

extension DeleteVectorBucketInput {

    static func urlPathProvider(_ value: DeleteVectorBucketInput) -> Swift.String? {
        return "/DeleteVectorBucket"
    }
}

extension DeleteVectorBucketPolicyInput {

    static func urlPathProvider(_ value: DeleteVectorBucketPolicyInput) -> Swift.String? {
        return "/DeleteVectorBucketPolicy"
    }
}

extension DeleteVectorsInput {

    static func urlPathProvider(_ value: DeleteVectorsInput) -> Swift.String? {
        return "/DeleteVectors"
    }
}

extension GetIndexInput {

    static func urlPathProvider(_ value: GetIndexInput) -> Swift.String? {
        return "/GetIndex"
    }
}

extension GetVectorBucketInput {

    static func urlPathProvider(_ value: GetVectorBucketInput) -> Swift.String? {
        return "/GetVectorBucket"
    }
}

extension GetVectorBucketPolicyInput {

    static func urlPathProvider(_ value: GetVectorBucketPolicyInput) -> Swift.String? {
        return "/GetVectorBucketPolicy"
    }
}

extension GetVectorsInput {

    static func urlPathProvider(_ value: GetVectorsInput) -> Swift.String? {
        return "/GetVectors"
    }
}

extension ListIndexesInput {

    static func urlPathProvider(_ value: ListIndexesInput) -> Swift.String? {
        return "/ListIndexes"
    }
}

extension ListVectorBucketsInput {

    static func urlPathProvider(_ value: ListVectorBucketsInput) -> Swift.String? {
        return "/ListVectorBuckets"
    }
}

extension ListVectorsInput {

    static func urlPathProvider(_ value: ListVectorsInput) -> Swift.String? {
        return "/ListVectors"
    }
}

extension PutVectorBucketPolicyInput {

    static func urlPathProvider(_ value: PutVectorBucketPolicyInput) -> Swift.String? {
        return "/PutVectorBucketPolicy"
    }
}

extension PutVectorsInput {

    static func urlPathProvider(_ value: PutVectorsInput) -> Swift.String? {
        return "/PutVectors"
    }
}

extension QueryVectorsInput {

    static func urlPathProvider(_ value: QueryVectorsInput) -> Swift.String? {
        return "/QueryVectors"
    }
}

extension CreateIndexInput {

    static func write(value: CreateIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataType"].write(value.dataType)
        try writer["dimension"].write(value.dimension)
        try writer["distanceMetric"].write(value.distanceMetric)
        try writer["indexName"].write(value.indexName)
        try writer["metadataConfiguration"].write(value.metadataConfiguration, with: S3VectorsClientTypes.MetadataConfiguration.write(value:to:))
        try writer["vectorBucketArn"].write(value.vectorBucketArn)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension CreateVectorBucketInput {

    static func write(value: CreateVectorBucketInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: S3VectorsClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension DeleteIndexInput {

    static func write(value: DeleteIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["indexArn"].write(value.indexArn)
        try writer["indexName"].write(value.indexName)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension DeleteVectorBucketInput {

    static func write(value: DeleteVectorBucketInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vectorBucketArn"].write(value.vectorBucketArn)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension DeleteVectorBucketPolicyInput {

    static func write(value: DeleteVectorBucketPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vectorBucketArn"].write(value.vectorBucketArn)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension DeleteVectorsInput {

    static func write(value: DeleteVectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["indexArn"].write(value.indexArn)
        try writer["indexName"].write(value.indexName)
        try writer["keys"].writeList(value.keys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension GetIndexInput {

    static func write(value: GetIndexInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["indexArn"].write(value.indexArn)
        try writer["indexName"].write(value.indexName)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension GetVectorBucketInput {

    static func write(value: GetVectorBucketInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vectorBucketArn"].write(value.vectorBucketArn)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension GetVectorBucketPolicyInput {

    static func write(value: GetVectorBucketPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vectorBucketArn"].write(value.vectorBucketArn)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension GetVectorsInput {

    static func write(value: GetVectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["indexArn"].write(value.indexArn)
        try writer["indexName"].write(value.indexName)
        try writer["keys"].writeList(value.keys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["returnData"].write(value.returnData)
        try writer["returnMetadata"].write(value.returnMetadata)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension ListIndexesInput {

    static func write(value: ListIndexesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["prefix"].write(value.`prefix`)
        try writer["vectorBucketArn"].write(value.vectorBucketArn)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension ListVectorBucketsInput {

    static func write(value: ListVectorBucketsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["prefix"].write(value.`prefix`)
    }
}

extension ListVectorsInput {

    static func write(value: ListVectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["indexArn"].write(value.indexArn)
        try writer["indexName"].write(value.indexName)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["returnData"].write(value.returnData)
        try writer["returnMetadata"].write(value.returnMetadata)
        try writer["segmentCount"].write(value.segmentCount)
        try writer["segmentIndex"].write(value.segmentIndex)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension PutVectorBucketPolicyInput {

    static func write(value: PutVectorBucketPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
        try writer["vectorBucketArn"].write(value.vectorBucketArn)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension PutVectorsInput {

    static func write(value: PutVectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["indexArn"].write(value.indexArn)
        try writer["indexName"].write(value.indexName)
        try writer["vectorBucketName"].write(value.vectorBucketName)
        try writer["vectors"].writeList(value.vectors, memberWritingClosure: S3VectorsClientTypes.PutInputVector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension QueryVectorsInput {

    static func write(value: QueryVectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter)
        try writer["indexArn"].write(value.indexArn)
        try writer["indexName"].write(value.indexName)
        try writer["queryVector"].write(value.queryVector, with: S3VectorsClientTypes.VectorData.write(value:to:))
        try writer["returnDistance"].write(value.returnDistance)
        try writer["returnMetadata"].write(value.returnMetadata)
        try writer["topK"].write(value.topk)
        try writer["vectorBucketName"].write(value.vectorBucketName)
    }
}

extension CreateIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIndexOutput {
        return CreateIndexOutput()
    }
}

extension CreateVectorBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVectorBucketOutput {
        return CreateVectorBucketOutput()
    }
}

extension DeleteIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIndexOutput {
        return DeleteIndexOutput()
    }
}

extension DeleteVectorBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVectorBucketOutput {
        return DeleteVectorBucketOutput()
    }
}

extension DeleteVectorBucketPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVectorBucketPolicyOutput {
        return DeleteVectorBucketPolicyOutput()
    }
}

extension DeleteVectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVectorsOutput {
        return DeleteVectorsOutput()
    }
}

extension GetIndexOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIndexOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIndexOutput()
        value.index = try reader["index"].readIfPresent(with: S3VectorsClientTypes.Index.read(from:))
        return value
    }
}

extension GetVectorBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVectorBucketOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVectorBucketOutput()
        value.vectorBucket = try reader["vectorBucket"].readIfPresent(with: S3VectorsClientTypes.VectorBucket.read(from:))
        return value
    }
}

extension GetVectorBucketPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVectorBucketPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVectorBucketPolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        return value
    }
}

extension GetVectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVectorsOutput()
        value.vectors = try reader["vectors"].readListIfPresent(memberReadingClosure: S3VectorsClientTypes.GetOutputVector.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListIndexesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIndexesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIndexesOutput()
        value.indexes = try reader["indexes"].readListIfPresent(memberReadingClosure: S3VectorsClientTypes.IndexSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListVectorBucketsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVectorBucketsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVectorBucketsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.vectorBuckets = try reader["vectorBuckets"].readListIfPresent(memberReadingClosure: S3VectorsClientTypes.VectorBucketSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListVectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVectorsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.vectors = try reader["vectors"].readListIfPresent(memberReadingClosure: S3VectorsClientTypes.ListOutputVector.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PutVectorBucketPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVectorBucketPolicyOutput {
        return PutVectorBucketPolicyOutput()
    }
}

extension PutVectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutVectorsOutput {
        return PutVectorsOutput()
    }
}

extension QueryVectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> QueryVectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = QueryVectorsOutput()
        value.vectors = try reader["vectors"].readListIfPresent(memberReadingClosure: S3VectorsClientTypes.QueryOutputVector.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

func httpServiceError(baseError: AWSClientRuntime.RestJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
        case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

enum CreateIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVectorBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVectorBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVectorBucketPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "KmsDisabledException": return try KmsDisabledException.makeError(baseError: baseError)
            case "KmsInvalidKeyUsageException": return try KmsInvalidKeyUsageException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsNotFoundException": return try KmsNotFoundException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIndexOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVectorBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVectorBucketPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "KmsDisabledException": return try KmsDisabledException.makeError(baseError: baseError)
            case "KmsInvalidKeyUsageException": return try KmsInvalidKeyUsageException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsNotFoundException": return try KmsNotFoundException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIndexesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVectorBucketsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVectorBucketPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutVectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "KmsDisabledException": return try KmsDisabledException.makeError(baseError: baseError)
            case "KmsInvalidKeyUsageException": return try KmsInvalidKeyUsageException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsNotFoundException": return try KmsNotFoundException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum QueryVectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "KmsDisabledException": return try KmsDisabledException.makeError(baseError: baseError)
            case "KmsInvalidKeyUsageException": return try KmsInvalidKeyUsageException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsNotFoundException": return try KmsNotFoundException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsDisabledException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KmsDisabledException {
        let reader = baseError.errorBodyReader
        var value = KmsDisabledException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsInvalidKeyUsageException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KmsInvalidKeyUsageException {
        let reader = baseError.errorBodyReader
        var value = KmsInvalidKeyUsageException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsInvalidStateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KmsInvalidStateException {
        let reader = baseError.errorBodyReader
        var value = KmsInvalidStateException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> KmsNotFoundException {
        let reader = baseError.errorBodyReader
        var value = KmsNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: S3VectorsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension S3VectorsClientTypes.Index {

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.Index {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.Index()
        value.vectorBucketName = try reader["vectorBucketName"].readIfPresent() ?? ""
        value.indexName = try reader["indexName"].readIfPresent() ?? ""
        value.indexArn = try reader["indexArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.dimension = try reader["dimension"].readIfPresent() ?? 0
        value.distanceMetric = try reader["distanceMetric"].readIfPresent() ?? .sdkUnknown("")
        value.metadataConfiguration = try reader["metadataConfiguration"].readIfPresent(with: S3VectorsClientTypes.MetadataConfiguration.read(from:))
        return value
    }
}

extension S3VectorsClientTypes.MetadataConfiguration {

    static func write(value: S3VectorsClientTypes.MetadataConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nonFilterableMetadataKeys"].writeList(value.nonFilterableMetadataKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.MetadataConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.MetadataConfiguration()
        value.nonFilterableMetadataKeys = try reader["nonFilterableMetadataKeys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension S3VectorsClientTypes.VectorBucket {

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.VectorBucket {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.VectorBucket()
        value.vectorBucketName = try reader["vectorBucketName"].readIfPresent() ?? ""
        value.vectorBucketArn = try reader["vectorBucketArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: S3VectorsClientTypes.EncryptionConfiguration.read(from:))
        return value
    }
}

extension S3VectorsClientTypes.EncryptionConfiguration {

    static func write(value: S3VectorsClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["sseType"].write(value.sseType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.EncryptionConfiguration()
        value.sseType = try reader["sseType"].readIfPresent() ?? S3VectorsClientTypes.SseType.aes256
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension S3VectorsClientTypes.GetOutputVector {

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.GetOutputVector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.GetOutputVector()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.data = try reader["data"].readIfPresent(with: S3VectorsClientTypes.VectorData.read(from:))
        value.metadata = try reader["metadata"].readIfPresent()
        return value
    }
}

extension S3VectorsClientTypes.VectorData {

    static func write(value: S3VectorsClientTypes.VectorData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .float32(float32):
                try writer["float32"].writeList(float32, memberWritingClosure: SmithyReadWrite.WritingClosures.writeFloat(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.VectorData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "float32":
                return .float32(try reader["float32"].readList(memberReadingClosure: SmithyReadWrite.ReadingClosures.readFloat(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension S3VectorsClientTypes.IndexSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.IndexSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.IndexSummary()
        value.vectorBucketName = try reader["vectorBucketName"].readIfPresent() ?? ""
        value.indexName = try reader["indexName"].readIfPresent() ?? ""
        value.indexArn = try reader["indexArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension S3VectorsClientTypes.VectorBucketSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.VectorBucketSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.VectorBucketSummary()
        value.vectorBucketName = try reader["vectorBucketName"].readIfPresent() ?? ""
        value.vectorBucketArn = try reader["vectorBucketArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension S3VectorsClientTypes.ListOutputVector {

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.ListOutputVector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.ListOutputVector()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.data = try reader["data"].readIfPresent(with: S3VectorsClientTypes.VectorData.read(from:))
        value.metadata = try reader["metadata"].readIfPresent()
        return value
    }
}

extension S3VectorsClientTypes.QueryOutputVector {

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.QueryOutputVector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.QueryOutputVector()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.data = try reader["data"].readIfPresent(with: S3VectorsClientTypes.VectorData.read(from:))
        value.metadata = try reader["metadata"].readIfPresent()
        value.distance = try reader["distance"].readIfPresent()
        return value
    }
}

extension S3VectorsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> S3VectorsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3VectorsClientTypes.ValidationExceptionField()
        value.path = try reader["path"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension S3VectorsClientTypes.PutInputVector {

    static func write(value: S3VectorsClientTypes.PutInputVector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["data"].write(value.data, with: S3VectorsClientTypes.VectorData.write(value:to:))
        try writer["key"].write(value.key)
        try writer["metadata"].write(value.metadata)
    }
}

public enum S3VectorsClientTypes {}
