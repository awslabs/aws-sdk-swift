//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// Access is denied. HTTP status code: 403
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on entity id of an AMI product.
    public struct AmiProductEntityIdFilter: Swift.Sendable {
        /// A string array of unique entity id values to be filtered on.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that contains date range of the last modified date to be filtered on. You can optionally provide a BeforeValue and/or AfterValue. Both are inclusive.
    public struct AmiProductLastModifiedDateFilterDateRange: Swift.Sendable {
        /// Date after which the AMI product was last modified.
        public var afterValue: Swift.String?
        /// Date before which the AMI product was last modified.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering based on the last modified date of AMI products.
    public struct AmiProductLastModifiedDateFilter: Swift.Sendable {
        /// Dates between which the AMI product was last modified.
        public var dateRange: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on product title.
    public struct AmiProductTitleFilter: Swift.Sendable {
        /// A string array of unique product title values to be filtered on.
        public var valueList: [Swift.String]?
        /// A string that will be the wildCard input for product tile filter. It matches the provided value as a substring in the actual value.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum AmiProductVisibilityString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case draft
        case limited
        case `public`
        case restricted
        case sdkUnknown(Swift.String)

        public static var allCases: [AmiProductVisibilityString] {
            return [
                .draft,
                .limited,
                .public,
                .restricted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .limited: return "Limited"
            case .public: return "Public"
            case .restricted: return "Restricted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on the visibility of the product in the AWS Marketplace.
    public struct AmiProductVisibilityFilter: Swift.Sendable {
        /// A string array of unique visibility values to be filtered on.
        public var valueList: [MarketplaceCatalogClientTypes.AmiProductVisibilityString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.AmiProductVisibilityString]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object containing all the filter fields for AMI products. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct AmiProductFilters: Swift.Sendable {
        /// Unique identifier for the AMI product.
        public var entityId: MarketplaceCatalogClientTypes.AmiProductEntityIdFilter?
        /// The last date on which the AMI product was modified.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilter?
        /// The title of the AMI product.
        public var productTitle: MarketplaceCatalogClientTypes.AmiProductTitleFilter?
        /// The visibility of the AMI product.
        public var visibility: MarketplaceCatalogClientTypes.AmiProductVisibilityFilter?

        public init(
            entityId: MarketplaceCatalogClientTypes.AmiProductEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilter? = nil,
            productTitle: MarketplaceCatalogClientTypes.AmiProductTitleFilter? = nil,
            visibility: MarketplaceCatalogClientTypes.AmiProductVisibilityFilter? = nil
        )
        {
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum AmiProductSortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entityid
        case lastmodifieddate
        case producttitle
        case visibility
        case sdkUnknown(Swift.String)

        public static var allCases: [AmiProductSortBy] {
            return [
                .entityid,
                .lastmodifieddate,
                .producttitle,
                .visibility
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .producttitle: return "ProductTitle"
            case .visibility: return "Visibility"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Objects that allows sorting on AMI products based on certain fields and sorting order.
    public struct AmiProductSort: Swift.Sendable {
        /// Field to sort the AMI products by.
        public var sortBy: MarketplaceCatalogClientTypes.AmiProductSortBy?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.AmiProductSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that contains summarized information about an AMI product.
    public struct AmiProductSummary: Swift.Sendable {
        /// The title of the AMI product.
        public var productTitle: Swift.String?
        /// The lifecycle of the AMI product.
        public var visibility: MarketplaceCatalogClientTypes.AmiProductVisibilityString?

        public init(
            productTitle: Swift.String? = nil,
            visibility: MarketplaceCatalogClientTypes.AmiProductVisibilityString? = nil
        )
        {
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }
}

/// There was an internal service exception. HTTP status code: 500
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Too many requests. HTTP status code: 429
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An error occurred during validation. HTTP status code: 422
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MarketplaceCatalogClientTypes {

    /// An object that contains entity ID and the catalog in which the entity is present.
    public struct EntityRequest: Swift.Sendable {
        /// The name of the catalog the entity is present in. The only value at this time is AWSMarketplace.
        /// This member is required.
        public var catalog: Swift.String?
        /// The ID of the entity.
        /// This member is required.
        public var entityId: Swift.String?

        public init(
            catalog: Swift.String? = nil,
            entityId: Swift.String? = nil
        )
        {
            self.catalog = catalog
            self.entityId = entityId
        }
    }
}

public struct BatchDescribeEntitiesInput: Swift.Sendable {
    /// List of entity IDs and the catalogs the entities are present in.
    /// This member is required.
    public var entityRequestList: [MarketplaceCatalogClientTypes.EntityRequest]?

    public init(
        entityRequestList: [MarketplaceCatalogClientTypes.EntityRequest]? = nil
    )
    {
        self.entityRequestList = entityRequestList
    }
}

extension MarketplaceCatalogClientTypes {

    /// An object that contains metadata and details about the entity.
    public struct EntityDetail: Swift.Sendable {
        /// An object that contains all the details of the entity.
        public var detailsDocument: Smithy.Document?
        /// The Amazon Resource Name (ARN) of the entity.
        public var entityArn: Swift.String?
        /// The ID of the entity, in the format of EntityId@RevisionId.
        public var entityIdentifier: Swift.String?
        /// The entity type of the entity, in the format of EntityType@Version.
        public var entityType: Swift.String?
        /// The last time the entity was modified.
        public var lastModifiedDate: Swift.String?

        public init(
            detailsDocument: Smithy.Document? = nil,
            entityArn: Swift.String? = nil,
            entityIdentifier: Swift.String? = nil,
            entityType: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil
        )
        {
            self.detailsDocument = detailsDocument
            self.entityArn = entityArn
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.lastModifiedDate = lastModifiedDate
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// An object that contains an error code and error message.
    public struct BatchDescribeErrorDetail: Swift.Sendable {
        /// The error code returned.
        public var errorCode: Swift.String?
        /// The error message returned.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

public struct BatchDescribeEntitiesOutput: Swift.Sendable {
    /// Details about each entity.
    public var entityDetails: [Swift.String: MarketplaceCatalogClientTypes.EntityDetail]?
    /// A map of errors returned, with EntityId as the key and errorDetail as the value.
    public var errors: [Swift.String: MarketplaceCatalogClientTypes.BatchDescribeErrorDetail]?

    public init(
        entityDetails: [Swift.String: MarketplaceCatalogClientTypes.EntityDetail]? = nil,
        errors: [Swift.String: MarketplaceCatalogClientTypes.BatchDescribeErrorDetail]? = nil
    )
    {
        self.entityDetails = entityDetails
        self.errors = errors
    }
}

/// The resource is currently in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource wasn't found. HTTP status code: 404
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelChangeSetInput: Swift.Sendable {
    /// Required. The catalog related to the request. Fixed value: AWSMarketplace.
    /// This member is required.
    public var catalog: Swift.String?
    /// Required. The unique identifier of the StartChangeSet request that you want to cancel.
    /// This member is required.
    public var changeSetId: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.changeSetId = changeSetId
    }
}

public struct CancelChangeSetOutput: Swift.Sendable {
    /// The ARN associated with the change set referenced in this request.
    public var changeSetArn: Swift.String?
    /// The unique identifier for the change set referenced in this request.
    public var changeSetId: Swift.String?

    public init(
        changeSetArn: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
    }
}

public struct DeleteResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the entity resource that is associated with the resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeChangeSetInput: Swift.Sendable {
    /// Required. The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// Required. The unique identifier for the StartChangeSet request that you want to describe the details for.
    /// This member is required.
    public var changeSetId: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.changeSetId = changeSetId
    }
}

extension MarketplaceCatalogClientTypes {

    /// An entity contains data that describes your product, its supported features, and how it can be used or launched by your customer.
    public struct Entity: Swift.Sendable {
        /// The identifier for the entity.
        public var identifier: Swift.String?
        /// The type of entity.
        /// This member is required.
        public var type: Swift.String?

        public init(
            identifier: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.identifier = identifier
            self.type = type
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Details about the error.
    public struct ErrorDetail: Swift.Sendable {
        /// The error code that identifies the type of error.
        public var errorCode: Swift.String?
        /// The message for the error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// This object is a container for common summary information about the change. The summary doesn't contain the whole change structure.
    public struct ChangeSummary: Swift.Sendable {
        /// Optional name for the change.
        public var changeName: Swift.String?
        /// The type of the change.
        public var changeType: Swift.String?
        /// This object contains details specific to the change type of the requested change.
        public var details: Swift.String?
        /// The JSON value of the details specific to the change type of the requested change.
        public var detailsDocument: Smithy.Document?
        /// The entity to be changed.
        public var entity: MarketplaceCatalogClientTypes.Entity?
        /// An array of ErrorDetail objects associated with the change.
        public var errorDetailList: [MarketplaceCatalogClientTypes.ErrorDetail]?

        public init(
            changeName: Swift.String? = nil,
            changeType: Swift.String? = nil,
            details: Swift.String? = nil,
            detailsDocument: Smithy.Document? = nil,
            entity: MarketplaceCatalogClientTypes.Entity? = nil,
            errorDetailList: [MarketplaceCatalogClientTypes.ErrorDetail]? = nil
        )
        {
            self.changeName = changeName
            self.changeType = changeType
            self.details = details
            self.detailsDocument = detailsDocument
            self.entity = entity
            self.errorDetailList = errorDetailList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum FailureCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clienterror
        case serverfault
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureCode] {
            return [
                .clienterror,
                .serverfault
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clienterror: return "CLIENT_ERROR"
            case .serverfault: return "SERVER_FAULT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum Intent: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apply
        case validate
        case sdkUnknown(Swift.String)

        public static var allCases: [Intent] {
            return [
                .apply,
                .validate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apply: return "APPLY"
            case .validate: return "VALIDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum ChangeStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applying
        case cancelled
        case failed
        case preparing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeStatus] {
            return [
                .applying,
                .cancelled,
                .failed,
                .preparing,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applying: return "APPLYING"
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .preparing: return "PREPARING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeChangeSetOutput: Swift.Sendable {
    /// An array of ChangeSummary objects.
    public var changeSet: [MarketplaceCatalogClientTypes.ChangeSummary]?
    /// The ARN associated with the unique identifier for the change set referenced in this request.
    public var changeSetArn: Swift.String?
    /// Required. The unique identifier for the change set referenced in this request.
    public var changeSetId: Swift.String?
    /// The optional name provided in the StartChangeSet request. If you do not provide a name, one is set by default.
    public var changeSetName: Swift.String?
    /// The date and time, in ISO 8601 format (2018-02-27T13:45:22Z), the request transitioned to a terminal state. The change cannot transition to a different state. Null if the request is not in a terminal state.
    public var endTime: Swift.String?
    /// Returned if the change set is in FAILED status. Can be either CLIENT_ERROR, which means that there are issues with the request (see the ErrorDetailList), or SERVER_FAULT, which means that there is a problem in the system, and you should retry your request.
    public var failureCode: MarketplaceCatalogClientTypes.FailureCode?
    /// Returned if there is a failure on the change set, but that failure is not related to any of the changes in the request.
    public var failureDescription: Swift.String?
    /// The optional intent provided in the StartChangeSet request. If you do not provide an intent, APPLY is set by default.
    public var intent: MarketplaceCatalogClientTypes.Intent?
    /// The date and time, in ISO 8601 format (2018-02-27T13:45:22Z), the request started.
    public var startTime: Swift.String?
    /// The status of the change request.
    public var status: MarketplaceCatalogClientTypes.ChangeStatus?

    public init(
        changeSet: [MarketplaceCatalogClientTypes.ChangeSummary]? = nil,
        changeSetArn: Swift.String? = nil,
        changeSetId: Swift.String? = nil,
        changeSetName: Swift.String? = nil,
        endTime: Swift.String? = nil,
        failureCode: MarketplaceCatalogClientTypes.FailureCode? = nil,
        failureDescription: Swift.String? = nil,
        intent: MarketplaceCatalogClientTypes.Intent? = nil,
        startTime: Swift.String? = nil,
        status: MarketplaceCatalogClientTypes.ChangeStatus? = nil
    )
    {
        self.changeSet = changeSet
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
        self.changeSetName = changeSetName
        self.endTime = endTime
        self.failureCode = failureCode
        self.failureDescription = failureDescription
        self.intent = intent
        self.startTime = startTime
        self.status = status
    }
}

/// Currently, the specified resource is not supported.
public struct ResourceNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotSupportedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeEntityInput: Swift.Sendable {
    /// Required. The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// Required. The unique ID of the entity to describe.
    /// This member is required.
    public var entityId: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        entityId: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.entityId = entityId
    }
}

public struct DescribeEntityOutput: Swift.Sendable {
    /// This stringified JSON object includes the details of the entity.
    public var details: Swift.String?
    /// The JSON value of the details specific to the entity.
    public var detailsDocument: Smithy.Document?
    /// The ARN associated to the unique identifier for the entity referenced in this request.
    public var entityArn: Swift.String?
    /// The identifier of the entity, in the format of EntityId@RevisionId.
    public var entityIdentifier: Swift.String?
    /// The named type of the entity, in the format of EntityType@Version.
    public var entityType: Swift.String?
    /// The last modified date of the entity, in ISO 8601 format (2018-02-27T13:45:22Z).
    public var lastModifiedDate: Swift.String?

    public init(
        details: Swift.String? = nil,
        detailsDocument: Smithy.Document? = nil,
        entityArn: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: Swift.String? = nil,
        lastModifiedDate: Swift.String? = nil
    )
    {
        self.details = details
        self.detailsDocument = detailsDocument
        self.entityArn = entityArn
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.lastModifiedDate = lastModifiedDate
    }
}

public struct GetResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the entity resource that is associated with the resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput: Swift.Sendable {
    /// The policy document to set; formatted in JSON.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

extension MarketplaceCatalogClientTypes {

    /// A filter object, used to optionally filter results from calls to the ListEntities and ListChangeSets actions.
    public struct Filter: Swift.Sendable {
        /// For ListEntities, the supported value for this is an EntityId. For ListChangeSets, the supported values are as follows:
        public var name: Swift.String?
        /// ListEntities - This is a list of unique EntityIds. ListChangeSets - The supported filter names and associated ValueLists is as follows:
        ///
        /// * ChangeSetName - The supported ValueList is a list of non-unique ChangeSetNames. These are defined when you call the StartChangeSet action.
        ///
        /// * Status - The supported ValueList is a list of statuses for all change set requests.
        ///
        /// * EntityId - The supported ValueList is a list of unique EntityIds.
        ///
        /// * BeforeStartTime - The supported ValueList is a list of all change sets that started before the filter value.
        ///
        /// * AfterStartTime - The supported ValueList is a list of all change sets that started after the filter value.
        ///
        /// * BeforeEndTime - The supported ValueList is a list of all change sets that ended before the filter value.
        ///
        /// * AfterEndTime - The supported ValueList is a list of all change sets that ended after the filter value.
        public var valueList: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            valueList: [Swift.String]? = nil
        )
        {
            self.name = name
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// An object that contains two attributes, SortBy and SortOrder.
    public struct Sort: Swift.Sendable {
        /// For ListEntities, supported attributes include LastModifiedDate (default) and EntityId. In addition to LastModifiedDate and EntityId, each EntityType might support additional fields. For ListChangeSets, supported attributes include StartTime and EndTime.
        public var sortBy: Swift.String?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: Swift.String? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

public struct ListChangeSetsInput: Swift.Sendable {
    /// The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// An array of filter objects.
    public var filterList: [MarketplaceCatalogClientTypes.Filter]?
    /// The maximum number of results returned by a single call. This value must be provided in the next call to retrieve the next set of results. By default, this value is 20.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// An object that contains two attributes, SortBy and SortOrder.
    public var sort: MarketplaceCatalogClientTypes.Sort?

    public init(
        catalog: Swift.String? = nil,
        filterList: [MarketplaceCatalogClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: MarketplaceCatalogClientTypes.Sort? = nil
    )
    {
        self.catalog = catalog
        self.filterList = filterList
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

extension MarketplaceCatalogClientTypes {

    /// A summary of a change set returned in a list of change sets when the ListChangeSets action is called.
    public struct ChangeSetSummaryListItem: Swift.Sendable {
        /// The ARN associated with the unique identifier for the change set referenced in this request.
        public var changeSetArn: Swift.String?
        /// The unique identifier for a change set.
        public var changeSetId: Swift.String?
        /// The non-unique name for the change set.
        public var changeSetName: Swift.String?
        /// The time, in ISO 8601 format (2018-02-27T13:45:22Z), when the change set was finished.
        public var endTime: Swift.String?
        /// This object is a list of entity IDs (string) that are a part of a change set. The entity ID list is a maximum of 20 entities. It must contain at least one entity.
        public var entityIdList: [Swift.String]?
        /// Returned if the change set is in FAILED status. Can be either CLIENT_ERROR, which means that there are issues with the request (see the ErrorDetailList of DescribeChangeSet), or SERVER_FAULT, which means that there is a problem in the system, and you should retry your request.
        public var failureCode: MarketplaceCatalogClientTypes.FailureCode?
        /// The time, in ISO 8601 format (2018-02-27T13:45:22Z), when the change set was started.
        public var startTime: Swift.String?
        /// The current status of the change set.
        public var status: MarketplaceCatalogClientTypes.ChangeStatus?

        public init(
            changeSetArn: Swift.String? = nil,
            changeSetId: Swift.String? = nil,
            changeSetName: Swift.String? = nil,
            endTime: Swift.String? = nil,
            entityIdList: [Swift.String]? = nil,
            failureCode: MarketplaceCatalogClientTypes.FailureCode? = nil,
            startTime: Swift.String? = nil,
            status: MarketplaceCatalogClientTypes.ChangeStatus? = nil
        )
        {
            self.changeSetArn = changeSetArn
            self.changeSetId = changeSetId
            self.changeSetName = changeSetName
            self.endTime = endTime
            self.entityIdList = entityIdList
            self.failureCode = failureCode
            self.startTime = startTime
            self.status = status
        }
    }
}

public struct ListChangeSetsOutput: Swift.Sendable {
    /// Array of ChangeSetSummaryListItem objects.
    public var changeSetSummaryList: [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]?
    /// The value of the next token, if it exists. Null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        changeSetSummaryList: [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.changeSetSummaryList = changeSetSummaryList
        self.nextToken = nextToken
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on entity id of a container product.
    public struct ContainerProductEntityIdFilter: Swift.Sendable {
        /// A string array of unique entity id values to be filtered on.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that contains date range of the last modified date to be filtered on. You can optionally provide a BeforeValue and/or AfterValue. Both are inclusive.
    public struct ContainerProductLastModifiedDateFilterDateRange: Swift.Sendable {
        /// Date after which the container product was last modified.
        public var afterValue: Swift.String?
        /// Date before which the container product was last modified.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering based on the last modified date of container products.
    public struct ContainerProductLastModifiedDateFilter: Swift.Sendable {
        /// Dates between which the container product was last modified.
        public var dateRange: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on product title.
    public struct ContainerProductTitleFilter: Swift.Sendable {
        /// A string array of unique product title values to be filtered on.
        public var valueList: [Swift.String]?
        /// A string that will be the wildCard input for product tile filter. It matches the provided value as a substring in the actual value.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum ContainerProductVisibilityString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case draft
        case limited
        case `public`
        case restricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerProductVisibilityString] {
            return [
                .draft,
                .limited,
                .public,
                .restricted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .limited: return "Limited"
            case .public: return "Public"
            case .restricted: return "Restricted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on the visibility of the product in the AWS Marketplace.
    public struct ContainerProductVisibilityFilter: Swift.Sendable {
        /// A string array of unique visibility values to be filtered on.
        public var valueList: [MarketplaceCatalogClientTypes.ContainerProductVisibilityString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.ContainerProductVisibilityString]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object containing all the filter fields for container products. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct ContainerProductFilters: Swift.Sendable {
        /// Unique identifier for the container product.
        public var entityId: MarketplaceCatalogClientTypes.ContainerProductEntityIdFilter?
        /// The last date on which the container product was modified.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilter?
        /// The title of the container product.
        public var productTitle: MarketplaceCatalogClientTypes.ContainerProductTitleFilter?
        /// The visibility of the container product.
        public var visibility: MarketplaceCatalogClientTypes.ContainerProductVisibilityFilter?

        public init(
            entityId: MarketplaceCatalogClientTypes.ContainerProductEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilter? = nil,
            productTitle: MarketplaceCatalogClientTypes.ContainerProductTitleFilter? = nil,
            visibility: MarketplaceCatalogClientTypes.ContainerProductVisibilityFilter? = nil
        )
        {
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on entity id of a data product.
    public struct DataProductEntityIdFilter: Swift.Sendable {
        /// A string array of unique entity id values to be filtered on.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that contains date range of the last modified date to be filtered on. You can optionally provide a BeforeValue and/or AfterValue. Both are inclusive.
    public struct DataProductLastModifiedDateFilterDateRange: Swift.Sendable {
        /// Date after which the data product was last modified.
        public var afterValue: Swift.String?
        /// Date before which the data product was last modified.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering based on the last modified date of data products.
    public struct DataProductLastModifiedDateFilter: Swift.Sendable {
        /// Dates between which the data product was last modified.
        public var dateRange: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on product title.
    public struct DataProductTitleFilter: Swift.Sendable {
        /// A string array of unique product title values to be filtered on.
        public var valueList: [Swift.String]?
        /// A string that will be the wildCard input for product tile filter. It matches the provided value as a substring in the actual value.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum DataProductVisibilityString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case draft
        case limited
        case `public`
        case restricted
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DataProductVisibilityString] {
            return [
                .draft,
                .limited,
                .public,
                .restricted,
                .unavailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .limited: return "Limited"
            case .public: return "Public"
            case .restricted: return "Restricted"
            case .unavailable: return "Unavailable"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on the visibility of the product in the AWS Marketplace.
    public struct DataProductVisibilityFilter: Swift.Sendable {
        /// A string array of unique visibility values to be filtered on.
        public var valueList: [MarketplaceCatalogClientTypes.DataProductVisibilityString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.DataProductVisibilityString]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object containing all the filter fields for data products. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct DataProductFilters: Swift.Sendable {
        /// Unique identifier for the data product.
        public var entityId: MarketplaceCatalogClientTypes.DataProductEntityIdFilter?
        /// The last date on which the data product was modified.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilter?
        /// The title of the data product.
        public var productTitle: MarketplaceCatalogClientTypes.DataProductTitleFilter?
        /// The visibility of the data product.
        public var visibility: MarketplaceCatalogClientTypes.DataProductVisibilityFilter?

        public init(
            entityId: MarketplaceCatalogClientTypes.DataProductEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilter? = nil,
            productTitle: MarketplaceCatalogClientTypes.DataProductTitleFilter? = nil,
            visibility: MarketplaceCatalogClientTypes.DataProductVisibilityFilter? = nil
        )
        {
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the AvailabilityEndDate of an offer with date range as input.
    public struct OfferAvailabilityEndDateFilterDateRange: Swift.Sendable {
        /// Allows filtering on the AvailabilityEndDate of an offer after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on the AvailabilityEndDate of an offer before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the AvailabilityEndDate of an offer.
    public struct OfferAvailabilityEndDateFilter: Swift.Sendable {
        /// Allows filtering on the AvailabilityEndDate of an offer with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the BuyerAccounts of an offer.
    public struct OfferBuyerAccountsFilter: Swift.Sendable {
        /// Allows filtering on the BuyerAccounts of an offer with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            wildCardValue: Swift.String? = nil
        )
        {
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the entity id of an offer.
    public struct OfferEntityIdFilter: Swift.Sendable {
        /// Allows filtering on entity id of an offer with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the LastModifiedDate of an offer with date range as input.
    public struct OfferLastModifiedDateFilterDateRange: Swift.Sendable {
        /// Allows filtering on the LastModifiedDate of an offer after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on the LastModifiedDate of an offer before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the LastModifiedDate of an offer.
    public struct OfferLastModifiedDateFilter: Swift.Sendable {
        /// Allows filtering on the LastModifiedDate of an offer with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the Name of an offer.
    public struct OfferNameFilter: Swift.Sendable {
        /// Allows filtering on the Name of an offer with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the Name of an offer with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ProductId of an offer.
    public struct OfferProductIdFilter: Swift.Sendable {
        /// Allows filtering on the ProductId of an offer with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ReleaseDate of an offer with date range as input.
    public struct OfferReleaseDateFilterDateRange: Swift.Sendable {
        /// Allows filtering on the ReleaseDate of offers after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on the ReleaseDate of offers before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ReleaseDate of an offer.
    public struct OfferReleaseDateFilter: Swift.Sendable {
        /// Allows filtering on the ReleaseDate of an offer with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.OfferReleaseDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.OfferReleaseDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ResaleAuthorizationId of an offer. Not all offers have a ResaleAuthorizationId. The response will only include offers for which you have permissions.
    public struct OfferResaleAuthorizationIdFilter: Swift.Sendable {
        /// Allows filtering on the ResaleAuthorizationId of an offer with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum OfferStateString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case draft
        case released
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferStateString] {
            return [
                .draft,
                .released
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .released: return "Released"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the State of an offer.
    public struct OfferStateFilter: Swift.Sendable {
        /// Allows filtering on the State of an offer with list input.
        public var valueList: [MarketplaceCatalogClientTypes.OfferStateString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.OfferStateString]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum OfferTargetingString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case buyeraccounts
        case countrycodes
        case `none`
        case participatingprograms
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferTargetingString] {
            return [
                .buyeraccounts,
                .countrycodes,
                .none,
                .participatingprograms
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .buyeraccounts: return "BuyerAccounts"
            case .countrycodes: return "CountryCodes"
            case .none: return "None"
            case .participatingprograms: return "ParticipatingPrograms"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the Targeting of an offer.
    public struct OfferTargetingFilter: Swift.Sendable {
        /// Allows filtering on the Targeting of an offer with list input.
        public var valueList: [MarketplaceCatalogClientTypes.OfferTargetingString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.OfferTargetingString]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object containing all the filter fields for offers entity. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct OfferFilters: Swift.Sendable {
        /// Allows filtering on the AvailabilityEndDate of an offer.
        public var availabilityEndDate: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilter?
        /// Allows filtering on the BuyerAccounts of an offer.
        public var buyerAccounts: MarketplaceCatalogClientTypes.OfferBuyerAccountsFilter?
        /// Allows filtering on EntityId of an offer.
        public var entityId: MarketplaceCatalogClientTypes.OfferEntityIdFilter?
        /// Allows filtering on the LastModifiedDate of an offer.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilter?
        /// Allows filtering on the Name of an offer.
        public var name: MarketplaceCatalogClientTypes.OfferNameFilter?
        /// Allows filtering on the ProductId of an offer.
        public var productId: MarketplaceCatalogClientTypes.OfferProductIdFilter?
        /// Allows filtering on the ReleaseDate of an offer.
        public var releaseDate: MarketplaceCatalogClientTypes.OfferReleaseDateFilter?
        /// Allows filtering on the ResaleAuthorizationId of an offer. Not all offers have a ResaleAuthorizationId. The response will only include offers for which you have permissions.
        public var resaleAuthorizationId: MarketplaceCatalogClientTypes.OfferResaleAuthorizationIdFilter?
        /// Allows filtering on the State of an offer.
        public var state: MarketplaceCatalogClientTypes.OfferStateFilter?
        /// Allows filtering on the Targeting of an offer.
        public var targeting: MarketplaceCatalogClientTypes.OfferTargetingFilter?

        public init(
            availabilityEndDate: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilter? = nil,
            buyerAccounts: MarketplaceCatalogClientTypes.OfferBuyerAccountsFilter? = nil,
            entityId: MarketplaceCatalogClientTypes.OfferEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilter? = nil,
            name: MarketplaceCatalogClientTypes.OfferNameFilter? = nil,
            productId: MarketplaceCatalogClientTypes.OfferProductIdFilter? = nil,
            releaseDate: MarketplaceCatalogClientTypes.OfferReleaseDateFilter? = nil,
            resaleAuthorizationId: MarketplaceCatalogClientTypes.OfferResaleAuthorizationIdFilter? = nil,
            state: MarketplaceCatalogClientTypes.OfferStateFilter? = nil,
            targeting: MarketplaceCatalogClientTypes.OfferTargetingFilter? = nil
        )
        {
            self.availabilityEndDate = availabilityEndDate
            self.buyerAccounts = buyerAccounts
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.productId = productId
            self.releaseDate = releaseDate
            self.resaleAuthorizationId = resaleAuthorizationId
            self.state = state
            self.targeting = targeting
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization with date range as input.
    public struct ResaleAuthorizationAvailabilityEndDateFilterDateRange: Swift.Sendable {
        /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization.
    public struct ResaleAuthorizationAvailabilityEndDateFilter: Swift.Sendable {
        /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization with date range as input
        public var dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilterDateRange?
        /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization with date value as input.
        public var valueList: [Swift.String]?

        public init(
            dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilterDateRange? = nil,
            valueList: [Swift.String]? = nil
        )
        {
            self.dateRange = dateRange
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on CreatedDate of a ResaleAuthorization with date range as input.
    public struct ResaleAuthorizationCreatedDateFilterDateRange: Swift.Sendable {
        /// Allows filtering on CreatedDate of a ResaleAuthorization after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on CreatedDate of a ResaleAuthorization before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on CreatedDate of a ResaleAuthorization.
    public struct ResaleAuthorizationCreatedDateFilter: Swift.Sendable {
        /// Allows filtering on CreatedDate of a ResaleAuthorization with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilterDateRange?
        /// Allows filtering on CreatedDate of a ResaleAuthorization with date value as input.
        public var valueList: [Swift.String]?

        public init(
            dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilterDateRange? = nil,
            valueList: [Swift.String]? = nil
        )
        {
            self.dateRange = dateRange
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on EntityId of a ResaleAuthorization.
    public struct ResaleAuthorizationEntityIdFilter: Swift.Sendable {
        /// Allows filtering on EntityId of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the LastModifiedDate of a ResaleAuthorization with date range as input.
    public struct ResaleAuthorizationLastModifiedDateFilterDateRange: Swift.Sendable {
        /// Allows filtering on the LastModifiedDate of a ResaleAuthorization after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on the LastModifiedDate of a ResaleAuthorization before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the LastModifiedDate of a ResaleAuthorization.
    public struct ResaleAuthorizationLastModifiedDateFilter: Swift.Sendable {
        /// Allows filtering on the LastModifiedDate of a ResaleAuthorization with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ManufacturerAccountId of a ResaleAuthorization.
    public struct ResaleAuthorizationManufacturerAccountIdFilter: Swift.Sendable {
        /// Allows filtering on the ManufacturerAccountId of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ManufacturerAccountId of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ManufacturerLegalName of a ResaleAuthorization.
    public struct ResaleAuthorizationManufacturerLegalNameFilter: Swift.Sendable {
        /// Allows filtering on the ManufacturerLegalName of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ManufacturerLegalName of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the Name of a ResaleAuthorization.
    public struct ResaleAuthorizationNameFilter: Swift.Sendable {
        /// Allows filtering on the Name of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the Name of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the OfferExtendedStatus of a ResaleAuthorization.
    public struct ResaleAuthorizationOfferExtendedStatusFilter: Swift.Sendable {
        /// Allows filtering on the OfferExtendedStatus of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ProductId of a ResaleAuthorization.
    public struct ResaleAuthorizationProductIdFilter: Swift.Sendable {
        /// Allows filtering on the ProductId of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ProductId of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ProductName of a ResaleAuthorization.
    public struct ResaleAuthorizationProductNameFilter: Swift.Sendable {
        /// Allows filtering on the ProductName of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ProductName of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ResellerAccountID of a ResaleAuthorization.
    public struct ResaleAuthorizationResellerAccountIDFilter: Swift.Sendable {
        /// Allows filtering on the ResellerAccountID of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ResellerAccountID of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the ResellerLegalName of a ResaleAuthorization.
    public struct ResaleAuthorizationResellerLegalNameFilter: Swift.Sendable {
        /// Allows filtering on the ResellerLegalNameProductName of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ResellerLegalName of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum ResaleAuthorizationStatusString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case draft
        case restricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ResaleAuthorizationStatusString] {
            return [
                .active,
                .draft,
                .restricted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .draft: return "Draft"
            case .restricted: return "Restricted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows filtering on the Status of a ResaleAuthorization.
    public struct ResaleAuthorizationStatusFilter: Swift.Sendable {
        /// Allows filtering on the Status of a ResaleAuthorization with list input.
        public var valueList: [MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object containing all the filter fields for resale authorization entity. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct ResaleAuthorizationFilters: Swift.Sendable {
        /// Allows filtering on the AvailabilityEndDate of a ResaleAuthorization.
        public var availabilityEndDate: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilter?
        /// Allows filtering on the CreatedDate of a ResaleAuthorization.
        public var createdDate: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilter?
        /// Allows filtering on the EntityId of a ResaleAuthorization.
        public var entityId: MarketplaceCatalogClientTypes.ResaleAuthorizationEntityIdFilter?
        /// Allows filtering on the LastModifiedDate of a ResaleAuthorization.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilter?
        /// Allows filtering on the ManufacturerAccountId of a ResaleAuthorization.
        public var manufacturerAccountId: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerAccountIdFilter?
        /// Allows filtering on the ManufacturerLegalName of a ResaleAuthorization.
        public var manufacturerLegalName: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerLegalNameFilter?
        /// Allows filtering on the Name of a ResaleAuthorization.
        public var name: MarketplaceCatalogClientTypes.ResaleAuthorizationNameFilter?
        /// Allows filtering on the OfferExtendedStatus of a ResaleAuthorization.
        public var offerExtendedStatus: MarketplaceCatalogClientTypes.ResaleAuthorizationOfferExtendedStatusFilter?
        /// Allows filtering on the ProductId of a ResaleAuthorization.
        public var productId: MarketplaceCatalogClientTypes.ResaleAuthorizationProductIdFilter?
        /// Allows filtering on the ProductName of a ResaleAuthorization.
        public var productName: MarketplaceCatalogClientTypes.ResaleAuthorizationProductNameFilter?
        /// Allows filtering on the ResellerAccountID of a ResaleAuthorization.
        public var resellerAccountID: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerAccountIDFilter?
        /// Allows filtering on the ResellerLegalName of a ResaleAuthorization.
        public var resellerLegalName: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerLegalNameFilter?
        /// Allows filtering on the Status of a ResaleAuthorization.
        public var status: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusFilter?

        public init(
            availabilityEndDate: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilter? = nil,
            createdDate: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilter? = nil,
            entityId: MarketplaceCatalogClientTypes.ResaleAuthorizationEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilter? = nil,
            manufacturerAccountId: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerAccountIdFilter? = nil,
            manufacturerLegalName: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerLegalNameFilter? = nil,
            name: MarketplaceCatalogClientTypes.ResaleAuthorizationNameFilter? = nil,
            offerExtendedStatus: MarketplaceCatalogClientTypes.ResaleAuthorizationOfferExtendedStatusFilter? = nil,
            productId: MarketplaceCatalogClientTypes.ResaleAuthorizationProductIdFilter? = nil,
            productName: MarketplaceCatalogClientTypes.ResaleAuthorizationProductNameFilter? = nil,
            resellerAccountID: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerAccountIDFilter? = nil,
            resellerLegalName: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerLegalNameFilter? = nil,
            status: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusFilter? = nil
        )
        {
            self.availabilityEndDate = availabilityEndDate
            self.createdDate = createdDate
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.manufacturerAccountId = manufacturerAccountId
            self.manufacturerLegalName = manufacturerLegalName
            self.name = name
            self.offerExtendedStatus = offerExtendedStatus
            self.productId = productId
            self.productName = productName
            self.resellerAccountID = resellerAccountID
            self.resellerLegalName = resellerLegalName
            self.status = status
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on entity id of a SaaS product.
    public struct SaaSProductEntityIdFilter: Swift.Sendable {
        /// A string array of unique entity id values to be filtered on.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that contains date range of the last modified date to be filtered on. You can optionally provide a BeforeValue and/or AfterValue. Both are inclusive.
    public struct SaaSProductLastModifiedDateFilterDateRange: Swift.Sendable {
        /// Date after which the SaaS product was last modified.
        public var afterValue: Swift.String?
        /// Date before which the SaaS product was last modified.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering based on the last modified date of SaaS products
    public struct SaaSProductLastModifiedDateFilter: Swift.Sendable {
        /// Dates between which the SaaS product was last modified.
        public var dateRange: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on product title.
    public struct SaaSProductTitleFilter: Swift.Sendable {
        /// A string array of unique product title values to be filtered on.
        public var valueList: [Swift.String]?
        /// A string that will be the wildCard input for product tile filter. It matches the provided value as a substring in the actual value.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum SaaSProductVisibilityString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case draft
        case limited
        case `public`
        case restricted
        case sdkUnknown(Swift.String)

        public static var allCases: [SaaSProductVisibilityString] {
            return [
                .draft,
                .limited,
                .public,
                .restricted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .limited: return "Limited"
            case .public: return "Public"
            case .restricted: return "Restricted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that allows filtering on the visibility of the product in the AWS Marketplace.
    public struct SaaSProductVisibilityFilter: Swift.Sendable {
        /// A string array of unique visibility values to be filtered on.
        public var valueList: [MarketplaceCatalogClientTypes.SaaSProductVisibilityString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.SaaSProductVisibilityString]? = nil
        )
        {
            self.valueList = valueList
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object containing all the filter fields for SaaS products. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct SaaSProductFilters: Swift.Sendable {
        /// Unique identifier for the SaaS product.
        public var entityId: MarketplaceCatalogClientTypes.SaaSProductEntityIdFilter?
        /// The last date on which the SaaS product was modified.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilter?
        /// The title of the SaaS product.
        public var productTitle: MarketplaceCatalogClientTypes.SaaSProductTitleFilter?
        /// The visibility of the SaaS product.
        public var visibility: MarketplaceCatalogClientTypes.SaaSProductVisibilityFilter?

        public init(
            entityId: MarketplaceCatalogClientTypes.SaaSProductEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilter? = nil,
            productTitle: MarketplaceCatalogClientTypes.SaaSProductTitleFilter? = nil,
            visibility: MarketplaceCatalogClientTypes.SaaSProductVisibilityFilter? = nil
        )
        {
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object containing all the filter fields per entity type.
    public enum EntityTypeFilters: Swift.Sendable {
        /// A filter for data products.
        case dataproductfilters(MarketplaceCatalogClientTypes.DataProductFilters)
        /// A filter for SaaS products.
        case saasproductfilters(MarketplaceCatalogClientTypes.SaaSProductFilters)
        /// A filter for AMI products.
        case amiproductfilters(MarketplaceCatalogClientTypes.AmiProductFilters)
        /// A filter for offers.
        case offerfilters(MarketplaceCatalogClientTypes.OfferFilters)
        /// A filter for container products.
        case containerproductfilters(MarketplaceCatalogClientTypes.ContainerProductFilters)
        /// A filter for Resale Authorizations.
        case resaleauthorizationfilters(MarketplaceCatalogClientTypes.ResaleAuthorizationFilters)
        case sdkUnknown(Swift.String)
    }
}

extension MarketplaceCatalogClientTypes {

    public enum ContainerProductSortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entityid
        case lastmodifieddate
        case producttitle
        case visibility
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerProductSortBy] {
            return [
                .entityid,
                .lastmodifieddate,
                .producttitle,
                .visibility
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .producttitle: return "ProductTitle"
            case .visibility: return "Visibility"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Objects that allows sorting on container products based on certain fields and sorting order.
    public struct ContainerProductSort: Swift.Sendable {
        /// Field to sort the container products by.
        public var sortBy: MarketplaceCatalogClientTypes.ContainerProductSortBy?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.ContainerProductSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum DataProductSortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entityid
        case lastmodifieddate
        case producttitle
        case visibility
        case sdkUnknown(Swift.String)

        public static var allCases: [DataProductSortBy] {
            return [
                .entityid,
                .lastmodifieddate,
                .producttitle,
                .visibility
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .producttitle: return "ProductTitle"
            case .visibility: return "Visibility"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Objects that allows sorting on data products based on certain fields and sorting order.
    public struct DataProductSort: Swift.Sendable {
        /// Field to sort the data products by.
        public var sortBy: MarketplaceCatalogClientTypes.DataProductSortBy?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.DataProductSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum OfferSortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case availabilityenddate
        case buyeraccounts
        case entityid
        case lastmodifieddate
        case name
        case productid
        case releasedate
        case resaleauthorizationid
        case state
        case targeting
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferSortBy] {
            return [
                .availabilityenddate,
                .buyeraccounts,
                .entityid,
                .lastmodifieddate,
                .name,
                .productid,
                .releasedate,
                .resaleauthorizationid,
                .state,
                .targeting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .availabilityenddate: return "AvailabilityEndDate"
            case .buyeraccounts: return "BuyerAccounts"
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .name: return "Name"
            case .productid: return "ProductId"
            case .releasedate: return "ReleaseDate"
            case .resaleauthorizationid: return "ResaleAuthorizationId"
            case .state: return "State"
            case .targeting: return "Targeting"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows to sort offers.
    public struct OfferSort: Swift.Sendable {
        /// Allows to sort offers.
        public var sortBy: MarketplaceCatalogClientTypes.OfferSortBy?
        /// Allows to sort offers.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.OfferSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum ResaleAuthorizationSortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case availabilityenddate
        case createddate
        case entityid
        case lastmodifieddate
        case manufactureraccountid
        case manufacturerlegalname
        case name
        case offerextendedstatus
        case productid
        case productname
        case reselleraccountid
        case resellerlegalname
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ResaleAuthorizationSortBy] {
            return [
                .availabilityenddate,
                .createddate,
                .entityid,
                .lastmodifieddate,
                .manufactureraccountid,
                .manufacturerlegalname,
                .name,
                .offerextendedstatus,
                .productid,
                .productname,
                .reselleraccountid,
                .resellerlegalname,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .availabilityenddate: return "AvailabilityEndDate"
            case .createddate: return "CreatedDate"
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .manufactureraccountid: return "ManufacturerAccountId"
            case .manufacturerlegalname: return "ManufacturerLegalName"
            case .name: return "Name"
            case .offerextendedstatus: return "OfferExtendedStatus"
            case .productid: return "ProductId"
            case .productname: return "ProductName"
            case .reselleraccountid: return "ResellerAccountID"
            case .resellerlegalname: return "ResellerLegalName"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Allows to sort ResaleAuthorization.
    public struct ResaleAuthorizationSort: Swift.Sendable {
        /// Allows to sort ResaleAuthorization.
        public var sortBy: MarketplaceCatalogClientTypes.ResaleAuthorizationSortBy?
        /// Allows to sort ResaleAuthorization.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.ResaleAuthorizationSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension MarketplaceCatalogClientTypes {

    public enum SaaSProductSortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entityid
        case lastmodifieddate
        case producttitle
        case visibility
        case sdkUnknown(Swift.String)

        public static var allCases: [SaaSProductSortBy] {
            return [
                .entityid,
                .lastmodifieddate,
                .producttitle,
                .visibility
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .producttitle: return "ProductTitle"
            case .visibility: return "Visibility"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Objects that allows sorting on SaaS products based on certain fields and sorting order.
    public struct SaaSProductSort: Swift.Sendable {
        /// Field to sort the SaaS products by.
        public var sortBy: MarketplaceCatalogClientTypes.SaaSProductSortBy?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.SaaSProductSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object containing all the sort fields per entity type.
    public enum EntityTypeSort: Swift.Sendable {
        /// A sort for data products.
        case dataproductsort(MarketplaceCatalogClientTypes.DataProductSort)
        /// A sort for SaaS products.
        case saasproductsort(MarketplaceCatalogClientTypes.SaaSProductSort)
        /// A sort for AMI products.
        case amiproductsort(MarketplaceCatalogClientTypes.AmiProductSort)
        /// A sort for offers.
        case offersort(MarketplaceCatalogClientTypes.OfferSort)
        /// A sort for container products.
        case containerproductsort(MarketplaceCatalogClientTypes.ContainerProductSort)
        /// A sort for Resale Authorizations.
        case resaleauthorizationsort(MarketplaceCatalogClientTypes.ResaleAuthorizationSort)
        case sdkUnknown(Swift.String)
    }
}

extension MarketplaceCatalogClientTypes {

    public enum OwnershipType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `self`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [OwnershipType] {
            return [
                .self,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .self: return "SELF"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListEntitiesInput: Swift.Sendable {
    /// The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// The type of entities to retrieve. Valid values are: AmiProduct, ContainerProduct, DataProduct, SaaSProduct, ProcurementPolicy, Experience, Audience, BrandingSettings, Offer, Seller, ResaleAuthorization.
    /// This member is required.
    public var entityType: Swift.String?
    /// A Union object containing filter shapes for all EntityTypes. Each EntityTypeFilter shape will have filters applicable for that EntityType that can be used to search or filter entities.
    public var entityTypeFilters: MarketplaceCatalogClientTypes.EntityTypeFilters?
    /// A Union object containing Sort shapes for all EntityTypes. Each EntityTypeSort shape will have SortBy and SortOrder applicable for fields on that EntityType. This can be used to sort the results of the filter query.
    public var entityTypeSort: MarketplaceCatalogClientTypes.EntityTypeSort?
    /// An array of filter objects. Each filter object contains two attributes, filterName and filterValues.
    public var filterList: [MarketplaceCatalogClientTypes.Filter]?
    /// Specifies the upper limit of the elements on a single page. If a value isn't provided, the default value is 20.
    public var maxResults: Swift.Int?
    /// The value of the next token, if it exists. Null if there are no more results.
    public var nextToken: Swift.String?
    /// Filters the returned set of entities based on their owner. The default is SELF. To list entities shared with you through AWS Resource Access Manager (AWS RAM), set to SHARED. Entities shared through the AWS Marketplace Catalog API PutResourcePolicy operation can't be discovered through the SHARED parameter.
    public var ownershipType: MarketplaceCatalogClientTypes.OwnershipType?
    /// An object that contains two attributes, SortBy and SortOrder.
    public var sort: MarketplaceCatalogClientTypes.Sort?

    public init(
        catalog: Swift.String? = nil,
        entityType: Swift.String? = nil,
        entityTypeFilters: MarketplaceCatalogClientTypes.EntityTypeFilters? = nil,
        entityTypeSort: MarketplaceCatalogClientTypes.EntityTypeSort? = nil,
        filterList: [MarketplaceCatalogClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownershipType: MarketplaceCatalogClientTypes.OwnershipType? = nil,
        sort: MarketplaceCatalogClientTypes.Sort? = nil
    )
    {
        self.catalog = catalog
        self.entityType = entityType
        self.entityTypeFilters = entityTypeFilters
        self.entityTypeSort = entityTypeSort
        self.filterList = filterList
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownershipType = ownershipType
        self.sort = sort
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that contains summarized information about a container product.
    public struct ContainerProductSummary: Swift.Sendable {
        /// The title of the container product.
        public var productTitle: Swift.String?
        /// The lifecycle of the product.
        public var visibility: MarketplaceCatalogClientTypes.ContainerProductVisibilityString?

        public init(
            productTitle: Swift.String? = nil,
            visibility: MarketplaceCatalogClientTypes.ContainerProductVisibilityString? = nil
        )
        {
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that contains summarized information about a data product.
    public struct DataProductSummary: Swift.Sendable {
        /// The title of the data product.
        public var productTitle: Swift.String?
        /// The lifecycle of the data product.
        public var visibility: MarketplaceCatalogClientTypes.DataProductVisibilityString?

        public init(
            productTitle: Swift.String? = nil,
            visibility: MarketplaceCatalogClientTypes.DataProductVisibilityString? = nil
        )
        {
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Summarized information about an offer.
    public struct OfferSummary: Swift.Sendable {
        /// The availability end date of the offer.
        public var availabilityEndDate: Swift.String?
        /// The buyer accounts in the offer.
        public var buyerAccounts: [Swift.String]?
        /// The name of the offer.
        public var name: Swift.String?
        /// The product ID of the offer.
        public var productId: Swift.String?
        /// The release date of the offer.
        public var releaseDate: Swift.String?
        /// The ResaleAuthorizationId of the offer.
        public var resaleAuthorizationId: Swift.String?
        /// The status of the offer.
        public var state: MarketplaceCatalogClientTypes.OfferStateString?
        /// The targeting in the offer.
        public var targeting: [MarketplaceCatalogClientTypes.OfferTargetingString]?

        public init(
            availabilityEndDate: Swift.String? = nil,
            buyerAccounts: [Swift.String]? = nil,
            name: Swift.String? = nil,
            productId: Swift.String? = nil,
            releaseDate: Swift.String? = nil,
            resaleAuthorizationId: Swift.String? = nil,
            state: MarketplaceCatalogClientTypes.OfferStateString? = nil,
            targeting: [MarketplaceCatalogClientTypes.OfferTargetingString]? = nil
        )
        {
            self.availabilityEndDate = availabilityEndDate
            self.buyerAccounts = buyerAccounts
            self.name = name
            self.productId = productId
            self.releaseDate = releaseDate
            self.resaleAuthorizationId = resaleAuthorizationId
            self.state = state
            self.targeting = targeting
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Summarized information about a Resale Authorization.
    public struct ResaleAuthorizationSummary: Swift.Sendable {
        /// The availability end date of the ResaleAuthorization.
        public var availabilityEndDate: Swift.String?
        /// The created date of the ResaleAuthorization.
        public var createdDate: Swift.String?
        /// The manufacturer account ID of the ResaleAuthorization.
        public var manufacturerAccountId: Swift.String?
        /// The manufacturer legal name of the ResaleAuthorization.
        public var manufacturerLegalName: Swift.String?
        /// The name of the ResaleAuthorization.
        public var name: Swift.String?
        /// The offer extended status of the ResaleAuthorization
        public var offerExtendedStatus: Swift.String?
        /// The product ID of the ResaleAuthorization.
        public var productId: Swift.String?
        /// The product name of the ResaleAuthorization.
        public var productName: Swift.String?
        /// The reseller account ID of the ResaleAuthorization.
        public var resellerAccountID: Swift.String?
        /// The reseller legal name of the ResaleAuthorization
        public var resellerLegalName: Swift.String?
        /// The status of the ResaleAuthorization.
        public var status: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString?

        public init(
            availabilityEndDate: Swift.String? = nil,
            createdDate: Swift.String? = nil,
            manufacturerAccountId: Swift.String? = nil,
            manufacturerLegalName: Swift.String? = nil,
            name: Swift.String? = nil,
            offerExtendedStatus: Swift.String? = nil,
            productId: Swift.String? = nil,
            productName: Swift.String? = nil,
            resellerAccountID: Swift.String? = nil,
            resellerLegalName: Swift.String? = nil,
            status: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString? = nil
        )
        {
            self.availabilityEndDate = availabilityEndDate
            self.createdDate = createdDate
            self.manufacturerAccountId = manufacturerAccountId
            self.manufacturerLegalName = manufacturerLegalName
            self.name = name
            self.offerExtendedStatus = offerExtendedStatus
            self.productId = productId
            self.productName = productName
            self.resellerAccountID = resellerAccountID
            self.resellerLegalName = resellerLegalName
            self.status = status
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// Object that contains summarized information about a SaaS product.
    public struct SaaSProductSummary: Swift.Sendable {
        /// The title of the SaaS product.
        public var productTitle: Swift.String?
        /// The lifecycle of the SaaS product.
        public var visibility: MarketplaceCatalogClientTypes.SaaSProductVisibilityString?

        public init(
            productTitle: Swift.String? = nil,
            visibility: MarketplaceCatalogClientTypes.SaaSProductVisibilityString? = nil
        )
        {
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }
}

extension MarketplaceCatalogClientTypes {

    /// This object is a container for common summary information about the entity. The summary doesn't contain the whole entity structure, but it does contain information common across all entities.
    public struct EntitySummary: Swift.Sendable {
        /// An object that contains summary information about the AMI product.
        public var amiProductSummary: MarketplaceCatalogClientTypes.AmiProductSummary?
        /// An object that contains summary information about the container product.
        public var containerProductSummary: MarketplaceCatalogClientTypes.ContainerProductSummary?
        /// An object that contains summary information about the data product.
        public var dataProductSummary: MarketplaceCatalogClientTypes.DataProductSummary?
        /// The ARN associated with the unique identifier for the entity.
        public var entityArn: Swift.String?
        /// The unique identifier for the entity.
        public var entityId: Swift.String?
        /// The type of the entity.
        public var entityType: Swift.String?
        /// The last time the entity was published, using ISO 8601 format (2018-02-27T13:45:22Z).
        public var lastModifiedDate: Swift.String?
        /// The name for the entity. This value is not unique. It is defined by the seller.
        public var name: Swift.String?
        /// An object that contains summary information about the offer.
        public var offerSummary: MarketplaceCatalogClientTypes.OfferSummary?
        /// An object that contains summary information about the Resale Authorization.
        public var resaleAuthorizationSummary: MarketplaceCatalogClientTypes.ResaleAuthorizationSummary?
        /// An object that contains summary information about the SaaS product.
        public var saaSProductSummary: MarketplaceCatalogClientTypes.SaaSProductSummary?
        /// The visibility status of the entity to buyers. This value can be Public (everyone can view the entity), Limited (the entity is visible to limited accounts only), or Restricted (the entity was published and then unpublished and only existing buyers can view it).
        public var visibility: Swift.String?

        public init(
            amiProductSummary: MarketplaceCatalogClientTypes.AmiProductSummary? = nil,
            containerProductSummary: MarketplaceCatalogClientTypes.ContainerProductSummary? = nil,
            dataProductSummary: MarketplaceCatalogClientTypes.DataProductSummary? = nil,
            entityArn: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityType: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            name: Swift.String? = nil,
            offerSummary: MarketplaceCatalogClientTypes.OfferSummary? = nil,
            resaleAuthorizationSummary: MarketplaceCatalogClientTypes.ResaleAuthorizationSummary? = nil,
            saaSProductSummary: MarketplaceCatalogClientTypes.SaaSProductSummary? = nil,
            visibility: Swift.String? = nil
        )
        {
            self.amiProductSummary = amiProductSummary
            self.containerProductSummary = containerProductSummary
            self.dataProductSummary = dataProductSummary
            self.entityArn = entityArn
            self.entityId = entityId
            self.entityType = entityType
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.offerSummary = offerSummary
            self.resaleAuthorizationSummary = resaleAuthorizationSummary
            self.saaSProductSummary = saaSProductSummary
            self.visibility = visibility
        }
    }
}

public struct ListEntitiesOutput: Swift.Sendable {
    /// Array of EntitySummary objects.
    public var entitySummaryList: [MarketplaceCatalogClientTypes.EntitySummary]?
    /// The value of the next token if it exists. Null if there is no more result.
    public var nextToken: Swift.String?

    public init(
        entitySummaryList: [MarketplaceCatalogClientTypes.EntitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitySummaryList = entitySummaryList
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// Required. The Amazon Resource Name (ARN) associated with the resource you want to list tags on.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension MarketplaceCatalogClientTypes {

    /// A list of objects specifying each key name and value.
    public struct Tag: Swift.Sendable {
        /// The key associated with the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Required. The ARN associated with the resource you want to list tags on.
    public var resourceArn: Swift.String?
    /// Required. A list of objects specifying each key name and value. Number of objects allowed: 1-50.
    public var tags: [MarketplaceCatalogClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [MarketplaceCatalogClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct PutResourcePolicyInput: Swift.Sendable {
    /// The policy document to set; formatted in JSON.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the entity resource you want to associate with a resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput: Swift.Sendable {

    public init() { }
}

/// The maximum number of open requests per account has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MarketplaceCatalogClientTypes {

    /// An object that contains the ChangeType, Details, and Entity.
    public struct Change: Swift.Sendable {
        /// Optional name for the change.
        public var changeName: Swift.String?
        /// Change types are single string values that describe your intention for the change. Each change type is unique for each EntityType provided in the change's scope. For more information about change types available for single-AMI products, see [Working with single-AMI products](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/ami-products.html#working-with-single-AMI-products). Also, for more information about change types available for container-based products, see [Working with container products](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/container-products.html#working-with-container-products).
        /// This member is required.
        public var changeType: Swift.String?
        /// This object contains details specific to the change type of the requested change. For more information about change types available for single-AMI products, see [Working with single-AMI products](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/ami-products.html#working-with-single-AMI-products). Also, for more information about change types available for container-based products, see [Working with container products](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/container-products.html#working-with-container-products).
        public var details: Swift.String?
        /// Alternative field that accepts a JSON value instead of a string for ChangeType details. You can use either Details or DetailsDocument, but not both.
        public var detailsDocument: Smithy.Document?
        /// The entity to be changed.
        /// This member is required.
        public var entity: MarketplaceCatalogClientTypes.Entity?
        /// The tags associated with the change.
        public var entityTags: [MarketplaceCatalogClientTypes.Tag]?

        public init(
            changeName: Swift.String? = nil,
            changeType: Swift.String? = nil,
            details: Swift.String? = nil,
            detailsDocument: Smithy.Document? = nil,
            entity: MarketplaceCatalogClientTypes.Entity? = nil,
            entityTags: [MarketplaceCatalogClientTypes.Tag]? = nil
        )
        {
            self.changeName = changeName
            self.changeType = changeType
            self.details = details
            self.detailsDocument = detailsDocument
            self.entity = entity
            self.entityTags = entityTags
        }
    }
}

public struct StartChangeSetInput: Swift.Sendable {
    /// The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// Array of change object.
    /// This member is required.
    public var changeSet: [MarketplaceCatalogClientTypes.Change]?
    /// Optional case sensitive string of up to 100 ASCII characters. The change set name can be used to filter the list of change sets.
    public var changeSetName: Swift.String?
    /// A list of objects specifying each key name and value for the ChangeSetTags property.
    public var changeSetTags: [MarketplaceCatalogClientTypes.Tag]?
    /// A unique token to identify the request to ensure idempotency.
    public var clientRequestToken: Swift.String?
    /// The intent related to the request. The default is APPLY. To test your request before applying changes to your entities, use VALIDATE. This feature is currently available for adding versions to single-AMI products. For more information, see [Add a new version](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/ami-products.html#ami-add-version).
    public var intent: MarketplaceCatalogClientTypes.Intent?

    public init(
        catalog: Swift.String? = nil,
        changeSet: [MarketplaceCatalogClientTypes.Change]? = nil,
        changeSetName: Swift.String? = nil,
        changeSetTags: [MarketplaceCatalogClientTypes.Tag]? = nil,
        clientRequestToken: Swift.String? = nil,
        intent: MarketplaceCatalogClientTypes.Intent? = nil
    )
    {
        self.catalog = catalog
        self.changeSet = changeSet
        self.changeSetName = changeSetName
        self.changeSetTags = changeSetTags
        self.clientRequestToken = clientRequestToken
        self.intent = intent
    }
}

public struct StartChangeSetOutput: Swift.Sendable {
    /// The ARN associated to the unique identifier generated for the request.
    public var changeSetArn: Swift.String?
    /// Unique identifier generated for the request.
    public var changeSetId: Swift.String?

    public init(
        changeSetArn: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// Required. The Amazon Resource Name (ARN) associated with the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Required. A list of objects specifying each key name and value. Number of objects allowed: 1-50.
    /// This member is required.
    public var tags: [MarketplaceCatalogClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [MarketplaceCatalogClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// Required. The Amazon Resource Name (ARN) associated with the resource you want to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Required. A list of key names of tags to be removed. Number of strings allowed: 0-256.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension BatchDescribeEntitiesInput {

    static func urlPathProvider(_ value: BatchDescribeEntitiesInput) -> Swift.String? {
        return "/BatchDescribeEntities"
    }
}

extension CancelChangeSetInput {

    static func urlPathProvider(_ value: CancelChangeSetInput) -> Swift.String? {
        return "/CancelChangeSet"
    }
}

extension CancelChangeSetInput {

    static func queryItemProvider(_ value: CancelChangeSetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let changeSetId = value.changeSetId else {
            let message = "Creating a URL Query Item failed. changeSetId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let changeSetIdQueryItem = Smithy.URIQueryItem(name: "changeSetId".urlPercentEncoding(), value: Swift.String(changeSetId).urlPercentEncoding())
        items.append(changeSetIdQueryItem)
        guard let catalog = value.catalog else {
            let message = "Creating a URL Query Item failed. catalog is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let catalogQueryItem = Smithy.URIQueryItem(name: "catalog".urlPercentEncoding(), value: Swift.String(catalog).urlPercentEncoding())
        items.append(catalogQueryItem)
        return items
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/DeleteResourcePolicy"
    }
}

extension DeleteResourcePolicyInput {

    static func queryItemProvider(_ value: DeleteResourcePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension DescribeChangeSetInput {

    static func urlPathProvider(_ value: DescribeChangeSetInput) -> Swift.String? {
        return "/DescribeChangeSet"
    }
}

extension DescribeChangeSetInput {

    static func queryItemProvider(_ value: DescribeChangeSetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let changeSetId = value.changeSetId else {
            let message = "Creating a URL Query Item failed. changeSetId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let changeSetIdQueryItem = Smithy.URIQueryItem(name: "changeSetId".urlPercentEncoding(), value: Swift.String(changeSetId).urlPercentEncoding())
        items.append(changeSetIdQueryItem)
        guard let catalog = value.catalog else {
            let message = "Creating a URL Query Item failed. catalog is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let catalogQueryItem = Smithy.URIQueryItem(name: "catalog".urlPercentEncoding(), value: Swift.String(catalog).urlPercentEncoding())
        items.append(catalogQueryItem)
        return items
    }
}

extension DescribeEntityInput {

    static func urlPathProvider(_ value: DescribeEntityInput) -> Swift.String? {
        return "/DescribeEntity"
    }
}

extension DescribeEntityInput {

    static func queryItemProvider(_ value: DescribeEntityInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let entityId = value.entityId else {
            let message = "Creating a URL Query Item failed. entityId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let entityIdQueryItem = Smithy.URIQueryItem(name: "entityId".urlPercentEncoding(), value: Swift.String(entityId).urlPercentEncoding())
        items.append(entityIdQueryItem)
        guard let catalog = value.catalog else {
            let message = "Creating a URL Query Item failed. catalog is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let catalogQueryItem = Smithy.URIQueryItem(name: "catalog".urlPercentEncoding(), value: Swift.String(catalog).urlPercentEncoding())
        items.append(catalogQueryItem)
        return items
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/GetResourcePolicy"
    }
}

extension GetResourcePolicyInput {

    static func queryItemProvider(_ value: GetResourcePolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension ListChangeSetsInput {

    static func urlPathProvider(_ value: ListChangeSetsInput) -> Swift.String? {
        return "/ListChangeSets"
    }
}

extension ListEntitiesInput {

    static func urlPathProvider(_ value: ListEntitiesInput) -> Swift.String? {
        return "/ListEntities"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/ListTagsForResource"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/PutResourcePolicy"
    }
}

extension StartChangeSetInput {

    static func urlPathProvider(_ value: StartChangeSetInput) -> Swift.String? {
        return "/StartChangeSet"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/TagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/UntagResource"
    }
}

extension BatchDescribeEntitiesInput {

    static func write(value: BatchDescribeEntitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityRequestList"].writeList(value.entityRequestList, memberWritingClosure: MarketplaceCatalogClientTypes.EntityRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListChangeSetsInput {

    static func write(value: ListChangeSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["FilterList"].writeList(value.filterList, memberWritingClosure: MarketplaceCatalogClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Sort"].write(value.sort, with: MarketplaceCatalogClientTypes.Sort.write(value:to:))
    }
}

extension ListEntitiesInput {

    static func write(value: ListEntitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["EntityType"].write(value.entityType)
        try writer["EntityTypeFilters"].write(value.entityTypeFilters, with: MarketplaceCatalogClientTypes.EntityTypeFilters.write(value:to:))
        try writer["EntityTypeSort"].write(value.entityTypeSort, with: MarketplaceCatalogClientTypes.EntityTypeSort.write(value:to:))
        try writer["FilterList"].writeList(value.filterList, memberWritingClosure: MarketplaceCatalogClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OwnershipType"].write(value.ownershipType)
        try writer["Sort"].write(value.sort, with: MarketplaceCatalogClientTypes.Sort.write(value:to:))
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension StartChangeSetInput {

    static func write(value: StartChangeSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ChangeSet"].writeList(value.changeSet, memberWritingClosure: MarketplaceCatalogClientTypes.Change.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ChangeSetName"].write(value.changeSetName)
        try writer["ChangeSetTags"].writeList(value.changeSetTags, memberWritingClosure: MarketplaceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Intent"].write(value.intent)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: MarketplaceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDescribeEntitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDescribeEntitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDescribeEntitiesOutput()
        value.entityDetails = try reader["EntityDetails"].readMapIfPresent(valueReadingClosure: MarketplaceCatalogClientTypes.EntityDetail.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.errors = try reader["Errors"].readMapIfPresent(valueReadingClosure: MarketplaceCatalogClientTypes.BatchDescribeErrorDetail.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CancelChangeSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelChangeSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelChangeSetOutput()
        value.changeSetArn = try reader["ChangeSetArn"].readIfPresent()
        value.changeSetId = try reader["ChangeSetId"].readIfPresent()
        return value
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DescribeChangeSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChangeSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChangeSetOutput()
        value.changeSet = try reader["ChangeSet"].readListIfPresent(memberReadingClosure: MarketplaceCatalogClientTypes.ChangeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.changeSetArn = try reader["ChangeSetArn"].readIfPresent()
        value.changeSetId = try reader["ChangeSetId"].readIfPresent()
        value.changeSetName = try reader["ChangeSetName"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.failureCode = try reader["FailureCode"].readIfPresent()
        value.failureDescription = try reader["FailureDescription"].readIfPresent()
        value.intent = try reader["Intent"].readIfPresent()
        value.startTime = try reader["StartTime"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeEntityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEntityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEntityOutput()
        value.details = try reader["Details"].readIfPresent()
        value.detailsDocument = try reader["DetailsDocument"].readIfPresent()
        value.entityArn = try reader["EntityArn"].readIfPresent()
        value.entityIdentifier = try reader["EntityIdentifier"].readIfPresent()
        value.entityType = try reader["EntityType"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension ListChangeSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChangeSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChangeSetsOutput()
        value.changeSetSummaryList = try reader["ChangeSetSummaryList"].readListIfPresent(memberReadingClosure: MarketplaceCatalogClientTypes.ChangeSetSummaryListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEntitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEntitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEntitiesOutput()
        value.entitySummaryList = try reader["EntitySummaryList"].readListIfPresent(memberReadingClosure: MarketplaceCatalogClientTypes.EntitySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: MarketplaceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        return PutResourcePolicyOutput()
    }
}

extension StartChangeSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartChangeSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartChangeSetOutput()
        value.changeSetArn = try reader["ChangeSetArn"].readIfPresent()
        value.changeSetId = try reader["ChangeSetId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum BatchDescribeEntitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelChangeSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChangeSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEntityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceNotSupportedException": return try ResourceNotSupportedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChangeSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEntitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartChangeSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotSupportedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MarketplaceCatalogClientTypes.EntityDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.EntityDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.EntityDetail()
        value.entityType = try reader["EntityType"].readIfPresent()
        value.entityArn = try reader["EntityArn"].readIfPresent()
        value.entityIdentifier = try reader["EntityIdentifier"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.detailsDocument = try reader["DetailsDocument"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.BatchDescribeErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.BatchDescribeErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.BatchDescribeErrorDetail()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.ChangeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.ChangeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.ChangeSummary()
        value.changeType = try reader["ChangeType"].readIfPresent()
        value.entity = try reader["Entity"].readIfPresent(with: MarketplaceCatalogClientTypes.Entity.read(from:))
        value.details = try reader["Details"].readIfPresent()
        value.detailsDocument = try reader["DetailsDocument"].readIfPresent()
        value.errorDetailList = try reader["ErrorDetailList"].readListIfPresent(memberReadingClosure: MarketplaceCatalogClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.changeName = try reader["ChangeName"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.ErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.ErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.ErrorDetail()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.Entity {

    static func write(value: MarketplaceCatalogClientTypes.Entity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.Entity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.Entity()
        value.type = try reader["Type"].readIfPresent() ?? ""
        value.identifier = try reader["Identifier"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.ChangeSetSummaryListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.ChangeSetSummaryListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.ChangeSetSummaryListItem()
        value.changeSetId = try reader["ChangeSetId"].readIfPresent()
        value.changeSetArn = try reader["ChangeSetArn"].readIfPresent()
        value.changeSetName = try reader["ChangeSetName"].readIfPresent()
        value.startTime = try reader["StartTime"].readIfPresent()
        value.endTime = try reader["EndTime"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.entityIdList = try reader["EntityIdList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.failureCode = try reader["FailureCode"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.EntitySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.EntitySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.EntitySummary()
        value.name = try reader["Name"].readIfPresent()
        value.entityType = try reader["EntityType"].readIfPresent()
        value.entityId = try reader["EntityId"].readIfPresent()
        value.entityArn = try reader["EntityArn"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.amiProductSummary = try reader["AmiProductSummary"].readIfPresent(with: MarketplaceCatalogClientTypes.AmiProductSummary.read(from:))
        value.containerProductSummary = try reader["ContainerProductSummary"].readIfPresent(with: MarketplaceCatalogClientTypes.ContainerProductSummary.read(from:))
        value.dataProductSummary = try reader["DataProductSummary"].readIfPresent(with: MarketplaceCatalogClientTypes.DataProductSummary.read(from:))
        value.saaSProductSummary = try reader["SaaSProductSummary"].readIfPresent(with: MarketplaceCatalogClientTypes.SaaSProductSummary.read(from:))
        value.offerSummary = try reader["OfferSummary"].readIfPresent(with: MarketplaceCatalogClientTypes.OfferSummary.read(from:))
        value.resaleAuthorizationSummary = try reader["ResaleAuthorizationSummary"].readIfPresent(with: MarketplaceCatalogClientTypes.ResaleAuthorizationSummary.read(from:))
        return value
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.ResaleAuthorizationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.ResaleAuthorizationSummary()
        value.name = try reader["Name"].readIfPresent()
        value.productId = try reader["ProductId"].readIfPresent()
        value.productName = try reader["ProductName"].readIfPresent()
        value.manufacturerAccountId = try reader["ManufacturerAccountId"].readIfPresent()
        value.manufacturerLegalName = try reader["ManufacturerLegalName"].readIfPresent()
        value.resellerAccountID = try reader["ResellerAccountID"].readIfPresent()
        value.resellerLegalName = try reader["ResellerLegalName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.offerExtendedStatus = try reader["OfferExtendedStatus"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readIfPresent()
        value.availabilityEndDate = try reader["AvailabilityEndDate"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.OfferSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.OfferSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.OfferSummary()
        value.name = try reader["Name"].readIfPresent()
        value.productId = try reader["ProductId"].readIfPresent()
        value.resaleAuthorizationId = try reader["ResaleAuthorizationId"].readIfPresent()
        value.releaseDate = try reader["ReleaseDate"].readIfPresent()
        value.availabilityEndDate = try reader["AvailabilityEndDate"].readIfPresent()
        value.buyerAccounts = try reader["BuyerAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["State"].readIfPresent()
        value.targeting = try reader["Targeting"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MarketplaceCatalogClientTypes.OfferTargetingString>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.SaaSProductSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.SaaSProductSummary()
        value.productTitle = try reader["ProductTitle"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.DataProductSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.DataProductSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.DataProductSummary()
        value.productTitle = try reader["ProductTitle"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.ContainerProductSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.ContainerProductSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.ContainerProductSummary()
        value.productTitle = try reader["ProductTitle"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.AmiProductSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.AmiProductSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.AmiProductSummary()
        value.productTitle = try reader["ProductTitle"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension MarketplaceCatalogClientTypes.Tag {

    static func write(value: MarketplaceCatalogClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MarketplaceCatalogClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MarketplaceCatalogClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension MarketplaceCatalogClientTypes.EntityRequest {

    static func write(value: MarketplaceCatalogClientTypes.EntityRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["EntityId"].write(value.entityId)
    }
}

extension MarketplaceCatalogClientTypes.Filter {

    static func write(value: MarketplaceCatalogClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.Sort {

    static func write(value: MarketplaceCatalogClientTypes.Sort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension MarketplaceCatalogClientTypes.EntityTypeFilters {

    static func write(value: MarketplaceCatalogClientTypes.EntityTypeFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .amiproductfilters(amiproductfilters):
                try writer["AmiProductFilters"].write(amiproductfilters, with: MarketplaceCatalogClientTypes.AmiProductFilters.write(value:to:))
            case let .containerproductfilters(containerproductfilters):
                try writer["ContainerProductFilters"].write(containerproductfilters, with: MarketplaceCatalogClientTypes.ContainerProductFilters.write(value:to:))
            case let .dataproductfilters(dataproductfilters):
                try writer["DataProductFilters"].write(dataproductfilters, with: MarketplaceCatalogClientTypes.DataProductFilters.write(value:to:))
            case let .offerfilters(offerfilters):
                try writer["OfferFilters"].write(offerfilters, with: MarketplaceCatalogClientTypes.OfferFilters.write(value:to:))
            case let .resaleauthorizationfilters(resaleauthorizationfilters):
                try writer["ResaleAuthorizationFilters"].write(resaleauthorizationfilters, with: MarketplaceCatalogClientTypes.ResaleAuthorizationFilters.write(value:to:))
            case let .saasproductfilters(saasproductfilters):
                try writer["SaaSProductFilters"].write(saasproductfilters, with: MarketplaceCatalogClientTypes.SaaSProductFilters.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationFilters {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityEndDate"].write(value.availabilityEndDate, with: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilter.write(value:to:))
        try writer["CreatedDate"].write(value.createdDate, with: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilter.write(value:to:))
        try writer["EntityId"].write(value.entityId, with: MarketplaceCatalogClientTypes.ResaleAuthorizationEntityIdFilter.write(value:to:))
        try writer["LastModifiedDate"].write(value.lastModifiedDate, with: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilter.write(value:to:))
        try writer["ManufacturerAccountId"].write(value.manufacturerAccountId, with: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerAccountIdFilter.write(value:to:))
        try writer["ManufacturerLegalName"].write(value.manufacturerLegalName, with: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerLegalNameFilter.write(value:to:))
        try writer["Name"].write(value.name, with: MarketplaceCatalogClientTypes.ResaleAuthorizationNameFilter.write(value:to:))
        try writer["OfferExtendedStatus"].write(value.offerExtendedStatus, with: MarketplaceCatalogClientTypes.ResaleAuthorizationOfferExtendedStatusFilter.write(value:to:))
        try writer["ProductId"].write(value.productId, with: MarketplaceCatalogClientTypes.ResaleAuthorizationProductIdFilter.write(value:to:))
        try writer["ProductName"].write(value.productName, with: MarketplaceCatalogClientTypes.ResaleAuthorizationProductNameFilter.write(value:to:))
        try writer["ResellerAccountID"].write(value.resellerAccountID, with: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerAccountIDFilter.write(value:to:))
        try writer["ResellerLegalName"].write(value.resellerLegalName, with: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerLegalNameFilter.write(value:to:))
        try writer["Status"].write(value.status, with: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusFilter.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilterDateRange.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationOfferExtendedStatusFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationOfferExtendedStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationStatusFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationResellerLegalNameFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerLegalNameFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationResellerAccountIDFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerAccountIDFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerLegalNameFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerLegalNameFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationProductNameFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationProductNameFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerAccountIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerAccountIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilterDateRange.write(value:to:))
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilterDateRange.write(value:to:))
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationProductIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationProductIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationNameFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationNameFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationEntityIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationEntityIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.ContainerProductFilters {

    static func write(value: MarketplaceCatalogClientTypes.ContainerProductFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId, with: MarketplaceCatalogClientTypes.ContainerProductEntityIdFilter.write(value:to:))
        try writer["LastModifiedDate"].write(value.lastModifiedDate, with: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilter.write(value:to:))
        try writer["ProductTitle"].write(value.productTitle, with: MarketplaceCatalogClientTypes.ContainerProductTitleFilter.write(value:to:))
        try writer["Visibility"].write(value.visibility, with: MarketplaceCatalogClientTypes.ContainerProductVisibilityFilter.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.ContainerProductVisibilityFilter {

    static func write(value: MarketplaceCatalogClientTypes.ContainerProductVisibilityFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MarketplaceCatalogClientTypes.ContainerProductVisibilityString>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.ContainerProductTitleFilter {

    static func write(value: MarketplaceCatalogClientTypes.ContainerProductTitleFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilterDateRange.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.ContainerProductEntityIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.ContainerProductEntityIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.OfferFilters {

    static func write(value: MarketplaceCatalogClientTypes.OfferFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityEndDate"].write(value.availabilityEndDate, with: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilter.write(value:to:))
        try writer["BuyerAccounts"].write(value.buyerAccounts, with: MarketplaceCatalogClientTypes.OfferBuyerAccountsFilter.write(value:to:))
        try writer["EntityId"].write(value.entityId, with: MarketplaceCatalogClientTypes.OfferEntityIdFilter.write(value:to:))
        try writer["LastModifiedDate"].write(value.lastModifiedDate, with: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilter.write(value:to:))
        try writer["Name"].write(value.name, with: MarketplaceCatalogClientTypes.OfferNameFilter.write(value:to:))
        try writer["ProductId"].write(value.productId, with: MarketplaceCatalogClientTypes.OfferProductIdFilter.write(value:to:))
        try writer["ReleaseDate"].write(value.releaseDate, with: MarketplaceCatalogClientTypes.OfferReleaseDateFilter.write(value:to:))
        try writer["ResaleAuthorizationId"].write(value.resaleAuthorizationId, with: MarketplaceCatalogClientTypes.OfferResaleAuthorizationIdFilter.write(value:to:))
        try writer["State"].write(value.state, with: MarketplaceCatalogClientTypes.OfferStateFilter.write(value:to:))
        try writer["Targeting"].write(value.targeting, with: MarketplaceCatalogClientTypes.OfferTargetingFilter.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.OfferLastModifiedDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilterDateRange.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.OfferLastModifiedDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.OfferTargetingFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferTargetingFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MarketplaceCatalogClientTypes.OfferTargetingString>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.OfferStateFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferStateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MarketplaceCatalogClientTypes.OfferStateString>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.OfferBuyerAccountsFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferBuyerAccountsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilterDateRange.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.OfferReleaseDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferReleaseDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.OfferReleaseDateFilterDateRange.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.OfferReleaseDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.OfferReleaseDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.OfferResaleAuthorizationIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferResaleAuthorizationIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.OfferProductIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferProductIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.OfferNameFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferNameFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.OfferEntityIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.OfferEntityIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.AmiProductFilters {

    static func write(value: MarketplaceCatalogClientTypes.AmiProductFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId, with: MarketplaceCatalogClientTypes.AmiProductEntityIdFilter.write(value:to:))
        try writer["LastModifiedDate"].write(value.lastModifiedDate, with: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilter.write(value:to:))
        try writer["ProductTitle"].write(value.productTitle, with: MarketplaceCatalogClientTypes.AmiProductTitleFilter.write(value:to:))
        try writer["Visibility"].write(value.visibility, with: MarketplaceCatalogClientTypes.AmiProductVisibilityFilter.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.AmiProductVisibilityFilter {

    static func write(value: MarketplaceCatalogClientTypes.AmiProductVisibilityFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MarketplaceCatalogClientTypes.AmiProductVisibilityString>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.AmiProductTitleFilter {

    static func write(value: MarketplaceCatalogClientTypes.AmiProductTitleFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilterDateRange.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.AmiProductEntityIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.AmiProductEntityIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductFilters {

    static func write(value: MarketplaceCatalogClientTypes.SaaSProductFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId, with: MarketplaceCatalogClientTypes.SaaSProductEntityIdFilter.write(value:to:))
        try writer["LastModifiedDate"].write(value.lastModifiedDate, with: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilter.write(value:to:))
        try writer["ProductTitle"].write(value.productTitle, with: MarketplaceCatalogClientTypes.SaaSProductTitleFilter.write(value:to:))
        try writer["Visibility"].write(value.visibility, with: MarketplaceCatalogClientTypes.SaaSProductVisibilityFilter.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilterDateRange.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductVisibilityFilter {

    static func write(value: MarketplaceCatalogClientTypes.SaaSProductVisibilityFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MarketplaceCatalogClientTypes.SaaSProductVisibilityString>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductTitleFilter {

    static func write(value: MarketplaceCatalogClientTypes.SaaSProductTitleFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductEntityIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.SaaSProductEntityIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.DataProductFilters {

    static func write(value: MarketplaceCatalogClientTypes.DataProductFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId, with: MarketplaceCatalogClientTypes.DataProductEntityIdFilter.write(value:to:))
        try writer["LastModifiedDate"].write(value.lastModifiedDate, with: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilter.write(value:to:))
        try writer["ProductTitle"].write(value.productTitle, with: MarketplaceCatalogClientTypes.DataProductTitleFilter.write(value:to:))
        try writer["Visibility"].write(value.visibility, with: MarketplaceCatalogClientTypes.DataProductVisibilityFilter.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilter {

    static func write(value: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateRange"].write(value.dateRange, with: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilterDateRange.write(value:to:))
    }
}

extension MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilterDateRange {

    static func write(value: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilterDateRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterValue"].write(value.afterValue)
        try writer["BeforeValue"].write(value.beforeValue)
    }
}

extension MarketplaceCatalogClientTypes.DataProductVisibilityFilter {

    static func write(value: MarketplaceCatalogClientTypes.DataProductVisibilityFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MarketplaceCatalogClientTypes.DataProductVisibilityString>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.DataProductTitleFilter {

    static func write(value: MarketplaceCatalogClientTypes.DataProductTitleFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WildCardValue"].write(value.wildCardValue)
    }
}

extension MarketplaceCatalogClientTypes.DataProductEntityIdFilter {

    static func write(value: MarketplaceCatalogClientTypes.DataProductEntityIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ValueList"].writeList(value.valueList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension MarketplaceCatalogClientTypes.EntityTypeSort {

    static func write(value: MarketplaceCatalogClientTypes.EntityTypeSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .amiproductsort(amiproductsort):
                try writer["AmiProductSort"].write(amiproductsort, with: MarketplaceCatalogClientTypes.AmiProductSort.write(value:to:))
            case let .containerproductsort(containerproductsort):
                try writer["ContainerProductSort"].write(containerproductsort, with: MarketplaceCatalogClientTypes.ContainerProductSort.write(value:to:))
            case let .dataproductsort(dataproductsort):
                try writer["DataProductSort"].write(dataproductsort, with: MarketplaceCatalogClientTypes.DataProductSort.write(value:to:))
            case let .offersort(offersort):
                try writer["OfferSort"].write(offersort, with: MarketplaceCatalogClientTypes.OfferSort.write(value:to:))
            case let .resaleauthorizationsort(resaleauthorizationsort):
                try writer["ResaleAuthorizationSort"].write(resaleauthorizationsort, with: MarketplaceCatalogClientTypes.ResaleAuthorizationSort.write(value:to:))
            case let .saasproductsort(saasproductsort):
                try writer["SaaSProductSort"].write(saasproductsort, with: MarketplaceCatalogClientTypes.SaaSProductSort.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationSort {

    static func write(value: MarketplaceCatalogClientTypes.ResaleAuthorizationSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension MarketplaceCatalogClientTypes.ContainerProductSort {

    static func write(value: MarketplaceCatalogClientTypes.ContainerProductSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension MarketplaceCatalogClientTypes.OfferSort {

    static func write(value: MarketplaceCatalogClientTypes.OfferSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension MarketplaceCatalogClientTypes.AmiProductSort {

    static func write(value: MarketplaceCatalogClientTypes.AmiProductSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductSort {

    static func write(value: MarketplaceCatalogClientTypes.SaaSProductSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension MarketplaceCatalogClientTypes.DataProductSort {

    static func write(value: MarketplaceCatalogClientTypes.DataProductSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension MarketplaceCatalogClientTypes.Change {

    static func write(value: MarketplaceCatalogClientTypes.Change?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChangeName"].write(value.changeName)
        try writer["ChangeType"].write(value.changeType)
        try writer["Details"].write(value.details)
        try writer["DetailsDocument"].write(value.detailsDocument)
        try writer["Entity"].write(value.entity, with: MarketplaceCatalogClientTypes.Entity.write(value:to:))
        try writer["EntityTags"].writeList(value.entityTags, memberWritingClosure: MarketplaceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum MarketplaceCatalogClientTypes {}
