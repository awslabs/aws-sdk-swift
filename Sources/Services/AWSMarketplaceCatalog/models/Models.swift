// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Access is denied.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelChangeSetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let changeSetId = changeSetId else {
                let message = "Creating a URL Query Item failed. changeSetId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let changeSetIdQueryItem = ClientRuntime.URLQueryItem(name: "changeSetId".urlPercentEncoding(), value: Swift.String(changeSetId).urlPercentEncoding())
            items.append(changeSetIdQueryItem)
            guard let catalog = catalog else {
                let message = "Creating a URL Query Item failed. catalog is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let catalogQueryItem = ClientRuntime.URLQueryItem(name: "catalog".urlPercentEncoding(), value: Swift.String(catalog).urlPercentEncoding())
            items.append(catalogQueryItem)
            return items
        }
    }
}

extension CancelChangeSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CancelChangeSet"
    }
}

public struct CancelChangeSetInput: Swift.Equatable {
    /// Required. The catalog related to the request. Fixed value: AWSMarketplace.
    /// This member is required.
    public var catalog: Swift.String?
    /// Required. The unique identifier of the StartChangeSet request that you want to cancel.
    /// This member is required.
    public var changeSetId: Swift.String?

    public init (
        catalog: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.changeSetId = changeSetId
    }
}

struct CancelChangeSetInputBody: Swift.Equatable {
}

extension CancelChangeSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelChangeSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelChangeSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelChangeSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelChangeSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changeSetArn = output.changeSetArn
            self.changeSetId = output.changeSetId
        } else {
            self.changeSetArn = nil
            self.changeSetId = nil
        }
    }
}

public struct CancelChangeSetOutputResponse: Swift.Equatable {
    /// The ARN associated with the change set referenced in this request.
    public var changeSetArn: Swift.String?
    /// The unique identifier for the change set referenced in this request.
    public var changeSetId: Swift.String?

    public init (
        changeSetArn: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
    }
}

struct CancelChangeSetOutputResponseBody: Swift.Equatable {
    let changeSetId: Swift.String?
    let changeSetArn: Swift.String?
}

extension CancelChangeSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
    }
}

extension MarketplaceCatalogClientTypes.Change: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeName = "ChangeName"
        case changeType = "ChangeType"
        case details = "Details"
        case entity = "Entity"
        case entityTags = "EntityTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeName = self.changeName {
            try encodeContainer.encode(changeName, forKey: .changeName)
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType, forKey: .changeType)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let entity = self.entity {
            try encodeContainer.encode(entity, forKey: .entity)
        }
        if let entityTags = entityTags {
            var entityTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTags)
            for tag0 in entityTags {
                try entityTagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let entityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Entity.self, forKey: .entity)
        entity = entityDecoded
        let entityTagsContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Tag?].self, forKey: .entityTags)
        var entityTagsDecoded0:[MarketplaceCatalogClientTypes.Tag]? = nil
        if let entityTagsContainer = entityTagsContainer {
            entityTagsDecoded0 = [MarketplaceCatalogClientTypes.Tag]()
            for structure0 in entityTagsContainer {
                if let structure0 = structure0 {
                    entityTagsDecoded0?.append(structure0)
                }
            }
        }
        entityTags = entityTagsDecoded0
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
        let changeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeName)
        changeName = changeNameDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// An object that contains the ChangeType, Details, and Entity.
    public struct Change: Swift.Equatable {
        /// Optional name for the change.
        public var changeName: Swift.String?
        /// Change types are single string values that describe your intention for the change. Each change type is unique for each EntityType provided in the change's scope.
        /// This member is required.
        public var changeType: Swift.String?
        /// This object contains details specific to the change type of the requested change.
        /// This member is required.
        public var details: Swift.String?
        /// The entity to be changed.
        /// This member is required.
        public var entity: MarketplaceCatalogClientTypes.Entity?
        /// The tags associated with the change.
        public var entityTags: [MarketplaceCatalogClientTypes.Tag]?

        public init (
            changeName: Swift.String? = nil,
            changeType: Swift.String? = nil,
            details: Swift.String? = nil,
            entity: MarketplaceCatalogClientTypes.Entity? = nil,
            entityTags: [MarketplaceCatalogClientTypes.Tag]? = nil
        )
        {
            self.changeName = changeName
            self.changeType = changeType
            self.details = details
            self.entity = entity
            self.entityTags = entityTags
        }
    }

}

extension MarketplaceCatalogClientTypes.ChangeSetSummaryListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
        case changeSetName = "ChangeSetName"
        case endTime = "EndTime"
        case entityIdList = "EntityIdList"
        case failureCode = "FailureCode"
        case startTime = "StartTime"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeSetArn = self.changeSetArn {
            try encodeContainer.encode(changeSetArn, forKey: .changeSetArn)
        }
        if let changeSetId = self.changeSetId {
            try encodeContainer.encode(changeSetId, forKey: .changeSetId)
        }
        if let changeSetName = self.changeSetName {
            try encodeContainer.encode(changeSetName, forKey: .changeSetName)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let entityIdList = entityIdList {
            var entityIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityIdList)
            for resourceid0 in entityIdList {
                try entityIdListContainer.encode(resourceid0)
            }
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
        let changeSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ChangeStatus.self, forKey: .status)
        status = statusDecoded
        let entityIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityIdList)
        var entityIdListDecoded0:[Swift.String]? = nil
        if let entityIdListContainer = entityIdListContainer {
            entityIdListDecoded0 = [Swift.String]()
            for string0 in entityIdListContainer {
                if let string0 = string0 {
                    entityIdListDecoded0?.append(string0)
                }
            }
        }
        entityIdList = entityIdListDecoded0
        let failureCodeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.FailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// A summary of a change set returned in a list of change sets when the ListChangeSets action is called.
    public struct ChangeSetSummaryListItem: Swift.Equatable {
        /// The ARN associated with the unique identifier for the change set referenced in this request.
        public var changeSetArn: Swift.String?
        /// The unique identifier for a change set.
        public var changeSetId: Swift.String?
        /// The non-unique name for the change set.
        public var changeSetName: Swift.String?
        /// The time, in ISO 8601 format (2018-02-27T13:45:22Z), when the change set was finished.
        public var endTime: Swift.String?
        /// This object is a list of entity IDs (string) that are a part of a change set. The entity ID list is a maximum of 20 entities. It must contain at least one entity.
        public var entityIdList: [Swift.String]?
        /// Returned if the change set is in FAILED status. Can be either CLIENT_ERROR, which means that there are issues with the request (see the ErrorDetailList of DescribeChangeSet), or SERVER_FAULT, which means that there is a problem in the system, and you should retry your request.
        public var failureCode: MarketplaceCatalogClientTypes.FailureCode?
        /// The time, in ISO 8601 format (2018-02-27T13:45:22Z), when the change set was started.
        public var startTime: Swift.String?
        /// The current status of the change set.
        public var status: MarketplaceCatalogClientTypes.ChangeStatus?

        public init (
            changeSetArn: Swift.String? = nil,
            changeSetId: Swift.String? = nil,
            changeSetName: Swift.String? = nil,
            endTime: Swift.String? = nil,
            entityIdList: [Swift.String]? = nil,
            failureCode: MarketplaceCatalogClientTypes.FailureCode? = nil,
            startTime: Swift.String? = nil,
            status: MarketplaceCatalogClientTypes.ChangeStatus? = nil
        )
        {
            self.changeSetArn = changeSetArn
            self.changeSetId = changeSetId
            self.changeSetName = changeSetName
            self.endTime = endTime
            self.entityIdList = entityIdList
            self.failureCode = failureCode
            self.startTime = startTime
            self.status = status
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum ChangeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applying
        case cancelled
        case failed
        case preparing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeStatus] {
            return [
                .applying,
                .cancelled,
                .failed,
                .preparing,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applying: return "APPLYING"
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .preparing: return "PREPARING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeStatus(rawValue: rawValue) ?? ChangeStatus.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.ChangeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeName = "ChangeName"
        case changeType = "ChangeType"
        case details = "Details"
        case entity = "Entity"
        case errorDetailList = "ErrorDetailList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeName = self.changeName {
            try encodeContainer.encode(changeName, forKey: .changeName)
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType, forKey: .changeType)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let entity = self.entity {
            try encodeContainer.encode(entity, forKey: .entity)
        }
        if let errorDetailList = errorDetailList {
            var errorDetailListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorDetailList)
            for errordetail0 in errorDetailList {
                try errorDetailListContainer.encode(errordetail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let entityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Entity.self, forKey: .entity)
        entity = entityDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
        let errorDetailListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.ErrorDetail?].self, forKey: .errorDetailList)
        var errorDetailListDecoded0:[MarketplaceCatalogClientTypes.ErrorDetail]? = nil
        if let errorDetailListContainer = errorDetailListContainer {
            errorDetailListDecoded0 = [MarketplaceCatalogClientTypes.ErrorDetail]()
            for structure0 in errorDetailListContainer {
                if let structure0 = structure0 {
                    errorDetailListDecoded0?.append(structure0)
                }
            }
        }
        errorDetailList = errorDetailListDecoded0
        let changeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeName)
        changeName = changeNameDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// This object is a container for common summary information about the change. The summary doesn't contain the whole change structure.
    public struct ChangeSummary: Swift.Equatable {
        /// Optional name for the change.
        public var changeName: Swift.String?
        /// The type of the change.
        public var changeType: Swift.String?
        /// This object contains details specific to the change type of the requested change.
        public var details: Swift.String?
        /// The entity to be changed.
        public var entity: MarketplaceCatalogClientTypes.Entity?
        /// An array of ErrorDetail objects associated with the change.
        public var errorDetailList: [MarketplaceCatalogClientTypes.ErrorDetail]?

        public init (
            changeName: Swift.String? = nil,
            changeType: Swift.String? = nil,
            details: Swift.String? = nil,
            entity: MarketplaceCatalogClientTypes.Entity? = nil,
            errorDetailList: [MarketplaceCatalogClientTypes.ErrorDetail]? = nil
        )
        {
            self.changeName = changeName
            self.changeType = changeType
            self.details = details
            self.entity = entity
            self.errorDetailList = errorDetailList
        }
    }

}

extension DescribeChangeSetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let changeSetId = changeSetId else {
                let message = "Creating a URL Query Item failed. changeSetId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let changeSetIdQueryItem = ClientRuntime.URLQueryItem(name: "changeSetId".urlPercentEncoding(), value: Swift.String(changeSetId).urlPercentEncoding())
            items.append(changeSetIdQueryItem)
            guard let catalog = catalog else {
                let message = "Creating a URL Query Item failed. catalog is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let catalogQueryItem = ClientRuntime.URLQueryItem(name: "catalog".urlPercentEncoding(), value: Swift.String(catalog).urlPercentEncoding())
            items.append(catalogQueryItem)
            return items
        }
    }
}

extension DescribeChangeSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeChangeSet"
    }
}

public struct DescribeChangeSetInput: Swift.Equatable {
    /// Required. The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// Required. The unique identifier for the StartChangeSet request that you want to describe the details for.
    /// This member is required.
    public var changeSetId: Swift.String?

    public init (
        catalog: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.changeSetId = changeSetId
    }
}

struct DescribeChangeSetInputBody: Swift.Equatable {
}

extension DescribeChangeSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChangeSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeChangeSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeChangeSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeChangeSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changeSet = output.changeSet
            self.changeSetArn = output.changeSetArn
            self.changeSetId = output.changeSetId
            self.changeSetName = output.changeSetName
            self.endTime = output.endTime
            self.failureCode = output.failureCode
            self.failureDescription = output.failureDescription
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.changeSet = nil
            self.changeSetArn = nil
            self.changeSetId = nil
            self.changeSetName = nil
            self.endTime = nil
            self.failureCode = nil
            self.failureDescription = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeChangeSetOutputResponse: Swift.Equatable {
    /// An array of ChangeSummary objects.
    public var changeSet: [MarketplaceCatalogClientTypes.ChangeSummary]?
    /// The ARN associated with the unique identifier for the change set referenced in this request.
    public var changeSetArn: Swift.String?
    /// Required. The unique identifier for the change set referenced in this request.
    public var changeSetId: Swift.String?
    /// The optional name provided in the StartChangeSet request. If you do not provide a name, one is set by default.
    public var changeSetName: Swift.String?
    /// The date and time, in ISO 8601 format (2018-02-27T13:45:22Z), the request transitioned to a terminal state. The change cannot transition to a different state. Null if the request is not in a terminal state.
    public var endTime: Swift.String?
    /// Returned if the change set is in FAILED status. Can be either CLIENT_ERROR, which means that there are issues with the request (see the ErrorDetailList), or SERVER_FAULT, which means that there is a problem in the system, and you should retry your request.
    public var failureCode: MarketplaceCatalogClientTypes.FailureCode?
    /// Returned if there is a failure on the change set, but that failure is not related to any of the changes in the request.
    public var failureDescription: Swift.String?
    /// The date and time, in ISO 8601 format (2018-02-27T13:45:22Z), the request started.
    public var startTime: Swift.String?
    /// The status of the change request.
    public var status: MarketplaceCatalogClientTypes.ChangeStatus?

    public init (
        changeSet: [MarketplaceCatalogClientTypes.ChangeSummary]? = nil,
        changeSetArn: Swift.String? = nil,
        changeSetId: Swift.String? = nil,
        changeSetName: Swift.String? = nil,
        endTime: Swift.String? = nil,
        failureCode: MarketplaceCatalogClientTypes.FailureCode? = nil,
        failureDescription: Swift.String? = nil,
        startTime: Swift.String? = nil,
        status: MarketplaceCatalogClientTypes.ChangeStatus? = nil
    )
    {
        self.changeSet = changeSet
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
        self.changeSetName = changeSetName
        self.endTime = endTime
        self.failureCode = failureCode
        self.failureDescription = failureDescription
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeChangeSetOutputResponseBody: Swift.Equatable {
    let changeSetId: Swift.String?
    let changeSetArn: Swift.String?
    let changeSetName: Swift.String?
    let startTime: Swift.String?
    let endTime: Swift.String?
    let status: MarketplaceCatalogClientTypes.ChangeStatus?
    let failureCode: MarketplaceCatalogClientTypes.FailureCode?
    let failureDescription: Swift.String?
    let changeSet: [MarketplaceCatalogClientTypes.ChangeSummary]?
}

extension DescribeChangeSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSet = "ChangeSet"
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
        case changeSetName = "ChangeSetName"
        case endTime = "EndTime"
        case failureCode = "FailureCode"
        case failureDescription = "FailureDescription"
        case startTime = "StartTime"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
        let changeSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ChangeStatus.self, forKey: .status)
        status = statusDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.FailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureDescription)
        failureDescription = failureDescriptionDecoded
        let changeSetContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.ChangeSummary?].self, forKey: .changeSet)
        var changeSetDecoded0:[MarketplaceCatalogClientTypes.ChangeSummary]? = nil
        if let changeSetContainer = changeSetContainer {
            changeSetDecoded0 = [MarketplaceCatalogClientTypes.ChangeSummary]()
            for structure0 in changeSetContainer {
                if let structure0 = structure0 {
                    changeSetDecoded0?.append(structure0)
                }
            }
        }
        changeSet = changeSetDecoded0
    }
}

extension DescribeEntityInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let entityId = entityId else {
                let message = "Creating a URL Query Item failed. entityId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let entityIdQueryItem = ClientRuntime.URLQueryItem(name: "entityId".urlPercentEncoding(), value: Swift.String(entityId).urlPercentEncoding())
            items.append(entityIdQueryItem)
            guard let catalog = catalog else {
                let message = "Creating a URL Query Item failed. catalog is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let catalogQueryItem = ClientRuntime.URLQueryItem(name: "catalog".urlPercentEncoding(), value: Swift.String(catalog).urlPercentEncoding())
            items.append(catalogQueryItem)
            return items
        }
    }
}

extension DescribeEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeEntity"
    }
}

public struct DescribeEntityInput: Swift.Equatable {
    /// Required. The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// Required. The unique ID of the entity to describe.
    /// This member is required.
    public var entityId: Swift.String?

    public init (
        catalog: Swift.String? = nil,
        entityId: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.entityId = entityId
    }
}

struct DescribeEntityInputBody: Swift.Equatable {
}

extension DescribeEntityInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEntityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEntityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotSupportedException" : self = .resourceNotSupportedException(try ResourceNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEntityOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceNotSupportedException(ResourceNotSupportedException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEntityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEntityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.entityArn = output.entityArn
            self.entityIdentifier = output.entityIdentifier
            self.entityType = output.entityType
            self.lastModifiedDate = output.lastModifiedDate
        } else {
            self.details = nil
            self.entityArn = nil
            self.entityIdentifier = nil
            self.entityType = nil
            self.lastModifiedDate = nil
        }
    }
}

public struct DescribeEntityOutputResponse: Swift.Equatable {
    /// This stringified JSON object includes the details of the entity.
    public var details: Swift.String?
    /// The ARN associated to the unique identifier for the entity referenced in this request.
    public var entityArn: Swift.String?
    /// The identifier of the entity, in the format of EntityId@RevisionId.
    public var entityIdentifier: Swift.String?
    /// The named type of the entity, in the format of EntityType@Version.
    public var entityType: Swift.String?
    /// The last modified date of the entity, in ISO 8601 format (2018-02-27T13:45:22Z).
    public var lastModifiedDate: Swift.String?

    public init (
        details: Swift.String? = nil,
        entityArn: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: Swift.String? = nil,
        lastModifiedDate: Swift.String? = nil
    )
    {
        self.details = details
        self.entityArn = entityArn
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.lastModifiedDate = lastModifiedDate
    }
}

struct DescribeEntityOutputResponseBody: Swift.Equatable {
    let entityType: Swift.String?
    let entityIdentifier: Swift.String?
    let entityArn: Swift.String?
    let lastModifiedDate: Swift.String?
    let details: Swift.String?
}

extension DescribeEntityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case entityArn = "EntityArn"
        case entityIdentifier = "EntityIdentifier"
        case entityType = "EntityType"
        case lastModifiedDate = "LastModifiedDate"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityIdentifier)
        entityIdentifier = entityIdentifierDecoded
        let entityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension MarketplaceCatalogClientTypes.Entity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// An entity contains data that describes your product, its supported features, and how it can be used or launched by your customer.
    public struct Entity: Swift.Equatable {
        /// The identifier for the entity.
        public var identifier: Swift.String?
        /// The type of entity.
        /// This member is required.
        public var type: Swift.String?

        public init (
            identifier: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.identifier = identifier
            self.type = type
        }
    }

}

extension MarketplaceCatalogClientTypes.EntitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityArn = "EntityArn"
        case entityId = "EntityId"
        case entityType = "EntityType"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityArn = self.entityArn {
            try encodeContainer.encode(entityArn, forKey: .entityArn)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// This object is a container for common summary information about the entity. The summary doesn't contain the whole entity structure, but it does contain information common across all entities.
    public struct EntitySummary: Swift.Equatable {
        /// The ARN associated with the unique identifier for the entity.
        public var entityArn: Swift.String?
        /// The unique identifier for the entity.
        public var entityId: Swift.String?
        /// The type of the entity.
        public var entityType: Swift.String?
        /// The last time the entity was published, using ISO 8601 format (2018-02-27T13:45:22Z).
        public var lastModifiedDate: Swift.String?
        /// The name for the entity. This value is not unique. It is defined by the seller.
        public var name: Swift.String?
        /// The visibility status of the entity to buyers. This value can be Public (everyone can view the entity), Limited (the entity is visible to limited accounts only), or Restricted (the entity was published and then unpublished and only existing buyers can view it).
        public var visibility: Swift.String?

        public init (
            entityArn: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityType: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            name: Swift.String? = nil,
            visibility: Swift.String? = nil
        )
        {
            self.entityArn = entityArn
            self.entityId = entityId
            self.entityType = entityType
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.ErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Details about the error.
    public struct ErrorDetail: Swift.Equatable {
        /// The error code that identifies the type of error.
        public var errorCode: Swift.String?
        /// The message for the error.
        public var errorMessage: Swift.String?

        public init (
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum FailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clienterror
        case serverfault
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureCode] {
            return [
                .clienterror,
                .serverfault,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clienterror: return "CLIENT_ERROR"
            case .serverfault: return "SERVER_FAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureCode(rawValue: rawValue) ?? FailureCode.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for filtervaluecontent0 in valueList {
                try valueListContainer.encode(filtervaluecontent0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// A filter object, used to optionally filter results from calls to the ListEntities and ListChangeSets actions.
    public struct Filter: Swift.Equatable {
        /// For ListEntities, the supported value for this is an EntityId. For ListChangeSets, the supported values are as follows:
        public var name: Swift.String?
        /// ListEntities - This is a list of unique EntityIds. ListChangeSets - The supported filter names and associated ValueLists is as follows:
        ///
        /// * ChangeSetName - The supported ValueList is a list of non-unique ChangeSetNames. These are defined when you call the StartChangeSet action.
        ///
        /// * Status - The supported ValueList is a list of statuses for all change set requests.
        ///
        /// * EntityId - The supported ValueList is a list of unique EntityIds.
        ///
        /// * BeforeStartTime - The supported ValueList is a list of all change sets that started before the filter value.
        ///
        /// * AfterStartTime - The supported ValueList is a list of all change sets that started after the filter value.
        ///
        /// * BeforeEndTime - The supported ValueList is a list of all change sets that ended before the filter value.
        ///
        /// * AfterEndTime - The supported ValueList is a list of all change sets that ended after the filter value.
        public var valueList: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            valueList: [Swift.String]? = nil
        )
        {
            self.name = name
            self.valueList = valueList
        }
    }

}

extension InternalServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an internal service exception.
public struct InternalServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChangeSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let filterList = filterList {
            var filterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterList)
            for filter0 in filterList {
                try filterListContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

extension ListChangeSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListChangeSets"
    }
}

public struct ListChangeSetsInput: Swift.Equatable {
    /// The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// An array of filter objects.
    public var filterList: [MarketplaceCatalogClientTypes.Filter]?
    /// The maximum number of results returned by a single call. This value must be provided in the next call to retrieve the next set of results. By default, this value is 20.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// An object that contains two attributes, SortBy and SortOrder.
    public var sort: MarketplaceCatalogClientTypes.Sort?

    public init (
        catalog: Swift.String? = nil,
        filterList: [MarketplaceCatalogClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: MarketplaceCatalogClientTypes.Sort? = nil
    )
    {
        self.catalog = catalog
        self.filterList = filterList
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListChangeSetsInputBody: Swift.Equatable {
    let catalog: Swift.String?
    let filterList: [MarketplaceCatalogClientTypes.Filter]?
    let sort: MarketplaceCatalogClientTypes.Sort?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListChangeSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let filterListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Filter?].self, forKey: .filterList)
        var filterListDecoded0:[MarketplaceCatalogClientTypes.Filter]? = nil
        if let filterListContainer = filterListContainer {
            filterListDecoded0 = [MarketplaceCatalogClientTypes.Filter]()
            for structure0 in filterListContainer {
                if let structure0 = structure0 {
                    filterListDecoded0?.append(structure0)
                }
            }
        }
        filterList = filterListDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Sort.self, forKey: .sort)
        sort = sortDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChangeSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChangeSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChangeSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChangeSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChangeSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changeSetSummaryList = output.changeSetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.changeSetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListChangeSetsOutputResponse: Swift.Equatable {
    /// Array of ChangeSetSummaryListItem objects.
    public var changeSetSummaryList: [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]?
    /// The value of the next token, if it exists. Null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        changeSetSummaryList: [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.changeSetSummaryList = changeSetSummaryList
        self.nextToken = nextToken
    }
}

struct ListChangeSetsOutputResponseBody: Swift.Equatable {
    let changeSetSummaryList: [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]?
    let nextToken: Swift.String?
}

extension ListChangeSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSetSummaryList = "ChangeSetSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetSummaryListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.ChangeSetSummaryListItem?].self, forKey: .changeSetSummaryList)
        var changeSetSummaryListDecoded0:[MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]? = nil
        if let changeSetSummaryListContainer = changeSetSummaryListContainer {
            changeSetSummaryListDecoded0 = [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]()
            for structure0 in changeSetSummaryListContainer {
                if let structure0 = structure0 {
                    changeSetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        changeSetSummaryList = changeSetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case entityType = "EntityType"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let filterList = filterList {
            var filterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterList)
            for filter0 in filterList {
                try filterListContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

extension ListEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListEntities"
    }
}

public struct ListEntitiesInput: Swift.Equatable {
    /// The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// The type of entities to retrieve.
    /// This member is required.
    public var entityType: Swift.String?
    /// An array of filter objects. Each filter object contains two attributes, filterName and filterValues.
    public var filterList: [MarketplaceCatalogClientTypes.Filter]?
    /// Specifies the upper limit of the elements on a single page. If a value isn't provided, the default value is 20.
    public var maxResults: Swift.Int?
    /// The value of the next token, if it exists. Null if there are no more results.
    public var nextToken: Swift.String?
    /// An object that contains two attributes, SortBy and SortOrder.
    public var sort: MarketplaceCatalogClientTypes.Sort?

    public init (
        catalog: Swift.String? = nil,
        entityType: Swift.String? = nil,
        filterList: [MarketplaceCatalogClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: MarketplaceCatalogClientTypes.Sort? = nil
    )
    {
        self.catalog = catalog
        self.entityType = entityType
        self.filterList = filterList
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListEntitiesInputBody: Swift.Equatable {
    let catalog: Swift.String?
    let entityType: Swift.String?
    let filterList: [MarketplaceCatalogClientTypes.Filter]?
    let sort: MarketplaceCatalogClientTypes.Sort?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case entityType = "EntityType"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let filterListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Filter?].self, forKey: .filterList)
        var filterListDecoded0:[MarketplaceCatalogClientTypes.Filter]? = nil
        if let filterListContainer = filterListContainer {
            filterListDecoded0 = [MarketplaceCatalogClientTypes.Filter]()
            for structure0 in filterListContainer {
                if let structure0 = structure0 {
                    filterListDecoded0?.append(structure0)
                }
            }
        }
        filterList = filterListDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Sort.self, forKey: .sort)
        sort = sortDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListEntitiesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entitySummaryList = output.entitySummaryList
            self.nextToken = output.nextToken
        } else {
            self.entitySummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesOutputResponse: Swift.Equatable {
    /// Array of EntitySummary object.
    public var entitySummaryList: [MarketplaceCatalogClientTypes.EntitySummary]?
    /// The value of the next token if it exists. Null if there is no more result.
    public var nextToken: Swift.String?

    public init (
        entitySummaryList: [MarketplaceCatalogClientTypes.EntitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitySummaryList = entitySummaryList
        self.nextToken = nextToken
    }
}

struct ListEntitiesOutputResponseBody: Swift.Equatable {
    let entitySummaryList: [MarketplaceCatalogClientTypes.EntitySummary]?
    let nextToken: Swift.String?
}

extension ListEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitySummaryList = "EntitySummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitySummaryListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.EntitySummary?].self, forKey: .entitySummaryList)
        var entitySummaryListDecoded0:[MarketplaceCatalogClientTypes.EntitySummary]? = nil
        if let entitySummaryListContainer = entitySummaryListContainer {
            entitySummaryListDecoded0 = [MarketplaceCatalogClientTypes.EntitySummary]()
            for structure0 in entitySummaryListContainer {
                if let structure0 = structure0 {
                    entitySummaryListDecoded0?.append(structure0)
                }
            }
        }
        entitySummaryList = entitySummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Required. The Amazon Resource Name (ARN) associated with the resource you want to list tags on.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Required. The ARN associated with the resource you want to list tags on.
    public var resourceArn: Swift.String?
    /// Required. A list of objects specifying each key name and value. Number of objects allowed: 1-50.
    public var tags: [MarketplaceCatalogClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [MarketplaceCatalogClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [MarketplaceCatalogClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MarketplaceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MarketplaceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is currently in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource wasn't found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Currently, the specified resource is not supported.
public struct ResourceNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotSupportedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum number of open requests per account has been exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceCatalogClientTypes.Sort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// An object that contains two attributes, SortBy and SortOrder.
    public struct Sort: Swift.Equatable {
        /// For ListEntities, supported attributes include LastModifiedDate (default), Visibility, EntityId, and Name. For ListChangeSets, supported attributes include StartTime and EndTime.
        public var sortBy: Swift.String?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init (
            sortBy: Swift.String? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StartChangeSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case changeSet = "ChangeSet"
        case changeSetName = "ChangeSetName"
        case changeSetTags = "ChangeSetTags"
        case clientRequestToken = "ClientRequestToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let changeSet = changeSet {
            var changeSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeSet)
            for change0 in changeSet {
                try changeSetContainer.encode(change0)
            }
        }
        if let changeSetName = self.changeSetName {
            try encodeContainer.encode(changeSetName, forKey: .changeSetName)
        }
        if let changeSetTags = changeSetTags {
            var changeSetTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeSetTags)
            for tag0 in changeSetTags {
                try changeSetTagsContainer.encode(tag0)
            }
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
    }
}

extension StartChangeSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartChangeSet"
    }
}

public struct StartChangeSetInput: Swift.Equatable {
    /// The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// Array of change object.
    /// This member is required.
    public var changeSet: [MarketplaceCatalogClientTypes.Change]?
    /// Optional case sensitive string of up to 100 ASCII characters. The change set name can be used to filter the list of change sets.
    public var changeSetName: Swift.String?
    /// A list of objects specifying each key name and value for the ChangeSetTags property.
    public var changeSetTags: [MarketplaceCatalogClientTypes.Tag]?
    /// A unique token to identify the request to ensure idempotency.
    public var clientRequestToken: Swift.String?

    public init (
        catalog: Swift.String? = nil,
        changeSet: [MarketplaceCatalogClientTypes.Change]? = nil,
        changeSetName: Swift.String? = nil,
        changeSetTags: [MarketplaceCatalogClientTypes.Tag]? = nil,
        clientRequestToken: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.changeSet = changeSet
        self.changeSetName = changeSetName
        self.changeSetTags = changeSetTags
        self.clientRequestToken = clientRequestToken
    }
}

struct StartChangeSetInputBody: Swift.Equatable {
    let catalog: Swift.String?
    let changeSet: [MarketplaceCatalogClientTypes.Change]?
    let changeSetName: Swift.String?
    let clientRequestToken: Swift.String?
    let changeSetTags: [MarketplaceCatalogClientTypes.Tag]?
}

extension StartChangeSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case changeSet = "ChangeSet"
        case changeSetName = "ChangeSetName"
        case changeSetTags = "ChangeSetTags"
        case clientRequestToken = "ClientRequestToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let changeSetContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Change?].self, forKey: .changeSet)
        var changeSetDecoded0:[MarketplaceCatalogClientTypes.Change]? = nil
        if let changeSetContainer = changeSetContainer {
            changeSetDecoded0 = [MarketplaceCatalogClientTypes.Change]()
            for structure0 in changeSetContainer {
                if let structure0 = structure0 {
                    changeSetDecoded0?.append(structure0)
                }
            }
        }
        changeSet = changeSetDecoded0
        let changeSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let changeSetTagsContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Tag?].self, forKey: .changeSetTags)
        var changeSetTagsDecoded0:[MarketplaceCatalogClientTypes.Tag]? = nil
        if let changeSetTagsContainer = changeSetTagsContainer {
            changeSetTagsDecoded0 = [MarketplaceCatalogClientTypes.Tag]()
            for structure0 in changeSetTagsContainer {
                if let structure0 = structure0 {
                    changeSetTagsDecoded0?.append(structure0)
                }
            }
        }
        changeSetTags = changeSetTagsDecoded0
    }
}

extension StartChangeSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartChangeSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartChangeSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartChangeSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartChangeSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changeSetArn = output.changeSetArn
            self.changeSetId = output.changeSetId
        } else {
            self.changeSetArn = nil
            self.changeSetId = nil
        }
    }
}

public struct StartChangeSetOutputResponse: Swift.Equatable {
    /// The ARN associated to the unique identifier generated for the request.
    public var changeSetArn: Swift.String?
    /// Unique identifier generated for the request.
    public var changeSetId: Swift.String?

    public init (
        changeSetArn: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
    }
}

struct StartChangeSetOutputResponseBody: Swift.Equatable {
    let changeSetId: Swift.String?
    let changeSetArn: Swift.String?
}

extension StartChangeSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
    }
}

extension MarketplaceCatalogClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// A list of objects specifying each key name and value.
    public struct Tag: Swift.Equatable {
        /// The key associated with the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Required. The Amazon Resource Name (ARN) associated with the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Required. A list of objects specifying each key name and value. Number of objects allowed: 1-50.
    /// This member is required.
    public var tags: [MarketplaceCatalogClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [MarketplaceCatalogClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [MarketplaceCatalogClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MarketplaceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MarketplaceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Too many requests.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UntagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Required. The Amazon Resource Name (ARN) associated with the resource you want to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Required. A list of key names of tags to be removed. Number of strings allowed: 0-256.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceException" : self = .internalServiceException(try InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceException(InternalServiceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error occurred during validation.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
