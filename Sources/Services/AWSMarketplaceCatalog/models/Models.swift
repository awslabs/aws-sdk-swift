// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access is denied. HTTP status code: 403
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceCatalogClientTypes.AmiProductEntityIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for amiproductentityidstring0 in valueList {
                try valueListContainer.encode(amiproductentityidstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on entity id of an AMI product.
    public struct AmiProductEntityIdFilter {
        /// A string array of unique entity id values to be filtered on.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.AmiProductFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case lastModifiedDate = "LastModifiedDate"
        case productTitle = "ProductTitle"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let productTitle = self.productTitle {
            try encodeContainer.encode(productTitle, forKey: .productTitle)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductEntityIdFilter.self, forKey: .entityId)
        entityId = entityIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilter.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let productTitleDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductTitleFilter.self, forKey: .productTitle)
        productTitle = productTitleDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductVisibilityFilter.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object containing all the filter fields for AMI products. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct AmiProductFilters {
        /// Unique identifier for the AMI product.
        public var entityId: MarketplaceCatalogClientTypes.AmiProductEntityIdFilter?
        /// The last date on which the AMI product was modified.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilter?
        /// The title of the AMI product.
        public var productTitle: MarketplaceCatalogClientTypes.AmiProductTitleFilter?
        /// The visibility of the AMI product.
        public var visibility: MarketplaceCatalogClientTypes.AmiProductVisibilityFilter?

        public init(
            entityId: MarketplaceCatalogClientTypes.AmiProductEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilter? = nil,
            productTitle: MarketplaceCatalogClientTypes.AmiProductTitleFilter? = nil,
            visibility: MarketplaceCatalogClientTypes.AmiProductVisibilityFilter? = nil
        )
        {
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering based on the last modified date of AMI products.
    public struct AmiProductLastModifiedDateFilter {
        /// Dates between which the AMI product was last modified.
        public var dateRange: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }

}

extension MarketplaceCatalogClientTypes.AmiProductLastModifiedDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that contains date range of the last modified date to be filtered on. You can optionally provide a BeforeValue and/or AfterValue. Both are inclusive.
    public struct AmiProductLastModifiedDateFilterDateRange {
        /// Date after which the AMI product was last modified.
        public var afterValue: Swift.String?
        /// Date before which the AMI product was last modified.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.AmiProductSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Objects that allows sorting on AMI products based on certain fields and sorting order.
    public struct AmiProductSort {
        /// Field to sort the AMI products by.
        public var sortBy: MarketplaceCatalogClientTypes.AmiProductSortBy?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.AmiProductSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum AmiProductSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entityid
        case lastmodifieddate
        case producttitle
        case visibility
        case sdkUnknown(Swift.String)

        public static var allCases: [AmiProductSortBy] {
            return [
                .entityid,
                .lastmodifieddate,
                .producttitle,
                .visibility,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .producttitle: return "ProductTitle"
            case .visibility: return "Visibility"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmiProductSortBy(rawValue: rawValue) ?? AmiProductSortBy.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.AmiProductSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productTitle = "ProductTitle"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productTitle = self.productTitle {
            try encodeContainer.encode(productTitle, forKey: .productTitle)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productTitle)
        productTitle = productTitleDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductVisibilityString.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that contains summarized information about an AMI product.
    public struct AmiProductSummary {
        /// The title of the AMI product.
        public var productTitle: Swift.String?
        /// The lifecycle of the AMI product.
        public var visibility: MarketplaceCatalogClientTypes.AmiProductVisibilityString?

        public init(
            productTitle: Swift.String? = nil,
            visibility: MarketplaceCatalogClientTypes.AmiProductVisibilityString? = nil
        )
        {
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.AmiProductTitleFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for amiproducttitlestring0 in valueList {
                try valueListContainer.encode(amiproducttitlestring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on product title.
    public struct AmiProductTitleFilter {
        /// A string array of unique product title values to be filtered on.
        public var valueList: [Swift.String]?
        /// A string that will be the wildCard input for product tile filter. It matches the provided value as a substring in the actual value.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.AmiProductVisibilityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for amiproductvisibilitystring0 in valueList {
                try valueListContainer.encode(amiproductvisibilitystring0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.AmiProductVisibilityString?].self, forKey: .valueList)
        var valueListDecoded0:[MarketplaceCatalogClientTypes.AmiProductVisibilityString]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [MarketplaceCatalogClientTypes.AmiProductVisibilityString]()
            for enum0 in valueListContainer {
                if let enum0 = enum0 {
                    valueListDecoded0?.append(enum0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on the visibility of the product in the AWS Marketplace.
    public struct AmiProductVisibilityFilter {
        /// A string array of unique visibility values to be filtered on.
        public var valueList: [MarketplaceCatalogClientTypes.AmiProductVisibilityString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.AmiProductVisibilityString]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum AmiProductVisibilityString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draft
        case limited
        case `public`
        case restricted
        case sdkUnknown(Swift.String)

        public static var allCases: [AmiProductVisibilityString] {
            return [
                .draft,
                .limited,
                .public,
                .restricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .limited: return "Limited"
            case .public: return "Public"
            case .restricted: return "Restricted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmiProductVisibilityString(rawValue: rawValue) ?? AmiProductVisibilityString.sdkUnknown(rawValue)
        }
    }
}

extension BatchDescribeEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityRequestList = "EntityRequestList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityRequestList = entityRequestList {
            var entityRequestListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityRequestList)
            for entityrequest0 in entityRequestList {
                try entityRequestListContainer.encode(entityrequest0)
            }
        }
    }
}

extension BatchDescribeEntitiesInput {

    static func urlPathProvider(_ value: BatchDescribeEntitiesInput) -> Swift.String? {
        return "/BatchDescribeEntities"
    }
}

public struct BatchDescribeEntitiesInput {
    /// List of entity IDs and the catalogs the entities are present in.
    /// This member is required.
    public var entityRequestList: [MarketplaceCatalogClientTypes.EntityRequest]?

    public init(
        entityRequestList: [MarketplaceCatalogClientTypes.EntityRequest]? = nil
    )
    {
        self.entityRequestList = entityRequestList
    }
}

struct BatchDescribeEntitiesInputBody {
    let entityRequestList: [MarketplaceCatalogClientTypes.EntityRequest]?
}

extension BatchDescribeEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityRequestList = "EntityRequestList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityRequestListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.EntityRequest?].self, forKey: .entityRequestList)
        var entityRequestListDecoded0:[MarketplaceCatalogClientTypes.EntityRequest]? = nil
        if let entityRequestListContainer = entityRequestListContainer {
            entityRequestListDecoded0 = [MarketplaceCatalogClientTypes.EntityRequest]()
            for structure0 in entityRequestListContainer {
                if let structure0 = structure0 {
                    entityRequestListDecoded0?.append(structure0)
                }
            }
        }
        entityRequestList = entityRequestListDecoded0
    }
}

extension BatchDescribeEntitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDescribeEntitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entityDetails = output.entityDetails
            self.errors = output.errors
        } else {
            self.entityDetails = nil
            self.errors = nil
        }
    }
}

public struct BatchDescribeEntitiesOutput {
    /// Details about each entity.
    public var entityDetails: [Swift.String:MarketplaceCatalogClientTypes.EntityDetail]?
    /// A map of errors returned, with EntityId as the key and errorDetail as the value.
    public var errors: [Swift.String:MarketplaceCatalogClientTypes.BatchDescribeErrorDetail]?

    public init(
        entityDetails: [Swift.String:MarketplaceCatalogClientTypes.EntityDetail]? = nil,
        errors: [Swift.String:MarketplaceCatalogClientTypes.BatchDescribeErrorDetail]? = nil
    )
    {
        self.entityDetails = entityDetails
        self.errors = errors
    }
}

struct BatchDescribeEntitiesOutputBody {
    let entityDetails: [Swift.String:MarketplaceCatalogClientTypes.EntityDetail]?
    let errors: [Swift.String:MarketplaceCatalogClientTypes.BatchDescribeErrorDetail]?
}

extension BatchDescribeEntitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityDetails = "EntityDetails"
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDetailsContainer = try containerValues.decodeIfPresent([Swift.String: MarketplaceCatalogClientTypes.EntityDetail?].self, forKey: .entityDetails)
        var entityDetailsDecoded0: [Swift.String:MarketplaceCatalogClientTypes.EntityDetail]? = nil
        if let entityDetailsContainer = entityDetailsContainer {
            entityDetailsDecoded0 = [Swift.String:MarketplaceCatalogClientTypes.EntityDetail]()
            for (key0, entitydetail0) in entityDetailsContainer {
                if let entitydetail0 = entitydetail0 {
                    entityDetailsDecoded0?[key0] = entitydetail0
                }
            }
        }
        entityDetails = entityDetailsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([Swift.String: MarketplaceCatalogClientTypes.BatchDescribeErrorDetail?].self, forKey: .errors)
        var errorsDecoded0: [Swift.String:MarketplaceCatalogClientTypes.BatchDescribeErrorDetail]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [Swift.String:MarketplaceCatalogClientTypes.BatchDescribeErrorDetail]()
            for (key0, batchdescribeerrordetail0) in errorsContainer {
                if let batchdescribeerrordetail0 = batchdescribeerrordetail0 {
                    errorsDecoded0?[key0] = batchdescribeerrordetail0
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDescribeEntitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceCatalogClientTypes.BatchDescribeErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// An object that contains an error code and error message.
    public struct BatchDescribeErrorDetail {
        /// The error code returned.
        public var errorCode: Swift.String?
        /// The error message returned.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension CancelChangeSetInput {

    static func queryItemProvider(_ value: CancelChangeSetInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let changeSetId = value.changeSetId else {
            let message = "Creating a URL Query Item failed. changeSetId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let changeSetIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "changeSetId".urlPercentEncoding(), value: Swift.String(changeSetId).urlPercentEncoding())
        items.append(changeSetIdQueryItem)
        guard let catalog = value.catalog else {
            let message = "Creating a URL Query Item failed. catalog is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let catalogQueryItem = ClientRuntime.SDKURLQueryItem(name: "catalog".urlPercentEncoding(), value: Swift.String(catalog).urlPercentEncoding())
        items.append(catalogQueryItem)
        return items
    }
}

extension CancelChangeSetInput {

    static func urlPathProvider(_ value: CancelChangeSetInput) -> Swift.String? {
        return "/CancelChangeSet"
    }
}

public struct CancelChangeSetInput {
    /// Required. The catalog related to the request. Fixed value: AWSMarketplace.
    /// This member is required.
    public var catalog: Swift.String?
    /// Required. The unique identifier of the StartChangeSet request that you want to cancel.
    /// This member is required.
    public var changeSetId: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.changeSetId = changeSetId
    }
}

struct CancelChangeSetInputBody {
}

extension CancelChangeSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelChangeSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelChangeSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.changeSetArn = output.changeSetArn
            self.changeSetId = output.changeSetId
        } else {
            self.changeSetArn = nil
            self.changeSetId = nil
        }
    }
}

public struct CancelChangeSetOutput {
    /// The ARN associated with the change set referenced in this request.
    public var changeSetArn: Swift.String?
    /// The unique identifier for the change set referenced in this request.
    public var changeSetId: Swift.String?

    public init(
        changeSetArn: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
    }
}

struct CancelChangeSetOutputBody {
    let changeSetId: Swift.String?
    let changeSetArn: Swift.String?
}

extension CancelChangeSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
    }
}

enum CancelChangeSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceCatalogClientTypes.Change: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeName = "ChangeName"
        case changeType = "ChangeType"
        case details = "Details"
        case detailsDocument = "DetailsDocument"
        case entity = "Entity"
        case entityTags = "EntityTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeName = self.changeName {
            try encodeContainer.encode(changeName, forKey: .changeName)
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType, forKey: .changeType)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let detailsDocument = self.detailsDocument {
            try encodeContainer.encode(detailsDocument, forKey: .detailsDocument)
        }
        if let entity = self.entity {
            try encodeContainer.encode(entity, forKey: .entity)
        }
        if let entityTags = entityTags {
            var entityTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTags)
            for tag0 in entityTags {
                try entityTagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let entityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Entity.self, forKey: .entity)
        entity = entityDecoded
        let entityTagsContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Tag?].self, forKey: .entityTags)
        var entityTagsDecoded0:[MarketplaceCatalogClientTypes.Tag]? = nil
        if let entityTagsContainer = entityTagsContainer {
            entityTagsDecoded0 = [MarketplaceCatalogClientTypes.Tag]()
            for structure0 in entityTagsContainer {
                if let structure0 = structure0 {
                    entityTagsDecoded0?.append(structure0)
                }
            }
        }
        entityTags = entityTagsDecoded0
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
        let detailsDocumentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .detailsDocument)
        detailsDocument = detailsDocumentDecoded
        let changeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeName)
        changeName = changeNameDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// An object that contains the ChangeType, Details, and Entity.
    public struct Change {
        /// Optional name for the change.
        public var changeName: Swift.String?
        /// Change types are single string values that describe your intention for the change. Each change type is unique for each EntityType provided in the change's scope. For more information about change types available for single-AMI products, see [Working with single-AMI products](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/ami-products.html#working-with-single-AMI-products). Also, for more information about change types available for container-based products, see [Working with container products](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/container-products.html#working-with-container-products).
        /// This member is required.
        public var changeType: Swift.String?
        /// This object contains details specific to the change type of the requested change. For more information about change types available for single-AMI products, see [Working with single-AMI products](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/ami-products.html#working-with-single-AMI-products). Also, for more information about change types available for container-based products, see [Working with container products](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/container-products.html#working-with-container-products).
        public var details: Swift.String?
        /// Alternative field that accepts a JSON value instead of a string for ChangeType details. You can use either Details or DetailsDocument, but not both.
        public var detailsDocument: ClientRuntime.Document?
        /// The entity to be changed.
        /// This member is required.
        public var entity: MarketplaceCatalogClientTypes.Entity?
        /// The tags associated with the change.
        public var entityTags: [MarketplaceCatalogClientTypes.Tag]?

        public init(
            changeName: Swift.String? = nil,
            changeType: Swift.String? = nil,
            details: Swift.String? = nil,
            detailsDocument: ClientRuntime.Document? = nil,
            entity: MarketplaceCatalogClientTypes.Entity? = nil,
            entityTags: [MarketplaceCatalogClientTypes.Tag]? = nil
        )
        {
            self.changeName = changeName
            self.changeType = changeType
            self.details = details
            self.detailsDocument = detailsDocument
            self.entity = entity
            self.entityTags = entityTags
        }
    }

}

extension MarketplaceCatalogClientTypes.ChangeSetSummaryListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
        case changeSetName = "ChangeSetName"
        case endTime = "EndTime"
        case entityIdList = "EntityIdList"
        case failureCode = "FailureCode"
        case startTime = "StartTime"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeSetArn = self.changeSetArn {
            try encodeContainer.encode(changeSetArn, forKey: .changeSetArn)
        }
        if let changeSetId = self.changeSetId {
            try encodeContainer.encode(changeSetId, forKey: .changeSetId)
        }
        if let changeSetName = self.changeSetName {
            try encodeContainer.encode(changeSetName, forKey: .changeSetName)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let entityIdList = entityIdList {
            var entityIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityIdList)
            for resourceid0 in entityIdList {
                try entityIdListContainer.encode(resourceid0)
            }
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
        let changeSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ChangeStatus.self, forKey: .status)
        status = statusDecoded
        let entityIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityIdList)
        var entityIdListDecoded0:[Swift.String]? = nil
        if let entityIdListContainer = entityIdListContainer {
            entityIdListDecoded0 = [Swift.String]()
            for string0 in entityIdListContainer {
                if let string0 = string0 {
                    entityIdListDecoded0?.append(string0)
                }
            }
        }
        entityIdList = entityIdListDecoded0
        let failureCodeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.FailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// A summary of a change set returned in a list of change sets when the ListChangeSets action is called.
    public struct ChangeSetSummaryListItem {
        /// The ARN associated with the unique identifier for the change set referenced in this request.
        public var changeSetArn: Swift.String?
        /// The unique identifier for a change set.
        public var changeSetId: Swift.String?
        /// The non-unique name for the change set.
        public var changeSetName: Swift.String?
        /// The time, in ISO 8601 format (2018-02-27T13:45:22Z), when the change set was finished.
        public var endTime: Swift.String?
        /// This object is a list of entity IDs (string) that are a part of a change set. The entity ID list is a maximum of 20 entities. It must contain at least one entity.
        public var entityIdList: [Swift.String]?
        /// Returned if the change set is in FAILED status. Can be either CLIENT_ERROR, which means that there are issues with the request (see the ErrorDetailList of DescribeChangeSet), or SERVER_FAULT, which means that there is a problem in the system, and you should retry your request.
        public var failureCode: MarketplaceCatalogClientTypes.FailureCode?
        /// The time, in ISO 8601 format (2018-02-27T13:45:22Z), when the change set was started.
        public var startTime: Swift.String?
        /// The current status of the change set.
        public var status: MarketplaceCatalogClientTypes.ChangeStatus?

        public init(
            changeSetArn: Swift.String? = nil,
            changeSetId: Swift.String? = nil,
            changeSetName: Swift.String? = nil,
            endTime: Swift.String? = nil,
            entityIdList: [Swift.String]? = nil,
            failureCode: MarketplaceCatalogClientTypes.FailureCode? = nil,
            startTime: Swift.String? = nil,
            status: MarketplaceCatalogClientTypes.ChangeStatus? = nil
        )
        {
            self.changeSetArn = changeSetArn
            self.changeSetId = changeSetId
            self.changeSetName = changeSetName
            self.endTime = endTime
            self.entityIdList = entityIdList
            self.failureCode = failureCode
            self.startTime = startTime
            self.status = status
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum ChangeStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applying
        case cancelled
        case failed
        case preparing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeStatus] {
            return [
                .applying,
                .cancelled,
                .failed,
                .preparing,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applying: return "APPLYING"
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .preparing: return "PREPARING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeStatus(rawValue: rawValue) ?? ChangeStatus.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.ChangeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeName = "ChangeName"
        case changeType = "ChangeType"
        case details = "Details"
        case detailsDocument = "DetailsDocument"
        case entity = "Entity"
        case errorDetailList = "ErrorDetailList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeName = self.changeName {
            try encodeContainer.encode(changeName, forKey: .changeName)
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType, forKey: .changeType)
        }
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let detailsDocument = self.detailsDocument {
            try encodeContainer.encode(detailsDocument, forKey: .detailsDocument)
        }
        if let entity = self.entity {
            try encodeContainer.encode(entity, forKey: .entity)
        }
        if let errorDetailList = errorDetailList {
            var errorDetailListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorDetailList)
            for errordetail0 in errorDetailList {
                try errorDetailListContainer.encode(errordetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let entityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Entity.self, forKey: .entity)
        entity = entityDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
        let detailsDocumentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .detailsDocument)
        detailsDocument = detailsDocumentDecoded
        let errorDetailListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.ErrorDetail?].self, forKey: .errorDetailList)
        var errorDetailListDecoded0:[MarketplaceCatalogClientTypes.ErrorDetail]? = nil
        if let errorDetailListContainer = errorDetailListContainer {
            errorDetailListDecoded0 = [MarketplaceCatalogClientTypes.ErrorDetail]()
            for structure0 in errorDetailListContainer {
                if let structure0 = structure0 {
                    errorDetailListDecoded0?.append(structure0)
                }
            }
        }
        errorDetailList = errorDetailListDecoded0
        let changeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeName)
        changeName = changeNameDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// This object is a container for common summary information about the change. The summary doesn't contain the whole change structure.
    public struct ChangeSummary {
        /// Optional name for the change.
        public var changeName: Swift.String?
        /// The type of the change.
        public var changeType: Swift.String?
        /// This object contains details specific to the change type of the requested change.
        public var details: Swift.String?
        /// The JSON value of the details specific to the change type of the requested change.
        public var detailsDocument: ClientRuntime.Document?
        /// The entity to be changed.
        public var entity: MarketplaceCatalogClientTypes.Entity?
        /// An array of ErrorDetail objects associated with the change.
        public var errorDetailList: [MarketplaceCatalogClientTypes.ErrorDetail]?

        public init(
            changeName: Swift.String? = nil,
            changeType: Swift.String? = nil,
            details: Swift.String? = nil,
            detailsDocument: ClientRuntime.Document? = nil,
            entity: MarketplaceCatalogClientTypes.Entity? = nil,
            errorDetailList: [MarketplaceCatalogClientTypes.ErrorDetail]? = nil
        )
        {
            self.changeName = changeName
            self.changeType = changeType
            self.details = details
            self.detailsDocument = detailsDocument
            self.entity = entity
            self.errorDetailList = errorDetailList
        }
    }

}

extension MarketplaceCatalogClientTypes.ContainerProductEntityIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for containerproductentityidstring0 in valueList {
                try valueListContainer.encode(containerproductentityidstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on entity id of a container product.
    public struct ContainerProductEntityIdFilter {
        /// A string array of unique entity id values to be filtered on.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.ContainerProductFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case lastModifiedDate = "LastModifiedDate"
        case productTitle = "ProductTitle"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let productTitle = self.productTitle {
            try encodeContainer.encode(productTitle, forKey: .productTitle)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductEntityIdFilter.self, forKey: .entityId)
        entityId = entityIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilter.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let productTitleDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductTitleFilter.self, forKey: .productTitle)
        productTitle = productTitleDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductVisibilityFilter.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object containing all the filter fields for container products. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct ContainerProductFilters {
        /// Unique identifier for the container product.
        public var entityId: MarketplaceCatalogClientTypes.ContainerProductEntityIdFilter?
        /// The last date on which the container product was modified.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilter?
        /// The title of the container product.
        public var productTitle: MarketplaceCatalogClientTypes.ContainerProductTitleFilter?
        /// The visibility of the container product.
        public var visibility: MarketplaceCatalogClientTypes.ContainerProductVisibilityFilter?

        public init(
            entityId: MarketplaceCatalogClientTypes.ContainerProductEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilter? = nil,
            productTitle: MarketplaceCatalogClientTypes.ContainerProductTitleFilter? = nil,
            visibility: MarketplaceCatalogClientTypes.ContainerProductVisibilityFilter? = nil
        )
        {
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering based on the last modified date of container products.
    public struct ContainerProductLastModifiedDateFilter {
        /// Dates between which the container product was last modified.
        public var dateRange: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }

}

extension MarketplaceCatalogClientTypes.ContainerProductLastModifiedDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that contains date range of the last modified date to be filtered on. You can optionally provide a BeforeValue and/or AfterValue. Both are inclusive.
    public struct ContainerProductLastModifiedDateFilterDateRange {
        /// Date after which the container product was last modified.
        public var afterValue: Swift.String?
        /// Date before which the container product was last modified.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ContainerProductSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Objects that allows sorting on container products based on certain fields and sorting order.
    public struct ContainerProductSort {
        /// Field to sort the container products by.
        public var sortBy: MarketplaceCatalogClientTypes.ContainerProductSortBy?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.ContainerProductSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum ContainerProductSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entityid
        case lastmodifieddate
        case producttitle
        case visibility
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerProductSortBy] {
            return [
                .entityid,
                .lastmodifieddate,
                .producttitle,
                .visibility,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .producttitle: return "ProductTitle"
            case .visibility: return "Visibility"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerProductSortBy(rawValue: rawValue) ?? ContainerProductSortBy.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.ContainerProductSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productTitle = "ProductTitle"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productTitle = self.productTitle {
            try encodeContainer.encode(productTitle, forKey: .productTitle)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productTitle)
        productTitle = productTitleDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductVisibilityString.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that contains summarized information about a container product.
    public struct ContainerProductSummary {
        /// The title of the container product.
        public var productTitle: Swift.String?
        /// The lifecycle of the product.
        public var visibility: MarketplaceCatalogClientTypes.ContainerProductVisibilityString?

        public init(
            productTitle: Swift.String? = nil,
            visibility: MarketplaceCatalogClientTypes.ContainerProductVisibilityString? = nil
        )
        {
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.ContainerProductTitleFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for containerproducttitlestring0 in valueList {
                try valueListContainer.encode(containerproducttitlestring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on product title.
    public struct ContainerProductTitleFilter {
        /// A string array of unique product title values to be filtered on.
        public var valueList: [Swift.String]?
        /// A string that will be the wildCard input for product tile filter. It matches the provided value as a substring in the actual value.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ContainerProductVisibilityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for containerproductvisibilitystring0 in valueList {
                try valueListContainer.encode(containerproductvisibilitystring0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.ContainerProductVisibilityString?].self, forKey: .valueList)
        var valueListDecoded0:[MarketplaceCatalogClientTypes.ContainerProductVisibilityString]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [MarketplaceCatalogClientTypes.ContainerProductVisibilityString]()
            for enum0 in valueListContainer {
                if let enum0 = enum0 {
                    valueListDecoded0?.append(enum0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on the visibility of the product in the AWS Marketplace.
    public struct ContainerProductVisibilityFilter {
        /// A string array of unique visibility values to be filtered on.
        public var valueList: [MarketplaceCatalogClientTypes.ContainerProductVisibilityString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.ContainerProductVisibilityString]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum ContainerProductVisibilityString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draft
        case limited
        case `public`
        case restricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerProductVisibilityString] {
            return [
                .draft,
                .limited,
                .public,
                .restricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .limited: return "Limited"
            case .public: return "Public"
            case .restricted: return "Restricted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerProductVisibilityString(rawValue: rawValue) ?? ContainerProductVisibilityString.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.DataProductEntityIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for dataproductentityidstring0 in valueList {
                try valueListContainer.encode(dataproductentityidstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on entity id of a data product.
    public struct DataProductEntityIdFilter {
        /// A string array of unique entity id values to be filtered on.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.DataProductFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case lastModifiedDate = "LastModifiedDate"
        case productTitle = "ProductTitle"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let productTitle = self.productTitle {
            try encodeContainer.encode(productTitle, forKey: .productTitle)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductEntityIdFilter.self, forKey: .entityId)
        entityId = entityIdDecoded
        let productTitleDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductTitleFilter.self, forKey: .productTitle)
        productTitle = productTitleDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductVisibilityFilter.self, forKey: .visibility)
        visibility = visibilityDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilter.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object containing all the filter fields for data products. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct DataProductFilters {
        /// Unique identifier for the data product.
        public var entityId: MarketplaceCatalogClientTypes.DataProductEntityIdFilter?
        /// The last date on which the data product was modified.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilter?
        /// The title of the data product.
        public var productTitle: MarketplaceCatalogClientTypes.DataProductTitleFilter?
        /// The visibility of the data product.
        public var visibility: MarketplaceCatalogClientTypes.DataProductVisibilityFilter?

        public init(
            entityId: MarketplaceCatalogClientTypes.DataProductEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilter? = nil,
            productTitle: MarketplaceCatalogClientTypes.DataProductTitleFilter? = nil,
            visibility: MarketplaceCatalogClientTypes.DataProductVisibilityFilter? = nil
        )
        {
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering based on the last modified date of data products.
    public struct DataProductLastModifiedDateFilter {
        /// Dates between which the data product was last modified.
        public var dateRange: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }

}

extension MarketplaceCatalogClientTypes.DataProductLastModifiedDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that contains date range of the last modified date to be filtered on. You can optionally provide a BeforeValue and/or AfterValue. Both are inclusive.
    public struct DataProductLastModifiedDateFilterDateRange {
        /// Date after which the data product was last modified.
        public var afterValue: Swift.String?
        /// Date before which the data product was last modified.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.DataProductSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Objects that allows sorting on data products based on certain fields and sorting order.
    public struct DataProductSort {
        /// Field to sort the data products by.
        public var sortBy: MarketplaceCatalogClientTypes.DataProductSortBy?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.DataProductSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum DataProductSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entityid
        case lastmodifieddate
        case producttitle
        case visibility
        case sdkUnknown(Swift.String)

        public static var allCases: [DataProductSortBy] {
            return [
                .entityid,
                .lastmodifieddate,
                .producttitle,
                .visibility,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .producttitle: return "ProductTitle"
            case .visibility: return "Visibility"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataProductSortBy(rawValue: rawValue) ?? DataProductSortBy.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.DataProductSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productTitle = "ProductTitle"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productTitle = self.productTitle {
            try encodeContainer.encode(productTitle, forKey: .productTitle)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productTitle)
        productTitle = productTitleDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductVisibilityString.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that contains summarized information about a data product.
    public struct DataProductSummary {
        /// The title of the data product.
        public var productTitle: Swift.String?
        /// The lifecycle of the data product.
        public var visibility: MarketplaceCatalogClientTypes.DataProductVisibilityString?

        public init(
            productTitle: Swift.String? = nil,
            visibility: MarketplaceCatalogClientTypes.DataProductVisibilityString? = nil
        )
        {
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.DataProductTitleFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for dataproducttitlestring0 in valueList {
                try valueListContainer.encode(dataproducttitlestring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on product title.
    public struct DataProductTitleFilter {
        /// A string array of unique product title values to be filtered on.
        public var valueList: [Swift.String]?
        /// A string that will be the wildCard input for product tile filter. It matches the provided value as a substring in the actual value.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.DataProductVisibilityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for dataproductvisibilitystring0 in valueList {
                try valueListContainer.encode(dataproductvisibilitystring0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.DataProductVisibilityString?].self, forKey: .valueList)
        var valueListDecoded0:[MarketplaceCatalogClientTypes.DataProductVisibilityString]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [MarketplaceCatalogClientTypes.DataProductVisibilityString]()
            for enum0 in valueListContainer {
                if let enum0 = enum0 {
                    valueListDecoded0?.append(enum0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on the visibility of the product in the AWS Marketplace.
    public struct DataProductVisibilityFilter {
        /// A string array of unique visibility values to be filtered on.
        public var valueList: [MarketplaceCatalogClientTypes.DataProductVisibilityString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.DataProductVisibilityString]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum DataProductVisibilityString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draft
        case limited
        case `public`
        case restricted
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DataProductVisibilityString] {
            return [
                .draft,
                .limited,
                .public,
                .restricted,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .limited: return "Limited"
            case .public: return "Public"
            case .restricted: return "Restricted"
            case .unavailable: return "Unavailable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataProductVisibilityString(rawValue: rawValue) ?? DataProductVisibilityString.sdkUnknown(rawValue)
        }
    }
}

extension DeleteResourcePolicyInput {

    static func queryItemProvider(_ value: DeleteResourcePolicyInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = ClientRuntime.SDKURLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/DeleteResourcePolicy"
    }
}

public struct DeleteResourcePolicyInput {
    /// The Amazon Resource Name (ARN) of the entity resource that is associated with the resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourcePolicyOutput {

    public init() { }
}

enum DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeChangeSetInput {

    static func queryItemProvider(_ value: DescribeChangeSetInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let changeSetId = value.changeSetId else {
            let message = "Creating a URL Query Item failed. changeSetId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let changeSetIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "changeSetId".urlPercentEncoding(), value: Swift.String(changeSetId).urlPercentEncoding())
        items.append(changeSetIdQueryItem)
        guard let catalog = value.catalog else {
            let message = "Creating a URL Query Item failed. catalog is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let catalogQueryItem = ClientRuntime.SDKURLQueryItem(name: "catalog".urlPercentEncoding(), value: Swift.String(catalog).urlPercentEncoding())
        items.append(catalogQueryItem)
        return items
    }
}

extension DescribeChangeSetInput {

    static func urlPathProvider(_ value: DescribeChangeSetInput) -> Swift.String? {
        return "/DescribeChangeSet"
    }
}

public struct DescribeChangeSetInput {
    /// Required. The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// Required. The unique identifier for the StartChangeSet request that you want to describe the details for.
    /// This member is required.
    public var changeSetId: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.changeSetId = changeSetId
    }
}

struct DescribeChangeSetInputBody {
}

extension DescribeChangeSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeChangeSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeChangeSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.changeSet = output.changeSet
            self.changeSetArn = output.changeSetArn
            self.changeSetId = output.changeSetId
            self.changeSetName = output.changeSetName
            self.endTime = output.endTime
            self.failureCode = output.failureCode
            self.failureDescription = output.failureDescription
            self.intent = output.intent
            self.startTime = output.startTime
            self.status = output.status
        } else {
            self.changeSet = nil
            self.changeSetArn = nil
            self.changeSetId = nil
            self.changeSetName = nil
            self.endTime = nil
            self.failureCode = nil
            self.failureDescription = nil
            self.intent = nil
            self.startTime = nil
            self.status = nil
        }
    }
}

public struct DescribeChangeSetOutput {
    /// An array of ChangeSummary objects.
    public var changeSet: [MarketplaceCatalogClientTypes.ChangeSummary]?
    /// The ARN associated with the unique identifier for the change set referenced in this request.
    public var changeSetArn: Swift.String?
    /// Required. The unique identifier for the change set referenced in this request.
    public var changeSetId: Swift.String?
    /// The optional name provided in the StartChangeSet request. If you do not provide a name, one is set by default.
    public var changeSetName: Swift.String?
    /// The date and time, in ISO 8601 format (2018-02-27T13:45:22Z), the request transitioned to a terminal state. The change cannot transition to a different state. Null if the request is not in a terminal state.
    public var endTime: Swift.String?
    /// Returned if the change set is in FAILED status. Can be either CLIENT_ERROR, which means that there are issues with the request (see the ErrorDetailList), or SERVER_FAULT, which means that there is a problem in the system, and you should retry your request.
    public var failureCode: MarketplaceCatalogClientTypes.FailureCode?
    /// Returned if there is a failure on the change set, but that failure is not related to any of the changes in the request.
    public var failureDescription: Swift.String?
    /// The optional intent provided in the StartChangeSet request. If you do not provide an intent, APPLY is set by default.
    public var intent: MarketplaceCatalogClientTypes.Intent?
    /// The date and time, in ISO 8601 format (2018-02-27T13:45:22Z), the request started.
    public var startTime: Swift.String?
    /// The status of the change request.
    public var status: MarketplaceCatalogClientTypes.ChangeStatus?

    public init(
        changeSet: [MarketplaceCatalogClientTypes.ChangeSummary]? = nil,
        changeSetArn: Swift.String? = nil,
        changeSetId: Swift.String? = nil,
        changeSetName: Swift.String? = nil,
        endTime: Swift.String? = nil,
        failureCode: MarketplaceCatalogClientTypes.FailureCode? = nil,
        failureDescription: Swift.String? = nil,
        intent: MarketplaceCatalogClientTypes.Intent? = nil,
        startTime: Swift.String? = nil,
        status: MarketplaceCatalogClientTypes.ChangeStatus? = nil
    )
    {
        self.changeSet = changeSet
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
        self.changeSetName = changeSetName
        self.endTime = endTime
        self.failureCode = failureCode
        self.failureDescription = failureDescription
        self.intent = intent
        self.startTime = startTime
        self.status = status
    }
}

struct DescribeChangeSetOutputBody {
    let changeSetId: Swift.String?
    let changeSetArn: Swift.String?
    let changeSetName: Swift.String?
    let intent: MarketplaceCatalogClientTypes.Intent?
    let startTime: Swift.String?
    let endTime: Swift.String?
    let status: MarketplaceCatalogClientTypes.ChangeStatus?
    let failureCode: MarketplaceCatalogClientTypes.FailureCode?
    let failureDescription: Swift.String?
    let changeSet: [MarketplaceCatalogClientTypes.ChangeSummary]?
}

extension DescribeChangeSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSet = "ChangeSet"
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
        case changeSetName = "ChangeSetName"
        case endTime = "EndTime"
        case failureCode = "FailureCode"
        case failureDescription = "FailureDescription"
        case intent = "Intent"
        case startTime = "StartTime"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
        let changeSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let intentDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Intent.self, forKey: .intent)
        intent = intentDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ChangeStatus.self, forKey: .status)
        status = statusDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.FailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureDescription)
        failureDescription = failureDescriptionDecoded
        let changeSetContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.ChangeSummary?].self, forKey: .changeSet)
        var changeSetDecoded0:[MarketplaceCatalogClientTypes.ChangeSummary]? = nil
        if let changeSetContainer = changeSetContainer {
            changeSetDecoded0 = [MarketplaceCatalogClientTypes.ChangeSummary]()
            for structure0 in changeSetContainer {
                if let structure0 = structure0 {
                    changeSetDecoded0?.append(structure0)
                }
            }
        }
        changeSet = changeSetDecoded0
    }
}

enum DescribeChangeSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEntityInput {

    static func queryItemProvider(_ value: DescribeEntityInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let entityId = value.entityId else {
            let message = "Creating a URL Query Item failed. entityId is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let entityIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "entityId".urlPercentEncoding(), value: Swift.String(entityId).urlPercentEncoding())
        items.append(entityIdQueryItem)
        guard let catalog = value.catalog else {
            let message = "Creating a URL Query Item failed. catalog is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let catalogQueryItem = ClientRuntime.SDKURLQueryItem(name: "catalog".urlPercentEncoding(), value: Swift.String(catalog).urlPercentEncoding())
        items.append(catalogQueryItem)
        return items
    }
}

extension DescribeEntityInput {

    static func urlPathProvider(_ value: DescribeEntityInput) -> Swift.String? {
        return "/DescribeEntity"
    }
}

public struct DescribeEntityInput {
    /// Required. The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// Required. The unique ID of the entity to describe.
    /// This member is required.
    public var entityId: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        entityId: Swift.String? = nil
    )
    {
        self.catalog = catalog
        self.entityId = entityId
    }
}

struct DescribeEntityInputBody {
}

extension DescribeEntityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEntityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEntityOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.detailsDocument = output.detailsDocument
            self.entityArn = output.entityArn
            self.entityIdentifier = output.entityIdentifier
            self.entityType = output.entityType
            self.lastModifiedDate = output.lastModifiedDate
        } else {
            self.details = nil
            self.detailsDocument = nil
            self.entityArn = nil
            self.entityIdentifier = nil
            self.entityType = nil
            self.lastModifiedDate = nil
        }
    }
}

public struct DescribeEntityOutput {
    /// This stringified JSON object includes the details of the entity.
    public var details: Swift.String?
    /// The JSON value of the details specific to the entity.
    public var detailsDocument: ClientRuntime.Document?
    /// The ARN associated to the unique identifier for the entity referenced in this request.
    public var entityArn: Swift.String?
    /// The identifier of the entity, in the format of EntityId@RevisionId.
    public var entityIdentifier: Swift.String?
    /// The named type of the entity, in the format of EntityType@Version.
    public var entityType: Swift.String?
    /// The last modified date of the entity, in ISO 8601 format (2018-02-27T13:45:22Z).
    public var lastModifiedDate: Swift.String?

    public init(
        details: Swift.String? = nil,
        detailsDocument: ClientRuntime.Document? = nil,
        entityArn: Swift.String? = nil,
        entityIdentifier: Swift.String? = nil,
        entityType: Swift.String? = nil,
        lastModifiedDate: Swift.String? = nil
    )
    {
        self.details = details
        self.detailsDocument = detailsDocument
        self.entityArn = entityArn
        self.entityIdentifier = entityIdentifier
        self.entityType = entityType
        self.lastModifiedDate = lastModifiedDate
    }
}

struct DescribeEntityOutputBody {
    let entityType: Swift.String?
    let entityIdentifier: Swift.String?
    let entityArn: Swift.String?
    let lastModifiedDate: Swift.String?
    let details: Swift.String?
    let detailsDocument: ClientRuntime.Document?
}

extension DescribeEntityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case detailsDocument = "DetailsDocument"
        case entityArn = "EntityArn"
        case entityIdentifier = "EntityIdentifier"
        case entityType = "EntityType"
        case lastModifiedDate = "LastModifiedDate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityIdentifier)
        entityIdentifier = entityIdentifierDecoded
        let entityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .details)
        details = detailsDecoded
        let detailsDocumentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .detailsDocument)
        detailsDocument = detailsDocumentDecoded
    }
}

enum DescribeEntityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotSupportedException": return try await ResourceNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceCatalogClientTypes.Entity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifier = "Identifier"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// An entity contains data that describes your product, its supported features, and how it can be used or launched by your customer.
    public struct Entity {
        /// The identifier for the entity.
        public var identifier: Swift.String?
        /// The type of entity.
        /// This member is required.
        public var type: Swift.String?

        public init(
            identifier: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.identifier = identifier
            self.type = type
        }
    }

}

extension MarketplaceCatalogClientTypes.EntityDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailsDocument = "DetailsDocument"
        case entityArn = "EntityArn"
        case entityIdentifier = "EntityIdentifier"
        case entityType = "EntityType"
        case lastModifiedDate = "LastModifiedDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailsDocument = self.detailsDocument {
            try encodeContainer.encode(detailsDocument, forKey: .detailsDocument)
        }
        if let entityArn = self.entityArn {
            try encodeContainer.encode(entityArn, forKey: .entityArn)
        }
        if let entityIdentifier = self.entityIdentifier {
            try encodeContainer.encode(entityIdentifier, forKey: .entityIdentifier)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let entityIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityIdentifier)
        entityIdentifier = entityIdentifierDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let detailsDocumentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .detailsDocument)
        detailsDocument = detailsDocumentDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// An object that contains metadata and details about the entity.
    public struct EntityDetail {
        /// An object that contains all the details of the entity.
        public var detailsDocument: ClientRuntime.Document?
        /// The Amazon Resource Name (ARN) of the entity.
        public var entityArn: Swift.String?
        /// The ID of the entity, in the format of EntityId@RevisionId.
        public var entityIdentifier: Swift.String?
        /// The entity type of the entity, in the format of EntityType@Version.
        public var entityType: Swift.String?
        /// The last time the entity was modified.
        public var lastModifiedDate: Swift.String?

        public init(
            detailsDocument: ClientRuntime.Document? = nil,
            entityArn: Swift.String? = nil,
            entityIdentifier: Swift.String? = nil,
            entityType: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil
        )
        {
            self.detailsDocument = detailsDocument
            self.entityArn = entityArn
            self.entityIdentifier = entityIdentifier
            self.entityType = entityType
            self.lastModifiedDate = lastModifiedDate
        }
    }

}

extension MarketplaceCatalogClientTypes.EntityRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case entityId = "EntityId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// An object that contains entity ID and the catalog in which the entity is present.
    public struct EntityRequest {
        /// The name of the catalog the entity is present in. The only value at this time is AWSMarketplace.
        /// This member is required.
        public var catalog: Swift.String?
        /// The ID of the entity.
        /// This member is required.
        public var entityId: Swift.String?

        public init(
            catalog: Swift.String? = nil,
            entityId: Swift.String? = nil
        )
        {
            self.catalog = catalog
            self.entityId = entityId
        }
    }

}

extension MarketplaceCatalogClientTypes.EntitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiProductSummary = "AmiProductSummary"
        case containerProductSummary = "ContainerProductSummary"
        case dataProductSummary = "DataProductSummary"
        case entityArn = "EntityArn"
        case entityId = "EntityId"
        case entityType = "EntityType"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case offerSummary = "OfferSummary"
        case resaleAuthorizationSummary = "ResaleAuthorizationSummary"
        case saaSProductSummary = "SaaSProductSummary"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiProductSummary = self.amiProductSummary {
            try encodeContainer.encode(amiProductSummary, forKey: .amiProductSummary)
        }
        if let containerProductSummary = self.containerProductSummary {
            try encodeContainer.encode(containerProductSummary, forKey: .containerProductSummary)
        }
        if let dataProductSummary = self.dataProductSummary {
            try encodeContainer.encode(dataProductSummary, forKey: .dataProductSummary)
        }
        if let entityArn = self.entityArn {
            try encodeContainer.encode(entityArn, forKey: .entityArn)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let offerSummary = self.offerSummary {
            try encodeContainer.encode(offerSummary, forKey: .offerSummary)
        }
        if let resaleAuthorizationSummary = self.resaleAuthorizationSummary {
            try encodeContainer.encode(resaleAuthorizationSummary, forKey: .resaleAuthorizationSummary)
        }
        if let saaSProductSummary = self.saaSProductSummary {
            try encodeContainer.encode(saaSProductSummary, forKey: .saaSProductSummary)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .visibility)
        visibility = visibilityDecoded
        let amiProductSummaryDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductSummary.self, forKey: .amiProductSummary)
        amiProductSummary = amiProductSummaryDecoded
        let containerProductSummaryDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductSummary.self, forKey: .containerProductSummary)
        containerProductSummary = containerProductSummaryDecoded
        let dataProductSummaryDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductSummary.self, forKey: .dataProductSummary)
        dataProductSummary = dataProductSummaryDecoded
        let saaSProductSummaryDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductSummary.self, forKey: .saaSProductSummary)
        saaSProductSummary = saaSProductSummaryDecoded
        let offerSummaryDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferSummary.self, forKey: .offerSummary)
        offerSummary = offerSummaryDecoded
        let resaleAuthorizationSummaryDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationSummary.self, forKey: .resaleAuthorizationSummary)
        resaleAuthorizationSummary = resaleAuthorizationSummaryDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// This object is a container for common summary information about the entity. The summary doesn't contain the whole entity structure, but it does contain information common across all entities.
    public struct EntitySummary {
        /// An object that contains summary information about the AMI product.
        public var amiProductSummary: MarketplaceCatalogClientTypes.AmiProductSummary?
        /// An object that contains summary information about the container product.
        public var containerProductSummary: MarketplaceCatalogClientTypes.ContainerProductSummary?
        /// An object that contains summary information about the data product.
        public var dataProductSummary: MarketplaceCatalogClientTypes.DataProductSummary?
        /// The ARN associated with the unique identifier for the entity.
        public var entityArn: Swift.String?
        /// The unique identifier for the entity.
        public var entityId: Swift.String?
        /// The type of the entity.
        public var entityType: Swift.String?
        /// The last time the entity was published, using ISO 8601 format (2018-02-27T13:45:22Z).
        public var lastModifiedDate: Swift.String?
        /// The name for the entity. This value is not unique. It is defined by the seller.
        public var name: Swift.String?
        /// An object that contains summary information about the offer.
        public var offerSummary: MarketplaceCatalogClientTypes.OfferSummary?
        /// An object that contains summary information about the Resale Authorization.
        public var resaleAuthorizationSummary: MarketplaceCatalogClientTypes.ResaleAuthorizationSummary?
        /// An object that contains summary information about the SaaS product.
        public var saaSProductSummary: MarketplaceCatalogClientTypes.SaaSProductSummary?
        /// The visibility status of the entity to buyers. This value can be Public (everyone can view the entity), Limited (the entity is visible to limited accounts only), or Restricted (the entity was published and then unpublished and only existing buyers can view it).
        public var visibility: Swift.String?

        public init(
            amiProductSummary: MarketplaceCatalogClientTypes.AmiProductSummary? = nil,
            containerProductSummary: MarketplaceCatalogClientTypes.ContainerProductSummary? = nil,
            dataProductSummary: MarketplaceCatalogClientTypes.DataProductSummary? = nil,
            entityArn: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityType: Swift.String? = nil,
            lastModifiedDate: Swift.String? = nil,
            name: Swift.String? = nil,
            offerSummary: MarketplaceCatalogClientTypes.OfferSummary? = nil,
            resaleAuthorizationSummary: MarketplaceCatalogClientTypes.ResaleAuthorizationSummary? = nil,
            saaSProductSummary: MarketplaceCatalogClientTypes.SaaSProductSummary? = nil,
            visibility: Swift.String? = nil
        )
        {
            self.amiProductSummary = amiProductSummary
            self.containerProductSummary = containerProductSummary
            self.dataProductSummary = dataProductSummary
            self.entityArn = entityArn
            self.entityId = entityId
            self.entityType = entityType
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.offerSummary = offerSummary
            self.resaleAuthorizationSummary = resaleAuthorizationSummary
            self.saaSProductSummary = saaSProductSummary
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.EntityTypeFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiproductfilters = "AmiProductFilters"
        case containerproductfilters = "ContainerProductFilters"
        case dataproductfilters = "DataProductFilters"
        case offerfilters = "OfferFilters"
        case resaleauthorizationfilters = "ResaleAuthorizationFilters"
        case saasproductfilters = "SaaSProductFilters"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .amiproductfilters(amiproductfilters):
                try container.encode(amiproductfilters, forKey: .amiproductfilters)
            case let .containerproductfilters(containerproductfilters):
                try container.encode(containerproductfilters, forKey: .containerproductfilters)
            case let .dataproductfilters(dataproductfilters):
                try container.encode(dataproductfilters, forKey: .dataproductfilters)
            case let .offerfilters(offerfilters):
                try container.encode(offerfilters, forKey: .offerfilters)
            case let .resaleauthorizationfilters(resaleauthorizationfilters):
                try container.encode(resaleauthorizationfilters, forKey: .resaleauthorizationfilters)
            case let .saasproductfilters(saasproductfilters):
                try container.encode(saasproductfilters, forKey: .saasproductfilters)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let dataproductfiltersDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductFilters.self, forKey: .dataproductfilters)
        if let dataproductfilters = dataproductfiltersDecoded {
            self = .dataproductfilters(dataproductfilters)
            return
        }
        let saasproductfiltersDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductFilters.self, forKey: .saasproductfilters)
        if let saasproductfilters = saasproductfiltersDecoded {
            self = .saasproductfilters(saasproductfilters)
            return
        }
        let amiproductfiltersDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductFilters.self, forKey: .amiproductfilters)
        if let amiproductfilters = amiproductfiltersDecoded {
            self = .amiproductfilters(amiproductfilters)
            return
        }
        let offerfiltersDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.OfferFilters.self, forKey: .offerfilters)
        if let offerfilters = offerfiltersDecoded {
            self = .offerfilters(offerfilters)
            return
        }
        let containerproductfiltersDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductFilters.self, forKey: .containerproductfilters)
        if let containerproductfilters = containerproductfiltersDecoded {
            self = .containerproductfilters(containerproductfilters)
            return
        }
        let resaleauthorizationfiltersDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationFilters.self, forKey: .resaleauthorizationfilters)
        if let resaleauthorizationfilters = resaleauthorizationfiltersDecoded {
            self = .resaleauthorizationfilters(resaleauthorizationfilters)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object containing all the filter fields per entity type.
    public enum EntityTypeFilters {
        /// A filter for data products.
        case dataproductfilters(MarketplaceCatalogClientTypes.DataProductFilters)
        /// A filter for SaaS products.
        case saasproductfilters(MarketplaceCatalogClientTypes.SaaSProductFilters)
        /// A filter for AMI products.
        case amiproductfilters(MarketplaceCatalogClientTypes.AmiProductFilters)
        /// A filter for offers.
        case offerfilters(MarketplaceCatalogClientTypes.OfferFilters)
        /// A filter for container products.
        case containerproductfilters(MarketplaceCatalogClientTypes.ContainerProductFilters)
        /// A filter for Resale Authorizations.
        case resaleauthorizationfilters(MarketplaceCatalogClientTypes.ResaleAuthorizationFilters)
        case sdkUnknown(Swift.String)
    }

}

extension MarketplaceCatalogClientTypes.EntityTypeSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiproductsort = "AmiProductSort"
        case containerproductsort = "ContainerProductSort"
        case dataproductsort = "DataProductSort"
        case offersort = "OfferSort"
        case resaleauthorizationsort = "ResaleAuthorizationSort"
        case saasproductsort = "SaaSProductSort"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .amiproductsort(amiproductsort):
                try container.encode(amiproductsort, forKey: .amiproductsort)
            case let .containerproductsort(containerproductsort):
                try container.encode(containerproductsort, forKey: .containerproductsort)
            case let .dataproductsort(dataproductsort):
                try container.encode(dataproductsort, forKey: .dataproductsort)
            case let .offersort(offersort):
                try container.encode(offersort, forKey: .offersort)
            case let .resaleauthorizationsort(resaleauthorizationsort):
                try container.encode(resaleauthorizationsort, forKey: .resaleauthorizationsort)
            case let .saasproductsort(saasproductsort):
                try container.encode(saasproductsort, forKey: .saasproductsort)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let dataproductsortDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.DataProductSort.self, forKey: .dataproductsort)
        if let dataproductsort = dataproductsortDecoded {
            self = .dataproductsort(dataproductsort)
            return
        }
        let saasproductsortDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductSort.self, forKey: .saasproductsort)
        if let saasproductsort = saasproductsortDecoded {
            self = .saasproductsort(saasproductsort)
            return
        }
        let amiproductsortDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.AmiProductSort.self, forKey: .amiproductsort)
        if let amiproductsort = amiproductsortDecoded {
            self = .amiproductsort(amiproductsort)
            return
        }
        let offersortDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.OfferSort.self, forKey: .offersort)
        if let offersort = offersortDecoded {
            self = .offersort(offersort)
            return
        }
        let containerproductsortDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.ContainerProductSort.self, forKey: .containerproductsort)
        if let containerproductsort = containerproductsortDecoded {
            self = .containerproductsort(containerproductsort)
            return
        }
        let resaleauthorizationsortDecoded = try values.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationSort.self, forKey: .resaleauthorizationsort)
        if let resaleauthorizationsort = resaleauthorizationsortDecoded {
            self = .resaleauthorizationsort(resaleauthorizationsort)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object containing all the sort fields per entity type.
    public enum EntityTypeSort {
        /// A sort for data products.
        case dataproductsort(MarketplaceCatalogClientTypes.DataProductSort)
        /// A sort for SaaS products.
        case saasproductsort(MarketplaceCatalogClientTypes.SaaSProductSort)
        /// A sort for AMI products.
        case amiproductsort(MarketplaceCatalogClientTypes.AmiProductSort)
        /// A sort for offers.
        case offersort(MarketplaceCatalogClientTypes.OfferSort)
        /// A sort for container products.
        case containerproductsort(MarketplaceCatalogClientTypes.ContainerProductSort)
        /// A sort for Resale Authorizations.
        case resaleauthorizationsort(MarketplaceCatalogClientTypes.ResaleAuthorizationSort)
        case sdkUnknown(Swift.String)
    }

}

extension MarketplaceCatalogClientTypes.ErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Details about the error.
    public struct ErrorDetail {
        /// The error code that identifies the type of error.
        public var errorCode: Swift.String?
        /// The message for the error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum FailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clienterror
        case serverfault
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureCode] {
            return [
                .clienterror,
                .serverfault,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clienterror: return "CLIENT_ERROR"
            case .serverfault: return "SERVER_FAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureCode(rawValue: rawValue) ?? FailureCode.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for filtervaluecontent0 in valueList {
                try valueListContainer.encode(filtervaluecontent0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// A filter object, used to optionally filter results from calls to the ListEntities and ListChangeSets actions.
    public struct Filter {
        /// For ListEntities, the supported value for this is an EntityId. For ListChangeSets, the supported values are as follows:
        public var name: Swift.String?
        /// ListEntities - This is a list of unique EntityIds. ListChangeSets - The supported filter names and associated ValueLists is as follows:
        ///
        /// * ChangeSetName - The supported ValueList is a list of non-unique ChangeSetNames. These are defined when you call the StartChangeSet action.
        ///
        /// * Status - The supported ValueList is a list of statuses for all change set requests.
        ///
        /// * EntityId - The supported ValueList is a list of unique EntityIds.
        ///
        /// * BeforeStartTime - The supported ValueList is a list of all change sets that started before the filter value.
        ///
        /// * AfterStartTime - The supported ValueList is a list of all change sets that started after the filter value.
        ///
        /// * BeforeEndTime - The supported ValueList is a list of all change sets that ended before the filter value.
        ///
        /// * AfterEndTime - The supported ValueList is a list of all change sets that ended after the filter value.
        public var valueList: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            valueList: [Swift.String]? = nil
        )
        {
            self.name = name
            self.valueList = valueList
        }
    }

}

extension GetResourcePolicyInput {

    static func queryItemProvider(_ value: GetResourcePolicyInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = ClientRuntime.SDKURLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/GetResourcePolicy"
    }
}

public struct GetResourcePolicyInput {
    /// The Amazon Resource Name (ARN) of the entity resource that is associated with the resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody {
}

extension GetResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetResourcePolicyOutput {
    /// The policy document to set; formatted in JSON.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetResourcePolicyOutputBody {
    let policy: Swift.String?
}

extension GetResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceCatalogClientTypes {
    public enum Intent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apply
        case validate
        case sdkUnknown(Swift.String)

        public static var allCases: [Intent] {
            return [
                .apply,
                .validate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apply: return "APPLY"
            case .validate: return "VALIDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Intent(rawValue: rawValue) ?? Intent.sdkUnknown(rawValue)
        }
    }
}

extension InternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an internal service exception. HTTP status code: 500
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServiceExceptionBody {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChangeSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let filterList = filterList {
            var filterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterList)
            for filter0 in filterList {
                try filterListContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

extension ListChangeSetsInput {

    static func urlPathProvider(_ value: ListChangeSetsInput) -> Swift.String? {
        return "/ListChangeSets"
    }
}

public struct ListChangeSetsInput {
    /// The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// An array of filter objects.
    public var filterList: [MarketplaceCatalogClientTypes.Filter]?
    /// The maximum number of results returned by a single call. This value must be provided in the next call to retrieve the next set of results. By default, this value is 20.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// An object that contains two attributes, SortBy and SortOrder.
    public var sort: MarketplaceCatalogClientTypes.Sort?

    public init(
        catalog: Swift.String? = nil,
        filterList: [MarketplaceCatalogClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: MarketplaceCatalogClientTypes.Sort? = nil
    )
    {
        self.catalog = catalog
        self.filterList = filterList
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListChangeSetsInputBody {
    let catalog: Swift.String?
    let filterList: [MarketplaceCatalogClientTypes.Filter]?
    let sort: MarketplaceCatalogClientTypes.Sort?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListChangeSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sort = "Sort"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let filterListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Filter?].self, forKey: .filterList)
        var filterListDecoded0:[MarketplaceCatalogClientTypes.Filter]? = nil
        if let filterListContainer = filterListContainer {
            filterListDecoded0 = [MarketplaceCatalogClientTypes.Filter]()
            for structure0 in filterListContainer {
                if let structure0 = structure0 {
                    filterListDecoded0?.append(structure0)
                }
            }
        }
        filterList = filterListDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Sort.self, forKey: .sort)
        sort = sortDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListChangeSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChangeSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.changeSetSummaryList = output.changeSetSummaryList
            self.nextToken = output.nextToken
        } else {
            self.changeSetSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListChangeSetsOutput {
    /// Array of ChangeSetSummaryListItem objects.
    public var changeSetSummaryList: [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]?
    /// The value of the next token, if it exists. Null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        changeSetSummaryList: [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.changeSetSummaryList = changeSetSummaryList
        self.nextToken = nextToken
    }
}

struct ListChangeSetsOutputBody {
    let changeSetSummaryList: [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]?
    let nextToken: Swift.String?
}

extension ListChangeSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSetSummaryList = "ChangeSetSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetSummaryListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.ChangeSetSummaryListItem?].self, forKey: .changeSetSummaryList)
        var changeSetSummaryListDecoded0:[MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]? = nil
        if let changeSetSummaryListContainer = changeSetSummaryListContainer {
            changeSetSummaryListDecoded0 = [MarketplaceCatalogClientTypes.ChangeSetSummaryListItem]()
            for structure0 in changeSetSummaryListContainer {
                if let structure0 = structure0 {
                    changeSetSummaryListDecoded0?.append(structure0)
                }
            }
        }
        changeSetSummaryList = changeSetSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChangeSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case entityType = "EntityType"
        case entityTypeFilters = "EntityTypeFilters"
        case entityTypeSort = "EntityTypeSort"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case ownershipType = "OwnershipType"
        case sort = "Sort"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
        if let entityTypeFilters = self.entityTypeFilters {
            try encodeContainer.encode(entityTypeFilters, forKey: .entityTypeFilters)
        }
        if let entityTypeSort = self.entityTypeSort {
            try encodeContainer.encode(entityTypeSort, forKey: .entityTypeSort)
        }
        if let filterList = filterList {
            var filterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterList)
            for filter0 in filterList {
                try filterListContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let ownershipType = self.ownershipType {
            try encodeContainer.encode(ownershipType.rawValue, forKey: .ownershipType)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

extension ListEntitiesInput {

    static func urlPathProvider(_ value: ListEntitiesInput) -> Swift.String? {
        return "/ListEntities"
    }
}

public struct ListEntitiesInput {
    /// The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// The type of entities to retrieve. Valid values are: AmiProduct, ContainerProduct, DataProduct, SaaSProduct, ProcurementPolicy, Experience, Audience, BrandingSettings, Offer, Seller, ResaleAuthorization.
    /// This member is required.
    public var entityType: Swift.String?
    /// A Union object containing filter shapes for all EntityTypes. Each EntityTypeFilter shape will have filters applicable for that EntityType that can be used to search or filter entities.
    public var entityTypeFilters: MarketplaceCatalogClientTypes.EntityTypeFilters?
    /// A Union object containing Sort shapes for all EntityTypes. Each EntityTypeSort shape will have SortBy and SortOrder applicable for fields on that EntityType. This can be used to sort the results of the filter query.
    public var entityTypeSort: MarketplaceCatalogClientTypes.EntityTypeSort?
    /// An array of filter objects. Each filter object contains two attributes, filterName and filterValues.
    public var filterList: [MarketplaceCatalogClientTypes.Filter]?
    /// Specifies the upper limit of the elements on a single page. If a value isn't provided, the default value is 20.
    public var maxResults: Swift.Int?
    /// The value of the next token, if it exists. Null if there are no more results.
    public var nextToken: Swift.String?
    /// Filters the returned set of entities based on their owner. The default is SELF. To list entities shared with you through AWS Resource Access Manager (AWS RAM), set to SHARED. Entities shared through the AWS Marketplace Catalog API PutResourcePolicy operation can't be discovered through the SHARED parameter.
    public var ownershipType: MarketplaceCatalogClientTypes.OwnershipType?
    /// An object that contains two attributes, SortBy and SortOrder.
    public var sort: MarketplaceCatalogClientTypes.Sort?

    public init(
        catalog: Swift.String? = nil,
        entityType: Swift.String? = nil,
        entityTypeFilters: MarketplaceCatalogClientTypes.EntityTypeFilters? = nil,
        entityTypeSort: MarketplaceCatalogClientTypes.EntityTypeSort? = nil,
        filterList: [MarketplaceCatalogClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownershipType: MarketplaceCatalogClientTypes.OwnershipType? = nil,
        sort: MarketplaceCatalogClientTypes.Sort? = nil
    )
    {
        self.catalog = catalog
        self.entityType = entityType
        self.entityTypeFilters = entityTypeFilters
        self.entityTypeSort = entityTypeSort
        self.filterList = filterList
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownershipType = ownershipType
        self.sort = sort
    }
}

struct ListEntitiesInputBody {
    let catalog: Swift.String?
    let entityType: Swift.String?
    let filterList: [MarketplaceCatalogClientTypes.Filter]?
    let sort: MarketplaceCatalogClientTypes.Sort?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let ownershipType: MarketplaceCatalogClientTypes.OwnershipType?
    let entityTypeFilters: MarketplaceCatalogClientTypes.EntityTypeFilters?
    let entityTypeSort: MarketplaceCatalogClientTypes.EntityTypeSort?
}

extension ListEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case entityType = "EntityType"
        case entityTypeFilters = "EntityTypeFilters"
        case entityTypeSort = "EntityTypeSort"
        case filterList = "FilterList"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case ownershipType = "OwnershipType"
        case sort = "Sort"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let filterListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Filter?].self, forKey: .filterList)
        var filterListDecoded0:[MarketplaceCatalogClientTypes.Filter]? = nil
        if let filterListContainer = filterListContainer {
            filterListDecoded0 = [MarketplaceCatalogClientTypes.Filter]()
            for structure0 in filterListContainer {
                if let structure0 = structure0 {
                    filterListDecoded0?.append(structure0)
                }
            }
        }
        filterList = filterListDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Sort.self, forKey: .sort)
        sort = sortDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let ownershipTypeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OwnershipType.self, forKey: .ownershipType)
        ownershipType = ownershipTypeDecoded
        let entityTypeFiltersDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.EntityTypeFilters.self, forKey: .entityTypeFilters)
        entityTypeFilters = entityTypeFiltersDecoded
        let entityTypeSortDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.EntityTypeSort.self, forKey: .entityTypeSort)
        entityTypeSort = entityTypeSortDecoded
    }
}

extension ListEntitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEntitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entitySummaryList = output.entitySummaryList
            self.nextToken = output.nextToken
        } else {
            self.entitySummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesOutput {
    /// Array of EntitySummary objects.
    public var entitySummaryList: [MarketplaceCatalogClientTypes.EntitySummary]?
    /// The value of the next token if it exists. Null if there is no more result.
    public var nextToken: Swift.String?

    public init(
        entitySummaryList: [MarketplaceCatalogClientTypes.EntitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitySummaryList = entitySummaryList
        self.nextToken = nextToken
    }
}

struct ListEntitiesOutputBody {
    let entitySummaryList: [MarketplaceCatalogClientTypes.EntitySummary]?
    let nextToken: Swift.String?
}

extension ListEntitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitySummaryList = "EntitySummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitySummaryListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.EntitySummary?].self, forKey: .entitySummaryList)
        var entitySummaryListDecoded0:[MarketplaceCatalogClientTypes.EntitySummary]? = nil
        if let entitySummaryListContainer = entitySummaryListContainer {
            entitySummaryListDecoded0 = [MarketplaceCatalogClientTypes.EntitySummary]()
            for structure0 in entitySummaryListContainer {
                if let structure0 = structure0 {
                    entitySummaryListDecoded0?.append(structure0)
                }
            }
        }
        entitySummaryList = entitySummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEntitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput {
    /// Required. The Amazon Resource Name (ARN) associated with the resource you want to list tags on.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceArn = output.resourceArn
            self.tags = output.tags
        } else {
            self.resourceArn = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput {
    /// Required. The ARN associated with the resource you want to list tags on.
    public var resourceArn: Swift.String?
    /// Required. A list of objects specifying each key name and value. Number of objects allowed: 1-50.
    public var tags: [MarketplaceCatalogClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [MarketplaceCatalogClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody {
    let resourceArn: Swift.String?
    let tags: [MarketplaceCatalogClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MarketplaceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MarketplaceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public enum MarketplaceCatalogClientTypes {}

extension MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the AvailabilityEndDate of an offer.
    public struct OfferAvailabilityEndDateFilter {
        /// Allows filtering on the AvailabilityEndDate of an offer with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the AvailabilityEndDate of an offer with date range as input.
    public struct OfferAvailabilityEndDateFilterDateRange {
        /// Allows filtering on the AvailabilityEndDate of an offer after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on the AvailabilityEndDate of an offer before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferBuyerAccountsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the BuyerAccounts of an offer.
    public struct OfferBuyerAccountsFilter {
        /// Allows filtering on the BuyerAccounts of an offer with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            wildCardValue: Swift.String? = nil
        )
        {
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferEntityIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for offerentityidstring0 in valueList {
                try valueListContainer.encode(offerentityidstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the entity id of an offer.
    public struct OfferEntityIdFilter {
        /// Allows filtering on entity id of an offer with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityEndDate = "AvailabilityEndDate"
        case buyerAccounts = "BuyerAccounts"
        case entityId = "EntityId"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case productId = "ProductId"
        case releaseDate = "ReleaseDate"
        case resaleAuthorizationId = "ResaleAuthorizationId"
        case state = "State"
        case targeting = "Targeting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityEndDate = self.availabilityEndDate {
            try encodeContainer.encode(availabilityEndDate, forKey: .availabilityEndDate)
        }
        if let buyerAccounts = self.buyerAccounts {
            try encodeContainer.encode(buyerAccounts, forKey: .buyerAccounts)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let releaseDate = self.releaseDate {
            try encodeContainer.encode(releaseDate, forKey: .releaseDate)
        }
        if let resaleAuthorizationId = self.resaleAuthorizationId {
            try encodeContainer.encode(resaleAuthorizationId, forKey: .resaleAuthorizationId)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let targeting = self.targeting {
            try encodeContainer.encode(targeting, forKey: .targeting)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferEntityIdFilter.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferNameFilter.self, forKey: .name)
        name = nameDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferProductIdFilter.self, forKey: .productId)
        productId = productIdDecoded
        let resaleAuthorizationIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferResaleAuthorizationIdFilter.self, forKey: .resaleAuthorizationId)
        resaleAuthorizationId = resaleAuthorizationIdDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferReleaseDateFilter.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let availabilityEndDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilter.self, forKey: .availabilityEndDate)
        availabilityEndDate = availabilityEndDateDecoded
        let buyerAccountsDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferBuyerAccountsFilter.self, forKey: .buyerAccounts)
        buyerAccounts = buyerAccountsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferStateFilter.self, forKey: .state)
        state = stateDecoded
        let targetingDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferTargetingFilter.self, forKey: .targeting)
        targeting = targetingDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferLastModifiedDateFilter.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object containing all the filter fields for offers entity. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct OfferFilters {
        /// Allows filtering on the AvailabilityEndDate of an offer.
        public var availabilityEndDate: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilter?
        /// Allows filtering on the BuyerAccounts of an offer.
        public var buyerAccounts: MarketplaceCatalogClientTypes.OfferBuyerAccountsFilter?
        /// Allows filtering on EntityId of an offer.
        public var entityId: MarketplaceCatalogClientTypes.OfferEntityIdFilter?
        /// Allows filtering on the LastModifiedDate of an offer.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilter?
        /// Allows filtering on the Name of an offer.
        public var name: MarketplaceCatalogClientTypes.OfferNameFilter?
        /// Allows filtering on the ProductId of an offer.
        public var productId: MarketplaceCatalogClientTypes.OfferProductIdFilter?
        /// Allows filtering on the ReleaseDate of an offer.
        public var releaseDate: MarketplaceCatalogClientTypes.OfferReleaseDateFilter?
        /// Allows filtering on the ResaleAuthorizationId of an offer. Not all offers have a ResaleAuthorizationId. The response will only include offers for which you have permissions.
        public var resaleAuthorizationId: MarketplaceCatalogClientTypes.OfferResaleAuthorizationIdFilter?
        /// Allows filtering on the State of an offer.
        public var state: MarketplaceCatalogClientTypes.OfferStateFilter?
        /// Allows filtering on the Targeting of an offer.
        public var targeting: MarketplaceCatalogClientTypes.OfferTargetingFilter?

        public init(
            availabilityEndDate: MarketplaceCatalogClientTypes.OfferAvailabilityEndDateFilter? = nil,
            buyerAccounts: MarketplaceCatalogClientTypes.OfferBuyerAccountsFilter? = nil,
            entityId: MarketplaceCatalogClientTypes.OfferEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilter? = nil,
            name: MarketplaceCatalogClientTypes.OfferNameFilter? = nil,
            productId: MarketplaceCatalogClientTypes.OfferProductIdFilter? = nil,
            releaseDate: MarketplaceCatalogClientTypes.OfferReleaseDateFilter? = nil,
            resaleAuthorizationId: MarketplaceCatalogClientTypes.OfferResaleAuthorizationIdFilter? = nil,
            state: MarketplaceCatalogClientTypes.OfferStateFilter? = nil,
            targeting: MarketplaceCatalogClientTypes.OfferTargetingFilter? = nil
        )
        {
            self.availabilityEndDate = availabilityEndDate
            self.buyerAccounts = buyerAccounts
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.productId = productId
            self.releaseDate = releaseDate
            self.resaleAuthorizationId = resaleAuthorizationId
            self.state = state
            self.targeting = targeting
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferLastModifiedDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferLastModifiedDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the LastModifiedDate of an offer.
    public struct OfferLastModifiedDateFilter {
        /// Allows filtering on the LastModifiedDate of an offer with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.OfferLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferLastModifiedDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the LastModifiedDate of an offer with date range as input.
    public struct OfferLastModifiedDateFilterDateRange {
        /// Allows filtering on the LastModifiedDate of an offer after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on the LastModifiedDate of an offer before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferNameFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for offernamestring0 in valueList {
                try valueListContainer.encode(offernamestring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the Name of an offer.
    public struct OfferNameFilter {
        /// Allows filtering on the Name of an offer with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the Name of an offer with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferProductIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for offerproductidstring0 in valueList {
                try valueListContainer.encode(offerproductidstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ProductId of an offer.
    public struct OfferProductIdFilter {
        /// Allows filtering on the ProductId of an offer with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferReleaseDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferReleaseDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ReleaseDate of an offer.
    public struct OfferReleaseDateFilter {
        /// Allows filtering on the ReleaseDate of an offer with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.OfferReleaseDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.OfferReleaseDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferReleaseDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ReleaseDate of an offer with date range as input.
    public struct OfferReleaseDateFilterDateRange {
        /// Allows filtering on the ReleaseDate of offers after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on the ReleaseDate of offers before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferResaleAuthorizationIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for offerresaleauthorizationidstring0 in valueList {
                try valueListContainer.encode(offerresaleauthorizationidstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ResaleAuthorizationId of an offer. Not all offers have a ResaleAuthorizationId. The response will only include offers for which you have permissions.
    public struct OfferResaleAuthorizationIdFilter {
        /// Allows filtering on the ResaleAuthorizationId of an offer with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows to sort offers.
    public struct OfferSort {
        /// Allows to sort offers.
        public var sortBy: MarketplaceCatalogClientTypes.OfferSortBy?
        /// Allows to sort offers.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.OfferSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum OfferSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case availabilityenddate
        case buyeraccounts
        case entityid
        case lastmodifieddate
        case name
        case productid
        case releasedate
        case resaleauthorizationid
        case state
        case targeting
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferSortBy] {
            return [
                .availabilityenddate,
                .buyeraccounts,
                .entityid,
                .lastmodifieddate,
                .name,
                .productid,
                .releasedate,
                .resaleauthorizationid,
                .state,
                .targeting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .availabilityenddate: return "AvailabilityEndDate"
            case .buyeraccounts: return "BuyerAccounts"
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .name: return "Name"
            case .productid: return "ProductId"
            case .releasedate: return "ReleaseDate"
            case .resaleauthorizationid: return "ResaleAuthorizationId"
            case .state: return "State"
            case .targeting: return "Targeting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferSortBy(rawValue: rawValue) ?? OfferSortBy.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.OfferStateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for offerstatestring0 in valueList {
                try valueListContainer.encode(offerstatestring0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.OfferStateString?].self, forKey: .valueList)
        var valueListDecoded0:[MarketplaceCatalogClientTypes.OfferStateString]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [MarketplaceCatalogClientTypes.OfferStateString]()
            for enum0 in valueListContainer {
                if let enum0 = enum0 {
                    valueListDecoded0?.append(enum0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the State of an offer.
    public struct OfferStateFilter {
        /// Allows filtering on the State of an offer with list input.
        public var valueList: [MarketplaceCatalogClientTypes.OfferStateString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.OfferStateString]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum OfferStateString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draft
        case released
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferStateString] {
            return [
                .draft,
                .released,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .released: return "Released"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferStateString(rawValue: rawValue) ?? OfferStateString.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.OfferSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityEndDate = "AvailabilityEndDate"
        case buyerAccounts = "BuyerAccounts"
        case name = "Name"
        case productId = "ProductId"
        case releaseDate = "ReleaseDate"
        case resaleAuthorizationId = "ResaleAuthorizationId"
        case state = "State"
        case targeting = "Targeting"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityEndDate = self.availabilityEndDate {
            try encodeContainer.encode(availabilityEndDate, forKey: .availabilityEndDate)
        }
        if let buyerAccounts = buyerAccounts {
            var buyerAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buyerAccounts)
            for offerbuyeraccountsstring0 in buyerAccounts {
                try buyerAccountsContainer.encode(offerbuyeraccountsstring0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let releaseDate = self.releaseDate {
            try encodeContainer.encode(releaseDate, forKey: .releaseDate)
        }
        if let resaleAuthorizationId = self.resaleAuthorizationId {
            try encodeContainer.encode(resaleAuthorizationId, forKey: .resaleAuthorizationId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let targeting = targeting {
            var targetingContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targeting)
            for offertargetingstring0 in targeting {
                try targetingContainer.encode(offertargetingstring0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let resaleAuthorizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resaleAuthorizationId)
        resaleAuthorizationId = resaleAuthorizationIdDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let availabilityEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityEndDate)
        availabilityEndDate = availabilityEndDateDecoded
        let buyerAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .buyerAccounts)
        var buyerAccountsDecoded0:[Swift.String]? = nil
        if let buyerAccountsContainer = buyerAccountsContainer {
            buyerAccountsDecoded0 = [Swift.String]()
            for string0 in buyerAccountsContainer {
                if let string0 = string0 {
                    buyerAccountsDecoded0?.append(string0)
                }
            }
        }
        buyerAccounts = buyerAccountsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.OfferStateString.self, forKey: .state)
        state = stateDecoded
        let targetingContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.OfferTargetingString?].self, forKey: .targeting)
        var targetingDecoded0:[MarketplaceCatalogClientTypes.OfferTargetingString]? = nil
        if let targetingContainer = targetingContainer {
            targetingDecoded0 = [MarketplaceCatalogClientTypes.OfferTargetingString]()
            for enum0 in targetingContainer {
                if let enum0 = enum0 {
                    targetingDecoded0?.append(enum0)
                }
            }
        }
        targeting = targetingDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Summarized information about an offer.
    public struct OfferSummary {
        /// The availability end date of the offer.
        public var availabilityEndDate: Swift.String?
        /// The buyer accounts in the offer.
        public var buyerAccounts: [Swift.String]?
        /// The name of the offer.
        public var name: Swift.String?
        /// The product ID of the offer.
        public var productId: Swift.String?
        /// The release date of the offer.
        public var releaseDate: Swift.String?
        /// The ResaleAuthorizationId of the offer.
        public var resaleAuthorizationId: Swift.String?
        /// The status of the offer.
        public var state: MarketplaceCatalogClientTypes.OfferStateString?
        /// The targeting in the offer.
        public var targeting: [MarketplaceCatalogClientTypes.OfferTargetingString]?

        public init(
            availabilityEndDate: Swift.String? = nil,
            buyerAccounts: [Swift.String]? = nil,
            name: Swift.String? = nil,
            productId: Swift.String? = nil,
            releaseDate: Swift.String? = nil,
            resaleAuthorizationId: Swift.String? = nil,
            state: MarketplaceCatalogClientTypes.OfferStateString? = nil,
            targeting: [MarketplaceCatalogClientTypes.OfferTargetingString]? = nil
        )
        {
            self.availabilityEndDate = availabilityEndDate
            self.buyerAccounts = buyerAccounts
            self.name = name
            self.productId = productId
            self.releaseDate = releaseDate
            self.resaleAuthorizationId = resaleAuthorizationId
            self.state = state
            self.targeting = targeting
        }
    }

}

extension MarketplaceCatalogClientTypes.OfferTargetingFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for offertargetingstring0 in valueList {
                try valueListContainer.encode(offertargetingstring0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.OfferTargetingString?].self, forKey: .valueList)
        var valueListDecoded0:[MarketplaceCatalogClientTypes.OfferTargetingString]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [MarketplaceCatalogClientTypes.OfferTargetingString]()
            for enum0 in valueListContainer {
                if let enum0 = enum0 {
                    valueListDecoded0?.append(enum0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the Targeting of an offer.
    public struct OfferTargetingFilter {
        /// Allows filtering on the Targeting of an offer with list input.
        public var valueList: [MarketplaceCatalogClientTypes.OfferTargetingString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.OfferTargetingString]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum OfferTargetingString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case buyeraccounts
        case countrycodes
        case `none`
        case participatingprograms
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferTargetingString] {
            return [
                .buyeraccounts,
                .countrycodes,
                .none,
                .participatingprograms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .buyeraccounts: return "BuyerAccounts"
            case .countrycodes: return "CountryCodes"
            case .none: return "None"
            case .participatingprograms: return "ParticipatingPrograms"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferTargetingString(rawValue: rawValue) ?? OfferTargetingString.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes {
    public enum OwnershipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `self`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [OwnershipType] {
            return [
                .self,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .self: return "SELF"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OwnershipType(rawValue: rawValue) ?? OwnershipType.sdkUnknown(rawValue)
        }
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/PutResourcePolicy"
    }
}

public struct PutResourcePolicyInput {
    /// The policy document to set; formatted in JSON.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the entity resource you want to associate with a resource policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody {
    let resourceArn: Swift.String?
    let policy: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutResourcePolicyOutput {

    public init() { }
}

enum PutResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for datetimeiso86010 in valueList {
                try valueListContainer.encode(datetimeiso86010)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization.
    public struct ResaleAuthorizationAvailabilityEndDateFilter {
        /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization with date range as input
        public var dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilterDateRange?
        /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization with date value as input.
        public var valueList: [Swift.String]?

        public init(
            dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilterDateRange? = nil,
            valueList: [Swift.String]? = nil
        )
        {
            self.dateRange = dateRange
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization with date range as input.
    public struct ResaleAuthorizationAvailabilityEndDateFilterDateRange {
        /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on AvailabilityEndDate of a ResaleAuthorization before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for datetimeiso86010 in valueList {
                try valueListContainer.encode(datetimeiso86010)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on CreatedDate of a ResaleAuthorization.
    public struct ResaleAuthorizationCreatedDateFilter {
        /// Allows filtering on CreatedDate of a ResaleAuthorization with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilterDateRange?
        /// Allows filtering on CreatedDate of a ResaleAuthorization with date value as input.
        public var valueList: [Swift.String]?

        public init(
            dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilterDateRange? = nil,
            valueList: [Swift.String]? = nil
        )
        {
            self.dateRange = dateRange
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on CreatedDate of a ResaleAuthorization with date range as input.
    public struct ResaleAuthorizationCreatedDateFilterDateRange {
        /// Allows filtering on CreatedDate of a ResaleAuthorization after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on CreatedDate of a ResaleAuthorization before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationEntityIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationentityidstring0 in valueList {
                try valueListContainer.encode(resaleauthorizationentityidstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on EntityId of a ResaleAuthorization.
    public struct ResaleAuthorizationEntityIdFilter {
        /// Allows filtering on EntityId of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityEndDate = "AvailabilityEndDate"
        case createdDate = "CreatedDate"
        case entityId = "EntityId"
        case lastModifiedDate = "LastModifiedDate"
        case manufacturerAccountId = "ManufacturerAccountId"
        case manufacturerLegalName = "ManufacturerLegalName"
        case name = "Name"
        case offerExtendedStatus = "OfferExtendedStatus"
        case productId = "ProductId"
        case productName = "ProductName"
        case resellerAccountID = "ResellerAccountID"
        case resellerLegalName = "ResellerLegalName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityEndDate = self.availabilityEndDate {
            try encodeContainer.encode(availabilityEndDate, forKey: .availabilityEndDate)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let manufacturerAccountId = self.manufacturerAccountId {
            try encodeContainer.encode(manufacturerAccountId, forKey: .manufacturerAccountId)
        }
        if let manufacturerLegalName = self.manufacturerLegalName {
            try encodeContainer.encode(manufacturerLegalName, forKey: .manufacturerLegalName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let offerExtendedStatus = self.offerExtendedStatus {
            try encodeContainer.encode(offerExtendedStatus, forKey: .offerExtendedStatus)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let resellerAccountID = self.resellerAccountID {
            try encodeContainer.encode(resellerAccountID, forKey: .resellerAccountID)
        }
        if let resellerLegalName = self.resellerLegalName {
            try encodeContainer.encode(resellerLegalName, forKey: .resellerLegalName)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationEntityIdFilter.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationNameFilter.self, forKey: .name)
        name = nameDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationProductIdFilter.self, forKey: .productId)
        productId = productIdDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilter.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let availabilityEndDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilter.self, forKey: .availabilityEndDate)
        availabilityEndDate = availabilityEndDateDecoded
        let manufacturerAccountIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerAccountIdFilter.self, forKey: .manufacturerAccountId)
        manufacturerAccountId = manufacturerAccountIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationProductNameFilter.self, forKey: .productName)
        productName = productNameDecoded
        let manufacturerLegalNameDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerLegalNameFilter.self, forKey: .manufacturerLegalName)
        manufacturerLegalName = manufacturerLegalNameDecoded
        let resellerAccountIDDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationResellerAccountIDFilter.self, forKey: .resellerAccountID)
        resellerAccountID = resellerAccountIDDecoded
        let resellerLegalNameDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationResellerLegalNameFilter.self, forKey: .resellerLegalName)
        resellerLegalName = resellerLegalNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationStatusFilter.self, forKey: .status)
        status = statusDecoded
        let offerExtendedStatusDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationOfferExtendedStatusFilter.self, forKey: .offerExtendedStatus)
        offerExtendedStatus = offerExtendedStatusDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilter.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object containing all the filter fields for resale authorization entity. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct ResaleAuthorizationFilters {
        /// Allows filtering on the AvailabilityEndDate of a ResaleAuthorization.
        public var availabilityEndDate: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilter?
        /// Allows filtering on the CreatedDate of a ResaleAuthorization.
        public var createdDate: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilter?
        /// Allows filtering on the EntityId of a ResaleAuthorization.
        public var entityId: MarketplaceCatalogClientTypes.ResaleAuthorizationEntityIdFilter?
        /// Allows filtering on the LastModifiedDate of a ResaleAuthorization.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilter?
        /// Allows filtering on the ManufacturerAccountId of a ResaleAuthorization.
        public var manufacturerAccountId: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerAccountIdFilter?
        /// Allows filtering on the ManufacturerLegalName of a ResaleAuthorization.
        public var manufacturerLegalName: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerLegalNameFilter?
        /// Allows filtering on the Name of a ResaleAuthorization.
        public var name: MarketplaceCatalogClientTypes.ResaleAuthorizationNameFilter?
        /// Allows filtering on the OfferExtendedStatus of a ResaleAuthorization.
        public var offerExtendedStatus: MarketplaceCatalogClientTypes.ResaleAuthorizationOfferExtendedStatusFilter?
        /// Allows filtering on the ProductId of a ResaleAuthorization.
        public var productId: MarketplaceCatalogClientTypes.ResaleAuthorizationProductIdFilter?
        /// Allows filtering on the ProductName of a ResaleAuthorization.
        public var productName: MarketplaceCatalogClientTypes.ResaleAuthorizationProductNameFilter?
        /// Allows filtering on the ResellerAccountID of a ResaleAuthorization.
        public var resellerAccountID: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerAccountIDFilter?
        /// Allows filtering on the ResellerLegalName of a ResaleAuthorization.
        public var resellerLegalName: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerLegalNameFilter?
        /// Allows filtering on the Status of a ResaleAuthorization.
        public var status: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusFilter?

        public init(
            availabilityEndDate: MarketplaceCatalogClientTypes.ResaleAuthorizationAvailabilityEndDateFilter? = nil,
            createdDate: MarketplaceCatalogClientTypes.ResaleAuthorizationCreatedDateFilter? = nil,
            entityId: MarketplaceCatalogClientTypes.ResaleAuthorizationEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilter? = nil,
            manufacturerAccountId: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerAccountIdFilter? = nil,
            manufacturerLegalName: MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerLegalNameFilter? = nil,
            name: MarketplaceCatalogClientTypes.ResaleAuthorizationNameFilter? = nil,
            offerExtendedStatus: MarketplaceCatalogClientTypes.ResaleAuthorizationOfferExtendedStatusFilter? = nil,
            productId: MarketplaceCatalogClientTypes.ResaleAuthorizationProductIdFilter? = nil,
            productName: MarketplaceCatalogClientTypes.ResaleAuthorizationProductNameFilter? = nil,
            resellerAccountID: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerAccountIDFilter? = nil,
            resellerLegalName: MarketplaceCatalogClientTypes.ResaleAuthorizationResellerLegalNameFilter? = nil,
            status: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusFilter? = nil
        )
        {
            self.availabilityEndDate = availabilityEndDate
            self.createdDate = createdDate
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.manufacturerAccountId = manufacturerAccountId
            self.manufacturerLegalName = manufacturerLegalName
            self.name = name
            self.offerExtendedStatus = offerExtendedStatus
            self.productId = productId
            self.productName = productName
            self.resellerAccountID = resellerAccountID
            self.resellerLegalName = resellerLegalName
            self.status = status
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the LastModifiedDate of a ResaleAuthorization.
    public struct ResaleAuthorizationLastModifiedDateFilter {
        /// Allows filtering on the LastModifiedDate of a ResaleAuthorization with date range as input.
        public var dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationLastModifiedDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the LastModifiedDate of a ResaleAuthorization with date range as input.
    public struct ResaleAuthorizationLastModifiedDateFilterDateRange {
        /// Allows filtering on the LastModifiedDate of a ResaleAuthorization after a date.
        public var afterValue: Swift.String?
        /// Allows filtering on the LastModifiedDate of a ResaleAuthorization before a date.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerAccountIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationmanufactureraccountidstring0 in valueList {
                try valueListContainer.encode(resaleauthorizationmanufactureraccountidstring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ManufacturerAccountId of a ResaleAuthorization.
    public struct ResaleAuthorizationManufacturerAccountIdFilter {
        /// Allows filtering on the ManufacturerAccountId of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ManufacturerAccountId of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationManufacturerLegalNameFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationmanufacturerlegalnamestring0 in valueList {
                try valueListContainer.encode(resaleauthorizationmanufacturerlegalnamestring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ManufacturerLegalName of a ResaleAuthorization.
    public struct ResaleAuthorizationManufacturerLegalNameFilter {
        /// Allows filtering on the ManufacturerLegalName of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ManufacturerLegalName of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationNameFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationnamestring0 in valueList {
                try valueListContainer.encode(resaleauthorizationnamestring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the Name of a ResaleAuthorization.
    public struct ResaleAuthorizationNameFilter {
        /// Allows filtering on the Name of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the Name of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationOfferExtendedStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationofferextendedstatusstring0 in valueList {
                try valueListContainer.encode(resaleauthorizationofferextendedstatusstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the OfferExtendedStatus of a ResaleAuthorization.
    public struct ResaleAuthorizationOfferExtendedStatusFilter {
        /// Allows filtering on the OfferExtendedStatus of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationProductIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationproductidstring0 in valueList {
                try valueListContainer.encode(resaleauthorizationproductidstring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ProductId of a ResaleAuthorization.
    public struct ResaleAuthorizationProductIdFilter {
        /// Allows filtering on the ProductId of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ProductId of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationProductNameFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationproductnamestring0 in valueList {
                try valueListContainer.encode(resaleauthorizationproductnamestring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ProductName of a ResaleAuthorization.
    public struct ResaleAuthorizationProductNameFilter {
        /// Allows filtering on the ProductName of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ProductName of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationResellerAccountIDFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationreselleraccountidstring0 in valueList {
                try valueListContainer.encode(resaleauthorizationreselleraccountidstring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ResellerAccountID of a ResaleAuthorization.
    public struct ResaleAuthorizationResellerAccountIDFilter {
        /// Allows filtering on the ResellerAccountID of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ResellerAccountID of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationResellerLegalNameFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationresellerlegalnamestring0 in valueList {
                try valueListContainer.encode(resaleauthorizationresellerlegalnamestring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the ResellerLegalName of a ResaleAuthorization.
    public struct ResaleAuthorizationResellerLegalNameFilter {
        /// Allows filtering on the ResellerLegalNameProductName of a ResaleAuthorization with list input.
        public var valueList: [Swift.String]?
        /// Allows filtering on the ResellerLegalName of a ResaleAuthorization with wild card input.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows to sort ResaleAuthorization.
    public struct ResaleAuthorizationSort {
        /// Allows to sort ResaleAuthorization.
        public var sortBy: MarketplaceCatalogClientTypes.ResaleAuthorizationSortBy?
        /// Allows to sort ResaleAuthorization.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.ResaleAuthorizationSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum ResaleAuthorizationSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case availabilityenddate
        case createddate
        case entityid
        case lastmodifieddate
        case manufactureraccountid
        case manufacturerlegalname
        case name
        case offerextendedstatus
        case productid
        case productname
        case reselleraccountid
        case resellerlegalname
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ResaleAuthorizationSortBy] {
            return [
                .availabilityenddate,
                .createddate,
                .entityid,
                .lastmodifieddate,
                .manufactureraccountid,
                .manufacturerlegalname,
                .name,
                .offerextendedstatus,
                .productid,
                .productname,
                .reselleraccountid,
                .resellerlegalname,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .availabilityenddate: return "AvailabilityEndDate"
            case .createddate: return "CreatedDate"
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .manufactureraccountid: return "ManufacturerAccountId"
            case .manufacturerlegalname: return "ManufacturerLegalName"
            case .name: return "Name"
            case .offerextendedstatus: return "OfferExtendedStatus"
            case .productid: return "ProductId"
            case .productname: return "ProductName"
            case .reselleraccountid: return "ResellerAccountID"
            case .resellerlegalname: return "ResellerLegalName"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResaleAuthorizationSortBy(rawValue: rawValue) ?? ResaleAuthorizationSortBy.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for resaleauthorizationstatusstring0 in valueList {
                try valueListContainer.encode(resaleauthorizationstatusstring0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString?].self, forKey: .valueList)
        var valueListDecoded0:[MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString]()
            for enum0 in valueListContainer {
                if let enum0 = enum0 {
                    valueListDecoded0?.append(enum0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Allows filtering on the Status of a ResaleAuthorization.
    public struct ResaleAuthorizationStatusFilter {
        /// Allows filtering on the Status of a ResaleAuthorization with list input.
        public var valueList: [MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum ResaleAuthorizationStatusString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case draft
        case restricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ResaleAuthorizationStatusString] {
            return [
                .active,
                .draft,
                .restricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .draft: return "Draft"
            case .restricted: return "Restricted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResaleAuthorizationStatusString(rawValue: rawValue) ?? ResaleAuthorizationStatusString.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.ResaleAuthorizationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityEndDate = "AvailabilityEndDate"
        case createdDate = "CreatedDate"
        case manufacturerAccountId = "ManufacturerAccountId"
        case manufacturerLegalName = "ManufacturerLegalName"
        case name = "Name"
        case offerExtendedStatus = "OfferExtendedStatus"
        case productId = "ProductId"
        case productName = "ProductName"
        case resellerAccountID = "ResellerAccountID"
        case resellerLegalName = "ResellerLegalName"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityEndDate = self.availabilityEndDate {
            try encodeContainer.encode(availabilityEndDate, forKey: .availabilityEndDate)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let manufacturerAccountId = self.manufacturerAccountId {
            try encodeContainer.encode(manufacturerAccountId, forKey: .manufacturerAccountId)
        }
        if let manufacturerLegalName = self.manufacturerLegalName {
            try encodeContainer.encode(manufacturerLegalName, forKey: .manufacturerLegalName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let offerExtendedStatus = self.offerExtendedStatus {
            try encodeContainer.encode(offerExtendedStatus, forKey: .offerExtendedStatus)
        }
        if let productId = self.productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = self.productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let resellerAccountID = self.resellerAccountID {
            try encodeContainer.encode(resellerAccountID, forKey: .resellerAccountID)
        }
        if let resellerLegalName = self.resellerLegalName {
            try encodeContainer.encode(resellerLegalName, forKey: .resellerLegalName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let manufacturerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturerAccountId)
        manufacturerAccountId = manufacturerAccountIdDecoded
        let manufacturerLegalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturerLegalName)
        manufacturerLegalName = manufacturerLegalNameDecoded
        let resellerAccountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resellerAccountID)
        resellerAccountID = resellerAccountIDDecoded
        let resellerLegalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resellerLegalName)
        resellerLegalName = resellerLegalNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString.self, forKey: .status)
        status = statusDecoded
        let offerExtendedStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offerExtendedStatus)
        offerExtendedStatus = offerExtendedStatusDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let availabilityEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityEndDate)
        availabilityEndDate = availabilityEndDateDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Summarized information about a Resale Authorization.
    public struct ResaleAuthorizationSummary {
        /// The availability end date of the ResaleAuthorization.
        public var availabilityEndDate: Swift.String?
        /// The created date of the ResaleAuthorization.
        public var createdDate: Swift.String?
        /// The manufacturer account ID of the ResaleAuthorization.
        public var manufacturerAccountId: Swift.String?
        /// The manufacturer legal name of the ResaleAuthorization.
        public var manufacturerLegalName: Swift.String?
        /// The name of the ResaleAuthorization.
        public var name: Swift.String?
        /// The offer extended status of the ResaleAuthorization
        public var offerExtendedStatus: Swift.String?
        /// The product ID of the ResaleAuthorization.
        public var productId: Swift.String?
        /// The product name of the ResaleAuthorization.
        public var productName: Swift.String?
        /// The reseller account ID of the ResaleAuthorization.
        public var resellerAccountID: Swift.String?
        /// The reseller legal name of the ResaleAuthorization
        public var resellerLegalName: Swift.String?
        /// The status of the ResaleAuthorization.
        public var status: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString?

        public init(
            availabilityEndDate: Swift.String? = nil,
            createdDate: Swift.String? = nil,
            manufacturerAccountId: Swift.String? = nil,
            manufacturerLegalName: Swift.String? = nil,
            name: Swift.String? = nil,
            offerExtendedStatus: Swift.String? = nil,
            productId: Swift.String? = nil,
            productName: Swift.String? = nil,
            resellerAccountID: Swift.String? = nil,
            resellerLegalName: Swift.String? = nil,
            status: MarketplaceCatalogClientTypes.ResaleAuthorizationStatusString? = nil
        )
        {
            self.availabilityEndDate = availabilityEndDate
            self.createdDate = createdDate
            self.manufacturerAccountId = manufacturerAccountId
            self.manufacturerLegalName = manufacturerLegalName
            self.name = name
            self.offerExtendedStatus = offerExtendedStatus
            self.productId = productId
            self.productName = productName
            self.resellerAccountID = resellerAccountID
            self.resellerLegalName = resellerLegalName
            self.status = status
        }
    }

}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource is currently in use.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource wasn't found. HTTP status code: 404
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotSupportedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Currently, the specified resource is not supported.
public struct ResourceNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotSupportedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotSupportedExceptionBody {
    let message: Swift.String?
}

extension ResourceNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductEntityIdFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for saasproductentityidstring0 in valueList {
                try valueListContainer.encode(saasproductentityidstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on entity id of a SaaS product.
    public struct SaaSProductEntityIdFilter {
        /// A string array of unique entity id values to be filtered on.
        public var valueList: [Swift.String]?

        public init(
            valueList: [Swift.String]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes.SaaSProductFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case lastModifiedDate = "LastModifiedDate"
        case productTitle = "ProductTitle"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let lastModifiedDate = self.lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let productTitle = self.productTitle {
            try encodeContainer.encode(productTitle, forKey: .productTitle)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductEntityIdFilter.self, forKey: .entityId)
        entityId = entityIdDecoded
        let productTitleDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductTitleFilter.self, forKey: .productTitle)
        productTitle = productTitleDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductVisibilityFilter.self, forKey: .visibility)
        visibility = visibilityDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilter.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object containing all the filter fields for SaaS products. Client can add only one wildcard filter and a maximum of 8 filters in a single ListEntities request.
    public struct SaaSProductFilters {
        /// Unique identifier for the SaaS product.
        public var entityId: MarketplaceCatalogClientTypes.SaaSProductEntityIdFilter?
        /// The last date on which the SaaS product was modified.
        public var lastModifiedDate: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilter?
        /// The title of the SaaS product.
        public var productTitle: MarketplaceCatalogClientTypes.SaaSProductTitleFilter?
        /// The visibility of the SaaS product.
        public var visibility: MarketplaceCatalogClientTypes.SaaSProductVisibilityFilter?

        public init(
            entityId: MarketplaceCatalogClientTypes.SaaSProductEntityIdFilter? = nil,
            lastModifiedDate: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilter? = nil,
            productTitle: MarketplaceCatalogClientTypes.SaaSProductTitleFilter? = nil,
            visibility: MarketplaceCatalogClientTypes.SaaSProductVisibilityFilter? = nil
        )
        {
            self.entityId = entityId
            self.lastModifiedDate = lastModifiedDate
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateRange = "DateRange"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateRange = self.dateRange {
            try encodeContainer.encode(dateRange, forKey: .dateRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateRangeDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilterDateRange.self, forKey: .dateRange)
        dateRange = dateRangeDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering based on the last modified date of SaaS products
    public struct SaaSProductLastModifiedDateFilter {
        /// Dates between which the SaaS product was last modified.
        public var dateRange: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilterDateRange?

        public init(
            dateRange: MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilterDateRange? = nil
        )
        {
            self.dateRange = dateRange
        }
    }

}

extension MarketplaceCatalogClientTypes.SaaSProductLastModifiedDateFilterDateRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case afterValue = "AfterValue"
        case beforeValue = "BeforeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let afterValue = self.afterValue {
            try encodeContainer.encode(afterValue, forKey: .afterValue)
        }
        if let beforeValue = self.beforeValue {
            try encodeContainer.encode(beforeValue, forKey: .beforeValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let afterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .afterValue)
        afterValue = afterValueDecoded
        let beforeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beforeValue)
        beforeValue = beforeValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that contains date range of the last modified date to be filtered on. You can optionally provide a BeforeValue and/or AfterValue. Both are inclusive.
    public struct SaaSProductLastModifiedDateFilterDateRange {
        /// Date after which the SaaS product was last modified.
        public var afterValue: Swift.String?
        /// Date before which the SaaS product was last modified.
        public var beforeValue: Swift.String?

        public init(
            afterValue: Swift.String? = nil,
            beforeValue: Swift.String? = nil
        )
        {
            self.afterValue = afterValue
            self.beforeValue = beforeValue
        }
    }

}

extension MarketplaceCatalogClientTypes.SaaSProductSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Objects that allows sorting on SaaS products based on certain fields and sorting order.
    public struct SaaSProductSort {
        /// Field to sort the SaaS products by.
        public var sortBy: MarketplaceCatalogClientTypes.SaaSProductSortBy?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: MarketplaceCatalogClientTypes.SaaSProductSortBy? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum SaaSProductSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entityid
        case lastmodifieddate
        case producttitle
        case visibility
        case sdkUnknown(Swift.String)

        public static var allCases: [SaaSProductSortBy] {
            return [
                .entityid,
                .lastmodifieddate,
                .producttitle,
                .visibility,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entityid: return "EntityId"
            case .lastmodifieddate: return "LastModifiedDate"
            case .producttitle: return "ProductTitle"
            case .visibility: return "Visibility"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SaaSProductSortBy(rawValue: rawValue) ?? SaaSProductSortBy.sdkUnknown(rawValue)
        }
    }
}

extension MarketplaceCatalogClientTypes.SaaSProductSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productTitle = "ProductTitle"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productTitle = self.productTitle {
            try encodeContainer.encode(productTitle, forKey: .productTitle)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productTitle)
        productTitle = productTitleDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SaaSProductVisibilityString.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that contains summarized information about a SaaS product.
    public struct SaaSProductSummary {
        /// The title of the SaaS product.
        public var productTitle: Swift.String?
        /// The lifecycle of the SaaS product.
        public var visibility: MarketplaceCatalogClientTypes.SaaSProductVisibilityString?

        public init(
            productTitle: Swift.String? = nil,
            visibility: MarketplaceCatalogClientTypes.SaaSProductVisibilityString? = nil
        )
        {
            self.productTitle = productTitle
            self.visibility = visibility
        }
    }

}

extension MarketplaceCatalogClientTypes.SaaSProductTitleFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
        case wildCardValue = "WildCardValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for saasproducttitlestring0 in valueList {
                try valueListContainer.encode(saasproducttitlestring0)
            }
        }
        if let wildCardValue = self.wildCardValue {
            try encodeContainer.encode(wildCardValue, forKey: .wildCardValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .valueList)
        var valueListDecoded0:[Swift.String]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [Swift.String]()
            for string0 in valueListContainer {
                if let string0 = string0 {
                    valueListDecoded0?.append(string0)
                }
            }
        }
        valueList = valueListDecoded0
        let wildCardValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .wildCardValue)
        wildCardValue = wildCardValueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on product title.
    public struct SaaSProductTitleFilter {
        /// A string array of unique product title values to be filtered on.
        public var valueList: [Swift.String]?
        /// A string that will be the wildCard input for product tile filter. It matches the provided value as a substring in the actual value.
        public var wildCardValue: Swift.String?

        public init(
            valueList: [Swift.String]? = nil,
            wildCardValue: Swift.String? = nil
        )
        {
            self.valueList = valueList
            self.wildCardValue = wildCardValue
        }
    }

}

extension MarketplaceCatalogClientTypes.SaaSProductVisibilityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case valueList = "ValueList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let valueList = valueList {
            var valueListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .valueList)
            for saasproductvisibilitystring0 in valueList {
                try valueListContainer.encode(saasproductvisibilitystring0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueListContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.SaaSProductVisibilityString?].self, forKey: .valueList)
        var valueListDecoded0:[MarketplaceCatalogClientTypes.SaaSProductVisibilityString]? = nil
        if let valueListContainer = valueListContainer {
            valueListDecoded0 = [MarketplaceCatalogClientTypes.SaaSProductVisibilityString]()
            for enum0 in valueListContainer {
                if let enum0 = enum0 {
                    valueListDecoded0?.append(enum0)
                }
            }
        }
        valueList = valueListDecoded0
    }
}

extension MarketplaceCatalogClientTypes {
    /// Object that allows filtering on the visibility of the product in the AWS Marketplace.
    public struct SaaSProductVisibilityFilter {
        /// A string array of unique visibility values to be filtered on.
        public var valueList: [MarketplaceCatalogClientTypes.SaaSProductVisibilityString]?

        public init(
            valueList: [MarketplaceCatalogClientTypes.SaaSProductVisibilityString]? = nil
        )
        {
            self.valueList = valueList
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum SaaSProductVisibilityString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case draft
        case limited
        case `public`
        case restricted
        case sdkUnknown(Swift.String)

        public static var allCases: [SaaSProductVisibilityString] {
            return [
                .draft,
                .limited,
                .public,
                .restricted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draft: return "Draft"
            case .limited: return "Limited"
            case .public: return "Public"
            case .restricted: return "Restricted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SaaSProductVisibilityString(rawValue: rawValue) ?? SaaSProductVisibilityString.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The maximum number of open requests per account has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MarketplaceCatalogClientTypes.Sort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// An object that contains two attributes, SortBy and SortOrder.
    public struct Sort {
        /// For ListEntities, supported attributes include LastModifiedDate (default) and EntityId. In addition to LastModifiedDate and EntityId, each EntityType might support additional fields. For ListChangeSets, supported attributes include StartTime and EndTime.
        public var sortBy: Swift.String?
        /// The sorting order. Can be ASCENDING or DESCENDING. The default value is DESCENDING.
        public var sortOrder: MarketplaceCatalogClientTypes.SortOrder?

        public init(
            sortBy: Swift.String? = nil,
            sortOrder: MarketplaceCatalogClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension MarketplaceCatalogClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StartChangeSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case changeSet = "ChangeSet"
        case changeSetName = "ChangeSetName"
        case changeSetTags = "ChangeSetTags"
        case clientRequestToken = "ClientRequestToken"
        case intent = "Intent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalog = self.catalog {
            try encodeContainer.encode(catalog, forKey: .catalog)
        }
        if let changeSet = changeSet {
            var changeSetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeSet)
            for change0 in changeSet {
                try changeSetContainer.encode(change0)
            }
        }
        if let changeSetName = self.changeSetName {
            try encodeContainer.encode(changeSetName, forKey: .changeSetName)
        }
        if let changeSetTags = changeSetTags {
            var changeSetTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .changeSetTags)
            for tag0 in changeSetTags {
                try changeSetTagsContainer.encode(tag0)
            }
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let intent = self.intent {
            try encodeContainer.encode(intent.rawValue, forKey: .intent)
        }
    }
}

extension StartChangeSetInput {

    static func urlPathProvider(_ value: StartChangeSetInput) -> Swift.String? {
        return "/StartChangeSet"
    }
}

public struct StartChangeSetInput {
    /// The catalog related to the request. Fixed value: AWSMarketplace
    /// This member is required.
    public var catalog: Swift.String?
    /// Array of change object.
    /// This member is required.
    public var changeSet: [MarketplaceCatalogClientTypes.Change]?
    /// Optional case sensitive string of up to 100 ASCII characters. The change set name can be used to filter the list of change sets.
    public var changeSetName: Swift.String?
    /// A list of objects specifying each key name and value for the ChangeSetTags property.
    public var changeSetTags: [MarketplaceCatalogClientTypes.Tag]?
    /// A unique token to identify the request to ensure idempotency.
    public var clientRequestToken: Swift.String?
    /// The intent related to the request. The default is APPLY. To test your request before applying changes to your entities, use VALIDATE. This feature is currently available for adding versions to single-AMI products. For more information, see [Add a new version](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/ami-products.html#ami-add-version).
    public var intent: MarketplaceCatalogClientTypes.Intent?

    public init(
        catalog: Swift.String? = nil,
        changeSet: [MarketplaceCatalogClientTypes.Change]? = nil,
        changeSetName: Swift.String? = nil,
        changeSetTags: [MarketplaceCatalogClientTypes.Tag]? = nil,
        clientRequestToken: Swift.String? = nil,
        intent: MarketplaceCatalogClientTypes.Intent? = nil
    )
    {
        self.catalog = catalog
        self.changeSet = changeSet
        self.changeSetName = changeSetName
        self.changeSetTags = changeSetTags
        self.clientRequestToken = clientRequestToken
        self.intent = intent
    }
}

struct StartChangeSetInputBody {
    let catalog: Swift.String?
    let changeSet: [MarketplaceCatalogClientTypes.Change]?
    let changeSetName: Swift.String?
    let clientRequestToken: Swift.String?
    let changeSetTags: [MarketplaceCatalogClientTypes.Tag]?
    let intent: MarketplaceCatalogClientTypes.Intent?
}

extension StartChangeSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalog = "Catalog"
        case changeSet = "ChangeSet"
        case changeSetName = "ChangeSetName"
        case changeSetTags = "ChangeSetTags"
        case clientRequestToken = "ClientRequestToken"
        case intent = "Intent"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .catalog)
        catalog = catalogDecoded
        let changeSetContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Change?].self, forKey: .changeSet)
        var changeSetDecoded0:[MarketplaceCatalogClientTypes.Change]? = nil
        if let changeSetContainer = changeSetContainer {
            changeSetDecoded0 = [MarketplaceCatalogClientTypes.Change]()
            for structure0 in changeSetContainer {
                if let structure0 = structure0 {
                    changeSetDecoded0?.append(structure0)
                }
            }
        }
        changeSet = changeSetDecoded0
        let changeSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let changeSetTagsContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Tag?].self, forKey: .changeSetTags)
        var changeSetTagsDecoded0:[MarketplaceCatalogClientTypes.Tag]? = nil
        if let changeSetTagsContainer = changeSetTagsContainer {
            changeSetTagsDecoded0 = [MarketplaceCatalogClientTypes.Tag]()
            for structure0 in changeSetTagsContainer {
                if let structure0 = structure0 {
                    changeSetTagsDecoded0?.append(structure0)
                }
            }
        }
        changeSetTags = changeSetTagsDecoded0
        let intentDecoded = try containerValues.decodeIfPresent(MarketplaceCatalogClientTypes.Intent.self, forKey: .intent)
        intent = intentDecoded
    }
}

extension StartChangeSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartChangeSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.changeSetArn = output.changeSetArn
            self.changeSetId = output.changeSetId
        } else {
            self.changeSetArn = nil
            self.changeSetId = nil
        }
    }
}

public struct StartChangeSetOutput {
    /// The ARN associated to the unique identifier generated for the request.
    public var changeSetArn: Swift.String?
    /// Unique identifier generated for the request.
    public var changeSetId: Swift.String?

    public init(
        changeSetArn: Swift.String? = nil,
        changeSetId: Swift.String? = nil
    )
    {
        self.changeSetArn = changeSetArn
        self.changeSetId = changeSetId
    }
}

struct StartChangeSetOutputBody {
    let changeSetId: Swift.String?
    let changeSetArn: Swift.String?
}

extension StartChangeSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeSetArn = "ChangeSetArn"
        case changeSetId = "ChangeSetId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let changeSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetArn)
        changeSetArn = changeSetArnDecoded
    }
}

enum StartChangeSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MarketplaceCatalogClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MarketplaceCatalogClientTypes {
    /// A list of objects specifying each key name and value.
    public struct Tag {
        /// The key associated with the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/TagResource"
    }
}

public struct TagResourceInput {
    /// Required. The Amazon Resource Name (ARN) associated with the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Required. A list of objects specifying each key name and value. Number of objects allowed: 1-50.
    /// This member is required.
    public var tags: [MarketplaceCatalogClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [MarketplaceCatalogClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody {
    let resourceArn: Swift.String?
    let tags: [MarketplaceCatalogClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([MarketplaceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[MarketplaceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [MarketplaceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Too many requests. HTTP status code: 429
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/UntagResource"
    }
}

public struct UntagResourceInput {
    /// Required. The Amazon Resource Name (ARN) associated with the resource you want to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Required. A list of key names of tags to be removed. Number of strings allowed: 0-256.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error occurred during validation. HTTP status code: 422
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
