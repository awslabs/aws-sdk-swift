//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// Activity already exists. EncryptionConfiguration may not be updated.
public struct ActivityAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ActivityAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified activity does not exist.
public struct ActivityDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ActivityDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SFNClientTypes {
    /// Contains details about an activity that failed during an execution.
    public struct ActivityFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.ActivityFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivityFailedEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

/// The maximum number of activities has been reached. Existing activities must be deleted before a new activity can be created.
public struct ActivityLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ActivityLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SFNClientTypes {
    /// Contains details about an activity.
    public struct ActivityListItem {
        /// The Amazon Resource Name (ARN) that identifies the activity.
        /// This member is required.
        public var activityArn: Swift.String?
        /// The date the activity is created.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// The name of the activity. A name must not contain:
        ///
        /// * white space
        ///
        /// * brackets < > { } [ ]
        ///
        /// * wildcard characters ? *
        ///
        /// * special characters " # % \ ^ | ~ ` $ & , ; : /
        ///
        /// * control characters (U+0000-001F, U+007F-009F)
        ///
        ///
        /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        /// This member is required.
        public var name: Swift.String?

        public init(
            activityArn: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.activityArn = activityArn
            self.creationDate = creationDate
            self.name = name
        }
    }

}

extension SFNClientTypes {
    /// Provides details about input or output in an execution history event.
    public struct HistoryEventExecutionDataDetails {
        /// Indicates whether input or output was truncated in the response. Always false for API calls.
        public var truncated: Swift.Bool

        public init(
            truncated: Swift.Bool = false
        )
        {
            self.truncated = truncated
        }
    }

}

extension SFNClientTypes {
    /// Contains details about an activity scheduled during an execution.
    public struct ActivityScheduledEventDetails {
        /// The maximum allowed duration between two heartbeats for the activity task.
        public var heartbeatInSeconds: Swift.Int?
        /// The JSON data input to the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var input: Swift.String?
        /// Contains details about the input for an execution history event.
        public var inputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the scheduled activity.
        /// This member is required.
        public var resource: Swift.String?
        /// The maximum allowed duration of the activity task.
        public var timeoutInSeconds: Swift.Int?

        public init(
            heartbeatInSeconds: Swift.Int? = 0,
            input: Swift.String? = nil,
            inputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil,
            resource: Swift.String? = nil,
            timeoutInSeconds: Swift.Int? = 0
        )
        {
            self.heartbeatInSeconds = heartbeatInSeconds
            self.input = input
            self.inputDetails = inputDetails
            self.resource = resource
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension SFNClientTypes.ActivityScheduledEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivityScheduledEventDetails(heartbeatInSeconds: \(Swift.String(describing: heartbeatInSeconds)), inputDetails: \(Swift.String(describing: inputDetails)), resource: \(Swift.String(describing: resource)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)), input: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about an activity schedule failure that occurred during an execution.
    public struct ActivityScheduleFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.ActivityScheduleFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivityScheduleFailedEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about the start of an activity during an execution.
    public struct ActivityStartedEventDetails {
        /// The name of the worker that the task is assigned to. These names are provided by the workers when calling [GetActivityTask].
        public var workerName: Swift.String?

        public init(
            workerName: Swift.String? = nil
        )
        {
            self.workerName = workerName
        }
    }

}

extension SFNClientTypes {
    /// Contains details about an activity that successfully terminated during an execution.
    public struct ActivitySucceededEventDetails {
        /// The JSON data output by the activity task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?

        public init(
            output: Swift.String? = nil,
            outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
        }
    }

}

extension SFNClientTypes.ActivitySucceededEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivitySucceededEventDetails(outputDetails: \(Swift.String(describing: outputDetails)), output: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about an activity timeout that occurred during an execution.
    public struct ActivityTimedOutEventDetails {
        /// A more detailed explanation of the cause of the timeout.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.ActivityTimedOutEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivityTimedOutEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

/// The maximum number of workers concurrently polling for activity tasks has been reached.
public struct ActivityWorkerLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ActivityWorkerLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Received when encryptionConfiguration is specified but various conditions exist which make the configuration invalid. For example, if type is set to CUSTOMER_MANAGED_KMS_KEY, but kmsKeyId is null, or kmsDataKeyReusePeriodSeconds is not between 60 and 900, or the KMS key is not symmetric or inactive.
public struct InvalidEncryptionConfiguration: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEncryptionConfiguration" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The provided name is not valid.
public struct InvalidName: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidName" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Either your KMS key policy or API caller does not have the required permissions.
public struct KmsAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsAccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Received when KMS returns ThrottlingException for a KMS call that Step Functions makes on behalf of the caller.
public struct KmsThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You've exceeded the number of tags allowed for a resource. See the [ Limits Topic](https://docs.aws.amazon.com/step-functions/latest/dg/limits.html) in the Step Functions Developer Guide.
public struct TooManyTags: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTags" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension SFNClientTypes {

    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsOwnedKey
        case customerManagedKmsKey
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .awsOwnedKey,
                .customerManagedKmsKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKey: return "AWS_OWNED_KEY"
            case .customerManagedKmsKey: return "CUSTOMER_MANAGED_KMS_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SFNClientTypes {
    /// Settings to configure server-side encryption. For additional control over security, you can encrypt your data using a customer-managed key for Step Functions state machines and activities. You can configure a symmetric KMS key and data key reuse period when creating or updating a State Machine, and when creating an Activity. The execution history and state machine definition will be encrypted with the key applied to the State Machine. Activity inputs will be encrypted with the key applied to the Activity. Step Functions automatically enables encryption at rest using Amazon Web Services owned keys at no charge. However, KMS charges apply when using a customer managed key. For more information about pricing, see [Key Management Service pricing](https://aws.amazon.com/kms/pricing/). For more information on KMS, see [What is Key Management Service?](https://docs.aws.amazon.com/kms/latest/developerguide/overview.html)
    public struct EncryptionConfiguration {
        /// Maximum duration that Step Functions will reuse data keys. When the period expires, Step Functions will call GenerateDataKey. Only applies to customer managed keys.
        public var kmsDataKeyReusePeriodSeconds: Swift.Int?
        /// An alias, alias ARN, key ID, or key ARN of a symmetric encryption KMS key to encrypt data. To specify a KMS key in a different Amazon Web Services account, you must use the key ARN or alias ARN.
        public var kmsKeyId: Swift.String?
        /// Encryption type
        /// This member is required.
        public var type: SFNClientTypes.EncryptionType?

        public init(
            kmsDataKeyReusePeriodSeconds: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            type: SFNClientTypes.EncryptionType? = nil
        )
        {
            self.kmsDataKeyReusePeriodSeconds = kmsDataKeyReusePeriodSeconds
            self.kmsKeyId = kmsKeyId
            self.type = type
        }
    }

}

extension SFNClientTypes {
    /// Tags are key-value pairs that can be associated with Step Functions state machines and activities. An array of key-value pairs. For more information, see [Using Cost Allocation Tags](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html) in the Amazon Web Services Billing and Cost Management User Guide, and [Controlling Access Using IAM Tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html). Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
    public struct Tag {
        /// The key of a tag.
        public var key: Swift.String?
        /// The value of a tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateActivityInput {
    /// Settings to configure server-side encryption.
    public var encryptionConfiguration: SFNClientTypes.EncryptionConfiguration?
    /// The name of the activity to create. This name must be unique for your Amazon Web Services account and region for 90 days. For more information, see [ Limits Related to State Machine Executions](https://docs.aws.amazon.com/step-functions/latest/dg/limits.html#service-limits-state-machine-executions) in the Step Functions Developer Guide. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    /// This member is required.
    public var name: Swift.String?
    /// The list of tags to add to a resource. An array of key-value pairs. For more information, see [Using Cost Allocation Tags](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html) in the Amazon Web Services Billing and Cost Management User Guide, and [Controlling Access Using IAM Tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html). Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
    public var tags: [SFNClientTypes.Tag]?

    public init(
        encryptionConfiguration: SFNClientTypes.EncryptionConfiguration? = nil,
        name: Swift.String? = nil,
        tags: [SFNClientTypes.Tag]? = nil
    )
    {
        self.encryptionConfiguration = encryptionConfiguration
        self.name = name
        self.tags = tags
    }
}

public struct CreateActivityOutput {
    /// The Amazon Resource Name (ARN) that identifies the created activity.
    /// This member is required.
    public var activityArn: Swift.String?
    /// The date the activity is created.
    /// This member is required.
    public var creationDate: Foundation.Date?

    public init(
        activityArn: Swift.String? = nil,
        creationDate: Foundation.Date? = nil
    )
    {
        self.activityArn = activityArn
        self.creationDate = creationDate
    }
}

/// Updating or deleting a resource can cause an inconsistent state. This error occurs when there're concurrent requests for [DeleteStateMachineVersion], [PublishStateMachineVersion], or [UpdateStateMachine] with the publish parameter set to true. HTTP Status Code: 409
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The provided Amazon Resource Name (ARN) is not valid.
public struct InvalidArn: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArn" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The provided Amazon States Language definition is not valid.
public struct InvalidDefinition: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDefinition" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Configuration is not valid.
public struct InvalidLoggingConfiguration: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLoggingConfiguration" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your tracingConfiguration key does not match, or enabled has not been set to true or false.
public struct InvalidTracingConfiguration: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTracingConfiguration" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A state machine with the same name but a different definition or role ARN already exists.
public struct StateMachineAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StateMachineAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified state machine is being deleted.
public struct StateMachineDeleting: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StateMachineDeleting" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum number of state machines has been reached. Existing state machines must be deleted before a new state machine can be created.
public struct StateMachineLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StateMachineLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// State machine type is not supported.
public struct StateMachineTypeNotSupported: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StateMachineTypeNotSupported" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SFNClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apiDoesNotSupportLabeledArns
        case cannotUpdateCompletedMapRun
        case invalidRoutingConfiguration
        case missingRequiredParameter
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .apiDoesNotSupportLabeledArns,
                .cannotUpdateCompletedMapRun,
                .invalidRoutingConfiguration,
                .missingRequiredParameter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apiDoesNotSupportLabeledArns: return "API_DOES_NOT_SUPPORT_LABELED_ARNS"
            case .cannotUpdateCompletedMapRun: return "CANNOT_UPDATE_COMPLETED_MAP_RUN"
            case .invalidRoutingConfiguration: return "INVALID_ROUTING_CONFIGURATION"
            case .missingRequiredParameter: return "MISSING_REQUIRED_PARAMETER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input does not satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The input does not satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var reason: SFNClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: SFNClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension SFNClientTypes {
    ///
    public struct CloudWatchLogsLogGroup {
        /// The ARN of the the CloudWatch log group to which you want your logs emitted to. The ARN must end with :*
        public var logGroupArn: Swift.String?

        public init(
            logGroupArn: Swift.String? = nil
        )
        {
            self.logGroupArn = logGroupArn
        }
    }

}

extension SFNClientTypes {
    ///
    public struct LogDestination {
        /// An object describing a CloudWatch log group. For more information, see [AWS::Logs::LogGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html) in the CloudFormation User Guide.
        public var cloudWatchLogsLogGroup: SFNClientTypes.CloudWatchLogsLogGroup?

        public init(
            cloudWatchLogsLogGroup: SFNClientTypes.CloudWatchLogsLogGroup? = nil
        )
        {
            self.cloudWatchLogsLogGroup = cloudWatchLogsLogGroup
        }
    }

}

extension SFNClientTypes {

    public enum LogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case error
        case fatal
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LogLevel] {
            return [
                .all,
                .error,
                .fatal,
                .off
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SFNClientTypes {
    /// The LoggingConfiguration data type is used to set CloudWatch Logs options.
    public struct LoggingConfiguration {
        /// An array of objects that describes where your execution history events will be logged. Limited to size 1. Required, if your log level is not set to OFF.
        public var destinations: [SFNClientTypes.LogDestination]?
        /// Determines whether execution data is included in your log. When set to false, data is excluded.
        public var includeExecutionData: Swift.Bool
        /// Defines which category of execution history events are logged.
        public var level: SFNClientTypes.LogLevel?

        public init(
            destinations: [SFNClientTypes.LogDestination]? = nil,
            includeExecutionData: Swift.Bool = false,
            level: SFNClientTypes.LogLevel? = nil
        )
        {
            self.destinations = destinations
            self.includeExecutionData = includeExecutionData
            self.level = level
        }
    }

}

extension SFNClientTypes {
    /// Selects whether or not the state machine's X-Ray tracing is enabled. Default is false
    public struct TracingConfiguration {
        /// When set to true, X-Ray tracing is enabled.
        public var enabled: Swift.Bool

        public init(
            enabled: Swift.Bool = false
        )
        {
            self.enabled = enabled
        }
    }

}

extension SFNClientTypes {

    public enum StateMachineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case express
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [StateMachineType] {
            return [
                .express,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .express: return "EXPRESS"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateStateMachineInput {
    /// The Amazon States Language definition of the state machine. See [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html).
    /// This member is required.
    public var definition: Swift.String?
    /// Settings to configure server-side encryption.
    public var encryptionConfiguration: SFNClientTypes.EncryptionConfiguration?
    /// Defines what execution history events are logged and where they are logged. By default, the level is set to OFF. For more information see [Log Levels](https://docs.aws.amazon.com/step-functions/latest/dg/cloudwatch-log-level.html) in the Step Functions User Guide.
    public var loggingConfiguration: SFNClientTypes.LoggingConfiguration?
    /// The name of the state machine. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    /// This member is required.
    public var name: Swift.String?
    /// Set to true to publish the first version of the state machine during creation. The default is false.
    public var publish: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to use for this state machine.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Tags to be added when creating a state machine. An array of key-value pairs. For more information, see [Using Cost Allocation Tags](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html) in the Amazon Web Services Billing and Cost Management User Guide, and [Controlling Access Using IAM Tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html). Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
    public var tags: [SFNClientTypes.Tag]?
    /// Selects whether X-Ray tracing is enabled.
    public var tracingConfiguration: SFNClientTypes.TracingConfiguration?
    /// Determines whether a Standard or Express state machine is created. The default is STANDARD. You cannot update the type of a state machine once it has been created.
    public var type: SFNClientTypes.StateMachineType?
    /// Sets description about the state machine version. You can only set the description if the publish parameter is set to true. Otherwise, if you set versionDescription, but publish to false, this API action throws ValidationException.
    public var versionDescription: Swift.String?

    public init(
        definition: Swift.String? = nil,
        encryptionConfiguration: SFNClientTypes.EncryptionConfiguration? = nil,
        loggingConfiguration: SFNClientTypes.LoggingConfiguration? = nil,
        name: Swift.String? = nil,
        publish: Swift.Bool? = false,
        roleArn: Swift.String? = nil,
        tags: [SFNClientTypes.Tag]? = nil,
        tracingConfiguration: SFNClientTypes.TracingConfiguration? = nil,
        type: SFNClientTypes.StateMachineType? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.definition = definition
        self.encryptionConfiguration = encryptionConfiguration
        self.loggingConfiguration = loggingConfiguration
        self.name = name
        self.publish = publish
        self.roleArn = roleArn
        self.tags = tags
        self.tracingConfiguration = tracingConfiguration
        self.type = type
        self.versionDescription = versionDescription
    }
}

extension CreateStateMachineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStateMachineInput(encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), loggingConfiguration: \(Swift.String(describing: loggingConfiguration)), name: \(Swift.String(describing: name)), publish: \(Swift.String(describing: publish)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), tracingConfiguration: \(Swift.String(describing: tracingConfiguration)), type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", versionDescription: \"CONTENT_REDACTED\")"}
}

public struct CreateStateMachineOutput {
    /// The date the state machine is created.
    /// This member is required.
    public var creationDate: Foundation.Date?
    /// The Amazon Resource Name (ARN) that identifies the created state machine.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the created state machine version. If you do not set the publish parameter to true, this field returns null value.
    public var stateMachineVersionArn: Swift.String?

    public init(
        creationDate: Foundation.Date? = nil,
        stateMachineArn: Swift.String? = nil,
        stateMachineVersionArn: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.stateMachineArn = stateMachineArn
        self.stateMachineVersionArn = stateMachineVersionArn
    }
}

/// Could not find the referenced resource.
public struct ResourceNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// The request would cause a service quota to be exceeded. HTTP Status Code: 402
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SFNClientTypes {
    /// Contains details about the routing configuration of a state machine alias. In a routing configuration, you define an array of objects that specify up to two state machine versions. You also specify the percentage of traffic to be routed to each version.
    public struct RoutingConfigurationListItem {
        /// The Amazon Resource Name (ARN) that identifies one or two state machine versions defined in the routing configuration. If you specify the ARN of a second version, it must belong to the same state machine as the first version.
        /// This member is required.
        public var stateMachineVersionArn: Swift.String?
        /// The percentage of traffic you want to route to a state machine version. The sum of the weights in the routing configuration must be equal to 100.
        /// This member is required.
        public var weight: Swift.Int

        public init(
            stateMachineVersionArn: Swift.String? = nil,
            weight: Swift.Int = 0
        )
        {
            self.stateMachineVersionArn = stateMachineVersionArn
            self.weight = weight
        }
    }

}

public struct CreateStateMachineAliasInput {
    /// A description for the state machine alias.
    public var description: Swift.String?
    /// The name of the state machine alias. To avoid conflict with version ARNs, don't use an integer in the name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// The routing configuration of a state machine alias. The routing configuration shifts execution traffic between two state machine versions. routingConfiguration contains an array of RoutingConfig objects that specify up to two state machine versions. Step Functions then randomly choses which version to run an execution with based on the weight assigned to each RoutingConfig.
    /// This member is required.
    public var routingConfiguration: [SFNClientTypes.RoutingConfigurationListItem]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfiguration: [SFNClientTypes.RoutingConfigurationListItem]? = nil
    )
    {
        self.description = description
        self.name = name
        self.routingConfiguration = routingConfiguration
    }
}

extension CreateStateMachineAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStateMachineAliasInput(name: \(Swift.String(describing: name)), routingConfiguration: \(Swift.String(describing: routingConfiguration)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateStateMachineAliasOutput {
    /// The date the state machine alias was created.
    /// This member is required.
    public var creationDate: Foundation.Date?
    /// The Amazon Resource Name (ARN) that identifies the created state machine alias.
    /// This member is required.
    public var stateMachineAliasArn: Swift.String?

    public init(
        creationDate: Foundation.Date? = nil,
        stateMachineAliasArn: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.stateMachineAliasArn = stateMachineAliasArn
    }
}

public struct DeleteActivityInput {
    /// The Amazon Resource Name (ARN) of the activity to delete.
    /// This member is required.
    public var activityArn: Swift.String?

    public init(
        activityArn: Swift.String? = nil
    )
    {
        self.activityArn = activityArn
    }
}

public struct DeleteActivityOutput {

    public init() { }
}

public struct DeleteStateMachineInput {
    /// The Amazon Resource Name (ARN) of the state machine to delete.
    /// This member is required.
    public var stateMachineArn: Swift.String?

    public init(
        stateMachineArn: Swift.String? = nil
    )
    {
        self.stateMachineArn = stateMachineArn
    }
}

public struct DeleteStateMachineOutput {

    public init() { }
}

public struct DeleteStateMachineAliasInput {
    /// The Amazon Resource Name (ARN) of the state machine alias to delete.
    /// This member is required.
    public var stateMachineAliasArn: Swift.String?

    public init(
        stateMachineAliasArn: Swift.String? = nil
    )
    {
        self.stateMachineAliasArn = stateMachineAliasArn
    }
}

public struct DeleteStateMachineAliasOutput {

    public init() { }
}

public struct DeleteStateMachineVersionInput {
    /// The Amazon Resource Name (ARN) of the state machine version to delete.
    /// This member is required.
    public var stateMachineVersionArn: Swift.String?

    public init(
        stateMachineVersionArn: Swift.String? = nil
    )
    {
        self.stateMachineVersionArn = stateMachineVersionArn
    }
}

public struct DeleteStateMachineVersionOutput {

    public init() { }
}

public struct DescribeActivityInput {
    /// The Amazon Resource Name (ARN) of the activity to describe.
    /// This member is required.
    public var activityArn: Swift.String?

    public init(
        activityArn: Swift.String? = nil
    )
    {
        self.activityArn = activityArn
    }
}

public struct DescribeActivityOutput {
    /// The Amazon Resource Name (ARN) that identifies the activity.
    /// This member is required.
    public var activityArn: Swift.String?
    /// The date the activity is created.
    /// This member is required.
    public var creationDate: Foundation.Date?
    /// Settings for configured server-side encryption.
    public var encryptionConfiguration: SFNClientTypes.EncryptionConfiguration?
    /// The name of the activity. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    /// This member is required.
    public var name: Swift.String?

    public init(
        activityArn: Swift.String? = nil,
        creationDate: Foundation.Date? = nil,
        encryptionConfiguration: SFNClientTypes.EncryptionConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.activityArn = activityArn
        self.creationDate = creationDate
        self.encryptionConfiguration = encryptionConfiguration
        self.name = name
    }
}

/// The specified execution does not exist.
public struct ExecutionDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExecutionDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SFNClientTypes {

    public enum KmsKeyState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case disabled
        case pendingDeletion
        case pendingImport
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [KmsKeyState] {
            return [
                .creating,
                .disabled,
                .pendingDeletion,
                .pendingImport,
                .unavailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .disabled: return "DISABLED"
            case .pendingDeletion: return "PENDING_DELETION"
            case .pendingImport: return "PENDING_IMPORT"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The KMS key is not in valid state, for example: Disabled or Deleted.
public struct KmsInvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Current status of the KMS; key. For example: DISABLED, PENDING_DELETION, PENDING_IMPORT, UNAVAILABLE, CREATING.
        public internal(set) var kmsKeyState: SFNClientTypes.KmsKeyState? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsInvalidStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        kmsKeyState: SFNClientTypes.KmsKeyState? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.kmsKeyState = kmsKeyState
        self.properties.message = message
    }
}

extension SFNClientTypes {

    public enum IncludedData: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allData
        case metadataOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [IncludedData] {
            return [
                .allData,
                .metadataOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allData: return "ALL_DATA"
            case .metadataOnly: return "METADATA_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeExecutionInput {
    /// The Amazon Resource Name (ARN) of the execution to describe.
    /// This member is required.
    public var executionArn: Swift.String?
    /// If your state machine definition is encrypted with a KMS key, callers must have kms:Decrypt permission to decrypt the definition. Alternatively, you can call DescribeStateMachine API with includedData = METADATA_ONLY to get a successful response without the encrypted definition.
    public var includedData: SFNClientTypes.IncludedData?

    public init(
        executionArn: Swift.String? = nil,
        includedData: SFNClientTypes.IncludedData? = nil
    )
    {
        self.executionArn = executionArn
        self.includedData = includedData
    }
}

extension SFNClientTypes {
    /// Provides details about execution input or output.
    public struct CloudWatchEventsExecutionDataDetails {
        /// Indicates whether input or output was included in the response. Always true for API calls.
        public var included: Swift.Bool

        public init(
            included: Swift.Bool = false
        )
        {
            self.included = included
        }
    }

}

extension SFNClientTypes {

    public enum ExecutionRedriveStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notRedrivable
        case redrivable
        case redrivableByMapRun
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionRedriveStatus] {
            return [
                .notRedrivable,
                .redrivable,
                .redrivableByMapRun
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notRedrivable: return "NOT_REDRIVABLE"
            case .redrivable: return "REDRIVABLE"
            case .redrivableByMapRun: return "REDRIVABLE_BY_MAP_RUN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SFNClientTypes {

    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case failed
        case pendingRedrive
        case running
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .aborted,
                .failed,
                .pendingRedrive,
                .running,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .pendingRedrive: return "PENDING_REDRIVE"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeExecutionOutput {
    /// The cause string if the state machine execution failed.
    public var cause: Swift.String?
    /// The error string if the state machine execution failed.
    public var error: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the execution.
    /// This member is required.
    public var executionArn: Swift.String?
    /// The string that contains the JSON input data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// Provides details about execution input or output.
    public var inputDetails: SFNClientTypes.CloudWatchEventsExecutionDataDetails?
    /// The Amazon Resource Name (ARN) that identifies a Map Run, which dispatched this execution.
    public var mapRunArn: Swift.String?
    /// The name of the execution. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    public var name: Swift.String?
    /// The JSON output data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding. This field is set only if the execution succeeds. If the execution fails, this field is null.
    public var output: Swift.String?
    /// Provides details about execution input or output.
    public var outputDetails: SFNClientTypes.CloudWatchEventsExecutionDataDetails?
    /// The number of times you've redriven an execution. If you have not yet redriven an execution, the redriveCount is 0. This count is only updated if you successfully redrive an execution.
    public var redriveCount: Swift.Int?
    /// The date the execution was last redriven. If you have not yet redriven an execution, the redriveDate is null. The redriveDate is unavailable if you redrive a Map Run that starts child workflow executions of type EXPRESS.
    public var redriveDate: Foundation.Date?
    /// Indicates whether or not an execution can be redriven at a given point in time.
    ///
    /// * For executions of type STANDARD, redriveStatus is NOT_REDRIVABLE if calling the [RedriveExecution] API action would return the ExecutionNotRedrivable error.
    ///
    /// * For a Distributed Map that includes child workflows of type STANDARD, redriveStatus indicates whether or not the Map Run can redrive child workflow executions.
    ///
    /// * For a Distributed Map that includes child workflows of type EXPRESS, redriveStatus indicates whether or not the Map Run can redrive child workflow executions. You can redrive failed or timed out EXPRESS workflows only if they're a part of a Map Run. When you [redrive](https://docs.aws.amazon.com/step-functions/latest/dg/redrive-map-run.html) the Map Run, these workflows are restarted using the [StartExecution] API action.
    public var redriveStatus: SFNClientTypes.ExecutionRedriveStatus?
    /// When redriveStatus is NOT_REDRIVABLE, redriveStatusReason specifies the reason why an execution cannot be redriven.
    ///
    /// * For executions of type STANDARD, or for a Distributed Map that includes child workflows of type STANDARD, redriveStatusReason can include one of the following reasons:
    ///
    /// * State machine is in DELETING status.
    ///
    /// * Execution is RUNNING and cannot be redriven.
    ///
    /// * Execution is SUCCEEDED and cannot be redriven.
    ///
    /// * Execution was started before the launch of RedriveExecution.
    ///
    /// * Execution history event limit exceeded.
    ///
    /// * Execution has exceeded the max execution time.
    ///
    /// * Execution redrivable period exceeded.
    ///
    ///
    ///
    ///
    /// * For a Distributed Map that includes child workflows of type EXPRESS, redriveStatusReason is only returned if the child workflows are not redrivable. This happens when the child workflow executions have completed successfully.
    public var redriveStatusReason: Swift.String?
    /// The date the execution is started.
    /// This member is required.
    public var startDate: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the state machine alias associated with the execution. The alias ARN is a combination of state machine ARN and the alias name separated by a colon (:). For example, stateMachineARN:PROD. If you start an execution from a StartExecution request with a state machine version ARN, this field will be null.
    public var stateMachineAliasArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the executed stated machine.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine version associated with the execution. The version ARN is a combination of state machine ARN and the version number separated by a colon (:). For example, stateMachineARN:1. If you start an execution from a StartExecution request without specifying a state machine version or alias ARN, Step Functions returns a null value.
    public var stateMachineVersionArn: Swift.String?
    /// The current status of the execution.
    /// This member is required.
    public var status: SFNClientTypes.ExecutionStatus?
    /// If the execution ended, the date the execution stopped.
    public var stopDate: Foundation.Date?
    /// The X-Ray trace header that was passed to the execution.
    public var traceHeader: Swift.String?

    public init(
        cause: Swift.String? = nil,
        error: Swift.String? = nil,
        executionArn: Swift.String? = nil,
        input: Swift.String? = nil,
        inputDetails: SFNClientTypes.CloudWatchEventsExecutionDataDetails? = nil,
        mapRunArn: Swift.String? = nil,
        name: Swift.String? = nil,
        output: Swift.String? = nil,
        outputDetails: SFNClientTypes.CloudWatchEventsExecutionDataDetails? = nil,
        redriveCount: Swift.Int? = nil,
        redriveDate: Foundation.Date? = nil,
        redriveStatus: SFNClientTypes.ExecutionRedriveStatus? = nil,
        redriveStatusReason: Swift.String? = nil,
        startDate: Foundation.Date? = nil,
        stateMachineAliasArn: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        stateMachineVersionArn: Swift.String? = nil,
        status: SFNClientTypes.ExecutionStatus? = nil,
        stopDate: Foundation.Date? = nil,
        traceHeader: Swift.String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.executionArn = executionArn
        self.input = input
        self.inputDetails = inputDetails
        self.mapRunArn = mapRunArn
        self.name = name
        self.output = output
        self.outputDetails = outputDetails
        self.redriveCount = redriveCount
        self.redriveDate = redriveDate
        self.redriveStatus = redriveStatus
        self.redriveStatusReason = redriveStatusReason
        self.startDate = startDate
        self.stateMachineAliasArn = stateMachineAliasArn
        self.stateMachineArn = stateMachineArn
        self.stateMachineVersionArn = stateMachineVersionArn
        self.status = status
        self.stopDate = stopDate
        self.traceHeader = traceHeader
    }
}

extension DescribeExecutionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeExecutionOutput(executionArn: \(Swift.String(describing: executionArn)), inputDetails: \(Swift.String(describing: inputDetails)), mapRunArn: \(Swift.String(describing: mapRunArn)), name: \(Swift.String(describing: name)), outputDetails: \(Swift.String(describing: outputDetails)), redriveCount: \(Swift.String(describing: redriveCount)), redriveDate: \(Swift.String(describing: redriveDate)), redriveStatus: \(Swift.String(describing: redriveStatus)), startDate: \(Swift.String(describing: startDate)), stateMachineAliasArn: \(Swift.String(describing: stateMachineAliasArn)), stateMachineArn: \(Swift.String(describing: stateMachineArn)), stateMachineVersionArn: \(Swift.String(describing: stateMachineVersionArn)), status: \(Swift.String(describing: status)), stopDate: \(Swift.String(describing: stopDate)), traceHeader: \(Swift.String(describing: traceHeader)), cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\", input: \"CONTENT_REDACTED\", output: \"CONTENT_REDACTED\", redriveStatusReason: \"CONTENT_REDACTED\")"}
}

public struct DescribeMapRunInput {
    /// The Amazon Resource Name (ARN) that identifies a Map Run.
    /// This member is required.
    public var mapRunArn: Swift.String?

    public init(
        mapRunArn: Swift.String? = nil
    )
    {
        self.mapRunArn = mapRunArn
    }
}

extension SFNClientTypes {
    /// Contains details about all of the child workflow executions started by a Map Run.
    public struct MapRunExecutionCounts {
        /// The total number of child workflow executions that were started by a Map Run and were running, but were either stopped by the user or by Step Functions because the Map Run failed.
        /// This member is required.
        public var aborted: Swift.Int
        /// The total number of child workflow executions that were started by a Map Run, but have failed.
        /// This member is required.
        public var failed: Swift.Int
        /// The number of FAILED, ABORTED, or TIMED_OUT child workflow executions that cannot be redriven because their execution status is terminal. For example, child workflows with an execution status of FAILED, ABORTED, or TIMED_OUT and a redriveStatus of NOT_REDRIVABLE.
        public var failuresNotRedrivable: Swift.Int?
        /// The total number of child workflow executions that were started by a Map Run, but haven't started executing yet.
        /// This member is required.
        public var pending: Swift.Int
        /// The number of unsuccessful child workflow executions currently waiting to be redriven. The status of these child workflow executions could be FAILED, ABORTED, or TIMED_OUT in the original execution attempt or a previous redrive attempt.
        public var pendingRedrive: Swift.Int?
        /// Returns the count of child workflow executions whose results were written by ResultWriter. For more information, see [ResultWriter](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-resultwriter.html) in the Step Functions Developer Guide.
        /// This member is required.
        public var resultsWritten: Swift.Int
        /// The total number of child workflow executions that were started by a Map Run and are currently in-progress.
        /// This member is required.
        public var running: Swift.Int
        /// The total number of child workflow executions that were started by a Map Run and have completed successfully.
        /// This member is required.
        public var succeeded: Swift.Int
        /// The total number of child workflow executions that were started by a Map Run and have timed out.
        /// This member is required.
        public var timedOut: Swift.Int
        /// The total number of child workflow executions that were started by a Map Run.
        /// This member is required.
        public var total: Swift.Int

        public init(
            aborted: Swift.Int = 0,
            failed: Swift.Int = 0,
            failuresNotRedrivable: Swift.Int? = nil,
            pending: Swift.Int = 0,
            pendingRedrive: Swift.Int? = nil,
            resultsWritten: Swift.Int = 0,
            running: Swift.Int = 0,
            succeeded: Swift.Int = 0,
            timedOut: Swift.Int = 0,
            total: Swift.Int = 0
        )
        {
            self.aborted = aborted
            self.failed = failed
            self.failuresNotRedrivable = failuresNotRedrivable
            self.pending = pending
            self.pendingRedrive = pendingRedrive
            self.resultsWritten = resultsWritten
            self.running = running
            self.succeeded = succeeded
            self.timedOut = timedOut
            self.total = total
        }
    }

}

extension SFNClientTypes {
    /// Contains details about items that were processed in all of the child workflow executions that were started by a Map Run.
    public struct MapRunItemCounts {
        /// The total number of items processed in child workflow executions that were either stopped by the user or by Step Functions, because the Map Run failed.
        /// This member is required.
        public var aborted: Swift.Int
        /// The total number of items processed in child workflow executions that have failed.
        /// This member is required.
        public var failed: Swift.Int
        /// The number of FAILED, ABORTED, or TIMED_OUT items in child workflow executions that cannot be redriven because the execution status of those child workflows is terminal. For example, child workflows with an execution status of FAILED, ABORTED, or TIMED_OUT and a redriveStatus of NOT_REDRIVABLE.
        public var failuresNotRedrivable: Swift.Int?
        /// The total number of items to process in child workflow executions that haven't started running yet.
        /// This member is required.
        public var pending: Swift.Int
        /// The number of unsuccessful items in child workflow executions currently waiting to be redriven.
        public var pendingRedrive: Swift.Int?
        /// Returns the count of items whose results were written by ResultWriter. For more information, see [ResultWriter](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-resultwriter.html) in the Step Functions Developer Guide.
        /// This member is required.
        public var resultsWritten: Swift.Int
        /// The total number of items being processed in child workflow executions that are currently in-progress.
        /// This member is required.
        public var running: Swift.Int
        /// The total number of items processed in child workflow executions that have completed successfully.
        /// This member is required.
        public var succeeded: Swift.Int
        /// The total number of items processed in child workflow executions that have timed out.
        /// This member is required.
        public var timedOut: Swift.Int
        /// The total number of items processed in all the child workflow executions started by a Map Run.
        /// This member is required.
        public var total: Swift.Int

        public init(
            aborted: Swift.Int = 0,
            failed: Swift.Int = 0,
            failuresNotRedrivable: Swift.Int? = nil,
            pending: Swift.Int = 0,
            pendingRedrive: Swift.Int? = nil,
            resultsWritten: Swift.Int = 0,
            running: Swift.Int = 0,
            succeeded: Swift.Int = 0,
            timedOut: Swift.Int = 0,
            total: Swift.Int = 0
        )
        {
            self.aborted = aborted
            self.failed = failed
            self.failuresNotRedrivable = failuresNotRedrivable
            self.pending = pending
            self.pendingRedrive = pendingRedrive
            self.resultsWritten = resultsWritten
            self.running = running
            self.succeeded = succeeded
            self.timedOut = timedOut
            self.total = total
        }
    }

}

extension SFNClientTypes {

    public enum MapRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aborted
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [MapRunStatus] {
            return [
                .aborted,
                .failed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aborted: return "ABORTED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeMapRunOutput {
    /// The Amazon Resource Name (ARN) that identifies the execution in which the Map Run was started.
    /// This member is required.
    public var executionArn: Swift.String?
    /// A JSON object that contains information about the total number of child workflow executions for the Map Run, and the count of child workflow executions for each status, such as failed and succeeded.
    /// This member is required.
    public var executionCounts: SFNClientTypes.MapRunExecutionCounts?
    /// A JSON object that contains information about the total number of items, and the item count for each processing status, such as pending and failed.
    /// This member is required.
    public var itemCounts: SFNClientTypes.MapRunItemCounts?
    /// The Amazon Resource Name (ARN) that identifies a Map Run.
    /// This member is required.
    public var mapRunArn: Swift.String?
    /// The maximum number of child workflow executions configured to run in parallel for the Map Run at the same time.
    /// This member is required.
    public var maxConcurrency: Swift.Int
    /// The number of times you've redriven a Map Run. If you have not yet redriven a Map Run, the redriveCount is 0. This count is only updated if you successfully redrive a Map Run.
    public var redriveCount: Swift.Int?
    /// The date a Map Run was last redriven. If you have not yet redriven a Map Run, the redriveDate is null.
    public var redriveDate: Foundation.Date?
    /// The date when the Map Run was started.
    /// This member is required.
    public var startDate: Foundation.Date?
    /// The current status of the Map Run.
    /// This member is required.
    public var status: SFNClientTypes.MapRunStatus?
    /// The date when the Map Run was stopped.
    public var stopDate: Foundation.Date?
    /// The maximum number of failed child workflow executions before the Map Run fails.
    /// This member is required.
    public var toleratedFailureCount: Swift.Int
    /// The maximum percentage of failed child workflow executions before the Map Run fails.
    /// This member is required.
    public var toleratedFailurePercentage: Swift.Float

    public init(
        executionArn: Swift.String? = nil,
        executionCounts: SFNClientTypes.MapRunExecutionCounts? = nil,
        itemCounts: SFNClientTypes.MapRunItemCounts? = nil,
        mapRunArn: Swift.String? = nil,
        maxConcurrency: Swift.Int = 0,
        redriveCount: Swift.Int? = nil,
        redriveDate: Foundation.Date? = nil,
        startDate: Foundation.Date? = nil,
        status: SFNClientTypes.MapRunStatus? = nil,
        stopDate: Foundation.Date? = nil,
        toleratedFailureCount: Swift.Int = 0,
        toleratedFailurePercentage: Swift.Float = 0.0
    )
    {
        self.executionArn = executionArn
        self.executionCounts = executionCounts
        self.itemCounts = itemCounts
        self.mapRunArn = mapRunArn
        self.maxConcurrency = maxConcurrency
        self.redriveCount = redriveCount
        self.redriveDate = redriveDate
        self.startDate = startDate
        self.status = status
        self.stopDate = stopDate
        self.toleratedFailureCount = toleratedFailureCount
        self.toleratedFailurePercentage = toleratedFailurePercentage
    }
}

/// The specified state machine does not exist.
public struct StateMachineDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StateMachineDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeStateMachineInput {
    /// If your state machine definition is encrypted with a KMS key, callers must have kms:Decrypt permission to decrypt the definition. Alternatively, you can call the API with includedData = METADATA_ONLY to get a successful response without the encrypted definition. When calling a labelled ARN for an encrypted state machine, the includedData = METADATA_ONLY parameter will not apply because Step Functions needs to decrypt the entire state machine definition to get the Distributed Map state’s definition. In this case, the API caller needs to have kms:Decrypt permission.
    public var includedData: SFNClientTypes.IncludedData?
    /// The Amazon Resource Name (ARN) of the state machine for which you want the information. If you specify a state machine version ARN, this API returns details about that version. The version ARN is a combination of state machine ARN and the version number separated by a colon (:). For example, stateMachineARN:1.
    /// This member is required.
    public var stateMachineArn: Swift.String?

    public init(
        includedData: SFNClientTypes.IncludedData? = nil,
        stateMachineArn: Swift.String? = nil
    )
    {
        self.includedData = includedData
        self.stateMachineArn = stateMachineArn
    }
}

extension SFNClientTypes {

    public enum StateMachineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [StateMachineStatus] {
            return [
                .active,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeStateMachineOutput {
    /// The date the state machine is created. For a state machine version, creationDate is the date the version was created.
    /// This member is required.
    public var creationDate: Foundation.Date?
    /// The Amazon States Language definition of the state machine. See [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html). If called with includedData = METADATA_ONLY, the returned definition will be {}.
    /// This member is required.
    public var definition: Swift.String?
    /// The description of the state machine version.
    public var description: Swift.String?
    /// Settings to configure server-side encryption.
    public var encryptionConfiguration: SFNClientTypes.EncryptionConfiguration?
    /// A user-defined or an auto-generated string that identifies a Map state. This parameter is present only if the stateMachineArn specified in input is a qualified state machine ARN.
    public var label: Swift.String?
    /// The LoggingConfiguration data type is used to set CloudWatch Logs options.
    public var loggingConfiguration: SFNClientTypes.LoggingConfiguration?
    /// The name of the state machine. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    /// This member is required.
    public var name: Swift.String?
    /// The revision identifier for the state machine. Use the revisionId parameter to compare between versions of a state machine configuration used for executions without performing a diff of the properties, such as definition and roleArn.
    public var revisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role used when creating this state machine. (The IAM role maintains security by granting Step Functions access to Amazon Web Services resources.)
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the state machine. If you specified a state machine version ARN in your request, the API returns the version ARN. The version ARN is a combination of state machine ARN and the version number separated by a colon (:). For example, stateMachineARN:1.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// The current status of the state machine.
    public var status: SFNClientTypes.StateMachineStatus?
    /// Selects whether X-Ray tracing is enabled.
    public var tracingConfiguration: SFNClientTypes.TracingConfiguration?
    /// The type of the state machine (STANDARD or EXPRESS).
    /// This member is required.
    public var type: SFNClientTypes.StateMachineType?

    public init(
        creationDate: Foundation.Date? = nil,
        definition: Swift.String? = nil,
        description: Swift.String? = nil,
        encryptionConfiguration: SFNClientTypes.EncryptionConfiguration? = nil,
        label: Swift.String? = nil,
        loggingConfiguration: SFNClientTypes.LoggingConfiguration? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        status: SFNClientTypes.StateMachineStatus? = nil,
        tracingConfiguration: SFNClientTypes.TracingConfiguration? = nil,
        type: SFNClientTypes.StateMachineType? = nil
    )
    {
        self.creationDate = creationDate
        self.definition = definition
        self.description = description
        self.encryptionConfiguration = encryptionConfiguration
        self.label = label
        self.loggingConfiguration = loggingConfiguration
        self.name = name
        self.revisionId = revisionId
        self.roleArn = roleArn
        self.stateMachineArn = stateMachineArn
        self.status = status
        self.tracingConfiguration = tracingConfiguration
        self.type = type
    }
}

extension DescribeStateMachineOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStateMachineOutput(creationDate: \(Swift.String(describing: creationDate)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), label: \(Swift.String(describing: label)), loggingConfiguration: \(Swift.String(describing: loggingConfiguration)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), roleArn: \(Swift.String(describing: roleArn)), stateMachineArn: \(Swift.String(describing: stateMachineArn)), status: \(Swift.String(describing: status)), tracingConfiguration: \(Swift.String(describing: tracingConfiguration)), type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\", description: \"CONTENT_REDACTED\")"}
}

public struct DescribeStateMachineAliasInput {
    /// The Amazon Resource Name (ARN) of the state machine alias.
    /// This member is required.
    public var stateMachineAliasArn: Swift.String?

    public init(
        stateMachineAliasArn: Swift.String? = nil
    )
    {
        self.stateMachineAliasArn = stateMachineAliasArn
    }
}

public struct DescribeStateMachineAliasOutput {
    /// The date the state machine alias was created.
    public var creationDate: Foundation.Date?
    /// A description of the alias.
    public var description: Swift.String?
    /// The name of the state machine alias.
    public var name: Swift.String?
    /// The routing configuration of the alias.
    public var routingConfiguration: [SFNClientTypes.RoutingConfigurationListItem]?
    /// The Amazon Resource Name (ARN) of the state machine alias.
    public var stateMachineAliasArn: Swift.String?
    /// The date the state machine alias was last updated. For a newly created state machine, this is the same as the creation date.
    public var updateDate: Foundation.Date?

    public init(
        creationDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfiguration: [SFNClientTypes.RoutingConfigurationListItem]? = nil,
        stateMachineAliasArn: Swift.String? = nil,
        updateDate: Foundation.Date? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.name = name
        self.routingConfiguration = routingConfiguration
        self.stateMachineAliasArn = stateMachineAliasArn
        self.updateDate = updateDate
    }
}

extension DescribeStateMachineAliasOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStateMachineAliasOutput(creationDate: \(Swift.String(describing: creationDate)), name: \(Swift.String(describing: name)), routingConfiguration: \(Swift.String(describing: routingConfiguration)), stateMachineAliasArn: \(Swift.String(describing: stateMachineAliasArn)), updateDate: \(Swift.String(describing: updateDate)), description: \"CONTENT_REDACTED\")"}
}

public struct DescribeStateMachineForExecutionInput {
    /// The Amazon Resource Name (ARN) of the execution you want state machine information for.
    /// This member is required.
    public var executionArn: Swift.String?
    /// If your state machine definition is encrypted with a KMS key, callers must have kms:Decrypt permission to decrypt the definition. Alternatively, you can call the API with includedData = METADATA_ONLY to get a successful response without the encrypted definition.
    public var includedData: SFNClientTypes.IncludedData?

    public init(
        executionArn: Swift.String? = nil,
        includedData: SFNClientTypes.IncludedData? = nil
    )
    {
        self.executionArn = executionArn
        self.includedData = includedData
    }
}

public struct DescribeStateMachineForExecutionOutput {
    /// The Amazon States Language definition of the state machine. See [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html).
    /// This member is required.
    public var definition: Swift.String?
    /// Settings to configure server-side encryption.
    public var encryptionConfiguration: SFNClientTypes.EncryptionConfiguration?
    /// A user-defined or an auto-generated string that identifies a Map state. This ﬁeld is returned only if the executionArn is a child workflow execution that was started by a Distributed Map state.
    public var label: Swift.String?
    /// The LoggingConfiguration data type is used to set CloudWatch Logs options.
    public var loggingConfiguration: SFNClientTypes.LoggingConfiguration?
    /// The Amazon Resource Name (ARN) of the Map Run that started the child workflow execution. This field is returned only if the executionArn is a child workflow execution that was started by a Distributed Map state.
    public var mapRunArn: Swift.String?
    /// The name of the state machine associated with the execution.
    /// This member is required.
    public var name: Swift.String?
    /// The revision identifier for the state machine. The first revision ID when you create the state machine is null. Use the state machine revisionId parameter to compare the revision of a state machine with the configuration of the state machine used for executions without performing a diff of the properties, such as definition and roleArn.
    public var revisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role of the State Machine for the execution.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine associated with the execution.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// Selects whether X-Ray tracing is enabled.
    public var tracingConfiguration: SFNClientTypes.TracingConfiguration?
    /// The date and time the state machine associated with an execution was updated. For a newly created state machine, this is the creation date.
    /// This member is required.
    public var updateDate: Foundation.Date?

    public init(
        definition: Swift.String? = nil,
        encryptionConfiguration: SFNClientTypes.EncryptionConfiguration? = nil,
        label: Swift.String? = nil,
        loggingConfiguration: SFNClientTypes.LoggingConfiguration? = nil,
        mapRunArn: Swift.String? = nil,
        name: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        tracingConfiguration: SFNClientTypes.TracingConfiguration? = nil,
        updateDate: Foundation.Date? = nil
    )
    {
        self.definition = definition
        self.encryptionConfiguration = encryptionConfiguration
        self.label = label
        self.loggingConfiguration = loggingConfiguration
        self.mapRunArn = mapRunArn
        self.name = name
        self.revisionId = revisionId
        self.roleArn = roleArn
        self.stateMachineArn = stateMachineArn
        self.tracingConfiguration = tracingConfiguration
        self.updateDate = updateDate
    }
}

extension DescribeStateMachineForExecutionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStateMachineForExecutionOutput(encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), label: \(Swift.String(describing: label)), loggingConfiguration: \(Swift.String(describing: loggingConfiguration)), mapRunArn: \(Swift.String(describing: mapRunArn)), name: \(Swift.String(describing: name)), revisionId: \(Swift.String(describing: revisionId)), roleArn: \(Swift.String(describing: roleArn)), stateMachineArn: \(Swift.String(describing: stateMachineArn)), tracingConfiguration: \(Swift.String(describing: tracingConfiguration)), updateDate: \(Swift.String(describing: updateDate)), definition: \"CONTENT_REDACTED\")"}
}

public struct GetActivityTaskInput {
    /// The Amazon Resource Name (ARN) of the activity to retrieve tasks from (assigned when you create the task using [CreateActivity].)
    /// This member is required.
    public var activityArn: Swift.String?
    /// You can provide an arbitrary name in order to identify the worker that the task is assigned to. This name is used when it is logged in the execution history.
    public var workerName: Swift.String?

    public init(
        activityArn: Swift.String? = nil,
        workerName: Swift.String? = nil
    )
    {
        self.activityArn = activityArn
        self.workerName = workerName
    }
}

public struct GetActivityTaskOutput {
    /// The string that contains the JSON input data for the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// A token that identifies the scheduled task. This token must be copied and included in subsequent calls to [SendTaskHeartbeat], [SendTaskSuccess] or [SendTaskFailure] in order to report the progress or completion of the task.
    public var taskToken: Swift.String?

    public init(
        input: Swift.String? = nil,
        taskToken: Swift.String? = nil
    )
    {
        self.input = input
        self.taskToken = taskToken
    }
}

extension GetActivityTaskOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetActivityTaskOutput(taskToken: \(Swift.String(describing: taskToken)), input: \"CONTENT_REDACTED\")"}
}

/// The provided token is not valid.
public struct InvalidToken: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidToken" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetExecutionHistoryInput {
    /// The Amazon Resource Name (ARN) of the execution.
    /// This member is required.
    public var executionArn: Swift.String?
    /// You can select whether execution data (input or output of a history event) is returned. The default is true.
    public var includeExecutionData: Swift.Bool?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// Lists events in descending order of their timeStamp.
    public var reverseOrder: Swift.Bool?

    public init(
        executionArn: Swift.String? = nil,
        includeExecutionData: Swift.Bool? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        reverseOrder: Swift.Bool? = false
    )
    {
        self.executionArn = executionArn
        self.includeExecutionData = includeExecutionData
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.reverseOrder = reverseOrder
    }
}

extension SFNClientTypes {
    /// Contains details about an abort of an execution.
    public struct ExecutionAbortedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.ExecutionAbortedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionAbortedEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about an execution failure event.
    public struct ExecutionFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.ExecutionFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionFailedEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a redriven execution.
    public struct ExecutionRedrivenEventDetails {
        /// The number of times you've redriven an execution. If you have not yet redriven an execution, the redriveCount is 0. This count is not updated for redrives that failed to start or are pending to be redriven.
        public var redriveCount: Swift.Int?

        public init(
            redriveCount: Swift.Int? = nil
        )
        {
            self.redriveCount = redriveCount
        }
    }

}

extension SFNClientTypes {
    /// Contains details about the start of the execution.
    public struct ExecutionStartedEventDetails {
        /// The JSON data input to the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var input: Swift.String?
        /// Contains details about the input for an execution history event.
        public var inputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the IAM role used for executing Lambda tasks.
        public var roleArn: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies a state machine alias used for starting the state machine execution.
        public var stateMachineAliasArn: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies a state machine version used for starting the state machine execution.
        public var stateMachineVersionArn: Swift.String?

        public init(
            input: Swift.String? = nil,
            inputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil,
            roleArn: Swift.String? = nil,
            stateMachineAliasArn: Swift.String? = nil,
            stateMachineVersionArn: Swift.String? = nil
        )
        {
            self.input = input
            self.inputDetails = inputDetails
            self.roleArn = roleArn
            self.stateMachineAliasArn = stateMachineAliasArn
            self.stateMachineVersionArn = stateMachineVersionArn
        }
    }

}

extension SFNClientTypes.ExecutionStartedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionStartedEventDetails(inputDetails: \(Swift.String(describing: inputDetails)), roleArn: \(Swift.String(describing: roleArn)), stateMachineAliasArn: \(Swift.String(describing: stateMachineAliasArn)), stateMachineVersionArn: \(Swift.String(describing: stateMachineVersionArn)), input: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about the successful termination of the execution.
    public struct ExecutionSucceededEventDetails {
        /// The JSON data output by the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?

        public init(
            output: Swift.String? = nil,
            outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
        }
    }

}

extension SFNClientTypes.ExecutionSucceededEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionSucceededEventDetails(outputDetails: \(Swift.String(describing: outputDetails)), output: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about the execution timeout that occurred during the execution.
    public struct ExecutionTimedOutEventDetails {
        /// A more detailed explanation of the cause of the timeout.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.ExecutionTimedOutEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionTimedOutEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a Lambda function that failed during an execution.
    public struct LambdaFunctionFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.LambdaFunctionFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionFailedEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about the credentials that Step Functions uses for a task.
    public struct TaskCredentials {
        /// The ARN of an IAM role that Step Functions assumes for the task. The role can allow cross-account access to resources.
        public var roleArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
        }
    }

}

extension SFNClientTypes {
    /// Contains details about a Lambda function scheduled during an execution.
    public struct LambdaFunctionScheduledEventDetails {
        /// The JSON data input to the Lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var input: Swift.String?
        /// Contains details about input for an execution history event.
        public var inputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?
        /// The Amazon Resource Name (ARN) of the scheduled Lambda function.
        /// This member is required.
        public var resource: Swift.String?
        /// The credentials that Step Functions uses for the task.
        public var taskCredentials: SFNClientTypes.TaskCredentials?
        /// The maximum allowed duration of the Lambda function.
        public var timeoutInSeconds: Swift.Int?

        public init(
            input: Swift.String? = nil,
            inputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil,
            resource: Swift.String? = nil,
            taskCredentials: SFNClientTypes.TaskCredentials? = nil,
            timeoutInSeconds: Swift.Int? = 0
        )
        {
            self.input = input
            self.inputDetails = inputDetails
            self.resource = resource
            self.taskCredentials = taskCredentials
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension SFNClientTypes.LambdaFunctionScheduledEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionScheduledEventDetails(inputDetails: \(Swift.String(describing: inputDetails)), resource: \(Swift.String(describing: resource)), taskCredentials: \(Swift.String(describing: taskCredentials)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)), input: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a failed Lambda function schedule event that occurred during an execution.
    public struct LambdaFunctionScheduleFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.LambdaFunctionScheduleFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionScheduleFailedEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a lambda function that failed to start during an execution.
    public struct LambdaFunctionStartFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.LambdaFunctionStartFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionStartFailedEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a Lambda function that successfully terminated during an execution.
    public struct LambdaFunctionSucceededEventDetails {
        /// The JSON data output by the Lambda function. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?

        public init(
            output: Swift.String? = nil,
            outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
        }
    }

}

extension SFNClientTypes.LambdaFunctionSucceededEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionSucceededEventDetails(outputDetails: \(Swift.String(describing: outputDetails)), output: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a Lambda function timeout that occurred during an execution.
    public struct LambdaFunctionTimedOutEventDetails {
        /// A more detailed explanation of the cause of the timeout.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.LambdaFunctionTimedOutEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionTimedOutEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about an iteration of a Map state.
    public struct MapIterationEventDetails {
        /// The index of the array belonging to the Map state iteration.
        public var index: Swift.Int
        /// The name of the iteration’s parent Map state.
        public var name: Swift.String?

        public init(
            index: Swift.Int = 0,
            name: Swift.String? = nil
        )
        {
            self.index = index
            self.name = name
        }
    }

}

extension SFNClientTypes {
    /// Contains details about a Map Run failure event that occurred during a state machine execution.
    public struct MapRunFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the Map Run failure.
        public var error: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
        }
    }

}

extension SFNClientTypes.MapRunFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MapRunFailedEventDetails(cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a Map Run that was redriven.
    public struct MapRunRedrivenEventDetails {
        /// The Amazon Resource Name (ARN) of a Map Run that was redriven.
        public var mapRunArn: Swift.String?
        /// The number of times the Map Run has been redriven at this point in the execution's history including this event. The redrive count for a redriven Map Run is always greater than 0.
        public var redriveCount: Swift.Int?

        public init(
            mapRunArn: Swift.String? = nil,
            redriveCount: Swift.Int? = nil
        )
        {
            self.mapRunArn = mapRunArn
            self.redriveCount = redriveCount
        }
    }

}

extension SFNClientTypes {
    /// Contains details about a Map Run that was started during a state machine execution.
    public struct MapRunStartedEventDetails {
        /// The Amazon Resource Name (ARN) of a Map Run that was started.
        public var mapRunArn: Swift.String?

        public init(
            mapRunArn: Swift.String? = nil
        )
        {
            self.mapRunArn = mapRunArn
        }
    }

}

extension SFNClientTypes {
    /// Details about a Map state that was started.
    public struct MapStateStartedEventDetails {
        /// The size of the array for Map state iterations.
        public var length: Swift.Int

        public init(
            length: Swift.Int = 0
        )
        {
            self.length = length
        }
    }

}

extension SFNClientTypes {
    /// Contains details about a state entered during an execution.
    public struct StateEnteredEventDetails {
        /// The string that contains the JSON input data for the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var input: Swift.String?
        /// Contains details about the input for an execution history event.
        public var inputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?
        /// The name of the state.
        /// This member is required.
        public var name: Swift.String?

        public init(
            input: Swift.String? = nil,
            inputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil,
            name: Swift.String? = nil
        )
        {
            self.input = input
            self.inputDetails = inputDetails
            self.name = name
        }
    }

}

extension SFNClientTypes.StateEnteredEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StateEnteredEventDetails(inputDetails: \(Swift.String(describing: inputDetails)), name: \(Swift.String(describing: name)), input: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about an exit from a state during an execution.
    public struct StateExitedEventDetails {
        /// The name of the state. A name must not contain:
        ///
        /// * white space
        ///
        /// * brackets < > { } [ ]
        ///
        /// * wildcard characters ? *
        ///
        /// * special characters " # % \ ^ | ~ ` $ & , ; : /
        ///
        /// * control characters (U+0000-001F, U+007F-009F)
        ///
        ///
        /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        /// This member is required.
        public var name: Swift.String?
        /// The JSON output data of the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?

        public init(
            name: Swift.String? = nil,
            output: Swift.String? = nil,
            outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil
        )
        {
            self.name = name
            self.output = output
            self.outputDetails = outputDetails
        }
    }

}

extension SFNClientTypes.StateExitedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StateExitedEventDetails(name: \(Swift.String(describing: name)), outputDetails: \(Swift.String(describing: outputDetails)), output: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a task failure event.
    public struct TaskFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SFNClientTypes.TaskFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskFailedEventDetails(resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)), cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a task scheduled during an execution.
    public struct TaskScheduledEventDetails {
        /// The maximum allowed duration between two heartbeats for the task.
        public var heartbeatInSeconds: Swift.Int?
        /// The JSON data passed to the resource referenced in a task state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        /// This member is required.
        public var parameters: Swift.String?
        /// The region of the scheduled task
        /// This member is required.
        public var region: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resourceType: Swift.String?
        /// The credentials that Step Functions uses for the task.
        public var taskCredentials: SFNClientTypes.TaskCredentials?
        /// The maximum allowed duration of the task.
        public var timeoutInSeconds: Swift.Int?

        public init(
            heartbeatInSeconds: Swift.Int? = 0,
            parameters: Swift.String? = nil,
            region: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            taskCredentials: SFNClientTypes.TaskCredentials? = nil,
            timeoutInSeconds: Swift.Int? = 0
        )
        {
            self.heartbeatInSeconds = heartbeatInSeconds
            self.parameters = parameters
            self.region = region
            self.resource = resource
            self.resourceType = resourceType
            self.taskCredentials = taskCredentials
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension SFNClientTypes.TaskScheduledEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskScheduledEventDetails(heartbeatInSeconds: \(Swift.String(describing: heartbeatInSeconds)), region: \(Swift.String(describing: region)), resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)), taskCredentials: \(Swift.String(describing: taskCredentials)), timeoutInSeconds: \(Swift.String(describing: timeoutInSeconds)), parameters: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about the start of a task during an execution.
    public struct TaskStartedEventDetails {
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SFNClientTypes {
    /// Contains details about a task that failed to start during an execution.
    public struct TaskStartFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SFNClientTypes.TaskStartFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskStartFailedEventDetails(resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)), cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a task that failed to submit during an execution.
    public struct TaskSubmitFailedEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SFNClientTypes.TaskSubmitFailedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskSubmitFailedEventDetails(resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)), cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a task submitted to a resource .
    public struct TaskSubmittedEventDetails {
        /// The response from a resource when a task has started. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            output: Swift.String? = nil,
            outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SFNClientTypes.TaskSubmittedEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskSubmittedEventDetails(outputDetails: \(Swift.String(describing: outputDetails)), resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)), output: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about the successful completion of a task state.
    public struct TaskSucceededEventDetails {
        /// The full JSON response from a resource when a task has succeeded. This response becomes the output of the related task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
        public var output: Swift.String?
        /// Contains details about the output of an execution history event.
        public var outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            output: Swift.String? = nil,
            outputDetails: SFNClientTypes.HistoryEventExecutionDataDetails? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.output = output
            self.outputDetails = outputDetails
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SFNClientTypes.TaskSucceededEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskSucceededEventDetails(outputDetails: \(Swift.String(describing: outputDetails)), resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)), output: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains details about a resource timeout that occurred during an execution.
    public struct TaskTimedOutEventDetails {
        /// A more detailed explanation of the cause of the failure.
        public var cause: Swift.String?
        /// The error code of the failure.
        public var error: Swift.String?
        /// The action of the resource called by a task state.
        /// This member is required.
        public var resource: Swift.String?
        /// The service name of the resource in a task state.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            cause: Swift.String? = nil,
            error: Swift.String? = nil,
            resource: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.cause = cause
            self.error = error
            self.resource = resource
            self.resourceType = resourceType
        }
    }

}

extension SFNClientTypes.TaskTimedOutEventDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskTimedOutEventDetails(resource: \(Swift.String(describing: resource)), resourceType: \(Swift.String(describing: resourceType)), cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {

    public enum HistoryEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activityfailed
        case activityschedulefailed
        case activityscheduled
        case activitystarted
        case activitysucceeded
        case activitytimedout
        case choicestateentered
        case choicestateexited
        case executionaborted
        case executionfailed
        case executionredriven
        case executionstarted
        case executionsucceeded
        case executiontimedout
        case failstateentered
        case lambdafunctionfailed
        case lambdafunctionschedulefailed
        case lambdafunctionscheduled
        case lambdafunctionstartfailed
        case lambdafunctionstarted
        case lambdafunctionsucceeded
        case lambdafunctiontimedout
        case mapiterationaborted
        case mapiterationfailed
        case mapiterationstarted
        case mapiterationsucceeded
        case maprunaborted
        case maprunfailed
        case maprunredriven
        case maprunstarted
        case maprunsucceeded
        case mapstateaborted
        case mapstateentered
        case mapstateexited
        case mapstatefailed
        case mapstatestarted
        case mapstatesucceeded
        case parallelstateaborted
        case parallelstateentered
        case parallelstateexited
        case parallelstatefailed
        case parallelstatestarted
        case parallelstatesucceeded
        case passstateentered
        case passstateexited
        case succeedstateentered
        case succeedstateexited
        case taskfailed
        case taskscheduled
        case taskstartfailed
        case taskstarted
        case taskstateaborted
        case taskstateentered
        case taskstateexited
        case tasksubmitfailed
        case tasksubmitted
        case tasksucceeded
        case tasktimedout
        case waitstateaborted
        case waitstateentered
        case waitstateexited
        case sdkUnknown(Swift.String)

        public static var allCases: [HistoryEventType] {
            return [
                .activityfailed,
                .activityschedulefailed,
                .activityscheduled,
                .activitystarted,
                .activitysucceeded,
                .activitytimedout,
                .choicestateentered,
                .choicestateexited,
                .executionaborted,
                .executionfailed,
                .executionredriven,
                .executionstarted,
                .executionsucceeded,
                .executiontimedout,
                .failstateentered,
                .lambdafunctionfailed,
                .lambdafunctionschedulefailed,
                .lambdafunctionscheduled,
                .lambdafunctionstartfailed,
                .lambdafunctionstarted,
                .lambdafunctionsucceeded,
                .lambdafunctiontimedout,
                .mapiterationaborted,
                .mapiterationfailed,
                .mapiterationstarted,
                .mapiterationsucceeded,
                .maprunaborted,
                .maprunfailed,
                .maprunredriven,
                .maprunstarted,
                .maprunsucceeded,
                .mapstateaborted,
                .mapstateentered,
                .mapstateexited,
                .mapstatefailed,
                .mapstatestarted,
                .mapstatesucceeded,
                .parallelstateaborted,
                .parallelstateentered,
                .parallelstateexited,
                .parallelstatefailed,
                .parallelstatestarted,
                .parallelstatesucceeded,
                .passstateentered,
                .passstateexited,
                .succeedstateentered,
                .succeedstateexited,
                .taskfailed,
                .taskscheduled,
                .taskstartfailed,
                .taskstarted,
                .taskstateaborted,
                .taskstateentered,
                .taskstateexited,
                .tasksubmitfailed,
                .tasksubmitted,
                .tasksucceeded,
                .tasktimedout,
                .waitstateaborted,
                .waitstateentered,
                .waitstateexited
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activityfailed: return "ActivityFailed"
            case .activityschedulefailed: return "ActivityScheduleFailed"
            case .activityscheduled: return "ActivityScheduled"
            case .activitystarted: return "ActivityStarted"
            case .activitysucceeded: return "ActivitySucceeded"
            case .activitytimedout: return "ActivityTimedOut"
            case .choicestateentered: return "ChoiceStateEntered"
            case .choicestateexited: return "ChoiceStateExited"
            case .executionaborted: return "ExecutionAborted"
            case .executionfailed: return "ExecutionFailed"
            case .executionredriven: return "ExecutionRedriven"
            case .executionstarted: return "ExecutionStarted"
            case .executionsucceeded: return "ExecutionSucceeded"
            case .executiontimedout: return "ExecutionTimedOut"
            case .failstateentered: return "FailStateEntered"
            case .lambdafunctionfailed: return "LambdaFunctionFailed"
            case .lambdafunctionschedulefailed: return "LambdaFunctionScheduleFailed"
            case .lambdafunctionscheduled: return "LambdaFunctionScheduled"
            case .lambdafunctionstartfailed: return "LambdaFunctionStartFailed"
            case .lambdafunctionstarted: return "LambdaFunctionStarted"
            case .lambdafunctionsucceeded: return "LambdaFunctionSucceeded"
            case .lambdafunctiontimedout: return "LambdaFunctionTimedOut"
            case .mapiterationaborted: return "MapIterationAborted"
            case .mapiterationfailed: return "MapIterationFailed"
            case .mapiterationstarted: return "MapIterationStarted"
            case .mapiterationsucceeded: return "MapIterationSucceeded"
            case .maprunaborted: return "MapRunAborted"
            case .maprunfailed: return "MapRunFailed"
            case .maprunredriven: return "MapRunRedriven"
            case .maprunstarted: return "MapRunStarted"
            case .maprunsucceeded: return "MapRunSucceeded"
            case .mapstateaborted: return "MapStateAborted"
            case .mapstateentered: return "MapStateEntered"
            case .mapstateexited: return "MapStateExited"
            case .mapstatefailed: return "MapStateFailed"
            case .mapstatestarted: return "MapStateStarted"
            case .mapstatesucceeded: return "MapStateSucceeded"
            case .parallelstateaborted: return "ParallelStateAborted"
            case .parallelstateentered: return "ParallelStateEntered"
            case .parallelstateexited: return "ParallelStateExited"
            case .parallelstatefailed: return "ParallelStateFailed"
            case .parallelstatestarted: return "ParallelStateStarted"
            case .parallelstatesucceeded: return "ParallelStateSucceeded"
            case .passstateentered: return "PassStateEntered"
            case .passstateexited: return "PassStateExited"
            case .succeedstateentered: return "SucceedStateEntered"
            case .succeedstateexited: return "SucceedStateExited"
            case .taskfailed: return "TaskFailed"
            case .taskscheduled: return "TaskScheduled"
            case .taskstartfailed: return "TaskStartFailed"
            case .taskstarted: return "TaskStarted"
            case .taskstateaborted: return "TaskStateAborted"
            case .taskstateentered: return "TaskStateEntered"
            case .taskstateexited: return "TaskStateExited"
            case .tasksubmitfailed: return "TaskSubmitFailed"
            case .tasksubmitted: return "TaskSubmitted"
            case .tasksucceeded: return "TaskSucceeded"
            case .tasktimedout: return "TaskTimedOut"
            case .waitstateaborted: return "WaitStateAborted"
            case .waitstateentered: return "WaitStateEntered"
            case .waitstateexited: return "WaitStateExited"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SFNClientTypes {
    /// Contains details about the events of an execution.
    public struct HistoryEvent {
        /// Contains details about an activity that failed during an execution.
        public var activityFailedEventDetails: SFNClientTypes.ActivityFailedEventDetails?
        /// Contains details about an activity schedule event that failed during an execution.
        public var activityScheduleFailedEventDetails: SFNClientTypes.ActivityScheduleFailedEventDetails?
        /// Contains details about an activity scheduled during an execution.
        public var activityScheduledEventDetails: SFNClientTypes.ActivityScheduledEventDetails?
        /// Contains details about the start of an activity during an execution.
        public var activityStartedEventDetails: SFNClientTypes.ActivityStartedEventDetails?
        /// Contains details about an activity that successfully terminated during an execution.
        public var activitySucceededEventDetails: SFNClientTypes.ActivitySucceededEventDetails?
        /// Contains details about an activity timeout that occurred during an execution.
        public var activityTimedOutEventDetails: SFNClientTypes.ActivityTimedOutEventDetails?
        /// Contains details about an abort of an execution.
        public var executionAbortedEventDetails: SFNClientTypes.ExecutionAbortedEventDetails?
        /// Contains details about an execution failure event.
        public var executionFailedEventDetails: SFNClientTypes.ExecutionFailedEventDetails?
        /// Contains details about the redrive attempt of an execution.
        public var executionRedrivenEventDetails: SFNClientTypes.ExecutionRedrivenEventDetails?
        /// Contains details about the start of the execution.
        public var executionStartedEventDetails: SFNClientTypes.ExecutionStartedEventDetails?
        /// Contains details about the successful termination of the execution.
        public var executionSucceededEventDetails: SFNClientTypes.ExecutionSucceededEventDetails?
        /// Contains details about the execution timeout that occurred during the execution.
        public var executionTimedOutEventDetails: SFNClientTypes.ExecutionTimedOutEventDetails?
        /// The id of the event. Events are numbered sequentially, starting at one.
        /// This member is required.
        public var id: Swift.Int
        /// Contains details about a Lambda function that failed during an execution.
        public var lambdaFunctionFailedEventDetails: SFNClientTypes.LambdaFunctionFailedEventDetails?
        /// Contains details about a failed Lambda function schedule event that occurred during an execution.
        public var lambdaFunctionScheduleFailedEventDetails: SFNClientTypes.LambdaFunctionScheduleFailedEventDetails?
        /// Contains details about a Lambda function scheduled during an execution.
        public var lambdaFunctionScheduledEventDetails: SFNClientTypes.LambdaFunctionScheduledEventDetails?
        /// Contains details about a lambda function that failed to start during an execution.
        public var lambdaFunctionStartFailedEventDetails: SFNClientTypes.LambdaFunctionStartFailedEventDetails?
        /// Contains details about a Lambda function that terminated successfully during an execution.
        public var lambdaFunctionSucceededEventDetails: SFNClientTypes.LambdaFunctionSucceededEventDetails?
        /// Contains details about a Lambda function timeout that occurred during an execution.
        public var lambdaFunctionTimedOutEventDetails: SFNClientTypes.LambdaFunctionTimedOutEventDetails?
        /// Contains details about an iteration of a Map state that was aborted.
        public var mapIterationAbortedEventDetails: SFNClientTypes.MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that failed.
        public var mapIterationFailedEventDetails: SFNClientTypes.MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that was started.
        public var mapIterationStartedEventDetails: SFNClientTypes.MapIterationEventDetails?
        /// Contains details about an iteration of a Map state that succeeded.
        public var mapIterationSucceededEventDetails: SFNClientTypes.MapIterationEventDetails?
        /// Contains error and cause details about a Map Run that failed.
        public var mapRunFailedEventDetails: SFNClientTypes.MapRunFailedEventDetails?
        /// Contains details about the redrive attempt of a Map Run.
        public var mapRunRedrivenEventDetails: SFNClientTypes.MapRunRedrivenEventDetails?
        /// Contains details, such as mapRunArn, and the start date and time of a Map Run. mapRunArn is the Amazon Resource Name (ARN) of the Map Run that was started.
        public var mapRunStartedEventDetails: SFNClientTypes.MapRunStartedEventDetails?
        /// Contains details about Map state that was started.
        public var mapStateStartedEventDetails: SFNClientTypes.MapStateStartedEventDetails?
        /// The id of the previous event.
        public var previousEventId: Swift.Int
        /// Contains details about a state entered during an execution.
        public var stateEnteredEventDetails: SFNClientTypes.StateEnteredEventDetails?
        /// Contains details about an exit from a state during an execution.
        public var stateExitedEventDetails: SFNClientTypes.StateExitedEventDetails?
        /// Contains details about the failure of a task.
        public var taskFailedEventDetails: SFNClientTypes.TaskFailedEventDetails?
        /// Contains details about a task that was scheduled.
        public var taskScheduledEventDetails: SFNClientTypes.TaskScheduledEventDetails?
        /// Contains details about a task that failed to start.
        public var taskStartFailedEventDetails: SFNClientTypes.TaskStartFailedEventDetails?
        /// Contains details about a task that was started.
        public var taskStartedEventDetails: SFNClientTypes.TaskStartedEventDetails?
        /// Contains details about a task that where the submit failed.
        public var taskSubmitFailedEventDetails: SFNClientTypes.TaskSubmitFailedEventDetails?
        /// Contains details about a submitted task.
        public var taskSubmittedEventDetails: SFNClientTypes.TaskSubmittedEventDetails?
        /// Contains details about a task that succeeded.
        public var taskSucceededEventDetails: SFNClientTypes.TaskSucceededEventDetails?
        /// Contains details about a task that timed out.
        public var taskTimedOutEventDetails: SFNClientTypes.TaskTimedOutEventDetails?
        /// The date and time the event occurred.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The type of the event.
        /// This member is required.
        public var type: SFNClientTypes.HistoryEventType?

        public init(
            activityFailedEventDetails: SFNClientTypes.ActivityFailedEventDetails? = nil,
            activityScheduleFailedEventDetails: SFNClientTypes.ActivityScheduleFailedEventDetails? = nil,
            activityScheduledEventDetails: SFNClientTypes.ActivityScheduledEventDetails? = nil,
            activityStartedEventDetails: SFNClientTypes.ActivityStartedEventDetails? = nil,
            activitySucceededEventDetails: SFNClientTypes.ActivitySucceededEventDetails? = nil,
            activityTimedOutEventDetails: SFNClientTypes.ActivityTimedOutEventDetails? = nil,
            executionAbortedEventDetails: SFNClientTypes.ExecutionAbortedEventDetails? = nil,
            executionFailedEventDetails: SFNClientTypes.ExecutionFailedEventDetails? = nil,
            executionRedrivenEventDetails: SFNClientTypes.ExecutionRedrivenEventDetails? = nil,
            executionStartedEventDetails: SFNClientTypes.ExecutionStartedEventDetails? = nil,
            executionSucceededEventDetails: SFNClientTypes.ExecutionSucceededEventDetails? = nil,
            executionTimedOutEventDetails: SFNClientTypes.ExecutionTimedOutEventDetails? = nil,
            id: Swift.Int = 0,
            lambdaFunctionFailedEventDetails: SFNClientTypes.LambdaFunctionFailedEventDetails? = nil,
            lambdaFunctionScheduleFailedEventDetails: SFNClientTypes.LambdaFunctionScheduleFailedEventDetails? = nil,
            lambdaFunctionScheduledEventDetails: SFNClientTypes.LambdaFunctionScheduledEventDetails? = nil,
            lambdaFunctionStartFailedEventDetails: SFNClientTypes.LambdaFunctionStartFailedEventDetails? = nil,
            lambdaFunctionSucceededEventDetails: SFNClientTypes.LambdaFunctionSucceededEventDetails? = nil,
            lambdaFunctionTimedOutEventDetails: SFNClientTypes.LambdaFunctionTimedOutEventDetails? = nil,
            mapIterationAbortedEventDetails: SFNClientTypes.MapIterationEventDetails? = nil,
            mapIterationFailedEventDetails: SFNClientTypes.MapIterationEventDetails? = nil,
            mapIterationStartedEventDetails: SFNClientTypes.MapIterationEventDetails? = nil,
            mapIterationSucceededEventDetails: SFNClientTypes.MapIterationEventDetails? = nil,
            mapRunFailedEventDetails: SFNClientTypes.MapRunFailedEventDetails? = nil,
            mapRunRedrivenEventDetails: SFNClientTypes.MapRunRedrivenEventDetails? = nil,
            mapRunStartedEventDetails: SFNClientTypes.MapRunStartedEventDetails? = nil,
            mapStateStartedEventDetails: SFNClientTypes.MapStateStartedEventDetails? = nil,
            previousEventId: Swift.Int = 0,
            stateEnteredEventDetails: SFNClientTypes.StateEnteredEventDetails? = nil,
            stateExitedEventDetails: SFNClientTypes.StateExitedEventDetails? = nil,
            taskFailedEventDetails: SFNClientTypes.TaskFailedEventDetails? = nil,
            taskScheduledEventDetails: SFNClientTypes.TaskScheduledEventDetails? = nil,
            taskStartFailedEventDetails: SFNClientTypes.TaskStartFailedEventDetails? = nil,
            taskStartedEventDetails: SFNClientTypes.TaskStartedEventDetails? = nil,
            taskSubmitFailedEventDetails: SFNClientTypes.TaskSubmitFailedEventDetails? = nil,
            taskSubmittedEventDetails: SFNClientTypes.TaskSubmittedEventDetails? = nil,
            taskSucceededEventDetails: SFNClientTypes.TaskSucceededEventDetails? = nil,
            taskTimedOutEventDetails: SFNClientTypes.TaskTimedOutEventDetails? = nil,
            timestamp: Foundation.Date? = nil,
            type: SFNClientTypes.HistoryEventType? = nil
        )
        {
            self.activityFailedEventDetails = activityFailedEventDetails
            self.activityScheduleFailedEventDetails = activityScheduleFailedEventDetails
            self.activityScheduledEventDetails = activityScheduledEventDetails
            self.activityStartedEventDetails = activityStartedEventDetails
            self.activitySucceededEventDetails = activitySucceededEventDetails
            self.activityTimedOutEventDetails = activityTimedOutEventDetails
            self.executionAbortedEventDetails = executionAbortedEventDetails
            self.executionFailedEventDetails = executionFailedEventDetails
            self.executionRedrivenEventDetails = executionRedrivenEventDetails
            self.executionStartedEventDetails = executionStartedEventDetails
            self.executionSucceededEventDetails = executionSucceededEventDetails
            self.executionTimedOutEventDetails = executionTimedOutEventDetails
            self.id = id
            self.lambdaFunctionFailedEventDetails = lambdaFunctionFailedEventDetails
            self.lambdaFunctionScheduleFailedEventDetails = lambdaFunctionScheduleFailedEventDetails
            self.lambdaFunctionScheduledEventDetails = lambdaFunctionScheduledEventDetails
            self.lambdaFunctionStartFailedEventDetails = lambdaFunctionStartFailedEventDetails
            self.lambdaFunctionSucceededEventDetails = lambdaFunctionSucceededEventDetails
            self.lambdaFunctionTimedOutEventDetails = lambdaFunctionTimedOutEventDetails
            self.mapIterationAbortedEventDetails = mapIterationAbortedEventDetails
            self.mapIterationFailedEventDetails = mapIterationFailedEventDetails
            self.mapIterationStartedEventDetails = mapIterationStartedEventDetails
            self.mapIterationSucceededEventDetails = mapIterationSucceededEventDetails
            self.mapRunFailedEventDetails = mapRunFailedEventDetails
            self.mapRunRedrivenEventDetails = mapRunRedrivenEventDetails
            self.mapRunStartedEventDetails = mapRunStartedEventDetails
            self.mapStateStartedEventDetails = mapStateStartedEventDetails
            self.previousEventId = previousEventId
            self.stateEnteredEventDetails = stateEnteredEventDetails
            self.stateExitedEventDetails = stateExitedEventDetails
            self.taskFailedEventDetails = taskFailedEventDetails
            self.taskScheduledEventDetails = taskScheduledEventDetails
            self.taskStartFailedEventDetails = taskStartFailedEventDetails
            self.taskStartedEventDetails = taskStartedEventDetails
            self.taskSubmitFailedEventDetails = taskSubmitFailedEventDetails
            self.taskSubmittedEventDetails = taskSubmittedEventDetails
            self.taskSucceededEventDetails = taskSucceededEventDetails
            self.taskTimedOutEventDetails = taskTimedOutEventDetails
            self.timestamp = timestamp
            self.type = type
        }
    }

}

public struct GetExecutionHistoryOutput {
    /// The list of events that occurred in the execution.
    /// This member is required.
    public var events: [SFNClientTypes.HistoryEvent]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        events: [SFNClientTypes.HistoryEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

public struct ListActivitiesInput {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListActivitiesOutput {
    /// The list of activities.
    /// This member is required.
    public var activities: [SFNClientTypes.ActivityListItem]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        activities: [SFNClientTypes.ActivityListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activities = activities
        self.nextToken = nextToken
    }
}

extension SFNClientTypes {

    public enum ExecutionRedriveFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notRedriven
        case redriven
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionRedriveFilter] {
            return [
                .notRedriven,
                .redriven
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notRedriven: return "NOT_REDRIVEN"
            case .redriven: return "REDRIVEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListExecutionsInput {
    /// The Amazon Resource Name (ARN) of the Map Run that started the child workflow executions. If the mapRunArn field is specified, a list of all of the child workflow executions started by a Map Run is returned. For more information, see [Examining Map Run](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-examine-map-run.html) in the Step Functions Developer Guide. You can specify either a mapRunArn or a stateMachineArn, but not both.
    public var mapRunArn: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// Sets a filter to list executions based on whether or not they have been redriven. For a Distributed Map, redriveFilter sets a filter to list child workflow executions based on whether or not they have been redriven. If you do not provide a redriveFilter, Step Functions returns a list of both redriven and non-redriven executions. If you provide a state machine ARN in redriveFilter, the API returns a validation exception.
    public var redriveFilter: SFNClientTypes.ExecutionRedriveFilter?
    /// The Amazon Resource Name (ARN) of the state machine whose executions is listed. You can specify either a mapRunArn or a stateMachineArn, but not both. You can also return a list of executions associated with a specific [alias](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html) or [version](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html), by specifying an alias ARN or a version ARN in the stateMachineArn parameter.
    public var stateMachineArn: Swift.String?
    /// If specified, only list the executions whose current execution status matches the given filter.
    public var statusFilter: SFNClientTypes.ExecutionStatus?

    public init(
        mapRunArn: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        redriveFilter: SFNClientTypes.ExecutionRedriveFilter? = nil,
        stateMachineArn: Swift.String? = nil,
        statusFilter: SFNClientTypes.ExecutionStatus? = nil
    )
    {
        self.mapRunArn = mapRunArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.redriveFilter = redriveFilter
        self.stateMachineArn = stateMachineArn
        self.statusFilter = statusFilter
    }
}

extension SFNClientTypes {
    /// Contains details about an execution.
    public struct ExecutionListItem {
        /// The Amazon Resource Name (ARN) that identifies the execution.
        /// This member is required.
        public var executionArn: Swift.String?
        /// The total number of items processed in a child workflow execution. This field is returned only if mapRunArn was specified in the ListExecutions API action. If stateMachineArn was specified in ListExecutions, the itemCount field isn't returned.
        public var itemCount: Swift.Int?
        /// The Amazon Resource Name (ARN) of a Map Run. This field is returned only if mapRunArn was specified in the ListExecutions API action. If stateMachineArn was specified in ListExecutions, the mapRunArn isn't returned.
        public var mapRunArn: Swift.String?
        /// The name of the execution. A name must not contain:
        ///
        /// * white space
        ///
        /// * brackets < > { } [ ]
        ///
        /// * wildcard characters ? *
        ///
        /// * special characters " # % \ ^ | ~ ` $ & , ; : /
        ///
        /// * control characters (U+0000-001F, U+007F-009F)
        ///
        ///
        /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        /// This member is required.
        public var name: Swift.String?
        /// The number of times you've redriven an execution. If you have not yet redriven an execution, the redriveCount is 0. This count is only updated when you successfully redrive an execution.
        public var redriveCount: Swift.Int?
        /// The date the execution was last redriven.
        public var redriveDate: Foundation.Date?
        /// The date the execution started.
        /// This member is required.
        public var startDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the state machine alias used to start an execution. If the state machine execution was started with an unqualified ARN or a version ARN, it returns null.
        public var stateMachineAliasArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the state machine that ran the execution.
        /// This member is required.
        public var stateMachineArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the state machine version associated with the execution. If the state machine execution was started with an unqualified ARN, it returns null. If the execution was started using a stateMachineAliasArn, both the stateMachineAliasArn and stateMachineVersionArn parameters contain the respective values.
        public var stateMachineVersionArn: Swift.String?
        /// The current status of the execution.
        /// This member is required.
        public var status: SFNClientTypes.ExecutionStatus?
        /// If the execution already ended, the date the execution stopped.
        public var stopDate: Foundation.Date?

        public init(
            executionArn: Swift.String? = nil,
            itemCount: Swift.Int? = 0,
            mapRunArn: Swift.String? = nil,
            name: Swift.String? = nil,
            redriveCount: Swift.Int? = nil,
            redriveDate: Foundation.Date? = nil,
            startDate: Foundation.Date? = nil,
            stateMachineAliasArn: Swift.String? = nil,
            stateMachineArn: Swift.String? = nil,
            stateMachineVersionArn: Swift.String? = nil,
            status: SFNClientTypes.ExecutionStatus? = nil,
            stopDate: Foundation.Date? = nil
        )
        {
            self.executionArn = executionArn
            self.itemCount = itemCount
            self.mapRunArn = mapRunArn
            self.name = name
            self.redriveCount = redriveCount
            self.redriveDate = redriveDate
            self.startDate = startDate
            self.stateMachineAliasArn = stateMachineAliasArn
            self.stateMachineArn = stateMachineArn
            self.stateMachineVersionArn = stateMachineVersionArn
            self.status = status
            self.stopDate = stopDate
        }
    }

}

public struct ListExecutionsOutput {
    /// The list of matching executions.
    /// This member is required.
    public var executions: [SFNClientTypes.ExecutionListItem]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        executions: [SFNClientTypes.ExecutionListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
    }
}

public struct ListMapRunsInput {
    /// The Amazon Resource Name (ARN) of the execution for which the Map Runs must be listed.
    /// This member is required.
    public var executionArn: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        executionArn: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.executionArn = executionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SFNClientTypes {
    /// Contains details about a specific Map Run.
    public struct MapRunListItem {
        /// The executionArn of the execution from which the Map Run was started.
        /// This member is required.
        public var executionArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Map Run.
        /// This member is required.
        public var mapRunArn: Swift.String?
        /// The date on which the Map Run started.
        /// This member is required.
        public var startDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the executed state machine.
        /// This member is required.
        public var stateMachineArn: Swift.String?
        /// The date on which the Map Run stopped.
        public var stopDate: Foundation.Date?

        public init(
            executionArn: Swift.String? = nil,
            mapRunArn: Swift.String? = nil,
            startDate: Foundation.Date? = nil,
            stateMachineArn: Swift.String? = nil,
            stopDate: Foundation.Date? = nil
        )
        {
            self.executionArn = executionArn
            self.mapRunArn = mapRunArn
            self.startDate = startDate
            self.stateMachineArn = stateMachineArn
            self.stopDate = stopDate
        }
    }

}

public struct ListMapRunsOutput {
    /// An array that lists information related to a Map Run, such as the Amazon Resource Name (ARN) of the Map Run and the ARN of the state machine that started the Map Run.
    /// This member is required.
    public var mapRuns: [SFNClientTypes.MapRunListItem]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        mapRuns: [SFNClientTypes.MapRunListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mapRuns = mapRuns
        self.nextToken = nextToken
    }
}

public struct ListStateMachineAliasesInput {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine for which you want to list aliases. If you specify a state machine version ARN, this API returns a list of aliases for that version.
    /// This member is required.
    public var stateMachineArn: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateMachineArn = stateMachineArn
    }
}

extension SFNClientTypes {
    /// Contains details about a specific state machine alias.
    public struct StateMachineAliasListItem {
        /// The creation date of a state machine alias.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) that identifies a state machine alias. The alias ARN is a combination of state machine ARN and the alias name separated by a colon (:). For example, stateMachineARN:PROD.
        /// This member is required.
        public var stateMachineAliasArn: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            stateMachineAliasArn: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.stateMachineAliasArn = stateMachineAliasArn
        }
    }

}

public struct ListStateMachineAliasesOutput {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// Aliases for the state machine.
    /// This member is required.
    public var stateMachineAliases: [SFNClientTypes.StateMachineAliasListItem]?

    public init(
        nextToken: Swift.String? = nil,
        stateMachineAliases: [SFNClientTypes.StateMachineAliasListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.stateMachineAliases = stateMachineAliases
    }
}

public struct ListStateMachinesInput {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SFNClientTypes {
    /// Contains details about the state machine.
    public struct StateMachineListItem {
        /// The date the state machine is created.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// The name of the state machine. A name must not contain:
        ///
        /// * white space
        ///
        /// * brackets < > { } [ ]
        ///
        /// * wildcard characters ? *
        ///
        /// * special characters " # % \ ^ | ~ ` $ & , ; : /
        ///
        /// * control characters (U+0000-001F, U+007F-009F)
        ///
        ///
        /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies the state machine.
        /// This member is required.
        public var stateMachineArn: Swift.String?
        ///
        /// This member is required.
        public var type: SFNClientTypes.StateMachineType?

        public init(
            creationDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            stateMachineArn: Swift.String? = nil,
            type: SFNClientTypes.StateMachineType? = nil
        )
        {
            self.creationDate = creationDate
            self.name = name
            self.stateMachineArn = stateMachineArn
            self.type = type
        }
    }

}

public struct ListStateMachinesOutput {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// This member is required.
    public var stateMachines: [SFNClientTypes.StateMachineListItem]?

    public init(
        nextToken: Swift.String? = nil,
        stateMachines: [SFNClientTypes.StateMachineListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.stateMachines = stateMachines
    }
}

public struct ListStateMachineVersionsInput {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default is 100 and the maximum allowed page size is 1000. A value of 0 uses the default. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine.
    /// This member is required.
    public var stateMachineArn: Swift.String?

    public init(
        maxResults: Swift.Int? = 0,
        nextToken: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stateMachineArn = stateMachineArn
    }
}

extension SFNClientTypes {
    /// Contains details about a specific state machine version.
    public struct StateMachineVersionListItem {
        /// The creation date of a state machine version.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// The Amazon Resource Name (ARN) that identifies a state machine version. The version ARN is a combination of state machine ARN and the version number separated by a colon (:). For example, stateMachineARN:1.
        /// This member is required.
        public var stateMachineVersionArn: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            stateMachineVersionArn: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.stateMachineVersionArn = stateMachineVersionArn
        }
    }

}

public struct ListStateMachineVersionsOutput {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// Versions for the state machine.
    /// This member is required.
    public var stateMachineVersions: [SFNClientTypes.StateMachineVersionListItem]?

    public init(
        nextToken: Swift.String? = nil,
        stateMachineVersions: [SFNClientTypes.StateMachineVersionListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.stateMachineVersions = stateMachineVersions
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// An array of tags associated with the resource.
    public var tags: [SFNClientTypes.Tag]?

    public init(
        tags: [SFNClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PublishStateMachineVersionInput {
    /// An optional description of the state machine version.
    public var description: Swift.String?
    /// Only publish the state machine version if the current state machine's revision ID matches the specified ID. Use this option to avoid publishing a version if the state machine changed since you last updated it. If the specified revision ID doesn't match the state machine's current revision ID, the API returns ConflictException. To specify an initial revision ID for a state machine with no revision ID assigned, specify the string INITIAL for the revisionId parameter. For example, you can specify a revisionID of INITIAL when you create a state machine using the [CreateStateMachine] API action.
    public var revisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine.
    /// This member is required.
    public var stateMachineArn: Swift.String?

    public init(
        description: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil
    )
    {
        self.description = description
        self.revisionId = revisionId
        self.stateMachineArn = stateMachineArn
    }
}

extension PublishStateMachineVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishStateMachineVersionInput(revisionId: \(Swift.String(describing: revisionId)), stateMachineArn: \(Swift.String(describing: stateMachineArn)), description: \"CONTENT_REDACTED\")"}
}

public struct PublishStateMachineVersionOutput {
    /// The date the version was created.
    /// This member is required.
    public var creationDate: Foundation.Date?
    /// The Amazon Resource Name (ARN) (ARN) that identifies the state machine version.
    /// This member is required.
    public var stateMachineVersionArn: Swift.String?

    public init(
        creationDate: Foundation.Date? = nil,
        stateMachineVersionArn: Swift.String? = nil
    )
    {
        self.creationDate = creationDate
        self.stateMachineVersionArn = stateMachineVersionArn
    }
}

/// The maximum number of running executions has been reached. Running executions must end or be stopped before a new execution can be started.
public struct ExecutionLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExecutionLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The execution Amazon Resource Name (ARN) that you specified for executionArn cannot be redriven.
public struct ExecutionNotRedrivable: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExecutionNotRedrivable" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct RedriveExecutionInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency. The API will return idempotent responses for the last 10 client tokens used to successfully redrive the execution. These client tokens are valid for up to 15 minutes after they are first used.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the execution to be redriven.
    /// This member is required.
    public var executionArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        executionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.executionArn = executionArn
    }
}

public struct RedriveExecutionOutput {
    /// The date the execution was last redriven.
    /// This member is required.
    public var redriveDate: Foundation.Date?

    public init(
        redriveDate: Foundation.Date? = nil
    )
    {
        self.redriveDate = redriveDate
    }
}

/// The activity does not exist.
public struct TaskDoesNotExist: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TaskDoesNotExist" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The task token has either expired or the task associated with the token has already been closed.
public struct TaskTimedOut: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TaskTimedOut" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct SendTaskFailureInput {
    /// A more detailed explanation of the cause of the failure.
    public var cause: Swift.String?
    /// The error code of the failure.
    public var error: Swift.String?
    /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the [context object](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-contextobject.html) when a workflow enters a task state. See [GetActivityTaskOutput$taskToken].
    /// This member is required.
    public var taskToken: Swift.String?

    public init(
        cause: Swift.String? = nil,
        error: Swift.String? = nil,
        taskToken: Swift.String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.taskToken = taskToken
    }
}

extension SendTaskFailureInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendTaskFailureInput(taskToken: \(Swift.String(describing: taskToken)), cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

public struct SendTaskFailureOutput {

    public init() { }
}

public struct SendTaskHeartbeatInput {
    /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the [context object](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-contextobject.html) when a workflow enters a task state. See [GetActivityTaskOutput$taskToken].
    /// This member is required.
    public var taskToken: Swift.String?

    public init(
        taskToken: Swift.String? = nil
    )
    {
        self.taskToken = taskToken
    }
}

public struct SendTaskHeartbeatOutput {

    public init() { }
}

/// The provided JSON output data is not valid.
public struct InvalidOutput: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOutput" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct SendTaskSuccessInput {
    /// The JSON output of the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    /// This member is required.
    public var output: Swift.String?
    /// The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the [context object](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-contextobject.html) when a workflow enters a task state. See [GetActivityTaskOutput$taskToken].
    /// This member is required.
    public var taskToken: Swift.String?

    public init(
        output: Swift.String? = nil,
        taskToken: Swift.String? = nil
    )
    {
        self.output = output
        self.taskToken = taskToken
    }
}

extension SendTaskSuccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendTaskSuccessInput(taskToken: \(Swift.String(describing: taskToken)), output: \"CONTENT_REDACTED\")"}
}

public struct SendTaskSuccessOutput {

    public init() { }
}

/// The execution has the same name as another execution (but a different input). Executions with the same name and input are considered idempotent.
public struct ExecutionAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExecutionAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The provided JSON input data is not valid.
public struct InvalidExecutionInput: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidExecutionInput" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartExecutionInput {
    /// The string that contains the JSON input data for the execution, for example: "input": "{\"first_name\" : \"test\"}" If you don't include any JSON input data, you still must include the two braces, for example: "input": "{}" Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// Optional name of the execution. This name must be unique for your Amazon Web Services account, Region, and state machine for 90 days. For more information, see [ Limits Related to State Machine Executions](https://docs.aws.amazon.com/step-functions/latest/dg/limits.html#service-limits-state-machine-executions) in the Step Functions Developer Guide. If you don't provide a name for the execution, Step Functions automatically generates a universally unique identifier (UUID) as the execution name. A name must not contain:
    ///
    /// * white space
    ///
    /// * brackets < > { } [ ]
    ///
    /// * wildcard characters ? *
    ///
    /// * special characters " # % \ ^ | ~ ` $ & , ; : /
    ///
    /// * control characters (U+0000-001F, U+007F-009F)
    ///
    ///
    /// To enable logging with CloudWatch Logs, the name should only contain 0-9, A-Z, a-z, - and _.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine to execute. The stateMachineArn parameter accepts one of the following inputs:
    ///
    /// * An unqualified state machine ARN – Refers to a state machine ARN that isn't qualified with a version or alias ARN. The following is an example of an unqualified state machine ARN. arn::states:::stateMachine: Step Functions doesn't associate state machine executions that you start with an unqualified ARN with a version. This is true even if that version uses the same revision that the execution used.
    ///
    /// * A state machine version ARN – Refers to a version ARN, which is a combination of state machine ARN and the version number separated by a colon (:). The following is an example of the ARN for version 10. arn::states:::stateMachine::10 Step Functions doesn't associate executions that you start with a version ARN with any aliases that point to that version.
    ///
    /// * A state machine alias ARN – Refers to an alias ARN, which is a combination of state machine ARN and the alias name separated by a colon (:). The following is an example of the ARN for an alias named PROD. arn::states:::stateMachine: Step Functions associates executions that you start with an alias ARN with that alias and the state machine version used for that execution.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// Passes the X-Ray trace header. The trace header can also be passed in the request payload.
    public var traceHeader: Swift.String?

    public init(
        input: Swift.String? = nil,
        name: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        traceHeader: Swift.String? = nil
    )
    {
        self.input = input
        self.name = name
        self.stateMachineArn = stateMachineArn
        self.traceHeader = traceHeader
    }
}

extension StartExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartExecutionInput(name: \(Swift.String(describing: name)), stateMachineArn: \(Swift.String(describing: stateMachineArn)), traceHeader: \(Swift.String(describing: traceHeader)), input: \"CONTENT_REDACTED\")"}
}

public struct StartExecutionOutput {
    /// The Amazon Resource Name (ARN) that identifies the execution.
    /// This member is required.
    public var executionArn: Swift.String?
    /// The date the execution is started.
    /// This member is required.
    public var startDate: Foundation.Date?

    public init(
        executionArn: Swift.String? = nil,
        startDate: Foundation.Date? = nil
    )
    {
        self.executionArn = executionArn
        self.startDate = startDate
    }
}

public struct StartSyncExecutionInput {
    /// If your state machine definition is encrypted with a KMS key, callers must have kms:Decrypt permission to decrypt the definition. Alternatively, you can call the API with includedData = METADATA_ONLY to get a successful response without the encrypted definition.
    public var includedData: SFNClientTypes.IncludedData?
    /// The string that contains the JSON input data for the execution, for example: "input": "{\"first_name\" : \"test\"}" If you don't include any JSON input data, you still must include the two braces, for example: "input": "{}" Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// The name of the execution.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine to execute.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// Passes the X-Ray trace header. The trace header can also be passed in the request payload.
    public var traceHeader: Swift.String?

    public init(
        includedData: SFNClientTypes.IncludedData? = nil,
        input: Swift.String? = nil,
        name: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        traceHeader: Swift.String? = nil
    )
    {
        self.includedData = includedData
        self.input = input
        self.name = name
        self.stateMachineArn = stateMachineArn
        self.traceHeader = traceHeader
    }
}

extension StartSyncExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSyncExecutionInput(includedData: \(Swift.String(describing: includedData)), name: \(Swift.String(describing: name)), stateMachineArn: \(Swift.String(describing: stateMachineArn)), traceHeader: \(Swift.String(describing: traceHeader)), input: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// An object that describes workflow billing details.
    public struct BillingDetails {
        /// Billed duration of your workflow, in milliseconds.
        public var billedDurationInMilliseconds: Swift.Int
        /// Billed memory consumption of your workflow, in MB.
        public var billedMemoryUsedInMB: Swift.Int

        public init(
            billedDurationInMilliseconds: Swift.Int = 0,
            billedMemoryUsedInMB: Swift.Int = 0
        )
        {
            self.billedDurationInMilliseconds = billedDurationInMilliseconds
            self.billedMemoryUsedInMB = billedMemoryUsedInMB
        }
    }

}

extension SFNClientTypes {

    public enum SyncExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncExecutionStatus] {
            return [
                .failed,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartSyncExecutionOutput {
    /// An object that describes workflow billing details, including billed duration and memory use.
    public var billingDetails: SFNClientTypes.BillingDetails?
    /// A more detailed explanation of the cause of the failure.
    public var cause: Swift.String?
    /// The error code of the failure.
    public var error: Swift.String?
    /// The Amazon Resource Name (ARN) that identifies the execution.
    /// This member is required.
    public var executionArn: Swift.String?
    /// The string that contains the JSON input data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var input: Swift.String?
    /// Provides details about execution input or output.
    public var inputDetails: SFNClientTypes.CloudWatchEventsExecutionDataDetails?
    /// The name of the execution.
    public var name: Swift.String?
    /// The JSON output data of the execution. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding. This field is set only if the execution succeeds. If the execution fails, this field is null.
    public var output: Swift.String?
    /// Provides details about execution input or output.
    public var outputDetails: SFNClientTypes.CloudWatchEventsExecutionDataDetails?
    /// The date the execution is started.
    /// This member is required.
    public var startDate: Foundation.Date?
    /// The Amazon Resource Name (ARN) that identifies the state machine.
    public var stateMachineArn: Swift.String?
    /// The current status of the execution.
    /// This member is required.
    public var status: SFNClientTypes.SyncExecutionStatus?
    /// If the execution has already ended, the date the execution stopped.
    /// This member is required.
    public var stopDate: Foundation.Date?
    /// The X-Ray trace header that was passed to the execution.
    public var traceHeader: Swift.String?

    public init(
        billingDetails: SFNClientTypes.BillingDetails? = nil,
        cause: Swift.String? = nil,
        error: Swift.String? = nil,
        executionArn: Swift.String? = nil,
        input: Swift.String? = nil,
        inputDetails: SFNClientTypes.CloudWatchEventsExecutionDataDetails? = nil,
        name: Swift.String? = nil,
        output: Swift.String? = nil,
        outputDetails: SFNClientTypes.CloudWatchEventsExecutionDataDetails? = nil,
        startDate: Foundation.Date? = nil,
        stateMachineArn: Swift.String? = nil,
        status: SFNClientTypes.SyncExecutionStatus? = nil,
        stopDate: Foundation.Date? = nil,
        traceHeader: Swift.String? = nil
    )
    {
        self.billingDetails = billingDetails
        self.cause = cause
        self.error = error
        self.executionArn = executionArn
        self.input = input
        self.inputDetails = inputDetails
        self.name = name
        self.output = output
        self.outputDetails = outputDetails
        self.startDate = startDate
        self.stateMachineArn = stateMachineArn
        self.status = status
        self.stopDate = stopDate
        self.traceHeader = traceHeader
    }
}

extension StartSyncExecutionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSyncExecutionOutput(billingDetails: \(Swift.String(describing: billingDetails)), executionArn: \(Swift.String(describing: executionArn)), inputDetails: \(Swift.String(describing: inputDetails)), name: \(Swift.String(describing: name)), outputDetails: \(Swift.String(describing: outputDetails)), startDate: \(Swift.String(describing: startDate)), stateMachineArn: \(Swift.String(describing: stateMachineArn)), status: \(Swift.String(describing: status)), stopDate: \(Swift.String(describing: stopDate)), traceHeader: \(Swift.String(describing: traceHeader)), cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\", input: \"CONTENT_REDACTED\", output: \"CONTENT_REDACTED\")"}
}

public struct StopExecutionInput {
    /// A more detailed explanation of the cause of the failure.
    public var cause: Swift.String?
    /// The error code of the failure.
    public var error: Swift.String?
    /// The Amazon Resource Name (ARN) of the execution to stop.
    /// This member is required.
    public var executionArn: Swift.String?

    public init(
        cause: Swift.String? = nil,
        error: Swift.String? = nil,
        executionArn: Swift.String? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.executionArn = executionArn
    }
}

extension StopExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopExecutionInput(executionArn: \(Swift.String(describing: executionArn)), cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\")"}
}

public struct StopExecutionOutput {
    /// The date the execution is stopped.
    /// This member is required.
    public var stopDate: Foundation.Date?

    public init(
        stopDate: Foundation.Date? = nil
    )
    {
        self.stopDate = stopDate
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to add to a resource. Tags may only contain Unicode letters, digits, white space, or these symbols: _ . : / = + - @.
    /// This member is required.
    public var tags: [SFNClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [SFNClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

extension SFNClientTypes {

    public enum InspectionLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case info
        case trace
        case sdkUnknown(Swift.String)

        public static var allCases: [InspectionLevel] {
            return [
                .debug,
                .info,
                .trace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .info: return "INFO"
            case .trace: return "TRACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct TestStateInput {
    /// The [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html) (ASL) definition of the state.
    /// This member is required.
    public var definition: Swift.String?
    /// A string that contains the JSON input data for the state.
    public var input: Swift.String?
    /// Determines the values to return when a state is tested. You can specify one of the following types:
    ///
    /// * INFO: Shows the final state output. By default, Step Functions sets inspectionLevel to INFO if you don't specify a level.
    ///
    /// * DEBUG: Shows the final state output along with the input and output data processing result.
    ///
    /// * TRACE: Shows the HTTP request and response for an HTTP Task. This level also shows the final state output along with the input and output data processing result.
    ///
    ///
    /// Each of these levels also provide information about the status of the state execution and the next state to transition to.
    public var inspectionLevel: SFNClientTypes.InspectionLevel?
    /// Specifies whether or not to include secret information in the test result. For HTTP Tasks, a secret includes the data that an EventBridge connection adds to modify the HTTP request headers, query parameters, and body. Step Functions doesn't omit any information included in the state definition or the HTTP response. If you set revealSecrets to true, you must make sure that the IAM user that calls the TestState API has permission for the states:RevealSecrets action. For an example of IAM policy that sets the states:RevealSecrets permission, see [IAM permissions to test a state](https://docs.aws.amazon.com/step-functions/latest/dg/test-state-isolation.html#test-state-permissions). Without this permission, Step Functions throws an access denied error. By default, revealSecrets is set to false.
    public var revealSecrets: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the execution role with the required IAM permissions for the state.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        definition: Swift.String? = nil,
        input: Swift.String? = nil,
        inspectionLevel: SFNClientTypes.InspectionLevel? = nil,
        revealSecrets: Swift.Bool? = false,
        roleArn: Swift.String? = nil
    )
    {
        self.definition = definition
        self.input = input
        self.inspectionLevel = inspectionLevel
        self.revealSecrets = revealSecrets
        self.roleArn = roleArn
    }
}

extension TestStateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestStateInput(inspectionLevel: \(Swift.String(describing: inspectionLevel)), revealSecrets: \(Swift.String(describing: revealSecrets)), roleArn: \(Swift.String(describing: roleArn)), definition: \"CONTENT_REDACTED\", input: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Contains additional details about the state's execution, including its input and output data processing flow, and HTTP request information.
    public struct InspectionDataRequest {
        /// The request body for the HTTP request.
        public var body: Swift.String?
        /// The request headers associated with the HTTP request.
        public var headers: Swift.String?
        /// The HTTP method used for the HTTP request.
        public var method: Swift.String?
        /// The protocol used to make the HTTP request.
        public var `protocol`: Swift.String?
        /// The API endpoint used for the HTTP request.
        public var url: Swift.String?

        public init(
            body: Swift.String? = nil,
            headers: Swift.String? = nil,
            method: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.body = body
            self.headers = headers
            self.method = method
            self.`protocol` = `protocol`
            self.url = url
        }
    }

}

extension SFNClientTypes {
    /// Contains additional details about the state's execution, including its input and output data processing flow, and HTTP response information. The inspectionLevel request parameter specifies which details are returned.
    public struct InspectionDataResponse {
        /// The HTTP response returned.
        public var body: Swift.String?
        /// The response headers associated with the HTTP response.
        public var headers: Swift.String?
        /// The protocol used to return the HTTP response.
        public var `protocol`: Swift.String?
        /// The HTTP response status code for the HTTP response.
        public var statusCode: Swift.String?
        /// The message associated with the HTTP status code.
        public var statusMessage: Swift.String?

        public init(
            body: Swift.String? = nil,
            headers: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            statusCode: Swift.String? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.body = body
            self.headers = headers
            self.`protocol` = `protocol`
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }
    }

}

extension SFNClientTypes {
    /// Contains additional details about the state's execution, including its input and output data processing flow, and HTTP request and response information.
    public struct InspectionData {
        /// The input after Step Functions applies the [InputPath](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-inputpath) filter.
        public var afterInputPath: Swift.String?
        /// The effective input after Step Functions applies the [Parameters](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-parameters) filter.
        public var afterParameters: Swift.String?
        /// The effective result combined with the raw state input after Step Functions applies the [ResultPath](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-resultpath.html) filter.
        public var afterResultPath: Swift.String?
        /// The effective result after Step Functions applies the [ResultSelector](https://docs.aws.amazon.com/step-functions/latest/dg/input-output-inputpath-params.html#input-output-resultselector) filter.
        public var afterResultSelector: Swift.String?
        /// The raw state input.
        public var input: Swift.String?
        /// The raw HTTP request that is sent when you test an HTTP Task.
        public var request: SFNClientTypes.InspectionDataRequest?
        /// The raw HTTP response that is returned when you test an HTTP Task.
        public var response: SFNClientTypes.InspectionDataResponse?
        /// The state's raw result.
        public var result: Swift.String?

        public init(
            afterInputPath: Swift.String? = nil,
            afterParameters: Swift.String? = nil,
            afterResultPath: Swift.String? = nil,
            afterResultSelector: Swift.String? = nil,
            input: Swift.String? = nil,
            request: SFNClientTypes.InspectionDataRequest? = nil,
            response: SFNClientTypes.InspectionDataResponse? = nil,
            result: Swift.String? = nil
        )
        {
            self.afterInputPath = afterInputPath
            self.afterParameters = afterParameters
            self.afterResultPath = afterResultPath
            self.afterResultSelector = afterResultSelector
            self.input = input
            self.request = request
            self.response = response
            self.result = result
        }
    }

}

extension SFNClientTypes.InspectionData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension SFNClientTypes {

    public enum TestExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case caughtError
        case failed
        case retriable
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [TestExecutionStatus] {
            return [
                .caughtError,
                .failed,
                .retriable,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .caughtError: return "CAUGHT_ERROR"
            case .failed: return "FAILED"
            case .retriable: return "RETRIABLE"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct TestStateOutput {
    /// A detailed explanation of the cause for the error when the execution of a state fails.
    public var cause: Swift.String?
    /// The error returned when the execution of a state fails.
    public var error: Swift.String?
    /// Returns additional details about the state's execution, including its input and output data processing flow, and HTTP request and response information. The inspectionLevel request parameter specifies which details are returned.
    public var inspectionData: SFNClientTypes.InspectionData?
    /// The name of the next state to transition to. If you haven't defined a next state in your definition or if the execution of the state fails, this ﬁeld doesn't contain a value.
    public var nextState: Swift.String?
    /// The JSON output data of the state. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.
    public var output: Swift.String?
    /// The execution status of the state.
    public var status: SFNClientTypes.TestExecutionStatus?

    public init(
        cause: Swift.String? = nil,
        error: Swift.String? = nil,
        inspectionData: SFNClientTypes.InspectionData? = nil,
        nextState: Swift.String? = nil,
        output: Swift.String? = nil,
        status: SFNClientTypes.TestExecutionStatus? = nil
    )
    {
        self.cause = cause
        self.error = error
        self.inspectionData = inspectionData
        self.nextState = nextState
        self.output = output
        self.status = status
    }
}

extension TestStateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestStateOutput(nextState: \(Swift.String(describing: nextState)), status: \(Swift.String(describing: status)), cause: \"CONTENT_REDACTED\", error: \"CONTENT_REDACTED\", inspectionData: \"CONTENT_REDACTED\", output: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) for the Step Functions state machine or activity.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateMapRunInput {
    /// The Amazon Resource Name (ARN) of a Map Run.
    /// This member is required.
    public var mapRunArn: Swift.String?
    /// The maximum number of child workflow executions that can be specified to run in parallel for the Map Run at the same time.
    public var maxConcurrency: Swift.Int?
    /// The maximum number of failed items before the Map Run fails.
    public var toleratedFailureCount: Swift.Int?
    /// The maximum percentage of failed items before the Map Run fails.
    public var toleratedFailurePercentage: Swift.Float?

    public init(
        mapRunArn: Swift.String? = nil,
        maxConcurrency: Swift.Int? = 0,
        toleratedFailureCount: Swift.Int? = 0,
        toleratedFailurePercentage: Swift.Float? = 0.0
    )
    {
        self.mapRunArn = mapRunArn
        self.maxConcurrency = maxConcurrency
        self.toleratedFailureCount = toleratedFailureCount
        self.toleratedFailurePercentage = toleratedFailurePercentage
    }
}

public struct UpdateMapRunOutput {

    public init() { }
}

/// Request is missing a required parameter. This error occurs if both definition and roleArn are not specified.
public struct MissingRequiredParameter: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingRequiredParameter" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct UpdateStateMachineInput {
    /// The Amazon States Language definition of the state machine. See [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html).
    public var definition: Swift.String?
    /// Settings to configure server-side encryption.
    public var encryptionConfiguration: SFNClientTypes.EncryptionConfiguration?
    /// Use the LoggingConfiguration data type to set CloudWatch Logs options.
    public var loggingConfiguration: SFNClientTypes.LoggingConfiguration?
    /// Specifies whether the state machine version is published. The default is false. To publish a version after updating the state machine, set publish to true.
    public var publish: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role of the state machine.
    public var roleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the state machine.
    /// This member is required.
    public var stateMachineArn: Swift.String?
    /// Selects whether X-Ray tracing is enabled.
    public var tracingConfiguration: SFNClientTypes.TracingConfiguration?
    /// An optional description of the state machine version to publish. You can only specify the versionDescription parameter if you've set publish to true.
    public var versionDescription: Swift.String?

    public init(
        definition: Swift.String? = nil,
        encryptionConfiguration: SFNClientTypes.EncryptionConfiguration? = nil,
        loggingConfiguration: SFNClientTypes.LoggingConfiguration? = nil,
        publish: Swift.Bool? = false,
        roleArn: Swift.String? = nil,
        stateMachineArn: Swift.String? = nil,
        tracingConfiguration: SFNClientTypes.TracingConfiguration? = nil,
        versionDescription: Swift.String? = nil
    )
    {
        self.definition = definition
        self.encryptionConfiguration = encryptionConfiguration
        self.loggingConfiguration = loggingConfiguration
        self.publish = publish
        self.roleArn = roleArn
        self.stateMachineArn = stateMachineArn
        self.tracingConfiguration = tracingConfiguration
        self.versionDescription = versionDescription
    }
}

extension UpdateStateMachineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStateMachineInput(encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), loggingConfiguration: \(Swift.String(describing: loggingConfiguration)), publish: \(Swift.String(describing: publish)), roleArn: \(Swift.String(describing: roleArn)), stateMachineArn: \(Swift.String(describing: stateMachineArn)), tracingConfiguration: \(Swift.String(describing: tracingConfiguration)), definition: \"CONTENT_REDACTED\", versionDescription: \"CONTENT_REDACTED\")"}
}

public struct UpdateStateMachineOutput {
    /// The revision identifier for the updated state machine.
    public var revisionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the published state machine version. If the publish parameter isn't set to true, this field returns null.
    public var stateMachineVersionArn: Swift.String?
    /// The date and time the state machine was updated.
    /// This member is required.
    public var updateDate: Foundation.Date?

    public init(
        revisionId: Swift.String? = nil,
        stateMachineVersionArn: Swift.String? = nil,
        updateDate: Foundation.Date? = nil
    )
    {
        self.revisionId = revisionId
        self.stateMachineVersionArn = stateMachineVersionArn
        self.updateDate = updateDate
    }
}

public struct UpdateStateMachineAliasInput {
    /// A description of the state machine alias.
    public var description: Swift.String?
    /// The routing configuration of the state machine alias. An array of RoutingConfig objects that specifies up to two state machine versions that the alias starts executions for.
    public var routingConfiguration: [SFNClientTypes.RoutingConfigurationListItem]?
    /// The Amazon Resource Name (ARN) of the state machine alias.
    /// This member is required.
    public var stateMachineAliasArn: Swift.String?

    public init(
        description: Swift.String? = nil,
        routingConfiguration: [SFNClientTypes.RoutingConfigurationListItem]? = nil,
        stateMachineAliasArn: Swift.String? = nil
    )
    {
        self.description = description
        self.routingConfiguration = routingConfiguration
        self.stateMachineAliasArn = stateMachineAliasArn
    }
}

extension UpdateStateMachineAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStateMachineAliasInput(routingConfiguration: \(Swift.String(describing: routingConfiguration)), stateMachineAliasArn: \(Swift.String(describing: stateMachineAliasArn)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdateStateMachineAliasOutput {
    /// The date and time the state machine alias was updated.
    /// This member is required.
    public var updateDate: Foundation.Date?

    public init(
        updateDate: Foundation.Date? = nil
    )
    {
        self.updateDate = updateDate
    }
}

extension SFNClientTypes {

    public enum ValidateStateMachineDefinitionSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidateStateMachineDefinitionSeverity] {
            return [
                .error,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ValidateStateMachineDefinitionInput {
    /// The Amazon States Language definition of the state machine. For more information, see [Amazon States Language](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html) (ASL).
    /// This member is required.
    public var definition: Swift.String?
    /// The maximum number of diagnostics that are returned per call. The default and maximum value is 100. Setting the value to 0 will also use the default of 100. If the number of diagnostics returned in the response exceeds maxResults, the value of the truncated field in the response will be set to true.
    public var maxResults: Swift.Int?
    /// Minimum level of diagnostics to return. ERROR returns only ERROR diagnostics, whereas WARNING returns both WARNING and ERROR diagnostics. The default is ERROR.
    public var severity: SFNClientTypes.ValidateStateMachineDefinitionSeverity?
    /// The target type of state machine for this definition. The default is STANDARD.
    public var type: SFNClientTypes.StateMachineType?

    public init(
        definition: Swift.String? = nil,
        maxResults: Swift.Int? = 0,
        severity: SFNClientTypes.ValidateStateMachineDefinitionSeverity? = nil,
        type: SFNClientTypes.StateMachineType? = nil
    )
    {
        self.definition = definition
        self.maxResults = maxResults
        self.severity = severity
        self.type = type
    }
}

extension ValidateStateMachineDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateStateMachineDefinitionInput(maxResults: \(Swift.String(describing: maxResults)), severity: \(Swift.String(describing: severity)), type: \(Swift.String(describing: type)), definition: \"CONTENT_REDACTED\")"}
}

extension SFNClientTypes {
    /// Describes an error found during validation. Validation errors found in the definition return in the response as diagnostic elements, rather than raise an exception.
    public struct ValidateStateMachineDefinitionDiagnostic {
        /// Identifying code for the diagnostic.
        /// This member is required.
        public var code: Swift.String?
        /// Location of the issue in the state machine, if available. For errors specific to a field, the location could be in the format: /States//, for example: /States/FailState/ErrorPath.
        public var location: Swift.String?
        /// Message describing the diagnostic condition.
        /// This member is required.
        public var message: Swift.String?
        /// A value of ERROR means that you cannot create or update a state machine with this definition.
        /// This member is required.
        public var severity: SFNClientTypes.ValidateStateMachineDefinitionSeverity?

        public init(
            code: Swift.String? = nil,
            location: Swift.String? = nil,
            message: Swift.String? = nil,
            severity: SFNClientTypes.ValidateStateMachineDefinitionSeverity? = nil
        )
        {
            self.code = code
            self.location = location
            self.message = message
            self.severity = severity
        }
    }

}

extension SFNClientTypes {

    public enum ValidateStateMachineDefinitionResultCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidateStateMachineDefinitionResultCode] {
            return [
                .fail,
                .ok
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ValidateStateMachineDefinitionOutput {
    /// If the result is OK, this field will be empty. When there are errors, this field will contain an array of Diagnostic objects to help you troubleshoot.
    /// This member is required.
    public var diagnostics: [SFNClientTypes.ValidateStateMachineDefinitionDiagnostic]?
    /// The result value will be OK when no syntax errors are found, or FAIL if the workflow definition does not pass verification.
    /// This member is required.
    public var result: SFNClientTypes.ValidateStateMachineDefinitionResultCode?
    /// The result value will be true if the number of diagnostics found in the workflow definition exceeds maxResults. When all diagnostics results are returned, the value will be false.
    public var truncated: Swift.Bool?

    public init(
        diagnostics: [SFNClientTypes.ValidateStateMachineDefinitionDiagnostic]? = nil,
        result: SFNClientTypes.ValidateStateMachineDefinitionResultCode? = nil,
        truncated: Swift.Bool? = nil
    )
    {
        self.diagnostics = diagnostics
        self.result = result
        self.truncated = truncated
    }
}

extension CreateActivityInput {

    static func urlPathProvider(_ value: CreateActivityInput) -> Swift.String? {
        return "/"
    }
}

extension CreateStateMachineInput {

    static func urlPathProvider(_ value: CreateStateMachineInput) -> Swift.String? {
        return "/"
    }
}

extension CreateStateMachineAliasInput {

    static func urlPathProvider(_ value: CreateStateMachineAliasInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteActivityInput {

    static func urlPathProvider(_ value: DeleteActivityInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteStateMachineInput {

    static func urlPathProvider(_ value: DeleteStateMachineInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteStateMachineAliasInput {

    static func urlPathProvider(_ value: DeleteStateMachineAliasInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteStateMachineVersionInput {

    static func urlPathProvider(_ value: DeleteStateMachineVersionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeActivityInput {

    static func urlPathProvider(_ value: DescribeActivityInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeExecutionInput {

    static func urlPathProvider(_ value: DescribeExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMapRunInput {

    static func urlPathProvider(_ value: DescribeMapRunInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeStateMachineInput {

    static func urlPathProvider(_ value: DescribeStateMachineInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeStateMachineAliasInput {

    static func urlPathProvider(_ value: DescribeStateMachineAliasInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeStateMachineForExecutionInput {

    static func urlPathProvider(_ value: DescribeStateMachineForExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension GetActivityTaskInput {

    static func urlPathProvider(_ value: GetActivityTaskInput) -> Swift.String? {
        return "/"
    }
}

extension GetExecutionHistoryInput {

    static func urlPathProvider(_ value: GetExecutionHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListActivitiesInput {

    static func urlPathProvider(_ value: ListActivitiesInput) -> Swift.String? {
        return "/"
    }
}

extension ListExecutionsInput {

    static func urlPathProvider(_ value: ListExecutionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMapRunsInput {

    static func urlPathProvider(_ value: ListMapRunsInput) -> Swift.String? {
        return "/"
    }
}

extension ListStateMachineAliasesInput {

    static func urlPathProvider(_ value: ListStateMachineAliasesInput) -> Swift.String? {
        return "/"
    }
}

extension ListStateMachinesInput {

    static func urlPathProvider(_ value: ListStateMachinesInput) -> Swift.String? {
        return "/"
    }
}

extension ListStateMachineVersionsInput {

    static func urlPathProvider(_ value: ListStateMachineVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PublishStateMachineVersionInput {

    static func urlPathProvider(_ value: PublishStateMachineVersionInput) -> Swift.String? {
        return "/"
    }
}

extension RedriveExecutionInput {

    static func urlPathProvider(_ value: RedriveExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension SendTaskFailureInput {

    static func urlPathProvider(_ value: SendTaskFailureInput) -> Swift.String? {
        return "/"
    }
}

extension SendTaskHeartbeatInput {

    static func urlPathProvider(_ value: SendTaskHeartbeatInput) -> Swift.String? {
        return "/"
    }
}

extension SendTaskSuccessInput {

    static func urlPathProvider(_ value: SendTaskSuccessInput) -> Swift.String? {
        return "/"
    }
}

extension StartExecutionInput {

    static func urlPathProvider(_ value: StartExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension StartSyncExecutionInput {

    static func urlPathProvider(_ value: StartSyncExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension StopExecutionInput {

    static func urlPathProvider(_ value: StopExecutionInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TestStateInput {

    static func urlPathProvider(_ value: TestStateInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMapRunInput {

    static func urlPathProvider(_ value: UpdateMapRunInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateStateMachineInput {

    static func urlPathProvider(_ value: UpdateStateMachineInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateStateMachineAliasInput {

    static func urlPathProvider(_ value: UpdateStateMachineAliasInput) -> Swift.String? {
        return "/"
    }
}

extension ValidateStateMachineDefinitionInput {

    static func urlPathProvider(_ value: ValidateStateMachineDefinitionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateActivityInput {

    static func write(value: CreateActivityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: SFNClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: SFNClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateStateMachineInput {

    static func write(value: CreateStateMachineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: SFNClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["loggingConfiguration"].write(value.loggingConfiguration, with: SFNClientTypes.LoggingConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["publish"].write(value.publish)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: SFNClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tracingConfiguration"].write(value.tracingConfiguration, with: SFNClientTypes.TracingConfiguration.write(value:to:))
        try writer["type"].write(value.type)
        try writer["versionDescription"].write(value.versionDescription)
    }
}

extension CreateStateMachineAliasInput {

    static func write(value: CreateStateMachineAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["routingConfiguration"].writeList(value.routingConfiguration, memberWritingClosure: SFNClientTypes.RoutingConfigurationListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteActivityInput {

    static func write(value: DeleteActivityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activityArn"].write(value.activityArn)
    }
}

extension DeleteStateMachineInput {

    static func write(value: DeleteStateMachineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stateMachineArn"].write(value.stateMachineArn)
    }
}

extension DeleteStateMachineAliasInput {

    static func write(value: DeleteStateMachineAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stateMachineAliasArn"].write(value.stateMachineAliasArn)
    }
}

extension DeleteStateMachineVersionInput {

    static func write(value: DeleteStateMachineVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stateMachineVersionArn"].write(value.stateMachineVersionArn)
    }
}

extension DescribeActivityInput {

    static func write(value: DescribeActivityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activityArn"].write(value.activityArn)
    }
}

extension DescribeExecutionInput {

    static func write(value: DescribeExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionArn"].write(value.executionArn)
        try writer["includedData"].write(value.includedData)
    }
}

extension DescribeMapRunInput {

    static func write(value: DescribeMapRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mapRunArn"].write(value.mapRunArn)
    }
}

extension DescribeStateMachineInput {

    static func write(value: DescribeStateMachineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includedData"].write(value.includedData)
        try writer["stateMachineArn"].write(value.stateMachineArn)
    }
}

extension DescribeStateMachineAliasInput {

    static func write(value: DescribeStateMachineAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stateMachineAliasArn"].write(value.stateMachineAliasArn)
    }
}

extension DescribeStateMachineForExecutionInput {

    static func write(value: DescribeStateMachineForExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionArn"].write(value.executionArn)
        try writer["includedData"].write(value.includedData)
    }
}

extension GetActivityTaskInput {

    static func write(value: GetActivityTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activityArn"].write(value.activityArn)
        try writer["workerName"].write(value.workerName)
    }
}

extension GetExecutionHistoryInput {

    static func write(value: GetExecutionHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionArn"].write(value.executionArn)
        try writer["includeExecutionData"].write(value.includeExecutionData)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["reverseOrder"].write(value.reverseOrder)
    }
}

extension ListActivitiesInput {

    static func write(value: ListActivitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListExecutionsInput {

    static func write(value: ListExecutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mapRunArn"].write(value.mapRunArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["redriveFilter"].write(value.redriveFilter)
        try writer["stateMachineArn"].write(value.stateMachineArn)
        try writer["statusFilter"].write(value.statusFilter)
    }
}

extension ListMapRunsInput {

    static func write(value: ListMapRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionArn"].write(value.executionArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListStateMachineAliasesInput {

    static func write(value: ListStateMachineAliasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["stateMachineArn"].write(value.stateMachineArn)
    }
}

extension ListStateMachinesInput {

    static func write(value: ListStateMachinesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListStateMachineVersionsInput {

    static func write(value: ListStateMachineVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["stateMachineArn"].write(value.stateMachineArn)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension PublishStateMachineVersionInput {

    static func write(value: PublishStateMachineVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["revisionId"].write(value.revisionId)
        try writer["stateMachineArn"].write(value.stateMachineArn)
    }
}

extension RedriveExecutionInput {

    static func write(value: RedriveExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["executionArn"].write(value.executionArn)
    }
}

extension SendTaskFailureInput {

    static func write(value: SendTaskFailureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cause"].write(value.cause)
        try writer["error"].write(value.error)
        try writer["taskToken"].write(value.taskToken)
    }
}

extension SendTaskHeartbeatInput {

    static func write(value: SendTaskHeartbeatInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["taskToken"].write(value.taskToken)
    }
}

extension SendTaskSuccessInput {

    static func write(value: SendTaskSuccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["output"].write(value.output)
        try writer["taskToken"].write(value.taskToken)
    }
}

extension StartExecutionInput {

    static func write(value: StartExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["input"].write(value.input)
        try writer["name"].write(value.name)
        try writer["stateMachineArn"].write(value.stateMachineArn)
        try writer["traceHeader"].write(value.traceHeader)
    }
}

extension StartSyncExecutionInput {

    static func write(value: StartSyncExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["includedData"].write(value.includedData)
        try writer["input"].write(value.input)
        try writer["name"].write(value.name)
        try writer["stateMachineArn"].write(value.stateMachineArn)
        try writer["traceHeader"].write(value.traceHeader)
    }
}

extension StopExecutionInput {

    static func write(value: StopExecutionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cause"].write(value.cause)
        try writer["error"].write(value.error)
        try writer["executionArn"].write(value.executionArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: SFNClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TestStateInput {

    static func write(value: TestStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["input"].write(value.input)
        try writer["inspectionLevel"].write(value.inspectionLevel)
        try writer["revealSecrets"].write(value.revealSecrets)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateMapRunInput {

    static func write(value: UpdateMapRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mapRunArn"].write(value.mapRunArn)
        try writer["maxConcurrency"].write(value.maxConcurrency)
        try writer["toleratedFailureCount"].write(value.toleratedFailureCount)
        try writer["toleratedFailurePercentage"].write(value.toleratedFailurePercentage)
    }
}

extension UpdateStateMachineInput {

    static func write(value: UpdateStateMachineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: SFNClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["loggingConfiguration"].write(value.loggingConfiguration, with: SFNClientTypes.LoggingConfiguration.write(value:to:))
        try writer["publish"].write(value.publish)
        try writer["roleArn"].write(value.roleArn)
        try writer["stateMachineArn"].write(value.stateMachineArn)
        try writer["tracingConfiguration"].write(value.tracingConfiguration, with: SFNClientTypes.TracingConfiguration.write(value:to:))
        try writer["versionDescription"].write(value.versionDescription)
    }
}

extension UpdateStateMachineAliasInput {

    static func write(value: UpdateStateMachineAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["routingConfiguration"].writeList(value.routingConfiguration, memberWritingClosure: SFNClientTypes.RoutingConfigurationListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["stateMachineAliasArn"].write(value.stateMachineAliasArn)
    }
}

extension ValidateStateMachineDefinitionInput {

    static func write(value: ValidateStateMachineDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition)
        try writer["maxResults"].write(value.maxResults)
        try writer["severity"].write(value.severity)
        try writer["type"].write(value.type)
    }
}

extension CreateActivityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateActivityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateActivityOutput()
        value.activityArn = try reader["activityArn"].readIfPresent() ?? ""
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateStateMachineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStateMachineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStateMachineOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.stateMachineArn = try reader["stateMachineArn"].readIfPresent() ?? ""
        value.stateMachineVersionArn = try reader["stateMachineVersionArn"].readIfPresent()
        return value
    }
}

extension CreateStateMachineAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStateMachineAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStateMachineAliasOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.stateMachineAliasArn = try reader["stateMachineAliasArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteActivityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteActivityOutput {
        return DeleteActivityOutput()
    }
}

extension DeleteStateMachineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStateMachineOutput {
        return DeleteStateMachineOutput()
    }
}

extension DeleteStateMachineAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStateMachineAliasOutput {
        return DeleteStateMachineAliasOutput()
    }
}

extension DeleteStateMachineVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStateMachineVersionOutput {
        return DeleteStateMachineVersionOutput()
    }
}

extension DescribeActivityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeActivityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeActivityOutput()
        value.activityArn = try reader["activityArn"].readIfPresent() ?? ""
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: SFNClientTypes.EncryptionConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeExecutionOutput()
        value.cause = try reader["cause"].readIfPresent()
        value.error = try reader["error"].readIfPresent()
        value.executionArn = try reader["executionArn"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent()
        value.inputDetails = try reader["inputDetails"].readIfPresent(with: SFNClientTypes.CloudWatchEventsExecutionDataDetails.read(from:))
        value.mapRunArn = try reader["mapRunArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.output = try reader["output"].readIfPresent()
        value.outputDetails = try reader["outputDetails"].readIfPresent(with: SFNClientTypes.CloudWatchEventsExecutionDataDetails.read(from:))
        value.redriveCount = try reader["redriveCount"].readIfPresent()
        value.redriveDate = try reader["redriveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.redriveStatus = try reader["redriveStatus"].readIfPresent()
        value.redriveStatusReason = try reader["redriveStatusReason"].readIfPresent()
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.stateMachineAliasArn = try reader["stateMachineAliasArn"].readIfPresent()
        value.stateMachineArn = try reader["stateMachineArn"].readIfPresent() ?? ""
        value.stateMachineVersionArn = try reader["stateMachineVersionArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.stopDate = try reader["stopDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.traceHeader = try reader["traceHeader"].readIfPresent()
        return value
    }
}

extension DescribeMapRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMapRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMapRunOutput()
        value.executionArn = try reader["executionArn"].readIfPresent() ?? ""
        value.executionCounts = try reader["executionCounts"].readIfPresent(with: SFNClientTypes.MapRunExecutionCounts.read(from:))
        value.itemCounts = try reader["itemCounts"].readIfPresent(with: SFNClientTypes.MapRunItemCounts.read(from:))
        value.mapRunArn = try reader["mapRunArn"].readIfPresent() ?? ""
        value.maxConcurrency = try reader["maxConcurrency"].readIfPresent() ?? 0
        value.redriveCount = try reader["redriveCount"].readIfPresent()
        value.redriveDate = try reader["redriveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.stopDate = try reader["stopDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.toleratedFailureCount = try reader["toleratedFailureCount"].readIfPresent() ?? 0
        value.toleratedFailurePercentage = try reader["toleratedFailurePercentage"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeStateMachineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStateMachineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStateMachineOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.definition = try reader["definition"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: SFNClientTypes.EncryptionConfiguration.read(from:))
        value.label = try reader["label"].readIfPresent()
        value.loggingConfiguration = try reader["loggingConfiguration"].readIfPresent(with: SFNClientTypes.LoggingConfiguration.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.stateMachineArn = try reader["stateMachineArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.tracingConfiguration = try reader["tracingConfiguration"].readIfPresent(with: SFNClientTypes.TracingConfiguration.read(from:))
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DescribeStateMachineAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStateMachineAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStateMachineAliasOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: SFNClientTypes.RoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stateMachineAliasArn = try reader["stateMachineAliasArn"].readIfPresent()
        value.updateDate = try reader["updateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DescribeStateMachineForExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStateMachineForExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStateMachineForExecutionOutput()
        value.definition = try reader["definition"].readIfPresent() ?? ""
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: SFNClientTypes.EncryptionConfiguration.read(from:))
        value.label = try reader["label"].readIfPresent()
        value.loggingConfiguration = try reader["loggingConfiguration"].readIfPresent(with: SFNClientTypes.LoggingConfiguration.read(from:))
        value.mapRunArn = try reader["mapRunArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.stateMachineArn = try reader["stateMachineArn"].readIfPresent() ?? ""
        value.tracingConfiguration = try reader["tracingConfiguration"].readIfPresent(with: SFNClientTypes.TracingConfiguration.read(from:))
        value.updateDate = try reader["updateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetActivityTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetActivityTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetActivityTaskOutput()
        value.input = try reader["input"].readIfPresent()
        value.taskToken = try reader["taskToken"].readIfPresent()
        return value
    }
}

extension GetExecutionHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExecutionHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExecutionHistoryOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: SFNClientTypes.HistoryEvent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListActivitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListActivitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListActivitiesOutput()
        value.activities = try reader["activities"].readListIfPresent(memberReadingClosure: SFNClientTypes.ActivityListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListExecutionsOutput()
        value.executions = try reader["executions"].readListIfPresent(memberReadingClosure: SFNClientTypes.ExecutionListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMapRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMapRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMapRunsOutput()
        value.mapRuns = try reader["mapRuns"].readListIfPresent(memberReadingClosure: SFNClientTypes.MapRunListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListStateMachineAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStateMachineAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStateMachineAliasesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.stateMachineAliases = try reader["stateMachineAliases"].readListIfPresent(memberReadingClosure: SFNClientTypes.StateMachineAliasListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStateMachinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStateMachinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStateMachinesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.stateMachines = try reader["stateMachines"].readListIfPresent(memberReadingClosure: SFNClientTypes.StateMachineListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStateMachineVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStateMachineVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStateMachineVersionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.stateMachineVersions = try reader["stateMachineVersions"].readListIfPresent(memberReadingClosure: SFNClientTypes.StateMachineVersionListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: SFNClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PublishStateMachineVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishStateMachineVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PublishStateMachineVersionOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.stateMachineVersionArn = try reader["stateMachineVersionArn"].readIfPresent() ?? ""
        return value
    }
}

extension RedriveExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RedriveExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RedriveExecutionOutput()
        value.redriveDate = try reader["redriveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SendTaskFailureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendTaskFailureOutput {
        return SendTaskFailureOutput()
    }
}

extension SendTaskHeartbeatOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendTaskHeartbeatOutput {
        return SendTaskHeartbeatOutput()
    }
}

extension SendTaskSuccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendTaskSuccessOutput {
        return SendTaskSuccessOutput()
    }
}

extension StartExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartExecutionOutput()
        value.executionArn = try reader["executionArn"].readIfPresent() ?? ""
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension StartSyncExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSyncExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSyncExecutionOutput()
        value.billingDetails = try reader["billingDetails"].readIfPresent(with: SFNClientTypes.BillingDetails.read(from:))
        value.cause = try reader["cause"].readIfPresent()
        value.error = try reader["error"].readIfPresent()
        value.executionArn = try reader["executionArn"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent()
        value.inputDetails = try reader["inputDetails"].readIfPresent(with: SFNClientTypes.CloudWatchEventsExecutionDataDetails.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.output = try reader["output"].readIfPresent()
        value.outputDetails = try reader["outputDetails"].readIfPresent(with: SFNClientTypes.CloudWatchEventsExecutionDataDetails.read(from:))
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.stateMachineArn = try reader["stateMachineArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.stopDate = try reader["stopDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.traceHeader = try reader["traceHeader"].readIfPresent()
        return value
    }
}

extension StopExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopExecutionOutput()
        value.stopDate = try reader["stopDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestStateOutput()
        value.cause = try reader["cause"].readIfPresent()
        value.error = try reader["error"].readIfPresent()
        value.inspectionData = try reader["inspectionData"].readIfPresent(with: SFNClientTypes.InspectionData.read(from:))
        value.nextState = try reader["nextState"].readIfPresent()
        value.output = try reader["output"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateMapRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMapRunOutput {
        return UpdateMapRunOutput()
    }
}

extension UpdateStateMachineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStateMachineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStateMachineOutput()
        value.revisionId = try reader["revisionId"].readIfPresent()
        value.stateMachineVersionArn = try reader["stateMachineVersionArn"].readIfPresent()
        value.updateDate = try reader["updateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateStateMachineAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStateMachineAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStateMachineAliasOutput()
        value.updateDate = try reader["updateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ValidateStateMachineDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ValidateStateMachineDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ValidateStateMachineDefinitionOutput()
        value.diagnostics = try reader["diagnostics"].readListIfPresent(memberReadingClosure: SFNClientTypes.ValidateStateMachineDefinitionDiagnostic.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.result = try reader["result"].readIfPresent() ?? .sdkUnknown("")
        value.truncated = try reader["truncated"].readIfPresent()
        return value
    }
}

enum CreateActivityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ActivityAlreadyExists": return try ActivityAlreadyExists.makeError(baseError: baseError)
            case "ActivityLimitExceeded": return try ActivityLimitExceeded.makeError(baseError: baseError)
            case "InvalidEncryptionConfiguration": return try InvalidEncryptionConfiguration.makeError(baseError: baseError)
            case "InvalidName": return try InvalidName.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            case "TooManyTags": return try TooManyTags.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStateMachineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidDefinition": return try InvalidDefinition.makeError(baseError: baseError)
            case "InvalidEncryptionConfiguration": return try InvalidEncryptionConfiguration.makeError(baseError: baseError)
            case "InvalidLoggingConfiguration": return try InvalidLoggingConfiguration.makeError(baseError: baseError)
            case "InvalidName": return try InvalidName.makeError(baseError: baseError)
            case "InvalidTracingConfiguration": return try InvalidTracingConfiguration.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            case "StateMachineAlreadyExists": return try StateMachineAlreadyExists.makeError(baseError: baseError)
            case "StateMachineDeleting": return try StateMachineDeleting.makeError(baseError: baseError)
            case "StateMachineLimitExceeded": return try StateMachineLimitExceeded.makeError(baseError: baseError)
            case "StateMachineTypeNotSupported": return try StateMachineTypeNotSupported.makeError(baseError: baseError)
            case "TooManyTags": return try TooManyTags.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStateMachineAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidName": return try InvalidName.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "StateMachineDeleting": return try StateMachineDeleting.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteActivityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStateMachineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStateMachineAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStateMachineVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeActivityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ActivityDoesNotExist": return try ActivityDoesNotExist.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExecutionDoesNotExist": return try ExecutionDoesNotExist.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMapRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStateMachineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            case "StateMachineDoesNotExist": return try StateMachineDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStateMachineAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStateMachineForExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExecutionDoesNotExist": return try ExecutionDoesNotExist.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetActivityTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ActivityDoesNotExist": return try ActivityDoesNotExist.makeError(baseError: baseError)
            case "ActivityWorkerLimitExceeded": return try ActivityWorkerLimitExceeded.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExecutionHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExecutionDoesNotExist": return try ExecutionDoesNotExist.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListActivitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            case "StateMachineDoesNotExist": return try StateMachineDoesNotExist.makeError(baseError: baseError)
            case "StateMachineTypeNotSupported": return try StateMachineTypeNotSupported.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMapRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExecutionDoesNotExist": return try ExecutionDoesNotExist.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStateMachineAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            case "StateMachineDeleting": return try StateMachineDeleting.makeError(baseError: baseError)
            case "StateMachineDoesNotExist": return try StateMachineDoesNotExist.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStateMachinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStateMachineVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishStateMachineVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "StateMachineDeleting": return try StateMachineDeleting.makeError(baseError: baseError)
            case "StateMachineDoesNotExist": return try StateMachineDoesNotExist.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RedriveExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExecutionDoesNotExist": return try ExecutionDoesNotExist.makeError(baseError: baseError)
            case "ExecutionLimitExceeded": return try ExecutionLimitExceeded.makeError(baseError: baseError)
            case "ExecutionNotRedrivable": return try ExecutionNotRedrivable.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendTaskFailureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            case "TaskDoesNotExist": return try TaskDoesNotExist.makeError(baseError: baseError)
            case "TaskTimedOut": return try TaskTimedOut.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendTaskHeartbeatOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            case "TaskDoesNotExist": return try TaskDoesNotExist.makeError(baseError: baseError)
            case "TaskTimedOut": return try TaskTimedOut.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendTaskSuccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidOutput": return try InvalidOutput.makeError(baseError: baseError)
            case "InvalidToken": return try InvalidToken.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            case "TaskDoesNotExist": return try TaskDoesNotExist.makeError(baseError: baseError)
            case "TaskTimedOut": return try TaskTimedOut.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExecutionAlreadyExists": return try ExecutionAlreadyExists.makeError(baseError: baseError)
            case "ExecutionLimitExceeded": return try ExecutionLimitExceeded.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidExecutionInput": return try InvalidExecutionInput.makeError(baseError: baseError)
            case "InvalidName": return try InvalidName.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            case "StateMachineDeleting": return try StateMachineDeleting.makeError(baseError: baseError)
            case "StateMachineDoesNotExist": return try StateMachineDoesNotExist.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSyncExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidExecutionInput": return try InvalidExecutionInput.makeError(baseError: baseError)
            case "InvalidName": return try InvalidName.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            case "StateMachineDeleting": return try StateMachineDeleting.makeError(baseError: baseError)
            case "StateMachineDoesNotExist": return try StateMachineDoesNotExist.makeError(baseError: baseError)
            case "StateMachineTypeNotSupported": return try StateMachineTypeNotSupported.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ExecutionDoesNotExist": return try ExecutionDoesNotExist.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsInvalidStateException": return try KmsInvalidStateException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            case "TooManyTags": return try TooManyTags.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidDefinition": return try InvalidDefinition.makeError(baseError: baseError)
            case "InvalidExecutionInput": return try InvalidExecutionInput.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMapRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStateMachineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "InvalidDefinition": return try InvalidDefinition.makeError(baseError: baseError)
            case "InvalidEncryptionConfiguration": return try InvalidEncryptionConfiguration.makeError(baseError: baseError)
            case "InvalidLoggingConfiguration": return try InvalidLoggingConfiguration.makeError(baseError: baseError)
            case "InvalidTracingConfiguration": return try InvalidTracingConfiguration.makeError(baseError: baseError)
            case "KmsAccessDeniedException": return try KmsAccessDeniedException.makeError(baseError: baseError)
            case "KmsThrottlingException": return try KmsThrottlingException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameter.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "StateMachineDeleting": return try StateMachineDeleting.makeError(baseError: baseError)
            case "StateMachineDoesNotExist": return try StateMachineDoesNotExist.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStateMachineAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidArn": return try InvalidArn.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFound.makeError(baseError: baseError)
            case "StateMachineDeleting": return try StateMachineDeleting.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ValidateStateMachineDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TooManyTags {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTags {
        let reader = baseError.errorBodyReader
        var value = TooManyTags()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KmsThrottlingException {
        let reader = baseError.errorBodyReader
        var value = KmsThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KmsAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = KmsAccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ActivityAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ActivityAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = ActivityAlreadyExists()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ActivityLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ActivityLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = ActivityLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEncryptionConfiguration {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidEncryptionConfiguration {
        let reader = baseError.errorBodyReader
        var value = InvalidEncryptionConfiguration()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidName {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidName {
        let reader = baseError.errorBodyReader
        var value = InvalidName()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDefinition {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidDefinition {
        let reader = baseError.errorBodyReader
        var value = InvalidDefinition()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTracingConfiguration {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTracingConfiguration {
        let reader = baseError.errorBodyReader
        var value = InvalidTracingConfiguration()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StateMachineLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> StateMachineLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = StateMachineLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StateMachineTypeNotSupported {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> StateMachineTypeNotSupported {
        let reader = baseError.errorBodyReader
        var value = StateMachineTypeNotSupported()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidLoggingConfiguration {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidLoggingConfiguration {
        let reader = baseError.errorBodyReader
        var value = InvalidLoggingConfiguration()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidArn {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidArn {
        let reader = baseError.errorBodyReader
        var value = InvalidArn()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StateMachineAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> StateMachineAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = StateMachineAlreadyExists()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StateMachineDeleting {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> StateMachineDeleting {
        let reader = baseError.errorBodyReader
        var value = StateMachineDeleting()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFound {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFound()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ActivityDoesNotExist {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ActivityDoesNotExist {
        let reader = baseError.errorBodyReader
        var value = ActivityDoesNotExist()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KmsInvalidStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KmsInvalidStateException {
        let reader = baseError.errorBodyReader
        var value = KmsInvalidStateException()
        value.properties.kmsKeyState = try reader["kmsKeyState"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExecutionDoesNotExist {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ExecutionDoesNotExist {
        let reader = baseError.errorBodyReader
        var value = ExecutionDoesNotExist()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StateMachineDoesNotExist {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> StateMachineDoesNotExist {
        let reader = baseError.errorBodyReader
        var value = StateMachineDoesNotExist()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ActivityWorkerLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ActivityWorkerLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = ActivityWorkerLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidToken {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidToken {
        let reader = baseError.errorBodyReader
        var value = InvalidToken()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExecutionNotRedrivable {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ExecutionNotRedrivable {
        let reader = baseError.errorBodyReader
        var value = ExecutionNotRedrivable()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExecutionLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ExecutionLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = ExecutionLimitExceeded()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TaskTimedOut {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TaskTimedOut {
        let reader = baseError.errorBodyReader
        var value = TaskTimedOut()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TaskDoesNotExist {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TaskDoesNotExist {
        let reader = baseError.errorBodyReader
        var value = TaskDoesNotExist()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOutput {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOutput {
        let reader = baseError.errorBodyReader
        var value = InvalidOutput()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExecutionAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ExecutionAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = ExecutionAlreadyExists()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidExecutionInput {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidExecutionInput {
        let reader = baseError.errorBodyReader
        var value = InvalidExecutionInput()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MissingRequiredParameter {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MissingRequiredParameter {
        let reader = baseError.errorBodyReader
        var value = MissingRequiredParameter()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SFNClientTypes.EncryptionConfiguration {

    static func write(value: SFNClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsDataKeyReusePeriodSeconds"].write(value.kmsDataKeyReusePeriodSeconds)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.EncryptionConfiguration()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.kmsDataKeyReusePeriodSeconds = try reader["kmsDataKeyReusePeriodSeconds"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SFNClientTypes.CloudWatchEventsExecutionDataDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.CloudWatchEventsExecutionDataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.CloudWatchEventsExecutionDataDetails()
        value.included = try reader["included"].readIfPresent() ?? false
        return value
    }
}

extension SFNClientTypes.MapRunItemCounts {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.MapRunItemCounts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.MapRunItemCounts()
        value.pending = try reader["pending"].readIfPresent() ?? 0
        value.running = try reader["running"].readIfPresent() ?? 0
        value.succeeded = try reader["succeeded"].readIfPresent() ?? 0
        value.failed = try reader["failed"].readIfPresent() ?? 0
        value.timedOut = try reader["timedOut"].readIfPresent() ?? 0
        value.aborted = try reader["aborted"].readIfPresent() ?? 0
        value.total = try reader["total"].readIfPresent() ?? 0
        value.resultsWritten = try reader["resultsWritten"].readIfPresent() ?? 0
        value.failuresNotRedrivable = try reader["failuresNotRedrivable"].readIfPresent()
        value.pendingRedrive = try reader["pendingRedrive"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.MapRunExecutionCounts {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.MapRunExecutionCounts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.MapRunExecutionCounts()
        value.pending = try reader["pending"].readIfPresent() ?? 0
        value.running = try reader["running"].readIfPresent() ?? 0
        value.succeeded = try reader["succeeded"].readIfPresent() ?? 0
        value.failed = try reader["failed"].readIfPresent() ?? 0
        value.timedOut = try reader["timedOut"].readIfPresent() ?? 0
        value.aborted = try reader["aborted"].readIfPresent() ?? 0
        value.total = try reader["total"].readIfPresent() ?? 0
        value.resultsWritten = try reader["resultsWritten"].readIfPresent() ?? 0
        value.failuresNotRedrivable = try reader["failuresNotRedrivable"].readIfPresent()
        value.pendingRedrive = try reader["pendingRedrive"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.LoggingConfiguration {

    static func write(value: SFNClientTypes.LoggingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinations"].writeList(value.destinations, memberWritingClosure: SFNClientTypes.LogDestination.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["includeExecutionData"].write(value.includeExecutionData)
        try writer["level"].write(value.level)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.LoggingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.LoggingConfiguration()
        value.level = try reader["level"].readIfPresent()
        value.includeExecutionData = try reader["includeExecutionData"].readIfPresent() ?? false
        value.destinations = try reader["destinations"].readListIfPresent(memberReadingClosure: SFNClientTypes.LogDestination.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SFNClientTypes.LogDestination {

    static func write(value: SFNClientTypes.LogDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogsLogGroup"].write(value.cloudWatchLogsLogGroup, with: SFNClientTypes.CloudWatchLogsLogGroup.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.LogDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.LogDestination()
        value.cloudWatchLogsLogGroup = try reader["cloudWatchLogsLogGroup"].readIfPresent(with: SFNClientTypes.CloudWatchLogsLogGroup.read(from:))
        return value
    }
}

extension SFNClientTypes.CloudWatchLogsLogGroup {

    static func write(value: SFNClientTypes.CloudWatchLogsLogGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroupArn"].write(value.logGroupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.CloudWatchLogsLogGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.CloudWatchLogsLogGroup()
        value.logGroupArn = try reader["logGroupArn"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.TracingConfiguration {

    static func write(value: SFNClientTypes.TracingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TracingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TracingConfiguration()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        return value
    }
}

extension SFNClientTypes.RoutingConfigurationListItem {

    static func write(value: SFNClientTypes.RoutingConfigurationListItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stateMachineVersionArn"].write(value.stateMachineVersionArn)
        try writer["weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.RoutingConfigurationListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.RoutingConfigurationListItem()
        value.stateMachineVersionArn = try reader["stateMachineVersionArn"].readIfPresent() ?? ""
        value.weight = try reader["weight"].readIfPresent() ?? 0
        return value
    }
}

extension SFNClientTypes.HistoryEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.HistoryEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.HistoryEvent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.id = try reader["id"].readIfPresent() ?? 0
        value.previousEventId = try reader["previousEventId"].readIfPresent() ?? 0
        value.activityFailedEventDetails = try reader["activityFailedEventDetails"].readIfPresent(with: SFNClientTypes.ActivityFailedEventDetails.read(from:))
        value.activityScheduleFailedEventDetails = try reader["activityScheduleFailedEventDetails"].readIfPresent(with: SFNClientTypes.ActivityScheduleFailedEventDetails.read(from:))
        value.activityScheduledEventDetails = try reader["activityScheduledEventDetails"].readIfPresent(with: SFNClientTypes.ActivityScheduledEventDetails.read(from:))
        value.activityStartedEventDetails = try reader["activityStartedEventDetails"].readIfPresent(with: SFNClientTypes.ActivityStartedEventDetails.read(from:))
        value.activitySucceededEventDetails = try reader["activitySucceededEventDetails"].readIfPresent(with: SFNClientTypes.ActivitySucceededEventDetails.read(from:))
        value.activityTimedOutEventDetails = try reader["activityTimedOutEventDetails"].readIfPresent(with: SFNClientTypes.ActivityTimedOutEventDetails.read(from:))
        value.taskFailedEventDetails = try reader["taskFailedEventDetails"].readIfPresent(with: SFNClientTypes.TaskFailedEventDetails.read(from:))
        value.taskScheduledEventDetails = try reader["taskScheduledEventDetails"].readIfPresent(with: SFNClientTypes.TaskScheduledEventDetails.read(from:))
        value.taskStartFailedEventDetails = try reader["taskStartFailedEventDetails"].readIfPresent(with: SFNClientTypes.TaskStartFailedEventDetails.read(from:))
        value.taskStartedEventDetails = try reader["taskStartedEventDetails"].readIfPresent(with: SFNClientTypes.TaskStartedEventDetails.read(from:))
        value.taskSubmitFailedEventDetails = try reader["taskSubmitFailedEventDetails"].readIfPresent(with: SFNClientTypes.TaskSubmitFailedEventDetails.read(from:))
        value.taskSubmittedEventDetails = try reader["taskSubmittedEventDetails"].readIfPresent(with: SFNClientTypes.TaskSubmittedEventDetails.read(from:))
        value.taskSucceededEventDetails = try reader["taskSucceededEventDetails"].readIfPresent(with: SFNClientTypes.TaskSucceededEventDetails.read(from:))
        value.taskTimedOutEventDetails = try reader["taskTimedOutEventDetails"].readIfPresent(with: SFNClientTypes.TaskTimedOutEventDetails.read(from:))
        value.executionFailedEventDetails = try reader["executionFailedEventDetails"].readIfPresent(with: SFNClientTypes.ExecutionFailedEventDetails.read(from:))
        value.executionStartedEventDetails = try reader["executionStartedEventDetails"].readIfPresent(with: SFNClientTypes.ExecutionStartedEventDetails.read(from:))
        value.executionSucceededEventDetails = try reader["executionSucceededEventDetails"].readIfPresent(with: SFNClientTypes.ExecutionSucceededEventDetails.read(from:))
        value.executionAbortedEventDetails = try reader["executionAbortedEventDetails"].readIfPresent(with: SFNClientTypes.ExecutionAbortedEventDetails.read(from:))
        value.executionTimedOutEventDetails = try reader["executionTimedOutEventDetails"].readIfPresent(with: SFNClientTypes.ExecutionTimedOutEventDetails.read(from:))
        value.executionRedrivenEventDetails = try reader["executionRedrivenEventDetails"].readIfPresent(with: SFNClientTypes.ExecutionRedrivenEventDetails.read(from:))
        value.mapStateStartedEventDetails = try reader["mapStateStartedEventDetails"].readIfPresent(with: SFNClientTypes.MapStateStartedEventDetails.read(from:))
        value.mapIterationStartedEventDetails = try reader["mapIterationStartedEventDetails"].readIfPresent(with: SFNClientTypes.MapIterationEventDetails.read(from:))
        value.mapIterationSucceededEventDetails = try reader["mapIterationSucceededEventDetails"].readIfPresent(with: SFNClientTypes.MapIterationEventDetails.read(from:))
        value.mapIterationFailedEventDetails = try reader["mapIterationFailedEventDetails"].readIfPresent(with: SFNClientTypes.MapIterationEventDetails.read(from:))
        value.mapIterationAbortedEventDetails = try reader["mapIterationAbortedEventDetails"].readIfPresent(with: SFNClientTypes.MapIterationEventDetails.read(from:))
        value.lambdaFunctionFailedEventDetails = try reader["lambdaFunctionFailedEventDetails"].readIfPresent(with: SFNClientTypes.LambdaFunctionFailedEventDetails.read(from:))
        value.lambdaFunctionScheduleFailedEventDetails = try reader["lambdaFunctionScheduleFailedEventDetails"].readIfPresent(with: SFNClientTypes.LambdaFunctionScheduleFailedEventDetails.read(from:))
        value.lambdaFunctionScheduledEventDetails = try reader["lambdaFunctionScheduledEventDetails"].readIfPresent(with: SFNClientTypes.LambdaFunctionScheduledEventDetails.read(from:))
        value.lambdaFunctionStartFailedEventDetails = try reader["lambdaFunctionStartFailedEventDetails"].readIfPresent(with: SFNClientTypes.LambdaFunctionStartFailedEventDetails.read(from:))
        value.lambdaFunctionSucceededEventDetails = try reader["lambdaFunctionSucceededEventDetails"].readIfPresent(with: SFNClientTypes.LambdaFunctionSucceededEventDetails.read(from:))
        value.lambdaFunctionTimedOutEventDetails = try reader["lambdaFunctionTimedOutEventDetails"].readIfPresent(with: SFNClientTypes.LambdaFunctionTimedOutEventDetails.read(from:))
        value.stateEnteredEventDetails = try reader["stateEnteredEventDetails"].readIfPresent(with: SFNClientTypes.StateEnteredEventDetails.read(from:))
        value.stateExitedEventDetails = try reader["stateExitedEventDetails"].readIfPresent(with: SFNClientTypes.StateExitedEventDetails.read(from:))
        value.mapRunStartedEventDetails = try reader["mapRunStartedEventDetails"].readIfPresent(with: SFNClientTypes.MapRunStartedEventDetails.read(from:))
        value.mapRunFailedEventDetails = try reader["mapRunFailedEventDetails"].readIfPresent(with: SFNClientTypes.MapRunFailedEventDetails.read(from:))
        value.mapRunRedrivenEventDetails = try reader["mapRunRedrivenEventDetails"].readIfPresent(with: SFNClientTypes.MapRunRedrivenEventDetails.read(from:))
        return value
    }
}

extension SFNClientTypes.MapRunRedrivenEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.MapRunRedrivenEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.MapRunRedrivenEventDetails()
        value.mapRunArn = try reader["mapRunArn"].readIfPresent()
        value.redriveCount = try reader["redriveCount"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.MapRunFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.MapRunFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.MapRunFailedEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.MapRunStartedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.MapRunStartedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.MapRunStartedEventDetails()
        value.mapRunArn = try reader["mapRunArn"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.StateExitedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.StateExitedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.StateExitedEventDetails()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.output = try reader["output"].readIfPresent()
        value.outputDetails = try reader["outputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        return value
    }
}

extension SFNClientTypes.HistoryEventExecutionDataDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.HistoryEventExecutionDataDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.HistoryEventExecutionDataDetails()
        value.truncated = try reader["truncated"].readIfPresent() ?? false
        return value
    }
}

extension SFNClientTypes.StateEnteredEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.StateEnteredEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.StateEnteredEventDetails()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent()
        value.inputDetails = try reader["inputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        return value
    }
}

extension SFNClientTypes.LambdaFunctionTimedOutEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.LambdaFunctionTimedOutEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.LambdaFunctionTimedOutEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.LambdaFunctionSucceededEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.LambdaFunctionSucceededEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.LambdaFunctionSucceededEventDetails()
        value.output = try reader["output"].readIfPresent()
        value.outputDetails = try reader["outputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        return value
    }
}

extension SFNClientTypes.LambdaFunctionStartFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.LambdaFunctionStartFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.LambdaFunctionStartFailedEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.LambdaFunctionScheduledEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.LambdaFunctionScheduledEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.LambdaFunctionScheduledEventDetails()
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent()
        value.inputDetails = try reader["inputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        value.timeoutInSeconds = try reader["timeoutInSeconds"].readIfPresent()
        value.taskCredentials = try reader["taskCredentials"].readIfPresent(with: SFNClientTypes.TaskCredentials.read(from:))
        return value
    }
}

extension SFNClientTypes.TaskCredentials {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TaskCredentials {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TaskCredentials()
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.LambdaFunctionScheduleFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.LambdaFunctionScheduleFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.LambdaFunctionScheduleFailedEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.LambdaFunctionFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.LambdaFunctionFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.LambdaFunctionFailedEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.MapIterationEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.MapIterationEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.MapIterationEventDetails()
        value.name = try reader["name"].readIfPresent()
        value.index = try reader["index"].readIfPresent() ?? 0
        return value
    }
}

extension SFNClientTypes.MapStateStartedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.MapStateStartedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.MapStateStartedEventDetails()
        value.length = try reader["length"].readIfPresent() ?? 0
        return value
    }
}

extension SFNClientTypes.ExecutionRedrivenEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ExecutionRedrivenEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ExecutionRedrivenEventDetails()
        value.redriveCount = try reader["redriveCount"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ExecutionTimedOutEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ExecutionTimedOutEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ExecutionTimedOutEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ExecutionAbortedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ExecutionAbortedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ExecutionAbortedEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ExecutionSucceededEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ExecutionSucceededEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ExecutionSucceededEventDetails()
        value.output = try reader["output"].readIfPresent()
        value.outputDetails = try reader["outputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        return value
    }
}

extension SFNClientTypes.ExecutionStartedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ExecutionStartedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ExecutionStartedEventDetails()
        value.input = try reader["input"].readIfPresent()
        value.inputDetails = try reader["inputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.stateMachineAliasArn = try reader["stateMachineAliasArn"].readIfPresent()
        value.stateMachineVersionArn = try reader["stateMachineVersionArn"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ExecutionFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ExecutionFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ExecutionFailedEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.TaskTimedOutEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TaskTimedOutEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TaskTimedOutEventDetails()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.TaskSucceededEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TaskSucceededEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TaskSucceededEventDetails()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.output = try reader["output"].readIfPresent()
        value.outputDetails = try reader["outputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        return value
    }
}

extension SFNClientTypes.TaskSubmittedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TaskSubmittedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TaskSubmittedEventDetails()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.output = try reader["output"].readIfPresent()
        value.outputDetails = try reader["outputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        return value
    }
}

extension SFNClientTypes.TaskSubmitFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TaskSubmitFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TaskSubmitFailedEventDetails()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.TaskStartedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TaskStartedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TaskStartedEventDetails()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent() ?? ""
        return value
    }
}

extension SFNClientTypes.TaskStartFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TaskStartFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TaskStartFailedEventDetails()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.TaskScheduledEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TaskScheduledEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TaskScheduledEventDetails()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.region = try reader["region"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readIfPresent() ?? ""
        value.timeoutInSeconds = try reader["timeoutInSeconds"].readIfPresent()
        value.heartbeatInSeconds = try reader["heartbeatInSeconds"].readIfPresent()
        value.taskCredentials = try reader["taskCredentials"].readIfPresent(with: SFNClientTypes.TaskCredentials.read(from:))
        return value
    }
}

extension SFNClientTypes.TaskFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.TaskFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.TaskFailedEventDetails()
        value.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ActivityTimedOutEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ActivityTimedOutEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ActivityTimedOutEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ActivitySucceededEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ActivitySucceededEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ActivitySucceededEventDetails()
        value.output = try reader["output"].readIfPresent()
        value.outputDetails = try reader["outputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        return value
    }
}

extension SFNClientTypes.ActivityStartedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ActivityStartedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ActivityStartedEventDetails()
        value.workerName = try reader["workerName"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ActivityScheduledEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ActivityScheduledEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ActivityScheduledEventDetails()
        value.resource = try reader["resource"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent()
        value.inputDetails = try reader["inputDetails"].readIfPresent(with: SFNClientTypes.HistoryEventExecutionDataDetails.read(from:))
        value.timeoutInSeconds = try reader["timeoutInSeconds"].readIfPresent()
        value.heartbeatInSeconds = try reader["heartbeatInSeconds"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ActivityScheduleFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ActivityScheduleFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ActivityScheduleFailedEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ActivityFailedEventDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ActivityFailedEventDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ActivityFailedEventDetails()
        value.error = try reader["error"].readIfPresent()
        value.cause = try reader["cause"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ActivityListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ActivityListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ActivityListItem()
        value.activityArn = try reader["activityArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SFNClientTypes.ExecutionListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ExecutionListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ExecutionListItem()
        value.executionArn = try reader["executionArn"].readIfPresent() ?? ""
        value.stateMachineArn = try reader["stateMachineArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.stopDate = try reader["stopDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.mapRunArn = try reader["mapRunArn"].readIfPresent()
        value.itemCount = try reader["itemCount"].readIfPresent()
        value.stateMachineVersionArn = try reader["stateMachineVersionArn"].readIfPresent()
        value.stateMachineAliasArn = try reader["stateMachineAliasArn"].readIfPresent()
        value.redriveCount = try reader["redriveCount"].readIfPresent()
        value.redriveDate = try reader["redriveDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SFNClientTypes.MapRunListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.MapRunListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.MapRunListItem()
        value.executionArn = try reader["executionArn"].readIfPresent() ?? ""
        value.mapRunArn = try reader["mapRunArn"].readIfPresent() ?? ""
        value.stateMachineArn = try reader["stateMachineArn"].readIfPresent() ?? ""
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.stopDate = try reader["stopDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SFNClientTypes.StateMachineAliasListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.StateMachineAliasListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.StateMachineAliasListItem()
        value.stateMachineAliasArn = try reader["stateMachineAliasArn"].readIfPresent() ?? ""
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SFNClientTypes.StateMachineListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.StateMachineListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.StateMachineListItem()
        value.stateMachineArn = try reader["stateMachineArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SFNClientTypes.StateMachineVersionListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.StateMachineVersionListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.StateMachineVersionListItem()
        value.stateMachineVersionArn = try reader["stateMachineVersionArn"].readIfPresent() ?? ""
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SFNClientTypes.Tag {

    static func write(value: SFNClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.Tag()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.BillingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.BillingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.BillingDetails()
        value.billedMemoryUsedInMB = try reader["billedMemoryUsedInMB"].readIfPresent() ?? 0
        value.billedDurationInMilliseconds = try reader["billedDurationInMilliseconds"].readIfPresent() ?? 0
        return value
    }
}

extension SFNClientTypes.InspectionData {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.InspectionData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.InspectionData()
        value.input = try reader["input"].readIfPresent()
        value.afterInputPath = try reader["afterInputPath"].readIfPresent()
        value.afterParameters = try reader["afterParameters"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.afterResultSelector = try reader["afterResultSelector"].readIfPresent()
        value.afterResultPath = try reader["afterResultPath"].readIfPresent()
        value.request = try reader["request"].readIfPresent(with: SFNClientTypes.InspectionDataRequest.read(from:))
        value.response = try reader["response"].readIfPresent(with: SFNClientTypes.InspectionDataResponse.read(from:))
        return value
    }
}

extension SFNClientTypes.InspectionDataResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.InspectionDataResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.InspectionDataResponse()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.headers = try reader["headers"].readIfPresent()
        value.body = try reader["body"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.InspectionDataRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.InspectionDataRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.InspectionDataRequest()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.method = try reader["method"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        value.headers = try reader["headers"].readIfPresent()
        value.body = try reader["body"].readIfPresent()
        return value
    }
}

extension SFNClientTypes.ValidateStateMachineDefinitionDiagnostic {

    static func read(from reader: SmithyJSON.Reader) throws -> SFNClientTypes.ValidateStateMachineDefinitionDiagnostic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SFNClientTypes.ValidateStateMachineDefinitionDiagnostic()
        value.severity = try reader["severity"].readIfPresent() ?? .sdkUnknown("")
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        value.location = try reader["location"].readIfPresent()
        return value
    }
}

public enum SFNClientTypes {}
