// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EKSClient {
    /// Paginate over `[DescribeAddonVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAddonVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAddonVersionsOutputResponse`
    public func describeAddonVersionsPaginated(input: DescribeAddonVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeAddonVersionsInput, DescribeAddonVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeAddonVersionsInput, DescribeAddonVersionsOutputResponse>(input: input, inputKey: \DescribeAddonVersionsInput.nextToken, outputKey: \DescribeAddonVersionsOutputResponse.nextToken, paginationFunction: self.describeAddonVersions(input:))
    }
}

extension DescribeAddonVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAddonVersionsInput {
        return DescribeAddonVersionsInput(
            addonName: self.addonName,
            kubernetesVersion: self.kubernetesVersion,
            maxResults: self.maxResults,
            nextToken: token,
            owners: self.owners,
            publishers: self.publishers,
            types: self.types
        )}
}

extension PaginatorSequence where Input == DescribeAddonVersionsInput, Output == DescribeAddonVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `describeAddonVersionsPaginated`
    /// to access the nested member `[EKSClientTypes.AddonInfo]`
    /// - Returns: `[EKSClientTypes.AddonInfo]`
    public func addons() async throws -> [EKSClientTypes.AddonInfo] {
        return try await self.asyncCompactMap { item in item.addons }
    }
}
extension EKSClient {
    /// Paginate over `[ListAddonsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAddonsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAddonsOutputResponse`
    public func listAddonsPaginated(input: ListAddonsInput) -> ClientRuntime.PaginatorSequence<ListAddonsInput, ListAddonsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAddonsInput, ListAddonsOutputResponse>(input: input, inputKey: \ListAddonsInput.nextToken, outputKey: \ListAddonsOutputResponse.nextToken, paginationFunction: self.listAddons(input:))
    }
}

extension ListAddonsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAddonsInput {
        return ListAddonsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAddonsInput, Output == ListAddonsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listAddonsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func addons() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.addons }
    }
}
extension EKSClient {
    /// Paginate over `[ListClustersOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListClustersOutputResponse`
    public func listClustersPaginated(input: ListClustersInput) -> ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutputResponse>(input: input, inputKey: \ListClustersInput.nextToken, outputKey: \ListClustersOutputResponse.nextToken, paginationFunction: self.listClusters(input:))
    }
}

extension ListClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListClustersInput {
        return ListClustersInput(
            include: self.include,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListClustersInput, Output == ListClustersOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listClustersPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func clusters() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.clusters }
    }
}
extension EKSClient {
    /// Paginate over `[ListFargateProfilesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFargateProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFargateProfilesOutputResponse`
    public func listFargateProfilesPaginated(input: ListFargateProfilesInput) -> ClientRuntime.PaginatorSequence<ListFargateProfilesInput, ListFargateProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFargateProfilesInput, ListFargateProfilesOutputResponse>(input: input, inputKey: \ListFargateProfilesInput.nextToken, outputKey: \ListFargateProfilesOutputResponse.nextToken, paginationFunction: self.listFargateProfiles(input:))
    }
}

extension ListFargateProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFargateProfilesInput {
        return ListFargateProfilesInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFargateProfilesInput, Output == ListFargateProfilesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listFargateProfilesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func fargateProfileNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.fargateProfileNames }
    }
}
extension EKSClient {
    /// Paginate over `[ListIdentityProviderConfigsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIdentityProviderConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIdentityProviderConfigsOutputResponse`
    public func listIdentityProviderConfigsPaginated(input: ListIdentityProviderConfigsInput) -> ClientRuntime.PaginatorSequence<ListIdentityProviderConfigsInput, ListIdentityProviderConfigsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListIdentityProviderConfigsInput, ListIdentityProviderConfigsOutputResponse>(input: input, inputKey: \ListIdentityProviderConfigsInput.nextToken, outputKey: \ListIdentityProviderConfigsOutputResponse.nextToken, paginationFunction: self.listIdentityProviderConfigs(input:))
    }
}

extension ListIdentityProviderConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIdentityProviderConfigsInput {
        return ListIdentityProviderConfigsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIdentityProviderConfigsInput, Output == ListIdentityProviderConfigsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listIdentityProviderConfigsPaginated`
    /// to access the nested member `[EKSClientTypes.IdentityProviderConfig]`
    /// - Returns: `[EKSClientTypes.IdentityProviderConfig]`
    public func identityProviderConfigs() async throws -> [EKSClientTypes.IdentityProviderConfig] {
        return try await self.asyncCompactMap { item in item.identityProviderConfigs }
    }
}
extension EKSClient {
    /// Paginate over `[ListNodegroupsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNodegroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNodegroupsOutputResponse`
    public func listNodegroupsPaginated(input: ListNodegroupsInput) -> ClientRuntime.PaginatorSequence<ListNodegroupsInput, ListNodegroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNodegroupsInput, ListNodegroupsOutputResponse>(input: input, inputKey: \ListNodegroupsInput.nextToken, outputKey: \ListNodegroupsOutputResponse.nextToken, paginationFunction: self.listNodegroups(input:))
    }
}

extension ListNodegroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNodegroupsInput {
        return ListNodegroupsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListNodegroupsInput, Output == ListNodegroupsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listNodegroupsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func nodegroups() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.nodegroups }
    }
}
extension EKSClient {
    /// Paginate over `[ListUpdatesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUpdatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUpdatesOutputResponse`
    public func listUpdatesPaginated(input: ListUpdatesInput) -> ClientRuntime.PaginatorSequence<ListUpdatesInput, ListUpdatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListUpdatesInput, ListUpdatesOutputResponse>(input: input, inputKey: \ListUpdatesInput.nextToken, outputKey: \ListUpdatesOutputResponse.nextToken, paginationFunction: self.listUpdates(input:))
    }
}

extension ListUpdatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUpdatesInput {
        return ListUpdatesInput(
            addonName: self.addonName,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            nodegroupName: self.nodegroupName
        )}
}

extension PaginatorSequence where Input == ListUpdatesInput, Output == ListUpdatesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listUpdatesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func updateIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.updateIds }
    }
}
