// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EKSClient {
    /// Paginate over `[DescribeAddonVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAddonVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAddonVersionsOutput`
    public func describeAddonVersionsPaginated(input: DescribeAddonVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeAddonVersionsInput, DescribeAddonVersionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAddonVersionsInput, DescribeAddonVersionsOutput>(input: input, inputKey: \DescribeAddonVersionsInput.nextToken, outputKey: \DescribeAddonVersionsOutput.nextToken, paginationFunction: self.describeAddonVersions(input:))
    }
}

extension DescribeAddonVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAddonVersionsInput {
        return DescribeAddonVersionsInput(
            addonName: self.addonName,
            kubernetesVersion: self.kubernetesVersion,
            maxResults: self.maxResults,
            nextToken: token,
            owners: self.owners,
            publishers: self.publishers,
            types: self.types
        )}
}

extension PaginatorSequence where Input == DescribeAddonVersionsInput, Output == DescribeAddonVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAddonVersionsPaginated`
    /// to access the nested member `[EKSClientTypes.AddonInfo]`
    /// - Returns: `[EKSClientTypes.AddonInfo]`
    public func addons() async throws -> [EKSClientTypes.AddonInfo] {
        return try await self.asyncCompactMap { item in item.addons }
    }
}
extension EKSClient {
    /// Paginate over `[ListAddonsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAddonsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAddonsOutput`
    public func listAddonsPaginated(input: ListAddonsInput) -> ClientRuntime.PaginatorSequence<ListAddonsInput, ListAddonsOutput> {
        return ClientRuntime.PaginatorSequence<ListAddonsInput, ListAddonsOutput>(input: input, inputKey: \ListAddonsInput.nextToken, outputKey: \ListAddonsOutput.nextToken, paginationFunction: self.listAddons(input:))
    }
}

extension ListAddonsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAddonsInput {
        return ListAddonsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAddonsInput, Output == ListAddonsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAddonsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func addons() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.addons }
    }
}
extension EKSClient {
    /// Paginate over `[ListClustersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListClustersOutput`
    public func listClustersPaginated(input: ListClustersInput) -> ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutput> {
        return ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutput>(input: input, inputKey: \ListClustersInput.nextToken, outputKey: \ListClustersOutput.nextToken, paginationFunction: self.listClusters(input:))
    }
}

extension ListClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListClustersInput {
        return ListClustersInput(
            include: self.include,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListClustersInput, Output == ListClustersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listClustersPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func clusters() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.clusters }
    }
}
extension EKSClient {
    /// Paginate over `[ListFargateProfilesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFargateProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFargateProfilesOutput`
    public func listFargateProfilesPaginated(input: ListFargateProfilesInput) -> ClientRuntime.PaginatorSequence<ListFargateProfilesInput, ListFargateProfilesOutput> {
        return ClientRuntime.PaginatorSequence<ListFargateProfilesInput, ListFargateProfilesOutput>(input: input, inputKey: \ListFargateProfilesInput.nextToken, outputKey: \ListFargateProfilesOutput.nextToken, paginationFunction: self.listFargateProfiles(input:))
    }
}

extension ListFargateProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFargateProfilesInput {
        return ListFargateProfilesInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListFargateProfilesInput, Output == ListFargateProfilesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFargateProfilesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func fargateProfileNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.fargateProfileNames }
    }
}
extension EKSClient {
    /// Paginate over `[ListIdentityProviderConfigsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIdentityProviderConfigsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIdentityProviderConfigsOutput`
    public func listIdentityProviderConfigsPaginated(input: ListIdentityProviderConfigsInput) -> ClientRuntime.PaginatorSequence<ListIdentityProviderConfigsInput, ListIdentityProviderConfigsOutput> {
        return ClientRuntime.PaginatorSequence<ListIdentityProviderConfigsInput, ListIdentityProviderConfigsOutput>(input: input, inputKey: \ListIdentityProviderConfigsInput.nextToken, outputKey: \ListIdentityProviderConfigsOutput.nextToken, paginationFunction: self.listIdentityProviderConfigs(input:))
    }
}

extension ListIdentityProviderConfigsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIdentityProviderConfigsInput {
        return ListIdentityProviderConfigsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListIdentityProviderConfigsInput, Output == ListIdentityProviderConfigsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIdentityProviderConfigsPaginated`
    /// to access the nested member `[EKSClientTypes.IdentityProviderConfig]`
    /// - Returns: `[EKSClientTypes.IdentityProviderConfig]`
    public func identityProviderConfigs() async throws -> [EKSClientTypes.IdentityProviderConfig] {
        return try await self.asyncCompactMap { item in item.identityProviderConfigs }
    }
}
extension EKSClient {
    /// Paginate over `[ListNodegroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNodegroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNodegroupsOutput`
    public func listNodegroupsPaginated(input: ListNodegroupsInput) -> ClientRuntime.PaginatorSequence<ListNodegroupsInput, ListNodegroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListNodegroupsInput, ListNodegroupsOutput>(input: input, inputKey: \ListNodegroupsInput.nextToken, outputKey: \ListNodegroupsOutput.nextToken, paginationFunction: self.listNodegroups(input:))
    }
}

extension ListNodegroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNodegroupsInput {
        return ListNodegroupsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListNodegroupsInput, Output == ListNodegroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listNodegroupsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func nodegroups() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.nodegroups }
    }
}
extension EKSClient {
    /// Paginate over `[ListUpdatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUpdatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUpdatesOutput`
    public func listUpdatesPaginated(input: ListUpdatesInput) -> ClientRuntime.PaginatorSequence<ListUpdatesInput, ListUpdatesOutput> {
        return ClientRuntime.PaginatorSequence<ListUpdatesInput, ListUpdatesOutput>(input: input, inputKey: \ListUpdatesInput.nextToken, outputKey: \ListUpdatesOutput.nextToken, paginationFunction: self.listUpdates(input:))
    }
}

extension ListUpdatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUpdatesInput {
        return ListUpdatesInput(
            addonName: self.addonName,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            nodegroupName: self.nodegroupName
        )}
}

extension PaginatorSequence where Input == ListUpdatesInput, Output == ListUpdatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUpdatesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func updateIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.updateIds }
    }
}
